{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"HHW Brick: Heating Hot Water System Brick Schema Toolkit <p> A Python package for converting heating hot water system data to Brick Schema models with comprehensive validation and portable analytics </p> <p> </p> <p> Get Started Installation </p>"},{"location":"#overview","title":"Overview","text":"<p>HHW Brick provides tools for converting building heating hot water system data to Brick Schema models and running portable analytics applications.</p> <p>Core Capabilities:</p> <ul> <li>CSV-to-Brick Converter: Automated conversion from tabular BMS data to Brick Schema 1.4 RDF models</li> <li>Multi-Level Validators: Ontology, point count, equipment count, and structural pattern validation  </li> <li>Portable Analytics: Building-agnostic applications that use SPARQL to auto-discover required sensors</li> </ul> <p>Key Benefits:</p> <ul> <li>Interoperability: Standardized semantic models work across different BMS platforms</li> <li>Portability: Write analytics once, run on any qualified building without recoding</li> <li>Quality Assurance: Comprehensive validation ensures model correctness</li> </ul> <p>The package supports five heating hot water system types (condensing boilers, non-condensing boilers, generic boilers, district hot water, district steam) and has been tested on 216 real buildings.</p>"},{"location":"#installation","title":"Installation","text":"<pre><code># For users (when published to PyPI)\npip install hhw-brick\n\n# For development (current method)\ngit clone https://github.com/CenterForTheBuiltEnvironment/HHW_brick.git\ncd HHW_brick\npip install -e .\n</code></pre> <p>Requirements: Python 3.8 or higher</p> <p>\ud83d\udcd8 Detailed Installation Guide \u2192</p>"},{"location":"#quick-start-example","title":"Quick Start Example","text":"<p>Convert, validate, and analyze a building in under 5 minutes:</p> <p>Sample Data: For input data format examples, see https://doi.org/10.5061/dryad.t4b8gtj8n or use test data in <code>tests/fixtures/</code></p>"},{"location":"#step-1-convert-csv-to-brick-model","title":"Step 1: Convert CSV to Brick Model","text":"<p>Transform your CSV data into a standardized Brick Schema RDF model with automatic system type detection and sensor mapping.</p> <pre><code>from pathlib import Path\nfrom hhw_brick import CSVToBrickConverter\n\n# Setup paths\nfixtures = Path(\"tests/fixtures\")\nmetadata_csv = fixtures / \"metadata.csv\"\nvars_csv = fixtures / \"vars_available_by_building.csv\"\n\n# Convert CSV to Brick model\nconverter = CSVToBrickConverter()\ngraph = converter.convert_to_brick(\n    metadata_csv=str(metadata_csv),\n    vars_csv=str(vars_csv),\n    building_tag=\"105\",\n    output_path=\"building_105.ttl\"\n)\nprint(f\"\u2713 Converted: {len(graph)} RDF triples\")\n</code></pre>"},{"location":"#step-2-validate-the-model","title":"Step 2: Validate the Model","text":"<p>Ensure your Brick model is correct through multi-level validation: ontology compliance (SHACL), point counts, and equipment counts.</p> <pre><code>from hhw_brick import BrickModelValidator\nfrom hhw_brick.validation import GroundTruthCalculator\n\n# 2a. Ontology validation (Brick Schema compliance)\nvalidator = BrickModelValidator(use_local_brick=True)\nresult = validator.validate_ontology(\"building_105.ttl\")\nprint(f\"\u2713 Ontology valid: {result['valid']}\")\n\n# 2b. Generate ground truth from CSV\ncalculator = GroundTruthCalculator()\ncalculator.calculate(\n    metadata_csv=str(metadata_csv),\n    vars_csv=str(vars_csv),\n    output_csv=\"ground_truth.csv\"\n)\n\n# 2c. Validate point counts\nvalidator = BrickModelValidator(ground_truth_csv_path=\"ground_truth.csv\")\npoint_result = validator.validate_point_count(\"building_105.ttl\")\nprint(f\"\u2713 Point count match: {point_result['match']}\")\n\n# 2d. Validate equipment counts\nequip_result = validator.validate_equipment_count(\"building_105.ttl\")\nprint(f\"\u2713 Equipment match: {equip_result.get('overall_success', False)}\")\n</code></pre>"},{"location":"#step-3-run-analytics-application","title":"Step 3: Run Analytics Application","text":"<p>Deploy portable analytics that automatically discover required sensors using SPARQL queries. Save configuration templates for easy customization.</p> <pre><code>from hhw_brick import apps\nimport yaml\n\n# Load application\napp = apps.load_app(\"secondary_loop_temp_diff\")\n\n# Check if building qualifies\nqualified = app.qualify(\"building_105.ttl\")\nif qualified:\n    # Get and save default config template\n    config = apps.get_default_config(\"secondary_loop_temp_diff\")\n\n    # Save config template for easy editing\n    with open(\"app_config.yaml\", \"w\") as f:\n        yaml.dump(config, f, default_flow_style=False, sort_keys=False)\n    print(\"\u2713 Config template saved: app_config.yaml\")\n\n    # Customize config (or edit the YAML file directly)\n    config[\"output\"][\"output_dir\"] = \"results/\"\n    config[\"output\"][\"generate_plots\"] = True\n\n    # Run analysis\n    results = app.analyze(\n        \"building_105.ttl\",\n        \"tests/fixtures/TimeSeriesData/105hhw_system_data.csv\",\n        config\n    )\n    print(f\"\u2713 Analysis complete! Results in: results/\")\n</code></pre> <p>That's it! From CSV to insights in 3 simple steps.</p> <p>\ud83d\udcd6 Full Tutorial \u2192</p>"},{"location":"#key-features","title":"Key Features","text":"\ud83d\udd04 Automated Conversion <p>Convert CSV data to Brick Schema 1.4 models with automatic system type detection and sensor mapping.</p> \ud83c\udfed 5 System Types <p>Support for condensing boilers, non-condensing boilers, generic boilers, district hot water, and district steam.</p> \u2705 Multi-Level Validation <p>Ontology (SHACL) + point counts + equipment counts + structural patterns ensure model quality.</p> \ud83d\udcca Portable Analytics <p>Applications use SPARQL to auto-discover sensors, working across any qualified building.</p> \u26a1 Batch Processing <p>Convert and validate 100+ buildings in parallel with progress tracking and error handling.</p> \ud83c\udfaf Ground Truth Validation <p>Independent validation using expected counts calculated directly from source CSV data.</p>"},{"location":"#documentation","title":"Documentation","text":"\ud83d\ude80 Getting Started <p>Installation guide, 5-minute quick start tutorial, understanding Brick Schema, and CSV data format requirements.</p> Read Guide \u2192 \ud83d\udd04 Conversion Guide <p>Single building conversion, batch processing, system type configuration, and sensor mapping customization.</p> Read Guide \u2192 \u2705 Validation Guide <p>Ontology validation, ground truth comparison, structural pattern matching, and batch validation workflows.</p> Read Guide \u2192 \ud83d\udcf1 Available Apps <p>Browse ready-to-use analytics applications: temperature differential analysis, efficiency monitoring, and more.</p> View Apps \u2192 \ud83d\udcca User Guide <p>Application management, running apps, and detailed usage instructions for all features.</p> Read Guide \u2192 \ud83d\udc68\u200d\ud83d\udcbb Developer Guide <p>Create your own applications: step-by-step tutorials, SPARQL queries, visualization, and best practices.</p> Read Guide \u2192"},{"location":"#resources","title":"ResourcesReady to Get Started?","text":"\ud83d\udcd6 Documentation <p> Getting Started User Guide Available Apps Developer Guide FAQ </p> \ud83d\udce6 Package Info <p> PyPI Package Changelog MIT License </p> \ud83d\udd27 Source Code <p> GitHub Repository View Examples Report Issues </p> <p> Transform your heating hot water system data into standardized Brick models </p> <p>      Get Started Now \u2192    </p> <p>Developed by Mingchen Li</p> <p>Making building heating hot water system data standardized and analyzable</p>"},{"location":"changelog/","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p>"},{"location":"changelog/#010-2025-11-02","title":"0.1.0 - 2025-11-02","text":""},{"location":"changelog/#initial-release","title":"\ud83c\udf89 Initial Release","text":"<p>First official release of HHW Brick, migrated from <code>hhws_brick_application</code>.</p>"},{"location":"changelog/#breaking-changes","title":"\ud83d\udd34 BREAKING CHANGES","text":""},{"location":"changelog/#package-rename","title":"Package Rename","text":"<ul> <li>Old: <code>hhws_brick_application</code></li> <li>New: <code>hhw_brick</code> (PyPI: <code>hhw-brick</code>)</li> </ul> <p>Migration: <pre><code># Before\nfrom hhws_brick_application.conversion import CSVToBrickConverter\n\n# After\nfrom hhw_brick import CSVToBrickConverter\n</code></pre></p>"},{"location":"changelog/#api-changes","title":"API Changes","text":"<ul> <li>Applications interface: <code>ApplicationManager</code> \u2192 <code>apps</code></li> <li>New CLI command: <code>hhw-brick</code></li> </ul>"},{"location":"changelog/#added","title":"\u2728 Added","text":""},{"location":"changelog/#core-features","title":"Core Features","text":"<ul> <li>CSV to Brick Conversion: Support for 5 hot water system types</li> <li>Validation Framework: 4-level validation (ontology, point count, equipment count, pattern)</li> <li>Ground Truth Calculator: Generate expected counts from CSV</li> <li>Batch Processing: Parallel conversion with multiprocessing</li> <li>Analytics Applications: Plugin-based apps framework with 2 built-in apps</li> <li>CLI Tool: <code>hhw-brick</code> command with convert, validate, deploy subcommands</li> <li>Utilities: SPARQL query helpers, data loading, file operations</li> </ul>"},{"location":"changelog/#testing","title":"Testing","text":"<ul> <li>110 test cases (95% pass rate)</li> <li>Test coverage: 40-45% overall</li> <li>pytest framework with fixtures</li> </ul>"},{"location":"changelog/#documentation","title":"Documentation","text":"<ul> <li>README with quick start</li> <li>MkDocs structure</li> <li>8 example scripts</li> <li>Contributing guide</li> </ul>"},{"location":"changelog/#changed","title":"\ud83d\udd04 Changed","text":"<ul> <li>Package structure reorganized</li> <li>All documentation translated to English</li> <li>Improved error messages and type hints</li> <li>Simplified public API</li> </ul>"},{"location":"changelog/#fixed","title":"\ud83d\udc1b Fixed","text":"<ul> <li>Package import paths (7 test files)</li> <li>Test API mismatches (60+ tests)</li> <li>UTF-8 BOM encoding in pyproject.toml</li> <li>Missing module exports</li> </ul>"},{"location":"changelog/#statistics","title":"\ud83d\udcca Statistics","text":"<ul> <li>Code: ~3,000+ lines</li> <li>Tests: 110 (53 passed, 3 skipped)</li> <li>Coverage: 40-45%</li> <li>Supported Systems: 5 hot water types</li> <li>Tested Buildings: 216 real buildings</li> </ul>"},{"location":"changelog/#upgrade-from-hhws_brick_application","title":"\ud83d\ude80 Upgrade from hhws_brick_application","text":"<pre><code># 1. Uninstall old package\npip uninstall hhws_brick_application\n\n# 2. Install new package\npip install hhw-brick\n\n# 3. Update imports\n# Replace hhws_brick_application with hhw_brick in all files\n\n# 4. Update application usage\nfrom hhw_brick import apps  # instead of ApplicationManager\n</code></pre>"},{"location":"changelog/#acknowledgments","title":"\ud83d\ude4f Acknowledgments","text":"<ul> <li>Original package: hhws_brick_application</li> <li>Author: Mingchen Li</li> <li>Built with: Brick Schema 1.4, RDF/OWL, SPARQL</li> </ul>"},{"location":"license/","title":"License","text":"<p>MIT License</p> <p>Copyright \u00a9 2025 Center for the Built Environment</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"api-reference/","title":"API Reference","text":"<p>Complete API documentation for HHW Brick Application.</p>"},{"location":"api-reference/#overview","title":"Overview","text":"<p>This section provides detailed documentation for all public APIs in the package.</p>"},{"location":"api-reference/#modules","title":"Modules","text":""},{"location":"api-reference/#conversion","title":"Conversion","text":"<p>Transform CSV data to Brick ontology models.</p> <ul> <li>CSVToBrickConverter - Main converter class</li> <li>BatchConverter - Batch processing</li> </ul>"},{"location":"api-reference/#validation","title":"Validation","text":"<p>Validate Brick models against schemas and ground truth.</p> <ul> <li>BrickModelValidator - Main validator</li> <li>SubgraphPatternValidator - Pattern matching</li> <li>GroundTruthCalculator - Ground truth comparison</li> </ul>"},{"location":"api-reference/#applications","title":"Applications","text":"<p>Analytics application framework.</p> <ul> <li>AppsManager - Application management</li> <li>BaseApp - Base application interface</li> </ul>"},{"location":"api-reference/#quick-reference","title":"Quick Reference","text":""},{"location":"api-reference/#import-statements","title":"Import Statements","text":"<pre><code># Main classes\nfrom hhw_brick import (\n    CSVToBrickConverter,\n    BatchConverter,\n    BrickModelValidator,\n    GroundTruthCalculator,\n    apps\n)\n\n\n# Validation\nfrom hhw_brick.validation import (\n    SubgraphPatternValidator\n)\n</code></pre>"},{"location":"api-reference/#common-methods","title":"Common Methods","text":""},{"location":"api-reference/#conversion_1","title":"Conversion","text":"<pre><code>converter = CSVToBrickConverter()\n\n# Convert single file\nconverter.convert_csv_to_brick(input_file, output_file)\n\n# Batch convert\nbatch = BatchConverter()\nbatch.convert_batch(input_dir, output_dir)\n</code></pre>"},{"location":"api-reference/#validation_1","title":"Validation","text":"<pre><code>validator = BrickModelValidator()\n\n# Validate model\nis_valid, report = validator.validate_model(model_path)\n\n# Check ontology\nis_valid, errors = validator.validate_ontology(model_path)\n</code></pre>"},{"location":"api-reference/#applications_1","title":"Applications","text":"<pre><code># List apps\navailable = apps.list_apps()\n\n# Load app\napp = apps.load_app(\"app_name\")\n\n# Qualify building\nqualified, details = app.qualify(brick_model)\n\n# Run analysis\nresults = app.analyze(brick_model, data, config)\n</code></pre>"},{"location":"api-reference/#type-hints","title":"Type Hints","text":"<p>All public APIs include type hints for better IDE support:</p> <pre><code>from typing import Dict, Tuple, Optional\nfrom rdflib import Graph\nimport pandas as pd\n\ndef qualify(brick_model: Graph) -&gt; Tuple[bool, Dict]:\n    ...\n\ndef analyze(\n    brick_model: Graph,\n    timeseries_data: pd.DataFrame,\n    config: Optional[Dict] = None\n) -&gt; Dict:\n    ...\n</code></pre>"},{"location":"api-reference/#return-values","title":"Return Values","text":""},{"location":"api-reference/#successfailure-pattern","title":"Success/Failure Pattern","text":"<p>Most methods return success status with details:</p> <pre><code># Pattern 1: Boolean + Details\nis_valid, report = validator.validate_model(path)\n# is_valid: bool\n# report: Dict[str, Any]\n\n# Pattern 2: Result Dictionary\nresult = {\n    \"success\": True,\n    \"data\": {...},\n    \"errors\": []\n}\n</code></pre>"},{"location":"api-reference/#error-handling","title":"Error Handling","text":"<p>APIs raise specific exceptions:</p> <pre><code>from hhw_brick.exceptions import (\n    ValidationError,\n    ConversionError,\n    ConfigurationError\n)\n</code></pre>"},{"location":"api-reference/#next-steps","title":"Next Steps","text":"<ul> <li>Browse module documentation in the sidebar</li> <li>Check Examples for practical usage</li> <li>Read User Guide for workflows</li> </ul> <p>Need details? Select a module from the navigation \u2192</p>"},{"location":"app-development/","title":"Application Development Tutorial","text":"<p>Learn to create HHW Brick analytics applications through hands-on, step-by-step tutorials.</p>"},{"location":"app-development/#tutorial-structure","title":"Tutorial Structure","text":"<p>This tutorial is divided into logical steps, each focusing on one aspect of application development.</p>"},{"location":"app-development/#tutorial-steps","title":"\ud83d\udcda Tutorial Steps","text":"Step Topic Time Difficulty Step 1 Create Application Structure 10 min \u2b50 Easy Step 2 Write load_config Function 15 min \u2b50 Easy Step 3 SPARQL Query &amp; qualify Function 30 min \u2b50\u2b50 Medium Step 4 analyze Function - Data Loading 20 min \u2b50\u2b50 Medium Step 5 analyze Function - Analysis Logic 25 min \u2b50\u2b50 Medium Step 6 Matplotlib Visualization 20 min \u2b50\u2b50 Medium Step 7 Plotly HTML Visualization 30 min \u2b50\u2b50\u2b50 Advanced Step 8 Testing Your Application 20 min \u2b50\u2b50 Medium Step 9 Deployment &amp; Integration 15 min \u2b50 Easy <p>Total Time: ~3 hours</p>"},{"location":"app-development/#what-youll-build","title":"What You'll Build","text":"<p>By the end of this tutorial, you'll have built a complete analytics application that:</p> <p>\u2705 Qualifies buildings based on required sensors \u2705 Analyzes time-series data from Brick models \u2705 Generates statistical reports \u2705 Creates visualizations (PNG and interactive HTML) \u2705 Integrates with the HHW Brick framework  </p>"},{"location":"app-development/#prerequisites","title":"Prerequisites","text":""},{"location":"app-development/#required-knowledge","title":"Required Knowledge","text":"<ul> <li>Python Basics: Variables, functions, file I/O</li> <li>Command Line: Navigate directories, run Python scripts</li> <li>YAML: Basic configuration file syntax</li> </ul> <p>Note: No prior experience with Brick Schema or SPARQL needed - we'll teach you!</p>"},{"location":"app-development/#software-requirements","title":"Software Requirements","text":"<pre><code># Python 3.8 or higher\npython --version\n\n# HHW Brick package installed\npip install -e /path/to/HHW_brick\n\n# Or install dependencies\npip install pandas numpy matplotlib seaborn plotly rdflib brickschema pyyaml\n</code></pre>"},{"location":"app-development/#tutorial-learning-path","title":"Tutorial Learning Path","text":""},{"location":"app-development/#path-1-quick-start-minimum-viable-app","title":"\ud83c\udfaf Path 1: Quick Start (Minimum Viable App)","text":"<p>Build a working app as fast as possible:</p> <ol> <li>Step 1 - Structure</li> <li>Step 2 - Config loading</li> <li>Step 3 - Qualification</li> <li>Step 4 - Basic analysis</li> <li>Step 8 - Test it</li> </ol> <p>Time: ~1.5 hours Result: Working application with basic functionality</p>"},{"location":"app-development/#path-2-complete-tutorial-recommended","title":"\ud83c\udf93 Path 2: Complete Tutorial (Recommended)","text":"<p>Follow all steps for full understanding:</p> <p>1-9 in order</p> <p>Time: ~3 hours Result: Production-ready application with all features</p>"},{"location":"app-development/#path-3-advanced-custom-applications","title":"\ud83d\ude80 Path 3: Advanced (Custom Applications)","text":"<p>After completing the tutorial:</p> <ul> <li>Modify existing applications</li> <li>Create complex SPARQL queries</li> <li>Implement custom analytics</li> <li>Add advanced visualizations</li> </ul>"},{"location":"app-development/#application-example","title":"Application Example","text":"<p>Here's what you'll build - a temperature differential analysis app:</p> <p>Input: - Brick model (.ttl file) with temperature sensors - Time-series data (.csv file) with sensor readings</p> <p>Process: 1. Check if building has supply and return temperature sensors 2. Load and map sensor data 3. Calculate temperature differential 4. Compute statistics (mean, std, range, etc.) 5. Generate visualizations</p> <p>Output: - CSV files with statistics and processed data - PNG plots (timeseries, histograms, heatmaps) - Interactive HTML dashboards</p> <p>See it in action: <code>hhw_brick/applications/secondary_loop_temp_diff/</code></p>"},{"location":"app-development/#how-to-use-this-tutorial","title":"How to Use This Tutorial","text":"<p>Each step follows this structure:</p> <ol> <li>Goal: What you'll accomplish</li> <li>Code: Copy-paste ready code snippets</li> <li>Explanation: Understanding what the code does</li> <li>Test: Verify your implementation works</li> <li>Checkpoint: Ensure you're ready for the next step</li> </ol> <p>Icons Used:</p> <ul> <li>\ud83d\udca1 Tip: Helpful suggestions</li> <li>\u26a0\ufe0f Warning: Common pitfalls</li> <li>\ud83d\udcda Resource: External learning materials</li> <li>\u2705 Best Practice: Recommended approaches</li> </ul>"},{"location":"app-development/#getting-help","title":"Getting Help","text":"<p>If code doesn't work:</p> <ol> <li>Check the Common Issues section in each step</li> <li>Compare with example applications in <code>hhw_brick/applications/</code></li> <li>Run the test scripts provided</li> </ol> <p>Resources:</p> <ul> <li>Brick Schema Docs</li> <li>SPARQL Tutorial</li> <li>GitHub Issues</li> </ul>"},{"location":"app-development/#example-applications","title":"Example Applications","text":"<p>Study these working applications in <code>hhw_brick/applications/</code> for reference:</p> <p>secondary_loop_temp_diff (\u2b50\u2b50 Medium): - Simple SPARQL query - Basic statistical analysis - Standard visualization patterns</p> <p>primary_loop_temp_diff (\u2b50\u2b50 Medium): - Filtered SPARQL queries - Anomaly detection - Multiple visualization types</p>"},{"location":"app-development/#tips-for-success","title":"Tips for Success","text":""},{"location":"app-development/#dos","title":"\u2705 Do's","text":"<ol> <li>Read the explanations: Don't just copy code, understand it</li> <li>Run tests frequently: Catch errors early</li> <li>Start simple: Get basics working before adding features</li> <li>Study examples: Look at existing applications</li> <li>Use version control: Git commit after each step</li> </ol>"},{"location":"app-development/#donts","title":"\u274c Don'ts","text":"<ol> <li>Don't skip steps: Each builds on the previous</li> <li>Don't ignore errors: Fix them before proceeding</li> <li>Don't customize prematurely: Finish tutorial first, then customize</li> <li>Don't skip testing: Tests ensure your code works</li> <li>Don't forget documentation: Update README as you go</li> </ol>"},{"location":"app-development/#after-completing-the-tutorial","title":"After Completing the Tutorial","text":""},{"location":"app-development/#next-steps","title":"Next Steps","text":"<ol> <li>Customize: Modify your app for specific use cases</li> <li>Create new apps: Build applications for different analyses</li> <li>Contribute: Share your applications with the community</li> <li>Advanced topics: Explore complex SPARQL, custom analytics</li> </ol>"},{"location":"app-development/#share-your-work","title":"Share Your Work","text":"<ul> <li>Submit pull requests to add your app to HHW Brick</li> <li>Write blog posts about your application</li> <li>Help others in GitHub Issues</li> </ul>"},{"location":"app-development/#ready-to-start","title":"Ready to Start?","text":"<p>\ud83d\ude80 Let's build your first HHW Brick application!</p> <p>\ud83d\udc49 Begin with Step 1: Create Application Structure</p>"},{"location":"app-development/step-01-structure/","title":"Step 1: Create Application Structure","text":"<p>Set up the basic file structure for your application.</p>"},{"location":"app-development/step-01-structure/#1-create-directory","title":"1. Create Directory","text":"<pre><code>cd hhw_brick/applications/\nmkdir my_first_app\ncd my_first_app\n</code></pre> <p>Naming: Use lowercase with underscores (e.g., <code>temperature_analysis</code>)</p>"},{"location":"app-development/step-01-structure/#2-create-required-files","title":"2. Create Required Files","text":"<p>Every application needs these 5 files:</p> <pre><code>my_first_app/\n\u251c\u2500\u2500 __init__.py          # Package metadata and exports\n\u251c\u2500\u2500 app.py               # Main application code\n\u251c\u2500\u2500 config.yaml          # Default configuration\n\u251c\u2500\u2500 requirements.txt     # Python dependencies\n\u2514\u2500\u2500 README.md            # User documentation\n</code></pre> <p>Windows: <pre><code>New-Item __init__.py, app.py, config.yaml, requirements.txt, README.md\n</code></pre></p> <p>Linux/Mac: <pre><code>touch __init__.py app.py config.yaml requirements.txt README.md\n</code></pre></p>"},{"location":"app-development/step-01-structure/#3-file-contents","title":"3. File Contents","text":""},{"location":"app-development/step-01-structure/#__init__py","title":"<code>__init__.py</code>","text":"<p>Exports the three required functions and defines metadata.</p> <pre><code>\"\"\"\nMy First Application\n\nTemperature differential analysis for hot water systems.\n\nAuthor: Your Name\n\"\"\"\n\nfrom .app import qualify, analyze, load_config\n\n__all__ = [\"qualify\", \"analyze\", \"load_config\"]\n\n__app_name__ = \"my_first_app\"\n__version__ = \"1.0.0\"\n__description__ = \"Temperature differential analysis\"\n__author__ = \"Your Name\"\n</code></pre>"},{"location":"app-development/step-01-structure/#requirementstxt","title":"<code>requirements.txt</code>","text":"<p>Lists all Python packages your app needs.</p> <pre><code>pandas&gt;=1.3.0\nnumpy&gt;=1.21.0\nmatplotlib&gt;=3.5.0\nseaborn&gt;=0.11.0\nplotly&gt;=5.0.0\nrdflib&gt;=6.0.0\nbrickschema&gt;=0.6.0\npyyaml&gt;=5.4.0\n</code></pre>"},{"location":"app-development/step-01-structure/#configyaml","title":"<code>config.yaml</code>","text":"<p>Default configuration that users can customize.</p> <pre><code># Analysis parameters (customize for your app)\nanalysis:\n  threshold_min_delta: 0.5\n  threshold_max_delta: 10.0\n\n# Output settings (standard, keep structure)\noutput:\n  save_results: true\n  output_dir: \"./results\"\n  export_format: \"csv\"           # csv or json\n  generate_plots: true\n  plot_format: \"png\"             # png, pdf, or svg\n  generate_plotly_html: true\n\n# Time filtering (optional)\ntime_range:\n  start_time: null               # YYYY-MM-DD or null\n  end_time: null\n</code></pre>"},{"location":"app-development/step-01-structure/#readmemd","title":"<code>README.md</code>","text":"<p>User-facing documentation for your application.</p> <pre><code># My First Application\n\n## Overview\n\nAnalyzes temperature differential in hot water systems.\n\n## Requirements\n\nBuildings must have:\n- Hot Water Loop\n- Supply temperature sensor (Leaving_Hot_Water_Temperature_Sensor)\n- Return temperature sensor (Entering_Hot_Water_Temperature_Sensor)\n\n## Usage\n\n\\`\\`\\`python\nfrom hhw_brick import apps\n\napp = apps.load_app(\"my_first_app\")\nqualified, details = app.qualify(\"building.ttl\")\n\nif qualified:\n    config = app.load_config()\n    results = app.analyze(\"building.ttl\", \"data.csv\", config)\n\\`\\`\\`\n\n## Output\n\n- `stats.csv` - Statistical results\n- `timeseries.csv` - Processed data\n- `*.png` - Static plots\n- `*.html` - Interactive visualizations\n\n## Author\n\nYour Name - v1.0.0\n</code></pre>"},{"location":"app-development/step-01-structure/#checkpoint","title":"Checkpoint","text":"<p>Verify your setup:</p> <ul> <li> Directory <code>my_first_app/</code> created</li> <li> All 5 files created</li> <li> <code>__init__.py</code> has metadata</li> <li> <code>requirements.txt</code> has dependencies</li> <li> <code>config.yaml</code> has correct structure</li> <li> <code>README.md</code> has basic docs</li> </ul>"},{"location":"app-development/step-01-structure/#next-step","title":"Next Step","text":"<p>\ud83d\udc49 Step 2: Write load_config Function</p>"},{"location":"app-development/step-02-load-config/","title":"Step 2: Write load_config Function","text":"<p>Implement configuration loading from YAML files.</p>"},{"location":"app-development/step-02-load-config/#1-add-imports-to-apppy","title":"1. Add Imports to <code>app.py</code>","text":"<p>Start your <code>app.py</code> with these imports:</p> <pre><code>#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\"\"\"\nMy First Application\n\nTemperature differential analysis for hot water systems.\n\nAuthor: Your Name\n\"\"\"\n\nimport sys\nfrom pathlib import Path\nimport yaml\n\n# Setup paths\napp_dir = Path(__file__).parent\npackage_dir = app_dir.parent.parent.parent\nsys.path.insert(0, str(package_dir))\n\n# Export core functions\n__all__ = [\"qualify\", \"analyze\", \"load_config\"]\n</code></pre> <p>Why: - <code>Path(__file__).parent</code> - Gets current app directory - <code>sys.path.insert()</code> - Allows importing HHW Brick utilities - <code>__all__</code> - Defines public API</p>"},{"location":"app-development/step-02-load-config/#2-implement-load_config","title":"2. Implement load_config()","text":"<p>Add this function to load configuration from YAML:</p> <pre><code>def load_config(config_file=None):\n    \"\"\"\n    Load configuration from YAML file\n\n    Args:\n        config_file: Path to config file (default: config.yaml in app dir)\n\n    Returns:\n        dict: Configuration dictionary\n    \"\"\"\n    if config_file is None:\n        config_file = app_dir / \"config.yaml\"\n\n    config_path = Path(config_file)\n\n    if not config_path.exists():\n        raise FileNotFoundError(\n            f\"Config file not found: {config_path}\\n\"\n            f\"Please ensure config.yaml exists.\"\n        )\n\n    with open(config_path, \"r\", encoding=\"utf-8\") as f:\n        config = yaml.safe_load(f)\n\n    return config if config else {}\n</code></pre> <p>How it works: 1. Uses default <code>config.yaml</code> if no file specified 2. Checks if file exists, raises error if not 3. Loads YAML using <code>safe_load()</code> (secure) 4. Returns dictionary or empty dict if file is empty</p>"},{"location":"app-development/step-02-load-config/#3-test-load_config","title":"3. Test load_config()","text":"<p>Create <code>test_config.py</code> in your app directory:</p> <pre><code>\"\"\"Test configuration loading\"\"\"\nfrom pathlib import Path\nimport sys\n\napp_dir = Path(__file__).parent\nsys.path.insert(0, str(app_dir.parent.parent.parent))\n\nfrom hhw_brick.applications.my_first_app.app import load_config\n\n# Test 1: Load default config\nconfig = load_config()\nassert \"output\" in config\nassert \"analysis\" in config\nprint(\"\u2713 Config loaded successfully\")\nprint(f\"  Keys: {list(config.keys())}\")\n\n# Test 2: Check structure\nassert config[\"output\"][\"generate_plots\"] is not None\nprint(\"\u2713 Config structure valid\")\n\nprint(\"\\n\u2705 All tests passed!\")\n</code></pre> <p>Run test: <pre><code>python test_config.py\n</code></pre></p> <p>Expected output: <pre><code>\u2713 Config loaded successfully\n  Keys: ['analysis', 'output', 'time_range']\n\u2713 Config structure valid\n\n\u2705 All tests passed!\n</code></pre></p>"},{"location":"app-development/step-02-load-config/#checkpoint","title":"Checkpoint","text":"<ul> <li> Imports added to <code>app.py</code></li> <li> <code>load_config()</code> function implemented</li> <li> Test script runs successfully</li> <li> Error handling works (try loading non-existent file)</li> </ul>"},{"location":"app-development/step-02-load-config/#common-issues","title":"Common Issues","text":"<p><code>ModuleNotFoundError: No module named 'yaml'</code> \u2192 Run: <code>pip install pyyaml</code></p> <p><code>FileNotFoundError</code> when running test \u2192 Ensure <code>config.yaml</code> exists from Step 1</p>"},{"location":"app-development/step-02-load-config/#next-step","title":"Next Step","text":"<p>\ud83d\udc49 Step 3: SPARQL Query &amp; qualify Function</p>"},{"location":"app-development/step-03-sparql-qualify/","title":"Step 3: SPARQL Query &amp; qualify Function","text":"<p>Learn SPARQL basics and implement building qualification.</p>"},{"location":"app-development/step-03-sparql-qualify/#1-understanding-sparql-for-brick","title":"1. Understanding SPARQL for Brick","text":"<p>SPARQL queries RDF data (Brick models use RDF).</p> <p>Basic Pattern: <pre><code>SELECT ?variable WHERE {\n    ?variable rdf:type brick:SomeClass .\n}\n</code></pre></p> <p>Example - Find all temperature sensors: <pre><code>SELECT ?sensor WHERE {\n    ?sensor rdf:type/rdfs:subClassOf* brick:Temperature_Sensor .\n}\n</code></pre></p> <p>Key Patterns: - <code>?variable</code> - Variable (like wildcards) - <code>rdf:type</code> - \"is a type of\" - <code>rdfs:subClassOf*</code> - Includes subclasses - <code>brick:hasPart</code> - System/Loop has point (used by Hot_Water_Loop, Hot_Water_System) - <code>brick:hasPoint</code> - Equipment has point (used by Boiler, Pump, Weather_Station) - <code>FILTER()</code> - Filter results</p> <p>Learn More: - Brick Docs: https://docs.brickschema.org/ - SPARQL Tutorial: https://www.w3.org/TR/sparql11-query/ - Brick Studio: https://brickstudio.io/</p>"},{"location":"app-development/step-03-sparql-qualify/#2-visualize-system-architecture","title":"2. Visualize System Architecture","text":"<p>Before writing SPARQL, understand your target system architecture.</p> <p>Reference Diagrams: See <code>docs/Figures/Development_Guide/</code> for common patterns:</p>"},{"location":"app-development/step-03-sparql-qualify/#pattern-1-boiler-system","title":"Pattern 1: Boiler System","text":"<ul> <li>Equipment: Boiler, Hot_Water_Loop</li> <li>Sensors: Leaving/Entering Temperature Sensors</li> <li>Relationships: Loop <code>hasPart</code> sensors</li> </ul>"},{"location":"app-development/step-03-sparql-qualify/#pattern-2-district-system","title":"Pattern 2: District System","text":"<ul> <li>Equipment: Heat_Exchanger, Hot_Water_Loop</li> <li>Sensors: Supply/Return Temperature Sensors</li> <li>Relationships: Loop <code>hasPart</code> sensors</li> </ul> <p>How to Use Diagrams: 1. Identify equipment (rectangles) \u2192 Use in <code>?equipment rdf:type brick:Hot_Water_Loop</code> 2. Identify sensors (circles) \u2192 Use in <code>?sensor rdf:type brick:Temperature_Sensor</code> 3. Trace relationships (arrows) \u2192 Use in <code>?equipment brick:hasPart ?sensor</code></p>"},{"location":"app-development/step-03-sparql-qualify/#understanding-point-equipment-relationships","title":"Understanding Point-Equipment Relationships","text":"<p>Before writing SPARQL queries, you need to know which points are connected to which equipment and the relationship type used. This information comes from <code>sensor_to_brick_mapping.yaml</code>.</p> <p>Important: Relationship Types - Equipment (Boiler, Pump, Weather_Station) \u2192 Use <code>brick:hasPoint</code> to connect sensors - Systems/Loops (Hot_Water_System, Primary_Loop, Secondary_Loop) \u2192 Use <code>brick:hasPart</code> to connect sensors</p> <p>Complete Point-to-Equipment Mapping:</p> Equipment/System Relationship Point Name Point Type Description secondary_loop <code>hasPart</code> <code>sup</code> Leaving_Hot_Water_Temperature_Sensor Supply water temp entering building <code>hasPart</code> <code>ret</code> Entering_Hot_Water_Temperature_Sensor Return water temp leaving building <code>hasPart</code> <code>flow</code> Flow_Sensor Flow rate entering building <code>hasPart</code> <code>dp</code> Differential_Pressure_Sensor End-of-line differential pressure <code>hasPart</code> <code>hw</code> Thermal_Power_Sensor Heating power supplied to building <code>hasPart</code> <code>gas_u</code> Natural_Gas_Flow_Sensor Gas consumption at utility meter <code>hasPart</code> <code>sup_stpt</code> Hot_Water_Temperature_Setpoint Supply temp setpoint <code>hasPart</code> <code>dp_stpt</code> Differential_Pressure_Setpoint Pressure setpoint primary_loop <code>hasPart</code> <code>supp</code> Leaving_Hot_Water_Temperature_Sensor Common supply temp (primary circuit) <code>hasPart</code> <code>retp</code> Entering_Hot_Water_Temperature_Sensor Common return temp (primary circuit) <code>hasPart</code> <code>flowp</code> Flow_Sensor Hot water flow rate (primary circuit) <code>hasPart</code> <code>gas</code> Natural_Gas_Flow_Sensor Gas consumption at boiler plant boiler <code>hasPoint</code> <code>sup1-4</code> Leaving_Hot_Water_Temperature_Sensor Boiler 1-4 outlet water temp <code>hasPoint</code> <code>ret1-4</code> Entering_Hot_Water_Temperature_Sensor Boiler 1-4 inlet water temp <code>hasPoint</code> <code>fire1-4</code> Firing_Rate_Sensor Boiler 1-4 firing rate pump <code>hasPoint</code> <code>pmp1_pwr</code> Power_Sensor Pump 1 power consumption <code>hasPoint</code> <code>pmp2_pwr</code> Power_Sensor Pump 2 power consumption <code>hasPoint</code> <code>pmp1_spd</code> Speed_Command Pump 1 speed command <code>hasPoint</code> <code>pmp2_spd</code> Speed_Command Pump 2 speed command <code>hasPoint</code> <code>pmp_spd</code> Speed_Command Main pump speed command <code>hasPoint</code> <code>pmp1_vfd</code> VFD_Enable_Command Pump 1 VFD enable <code>hasPoint</code> <code>pmp2_vfd</code> VFD_Enable_Command Pump 2 VFD enable weather_station <code>hasPoint</code> <code>t_out</code> Outside_Air_Temperature_Sensor Outdoor drybulb temperature hot_water_system <code>hasPart</code> <code>enab</code> Enable_Command System enable/disable command <code>hasPart</code> <code>oper</code> Enable_Status System operation status <p>Key Summary by Type: - Loops (use hasPart):   - Secondary Loop: 8 points   - Primary Loop: 4 points   - Hot Water System: 2 points - Equipment (use hasPoint):   - Boiler: 12 points (4 boilers)   - Pump: 7 points   - Weather Station: 1 point</p> <p>Example 1: For secondary loop (uses <code>hasPart</code>), SPARQL query: <pre><code>SELECT ?loop ?supply ?return WHERE {\n    # Find secondary hot water loop (Loop uses hasPart)\n    ?loop rdf:type brick:Hot_Water_Loop .\n    FILTER(CONTAINS(LCASE(STR(?loop)), \"secondary\"))\n\n    # Loops use brick:hasPart for sensors\n    ?loop brick:hasPart ?supply .\n    ?supply rdf:type brick:Leaving_Hot_Water_Temperature_Sensor .\n\n    ?loop brick:hasPart ?return .\n    ?return rdf:type brick:Entering_Hot_Water_Temperature_Sensor .\n}\n</code></pre></p> <p>Example 2: For boiler sensors (uses <code>hasPoint</code>), SPARQL query: <pre><code>SELECT ?boiler ?supply ?return WHERE {\n    # Find boiler equipment (Equipment uses hasPoint)\n    ?boiler rdf:type brick:Boiler .\n\n    # Equipment use brick:hasPoint for sensors\n    ?boiler brick:hasPoint ?supply .\n    ?supply rdf:type brick:Leaving_Hot_Water_Temperature_Sensor .\n\n    ?boiler brick:hasPoint ?return .\n    ?return rdf:type brick:Entering_Hot_Water_Temperature_Sensor .\n}\n</code></pre></p>"},{"location":"app-development/step-03-sparql-qualify/#3-write-sparql-query","title":"3. Write SPARQL Query","text":"<p>Add this function to find required sensors:</p> <pre><code>def find_required_sensors(graph):\n    \"\"\"\n    Find supply and return temperature sensors on hot water loop\n\n    Returns:\n        Tuple of (loop, supply_sensor, return_sensor) or None\n    \"\"\"\n    from hhw_brick.utils import query_sensors\n\n    query = \"\"\"\n    SELECT ?loop ?supply ?return WHERE {\n        # Find hot water loop (could be secondary_loop or primary_loop)\n        ?loop rdf:type/rdfs:subClassOf* brick:Hot_Water_Loop .\n\n        # Find supply sensor (part of loop)\n        # In our system: 'sup' on secondary_loop, 'supp' on primary_loop\n        ?loop brick:hasPart ?supply .\n        ?supply rdf:type/rdfs:subClassOf* brick:Leaving_Hot_Water_Temperature_Sensor .\n\n        # Find return sensor (part of loop)\n        # In our system: 'ret' on secondary_loop, 'retp' on primary_loop\n        ?loop brick:hasPart ?return .\n        ?return rdf:type/rdfs:subClassOf* brick:Entering_Hot_Water_Temperature_Sensor .\n    }\n    \"\"\"\n\n    results = query_sensors(graph, [], custom_query=query)\n    return results[0] if results else None\n</code></pre> <p>How it works: 1. Find any Hot_Water_Loop (secondary or primary) 2. Find supply sensor (Leaving temp) that's part of the loop    - <code>brick:hasPart</code> establishes the point-equipment relationship 3. Find return sensor (Entering temp) that's part of the loop 4. Return first match or None</p> <p>Equipment-Point Relationships: - Based on <code>sensor_to_brick_mapping.yaml</code>, points are assigned to equipment:   - Secondary loop: <code>sup</code>, <code>ret</code>, <code>flow</code>, <code>dp</code>, <code>hw</code>, <code>gas_u</code>, <code>sup_stpt</code>, <code>dp_stpt</code>   - Primary loop: <code>supp</code>, <code>retp</code>, <code>flowp</code>, <code>gas</code>   - Boiler: <code>sup1-4</code>, <code>ret1-4</code>, <code>fire1-4</code>   - Pump: <code>pmp1_pwr</code>, <code>pmp2_pwr</code>, <code>pmp1_spd</code>, <code>pmp2_spd</code>, <code>pmp1_vfd</code>, <code>pmp2_vfd</code>   - Weather station: <code>t_out</code></p>"},{"location":"app-development/step-03-sparql-qualify/#4-implement-qualify","title":"4. Implement qualify()","text":"<p>Check if building has required sensors:</p> <pre><code>def qualify(brick_model_path):\n    \"\"\"\n    Check if building has required sensors\n\n    Args:\n        brick_model_path: Path to Brick model (.ttl file)\n\n    Returns:\n        Tuple of (qualified: bool, details: dict)\n    \"\"\"\n    print(f\"\\n{'='*60}\")\n    print(f\"QUALIFY: Checking required sensors\")\n    print(f\"{'='*60}\\n\")\n\n    from rdflib import Graph\n\n    # Load Brick model\n    g = Graph()\n    g.parse(brick_model_path, format=\"turtle\")\n\n    # Find sensors\n    result = find_required_sensors(g)\n\n    if result:\n        loop, supply, return_sensor = result\n        print(f\"[OK] Building qualified\")\n        print(f\"   Loop: {loop}\")\n        print(f\"   Supply: {supply}\")\n        print(f\"   Return: {return_sensor}\\n\")\n\n        return True, {\n            \"loop\": str(loop),\n            \"supply\": str(supply),\n            \"return\": str(return_sensor)\n        }\n    else:\n        print(f\"[FAIL] Building NOT qualified\")\n        print(f\"   Missing: Supply and return sensors on hot water loop\\n\")\n        return False, {}\n</code></pre> <p>Returns: - <code>qualified=True</code> + sensor details if building has sensors - <code>qualified=False</code> + empty dict if missing sensors</p>"},{"location":"app-development/step-03-sparql-qualify/#5-test-qualify","title":"5. Test qualify()","text":"<p>Create <code>test_qualify.py</code>:</p> <pre><code>\"\"\"Test qualification\"\"\"\nfrom pathlib import Path\nimport sys\n\napp_dir = Path(__file__).parent\nsys.path.insert(0, str(app_dir.parent.parent.parent))\n\nfrom hhw_brick.applications.my_first_app.app import qualify\n\n# Test with a Brick model\nfixtures = Path(__file__).parent.parent.parent.parent / \"tests\" / \"fixtures\"\nmodel_file = fixtures / \"Brick_Model_File\" / \"building_29.ttl\"\n\nif model_file.exists():\n    qualified, details = qualify(str(model_file))\n\n    if qualified:\n        print(\"\u2705 Test passed - building qualified\")\n        print(f\"   Found sensors: {list(details.keys())}\")\n    else:\n        print(\"\u26a0\ufe0f  Building not qualified\")\nelse:\n    print(\"\u26a0\ufe0f  Test file not found\")\n</code></pre> <p>Run: <pre><code>python test_qualify.py\n</code></pre></p>"},{"location":"app-development/step-03-sparql-qualify/#6-complete-apppy-so-far","title":"6. Complete app.py So Far","text":"<p>Your <code>app.py</code> should now have:</p> <pre><code>#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\"\"\"My First Application\"\"\"\n\nimport sys\nfrom pathlib import Path\nimport yaml\n\napp_dir = Path(__file__).parent\npackage_dir = app_dir.parent.parent.parent\nsys.path.insert(0, str(package_dir))\n\n__all__ = [\"qualify\", \"analyze\", \"load_config\"]\n\n\ndef load_config(config_file=None):\n    \"\"\"Load configuration from YAML file\"\"\"\n    # ...implementation from Step 2...\n\n\ndef find_required_sensors(graph):\n    \"\"\"Find required sensors using SPARQL\"\"\"\n    # ...implementation from this step...\n\n\ndef qualify(brick_model_path):\n    \"\"\"Check if building has required sensors\"\"\"\n    # ...implementation from this step...\n\n\n# analyze() will be added in Step 4\n</code></pre>"},{"location":"app-development/step-03-sparql-qualify/#checkpoint","title":"Checkpoint","text":"<ul> <li> Understand basic SPARQL patterns</li> <li> <code>find_required_sensors()</code> implemented</li> <li> <code>qualify()</code> function implemented</li> <li> Test finds qualified buildings</li> <li> Returns correct format: (bool, dict)</li> </ul>"},{"location":"app-development/step-03-sparql-qualify/#sparql-tips","title":"SPARQL Tips","text":"<p>Debug queries: 1. Start simple - find just the loop 2. Add one sensor at a time 3. Test in Brick Studio</p> <p>Common patterns: <pre><code># Find by type\n?equipment rdf:type brick:Hot_Water_Loop .\n\n# Find with subclasses\n?sensor rdf:type/rdfs:subClassOf* brick:Temperature_Sensor .\n\n# Filter by name\nFILTER(CONTAINS(LCASE(STR(?equipment)), \"primary\"))\n\n# Relationships (use hasPart for Systems/Loops, hasPoint for Equipment)\n?loop brick:hasPart ?point .        # For Hot_Water_Loop, Hot_Water_System\n?equipment brick:hasPoint ?point .  # For Boiler, Pump, Weather_Station\n</code></pre></p>"},{"location":"app-development/step-03-sparql-qualify/#next-step","title":"Next Step","text":"<p>\ud83d\udc49 Step 4: analyze Function - Part 1</p> <p>In this step, you'll learn to write SPARQL queries to find sensors in Brick models and implement the <code>qualify()</code> function.</p>"},{"location":"app-development/step-03-sparql-qualify/#goal-of-this-step","title":"Goal of This Step","text":"<ul> <li>Learn how to write SPARQL queries for Brick Schema</li> <li>Implement sensor discovery logic</li> <li>Create the <code>qualify()</code> function to check if buildings have required sensors</li> </ul>"},{"location":"app-development/step-03-sparql-qualify/#step-31-understanding-brick-schema","title":"Step 3.1: Understanding Brick Schema","text":"<p>Before writing SPARQL, understand how Brick models buildings:</p> <p>Brick uses RDF triples (Subject - Predicate - Object): <pre><code>&lt;equipment&gt; &lt;relationship&gt; &lt;point&gt;\n</code></pre></p> <p>Example: <pre><code>building:loop1 rdf:type brick:Hot_Water_Loop .\nbuilding:loop1 brick:hasPart building:temp_sensor1 .\nbuilding:temp_sensor1 rdf:type brick:Temperature_Sensor .\n</code></pre></p> <p>Common Relationships: - <code>brick:hasPart</code> - System/Loop has a point as part (used for Hot_Water_System, Hot_Water_Loop) - <code>brick:hasPoint</code> - Equipment has a point (used for Boiler, Pump, Weather_Station) - <code>brick:isPointOf</code> - Point belongs to equipment (inverse of hasPoint) - <code>rdf:type</code> - Entity is of a certain type - <code>rdfs:subClassOf*</code> - Includes subclasses (e.g., all types of temperature sensors)</p>"},{"location":"app-development/step-03-sparql-qualify/#step-32-learning-sparql-basics","title":"Step 3.2: Learning SPARQL Basics","text":"<p>SPARQL is a query language for RDF data.</p> <p>Basic SPARQL Pattern: <pre><code>SELECT ?variable1 ?variable2 WHERE {\n    ?variable1 predicate object .\n    ?variable2 predicate ?variable1 .\n}\n</code></pre></p> <p>Example - Find all temperature sensors: <pre><code>SELECT ?sensor WHERE {\n    ?sensor rdf:type/rdfs:subClassOf* brick:Temperature_Sensor .\n}\n</code></pre></p> <p>Point-to-Equipment Relationships: In our system, points are connected to equipment/systems via two different relationships: - Systems/Loops use <code>brick:hasPart</code> (e.g., secondary_loop, primary_loop, hot_water_system) - Equipment use <code>brick:hasPoint</code> (e.g., boiler, pump, weather_station)</p> <p>This mapping is defined in <code>sensor_to_brick_mapping.yaml</code>. For example: - <code>secondary_loop</code> hasPart: <code>sup</code>, <code>ret</code>, <code>flow</code>, <code>dp</code>, <code>hw</code> (Loops use hasPart) - <code>primary_loop</code> hasPart: <code>supp</code>, <code>retp</code>, <code>flowp</code>, <code>gas</code> (Loops use hasPart) - <code>boiler</code> hasPoint: <code>sup1-4</code>, <code>ret1-4</code>, <code>fire1-4</code> (Equipment use hasPoint) - <code>pump</code> hasPoint: <code>pmp1_pwr</code>, <code>pmp2_pwr</code>, <code>pmp1_spd</code>, <code>pmp2_spd</code> (Equipment use hasPoint)</p> <p>SPARQL Resources: - Brick Schema Docs: https://docs.brickschema.org/ - SPARQL Tutorial: https://www.w3.org/TR/sparql11-query/ - Brick Studio (Visual Tool): https://brickstudio.io/</p>"},{"location":"app-development/step-03-sparql-qualify/#step-33-write-a-simple-sparql-query","title":"Step 3.3: Write a Simple SPARQL Query","text":"<p>Let's create a query to find temperature sensors on a hot water loop.</p> <p>Add this function to <code>app.py</code>:</p> <pre><code>def find_required_sensors(graph):\n    \"\"\"\n    Find required sensors using SPARQL query\n\n    Args:\n        graph: RDF graph loaded from Brick model\n\n    Returns:\n        Tuple of (equipment, sensor1, sensor2) or None if not found\n\n    Example:\n        This query finds:\n        - A Hot_Water_Loop (secondary_loop or primary_loop)\n        - A Leaving_Hot_Water_Temperature_Sensor (supply) - part of that loop\n        - An Entering_Hot_Water_Temperature_Sensor (return) - part of that loop\n\n    Note:\n        Based on sensor_to_brick_mapping.yaml:\n        - secondary_loop has: sup (leaving), ret (entering)\n        - primary_loop has: supp (leaving), retp (entering)\n    \"\"\"\n    from hhw_brick.utils import query_sensors\n\n    # SPARQL query to find sensors\n    query = \"\"\"\n    SELECT ?equipment ?supply_sensor ?return_sensor WHERE {\n        # Find a Hot Water Loop (secondary_loop or primary_loop)\n        ?equipment rdf:type/rdfs:subClassOf* brick:Hot_Water_Loop .\n\n        # Find supply temperature sensor (part of the loop)\n        # This could be 'sup' on secondary_loop or 'supp' on primary_loop\n        ?equipment brick:hasPart ?supply_sensor .\n        ?supply_sensor rdf:type/rdfs:subClassOf* brick:Leaving_Hot_Water_Temperature_Sensor .\n\n        # Find return temperature sensor (part of the loop)\n        # This could be 'ret' on secondary_loop or 'retp' on primary_loop\n        ?equipment brick:hasPart ?return_sensor .\n        ?return_sensor rdf:type/rdfs:subClassOf* brick:Entering_Hot_Water_Temperature_Sensor .\n    }\n    \"\"\"\n\n    # Execute query using HHW Brick utility\n    results = query_sensors(graph, [], custom_query=query)\n\n    # Return first result or None\n    return results[0] if results else None\n</code></pre> <p>Understanding the Query:</p> <ol> <li>Find equipment:    <pre><code>?equipment rdf:type/rdfs:subClassOf* brick:Hot_Water_Loop .\n</code></pre></li> <li><code>?equipment</code> is a variable (like a wildcard)</li> <li><code>rdf:type/rdfs:subClassOf*</code> means \"is a type of or subtype of\"</li> <li> <p>Finds any Hot_Water_Loop</p> </li> <li> <p>Find supply sensor:    <pre><code>?equipment brick:hasPart ?supply_sensor .\n?supply_sensor rdf:type/rdfs:subClassOf* brick:Leaving_Hot_Water_Temperature_Sensor .\n</code></pre></p> </li> <li>First line: loop has this sensor as a part</li> <li> <p>Second line: sensor is a Leaving (supply) temperature sensor</p> </li> <li> <p>Find return sensor:    <pre><code>?equipment brick:hasPart ?return_sensor .\n?return_sensor rdf:type/rdfs:subClassOf* brick:Entering_Hot_Water_Temperature_Sensor .\n</code></pre></p> </li> <li>Similar pattern for return temperature sensor</li> </ol>"},{"location":"app-development/step-03-sparql-qualify/#step-34-add-filters-optional","title":"Step 3.4: Add Filters (Optional)","text":"<p>You can add filters to make queries more specific.</p> <p>Example - Filter by name: <pre><code>SELECT ?equipment ?supply_sensor ?return_sensor WHERE {\n    ?equipment rdf:type/rdfs:subClassOf* brick:Hot_Water_Loop .\n\n    # Filter to only primary loops (name contains \"primary\")\n    FILTER(CONTAINS(LCASE(STR(?equipment)), \"primary\"))\n\n    ?equipment brick:hasPart ?supply_sensor .\n    ?supply_sensor rdf:type/rdfs:subClassOf* brick:Leaving_Hot_Water_Temperature_Sensor .\n\n    ?equipment brick:hasPart ?return_sensor .\n    ?return_sensor rdf:type/rdfs:subClassOf* brick:Entering_Hot_Water_Temperature_Sensor .\n}\n</code></pre></p> <p>Filter Functions: - <code>CONTAINS(string, substring)</code> - Check if string contains substring - <code>LCASE(string)</code> - Convert to lowercase - <code>STR(uri)</code> - Convert URI to string</p>"},{"location":"app-development/step-03-sparql-qualify/#step-35-implement-qualify-function","title":"Step 3.5: Implement qualify() Function","text":"<p>Now create the <code>qualify()</code> function that uses the SPARQL query.</p> <p>Add this to <code>app.py</code>:</p> <pre><code>def qualify(brick_model_path):\n    \"\"\"\n    Check if building has required sensors\n\n    Args:\n        brick_model_path (str|Path): Path to Brick model file (.ttl)\n\n    Returns:\n        Tuple of (qualified: bool, details: dict)\n        - qualified: True if building has all required sensors\n        - details: Dictionary with sensor URIs if qualified, empty dict otherwise\n\n    Example:\n        &gt;&gt;&gt; qualified, details = qualify(\"building_model.ttl\")\n        &gt;&gt;&gt; if qualified:\n        ...     print(f\"Loop: {details['equipment']}\")\n        ...     print(f\"Supply sensor: {details['supply']}\")\n        ...     print(f\"Return sensor: {details['return']}\")\n    \"\"\"\n    print(f\"\\n{'='*60}\")\n    print(f\"QUALIFY: Checking required sensors\")\n    print(f\"{'='*60}\\n\")\n\n    # Load Brick model\n    from rdflib import Graph\n\n    g = Graph()\n    g.parse(brick_model_path, format=\"turtle\")\n\n    # Find sensors using SPARQL\n    result = find_required_sensors(g)\n\n    if result:\n        equipment, supply_sensor, return_sensor = result\n\n        # Building is qualified\n        print(f\"[OK] Building qualified\")\n        print(f\"   Equipment: {equipment}\")\n        print(f\"   Supply Sensor: {supply_sensor}\")\n        print(f\"   Return Sensor: {return_sensor}\\n\")\n\n        return True, {\n            \"equipment\": str(equipment),\n            \"supply\": str(supply_sensor),\n            \"return\": str(return_sensor)\n        }\n    else:\n        # Building not qualified\n        print(f\"[FAIL] Building NOT qualified\")\n        print(f\"   Missing: Required sensors (supply and return temperature on hot water loop)\\n\")\n\n        return False, {}\n</code></pre> <p>Understanding the Function:</p> <ol> <li>Print header: Inform user what's happening</li> <li>Load model: Parse Brick .ttl file into RDF graph</li> <li>Query sensors: Use SPARQL to find required sensors</li> <li>Check result:</li> <li>If found: return <code>True</code> with sensor details</li> <li>If not found: return <code>False</code> with empty dict</li> </ol>"},{"location":"app-development/step-03-sparql-qualify/#step-36-test-qualify-function","title":"Step 3.6: Test qualify() Function","text":"<p>Create a test script to verify <code>qualify()</code> works.</p> <p>Create <code>test_qualify.py</code>:</p> <pre><code>\"\"\"\nTest script for qualify function\n\"\"\"\n\nfrom pathlib import Path\nimport sys\n\n# Add parent directory to path\napp_dir = Path(__file__).parent\nsys.path.insert(0, str(app_dir.parent.parent.parent))\n\nfrom hhw_brick.applications.my_first_app.app import qualify\n\ndef test_qualify():\n    \"\"\"Test qualification function\"\"\"\n    print(\"Testing qualify() function...\\n\")\n\n    # Path to test Brick models\n    fixtures = Path(__file__).parent.parent.parent.parent / \"tests\" / \"fixtures\" / \"Brick_Model_File\"\n\n    if not fixtures.exists():\n        print(\"Warning: Test fixtures not found. Skipping test.\")\n        return\n\n    # Test on multiple buildings\n    for model_file in fixtures.glob(\"*.ttl\"):\n        print(f\"\\n{'='*60}\")\n        print(f\"Testing: {model_file.name}\")\n        print(f\"{'='*60}\")\n\n        try:\n            qualified, details = qualify(str(model_file))\n\n            if qualified:\n                print(f\"\u2713 Building qualifies!\")\n                print(f\"  Found sensors:\")\n                for key, value in details.items():\n                    print(f\"    {key}: {value.split('#')[-1]}\")\n            else:\n                print(f\"\u2717 Building does not qualify\")\n\n        except Exception as e:\n            print(f\"\u274c Error: {e}\")\n\n    print(f\"\\n{'='*60}\")\n    print(\"Test complete!\")\n    print(f\"{'='*60}\\n\")\n\nif __name__ == \"__main__\":\n    test_qualify()\n</code></pre> <p>Run the test: <pre><code>python test_qualify.py\n</code></pre></p>"},{"location":"app-development/step-03-sparql-qualify/#step-37-your-apppy-structure-so-far","title":"Step 3.7: Your app.py Structure So Far","text":"<p>Your <code>app.py</code> should now have:</p> <pre><code>#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\"\"\"My First Application\"\"\"\n\nimport sys\nfrom pathlib import Path\nimport yaml\n\n# Setup paths\napp_dir = Path(__file__).parent\npackage_dir = app_dir.parent.parent.parent\nsys.path.insert(0, str(package_dir))\n\n__all__ = [\"qualify\", \"analyze\", \"load_config\"]\n\n\ndef load_config(config_file=None):\n    \"\"\"Load configuration from YAML file\"\"\"\n    # ... implementation from Step 2 ...\n\n\ndef find_required_sensors(graph):\n    \"\"\"Find required sensors using SPARQL query\"\"\"\n    # ... implementation from this step ...\n\n\ndef qualify(brick_model_path):\n    \"\"\"Check if building has required sensors\"\"\"\n    # ... implementation from this step ...\n\n\n# analyze() will be added in next step\n</code></pre>"},{"location":"app-development/step-03-sparql-qualify/#checkpoint_1","title":"Checkpoint","text":"<p>Before proceeding, verify:</p> <ul> <li> <code>find_required_sensors()</code> function is implemented</li> <li> SPARQL query is correct and finds sensors</li> <li> <code>qualify()</code> function is implemented</li> <li> Function returns (bool, dict) tuple</li> <li> Test script runs and finds qualified buildings</li> </ul>"},{"location":"app-development/step-03-sparql-qualify/#next-steps","title":"Next Steps","text":"<p>\u2705 Qualification logic complete!</p> <p>\ud83d\udc49 Continue to Step 4: Write analyze Function - Part 1</p>"},{"location":"app-development/step-03-sparql-qualify/#sparql-tips_1","title":"SPARQL Tips","text":"<p>Debugging SPARQL Queries:</p> <ol> <li> <p>Start simple: First find just the equipment    <pre><code>SELECT ?equipment WHERE {\n    ?equipment rdf:type brick:Hot_Water_Loop .\n}\n</code></pre></p> </li> <li> <p>Add one constraint at a time: Then add sensors    <pre><code>SELECT ?equipment ?sensor WHERE {\n    ?equipment rdf:type brick:Hot_Water_Loop .\n    ?equipment brick:hasPart ?sensor .\n}\n</code></pre></p> </li> <li> <p>Add type filters: Finally filter sensor types    <pre><code>SELECT ?equipment ?sensor WHERE {\n    ?equipment rdf:type brick:Hot_Water_Loop .\n    ?equipment brick:hasPart ?sensor .\n    ?sensor rdf:type brick:Temperature_Sensor .\n}\n</code></pre></p> </li> </ol> <p>Common SPARQL Patterns:</p> <pre><code># Find all points of a system/loop (hasPart)\n?system brick:hasPart ?point .\n\n# Find all points of equipment (hasPoint)\n?equipment brick:hasPoint ?point .\n\n# Find equipment a point belongs to (inverse)\n?point brick:isPointOf ?equipment .\n\n# Find by exact type\n?entity rdf:type brick:SomeClass .\n\n# Find by type including subclasses\n?entity rdf:type/rdfs:subClassOf* brick:SomeClass .\n\n# Optional relationships (won't fail if missing)\nOPTIONAL { ?equipment brick:hasPart ?optionalPoint . }\n\n# Filter by property value\n?point brick:hasUnit \"degreesCelsius\" .\n</code></pre>"},{"location":"app-development/step-03-sparql-qualify/#common-issues","title":"Common Issues","text":"<p>Issue: Query returns no results Solution: - Check sensor type names (case-sensitive!) - Try without <code>rdfs:subClassOf*</code> first - Use Brick Studio to explore the model</p> <p>Issue: <code>ImportError: cannot import name 'query_sensors'</code> Solution: Make sure you added <code>sys.path.insert(0, ...)</code> at top of file</p> <p>Issue: Multiple results returned Solution: Add filters or take first result: <code>results[0]</code></p>"},{"location":"app-development/step-03-sparql-qualify/#resources","title":"Resources","text":"<p>Learn More About SPARQL for Brick: - Brick Schema Documentation: https://docs.brickschema.org/ - Brick Query Examples: https://docs.brickschema.org/query/index.html - SPARQL 1.1 Specification: https://www.w3.org/TR/sparql11-query/ - Brick Studio (Interactive): https://brickstudio.io/</p> <p>Brick Sensor Types: - Temperature: <code>Leaving_Hot_Water_Temperature_Sensor</code>, <code>Entering_Hot_Water_Temperature_Sensor</code> - Flow: <code>Water_Flow_Sensor</code>, <code>Hot_Water_Flow_Sensor</code> - Power: <code>Thermal_Power_Sensor</code>, <code>Electric_Power_Sensor</code> - Full list: https://brickschema.org/ontology/</p>"},{"location":"app-development/step-04-analyze-part1/","title":"Step 4: analyze Function - Part 1 (Data Loading)","text":"<p>Implement data loading and sensor mapping in the analyze function.</p>"},{"location":"app-development/step-04-analyze-part1/#1-add-data-processing-imports","title":"1. Add Data Processing Imports","text":"<p>Add these to the top of <code>app.py</code>:</p> <pre><code>import pandas as pd\nimport numpy as np\n\nfrom hhw_brick.utils import (\n    load_data,\n    map_sensors_to_columns,\n    extract_data_columns,\n    filter_time_range,\n)\n</code></pre>"},{"location":"app-development/step-04-analyze-part1/#2-start-analyze-function","title":"2. Start analyze() Function","text":"<pre><code>def analyze(brick_model_path, timeseries_data_path, config):\n    \"\"\"\n    Execute analysis workflow\n\n    Args:\n        brick_model_path: Path to Brick model (.ttl)\n        timeseries_data_path: Path to time-series data (.csv)\n        config: Configuration dictionary\n\n    Returns:\n        dict: {'stats': {...}, 'data': DataFrame} or None if failed\n    \"\"\"\n    # Step 1: Qualify building\n    qualified, qualify_result = qualify(brick_model_path)\n    if not qualified:\n        return None\n\n    # Step 2: Load data\n    print(f\"\\n{'='*60}\")\n    print(\"LOAD DATA\")\n    print(f\"{'='*60}\\n\")\n\n    g, df = load_data(brick_model_path, timeseries_data_path)\n    print(f\"\u2713 Loaded {len(df)} data points\")\n    print(f\"\u2713 Time range: {df.index.min()} to {df.index.max()}\\n\")\n</code></pre> <p>What happens: - Checks if building qualifies (from Step 3) - Loads Brick model as RDF graph (<code>g</code>) - Loads CSV as pandas DataFrame (<code>df</code>)</p>"},{"location":"app-development/step-04-analyze-part1/#3-map-sensors-to-data-columns","title":"3. Map Sensors to Data Columns","text":"<pre><code>    # Step 3: Map sensors to columns\n    print(f\"{'='*60}\")\n    print(\"MAP SENSORS\")\n    print(f\"{'='*60}\\n\")\n\n    supply_uri = qualify_result[\"supply\"]\n    return_uri = qualify_result[\"return\"]\n\n    sensor_mapping = map_sensors_to_columns(g, [supply_uri, return_uri], df)\n\n    if len(sensor_mapping) != 2:\n        print(\"\u2717 Failed to map sensors to data columns\\n\")\n        return None\n\n    print(f\"\u2713 Sensors mapped:\")\n    for uri, col in sensor_mapping.items():\n        print(f\"  {uri.split('#')[-1]} \u2192 {col}\")\n    print()\n</code></pre> <p>Why mapping: - Brick models use URIs like <code>building:sensor1</code> - CSV has column names like <code>\"temp_supply\"</code> - Need to connect them</p>"},{"location":"app-development/step-04-analyze-part1/#4-extract-and-rename-data","title":"4. Extract and Rename Data","text":"<pre><code>    # Step 4: Extract data\n    df_extracted = extract_data_columns(\n        df,\n        sensor_mapping,\n        rename_map={supply_uri: \"supply\", return_uri: \"return\"}\n    )\n\n    print(f\"\u2713 Extracted {len(df_extracted)} rows\")\n    print(f\"\u2713 Columns: {list(df_extracted.columns)}\\n\")\n</code></pre> <p>Result: DataFrame with just <code>supply</code> and <code>return</code> columns</p>"},{"location":"app-development/step-04-analyze-part1/#5-filter-time-range-optional","title":"5. Filter Time Range (Optional)","text":"<pre><code>    # Step 5: Filter time range (optional)\n    if config[\"time_range\"][\"start_time\"] or config[\"time_range\"][\"end_time\"]:\n        df_extracted = filter_time_range(\n            df_extracted,\n            config[\"time_range\"][\"start_time\"],\n            config[\"time_range\"][\"end_time\"]\n        )\n        print(f\"\u2713 Filtered to {len(df_extracted)} rows\\n\")\n\n    # Temporary return (will add analysis in Step 5)\n    return {\"stats\": {}, \"data\": df_extracted}\n</code></pre>"},{"location":"app-development/step-04-analyze-part1/#6-test-data-loading","title":"6. Test Data Loading","text":"<p>Create <code>test_analyze.py</code>:</p> <pre><code>\"\"\"Test analyze data loading\"\"\"\nfrom pathlib import Path\nimport sys\n\napp_dir = Path(__file__).parent\nsys.path.insert(0, str(app_dir.parent.parent.parent))\n\nfrom hhw_brick.applications.my_first_app.app import analyze, load_config\n\nfixtures = Path(__file__).parent.parent.parent.parent / \"tests\" / \"fixtures\"\nmodel = fixtures / \"Brick_Model_File\" / \"building_29.ttl\"\ndata = fixtures / \"TimeSeriesData\" / \"29hhw_system_data.csv\"\n\nif model.exists() and data.exists():\n    config = load_config()\n    results = analyze(str(model), str(data), config)\n\n    if results:\n        print(\"\\n\u2705 Data loading successful\")\n        print(f\"Data shape: {results['data'].shape}\")\n        print(f\"Columns: {list(results['data'].columns)}\")\n    else:\n        print(\"\\n\u2717 Failed\")\nelse:\n    print(\"\u26a0\ufe0f  Test files not found\")\n</code></pre> <p>Run: <pre><code>python test_analyze.py\n</code></pre></p>"},{"location":"app-development/step-04-analyze-part1/#checkpoint","title":"Checkpoint","text":"<ul> <li> Data processing imports added</li> <li> <code>analyze()</code> function started</li> <li> Data loading works</li> <li> Sensor mapping successful</li> <li> Data extraction returns DataFrame</li> <li> Test runs successfully</li> </ul>"},{"location":"app-development/step-04-analyze-part1/#next-step","title":"Next Step","text":"<p>\ud83d\udc49 Step 5: analyze Function - Part 2</p> <p>In this step, you'll implement the first part of the <code>analyze()</code> function, focusing on loading and preparing data.</p>"},{"location":"app-development/step-04-analyze-part1/#goal-of-this-step","title":"Goal of This Step","text":"<ul> <li>Load Brick model and time-series data</li> <li>Map sensors to data columns</li> <li>Extract and filter relevant data</li> </ul>"},{"location":"app-development/step-04-analyze-part1/#step-41-add-required-imports","title":"Step 4.1: Add Required Imports","text":"<p>Add these imports to the top of your <code>app.py</code> (after existing imports):</p> <pre><code>import pandas as pd\nimport numpy as np\n\n# Import HHW Brick utilities\nfrom hhw_brick.utils import (\n    load_data,\n    map_sensors_to_columns,\n    extract_data_columns,\n    filter_time_range,\n)\n</code></pre>"},{"location":"app-development/step-04-analyze-part1/#step-42-start-the-analyze-function","title":"Step 4.2: Start the analyze() Function","text":"<p>Add the basic structure of the <code>analyze()</code> function:</p> <pre><code>def analyze(brick_model_path, timeseries_data_path, config):\n    \"\"\"\n    Execute analysis workflow\n\n    Args:\n        brick_model_path (str|Path): Path to Brick model file (.ttl)\n        timeseries_data_path (str|Path): Path to time-series data (.csv)\n        config (dict): Configuration dictionary from load_config()\n\n    Returns:\n        dict: Analysis results with 'stats' and 'data' keys, or None if analysis fails\n\n    Example:\n        &gt;&gt;&gt; config = load_config()\n        &gt;&gt;&gt; results = analyze(\"model.ttl\", \"data.csv\", config)\n        &gt;&gt;&gt; if results:\n        ...     print(f\"Mean: {results['stats']['mean']}\")\n        ...     print(f\"Data shape: {results['data'].shape}\")\n    \"\"\"\n    # Step 1: Qualify building\n    print(f\"\\n{'='*60}\")\n    print(f\"STEP 1: Qualification\")\n    print(f\"{'='*60}\")\n\n    qualified, qualify_result = qualify(brick_model_path)\n    if not qualified:\n        print(\"[FAIL] Building not qualified. Analysis aborted.\\n\")\n        return None\n\n    print(\"[OK] Building qualified. Proceeding with analysis.\\n\")\n\n    # Steps 2-5 will be added below...\n</code></pre>"},{"location":"app-development/step-04-analyze-part1/#step-43-load-data","title":"Step 4.3: Load Data","text":"<p>Add data loading logic:</p> <pre><code>    # Step 2: Load data\n    print(f\"{'='*60}\")\n    print(f\"STEP 2: Load Data\")\n    print(f\"{'='*60}\\n\")\n\n    # Load both Brick model and time-series data\n    g, df = load_data(brick_model_path, timeseries_data_path)\n\n    print(f\"[OK] Loaded {len(df)} data points\")\n    print(f\"[OK] Time range: {df.index.min()} to {df.index.max()}\")\n    print(f\"[OK] Columns: {list(df.columns)}\\n\")\n</code></pre> <p>Understanding load_data(): - Loads Brick model as RDF graph (<code>g</code>) - Loads CSV as pandas DataFrame (<code>df</code>) - Automatically sets datetime index - Returns both objects as tuple</p>"},{"location":"app-development/step-04-analyze-part1/#step-44-map-sensors-to-columns","title":"Step 4.4: Map Sensors to Columns","text":"<p>Time-series data has column names, but Brick models have sensor URIs. We need to map them:</p> <pre><code>    # Step 3: Map sensors to data columns\n    print(f\"{'='*60}\")\n    print(f\"STEP 3: Map Sensors to Data\")\n    print(f\"{'='*60}\\n\")\n\n    # Get sensor URIs from qualification result\n    supply_uri = qualify_result[\"supply\"]\n    return_uri = qualify_result[\"return\"]\n\n    print(f\"Looking for sensors:\")\n    print(f\"  Supply: {supply_uri}\")\n    print(f\"  Return: {return_uri}\\n\")\n\n    # Map sensor URIs to column names in DataFrame\n    sensor_mapping = map_sensors_to_columns(\n        g,  # Brick model graph\n        [supply_uri, return_uri],  # Sensors to find\n        df  # DataFrame with column names\n    )\n\n    # Verify we found both sensors\n    if len(sensor_mapping) != 2:\n        print(f\"[FAIL] Failed to map sensors to data columns\")\n        print(f\"  Expected 2 sensors, found {len(sensor_mapping)}\\n\")\n        return None\n\n    print(f\"[OK] Sensors mapped successfully:\")\n    for uri, col in sensor_mapping.items():\n        print(f\"  {uri.split('#')[-1]} -&gt; {col}\")\n    print()\n</code></pre> <p>Understanding map_sensors_to_columns(): - Uses Brick model to find <code>brick:hasLabel</code> or <code>brick:timeseries</code> properties - Matches sensor URIs to CSV column names - Returns dictionary: <code>{sensor_uri: column_name}</code></p>"},{"location":"app-development/step-04-analyze-part1/#step-45-extract-relevant-data","title":"Step 4.5: Extract Relevant Data","text":"<p>Extract only the columns we need and rename them:</p> <pre><code>    # Step 4: Extract and prepare data\n    print(f\"{'='*60}\")\n    print(f\"STEP 4: Extract Data\")\n    print(f\"{'='*60}\\n\")\n\n    # Extract sensor data and rename columns\n    df_extracted = extract_data_columns(\n        df,\n        sensor_mapping,\n        rename_map={\n            supply_uri: \"supply\",  # Rename to friendly name\n            return_uri: \"return\"   # Rename to friendly name\n        }\n    )\n\n    print(f\"[OK] Extracted {len(df_extracted)} rows\")\n    print(f\"[OK] Columns: {list(df_extracted.columns)}\\n\")\n</code></pre> <p>Understanding extract_data_columns(): - Extracts specific columns from DataFrame - Renames them to friendly names - Returns new DataFrame with only relevant data</p>"},{"location":"app-development/step-04-analyze-part1/#step-46-filter-time-range-optional","title":"Step 4.6: Filter Time Range (Optional)","text":"<p>If user specified a time range in config, filter the data:</p> <pre><code>    # Step 5: Filter time range (optional)\n    if config[\"time_range\"][\"start_time\"] or config[\"time_range\"][\"end_time\"]:\n        print(f\"{'='*60}\")\n        print(f\"STEP 5: Filter Time Range\")\n        print(f\"{'='*60}\\n\")\n\n        start = config[\"time_range\"][\"start_time\"]\n        end = config[\"time_range\"][\"end_time\"]\n\n        print(f\"Filtering to: {start} to {end}\")\n\n        df_extracted = filter_time_range(df_extracted, start, end)\n\n        print(f\"[OK] Filtered to {len(df_extracted)} rows\\n\")\n\n    # Return prepared data (analysis logic will be added in next step)\n    return {\n        \"stats\": {},  # Will be filled in Step 5\n        \"data\": df_extracted\n    }\n</code></pre>"},{"location":"app-development/step-04-analyze-part1/#step-47-complete-analyze-so-far","title":"Step 4.7: Complete analyze() So Far","text":"<p>Your <code>analyze()</code> function should now look like this:</p> <pre><code>def analyze(brick_model_path, timeseries_data_path, config):\n    \"\"\"Execute analysis workflow\"\"\"\n\n    # Step 1: Qualify\n    print(f\"\\n{'='*60}\")\n    print(f\"STEP 1: Qualification\")\n    print(f\"{'='*60}\")\n    qualified, qualify_result = qualify(brick_model_path)\n    if not qualified:\n        return None\n    print(\"[OK] Qualified\\n\")\n\n    # Step 2: Load data\n    print(f\"{'='*60}\")\n    print(f\"STEP 2: Load Data\")\n    print(f\"{'='*60}\\n\")\n    g, df = load_data(brick_model_path, timeseries_data_path)\n    print(f\"[OK] Loaded {len(df)} data points\\n\")\n\n    # Step 3: Map sensors\n    print(f\"{'='*60}\")\n    print(f\"STEP 3: Map Sensors\")\n    print(f\"{'='*60}\\n\")\n    supply_uri = qualify_result[\"supply\"]\n    return_uri = qualify_result[\"return\"]\n    sensor_mapping = map_sensors_to_columns(g, [supply_uri, return_uri], df)\n\n    if len(sensor_mapping) != 2:\n        print(\"[FAIL] Sensor mapping failed\\n\")\n        return None\n    print(\"[OK] Sensors mapped\\n\")\n\n    # Step 4: Extract data\n    print(f\"{'='*60}\")\n    print(f\"STEP 4: Extract Data\")\n    print(f\"{'='*60}\\n\")\n    df_extracted = extract_data_columns(\n        df, sensor_mapping,\n        rename_map={supply_uri: \"supply\", return_uri: \"return\"}\n    )\n    print(f\"[OK] Data extracted\\n\")\n\n    # Step 5: Filter time range (optional)\n    if config[\"time_range\"][\"start_time\"] or config[\"time_range\"][\"end_time\"]:\n        df_extracted = filter_time_range(\n            df_extracted,\n            config[\"time_range\"][\"start_time\"],\n            config[\"time_range\"][\"end_time\"]\n        )\n        print(f\"[OK] Time filtered\\n\")\n\n    # Placeholder return (will be completed in Step 5)\n    return {\n        \"stats\": {},\n        \"data\": df_extracted\n    }\n</code></pre>"},{"location":"app-development/step-04-analyze-part1/#step-48-test-data-loading","title":"Step 4.8: Test Data Loading","text":"<p>Create a test to verify data loading works:</p> <p>Create <code>test_analyze_part1.py</code>:</p> <pre><code>\"\"\"\nTest data loading part of analyze function\n\"\"\"\n\nfrom pathlib import Path\nimport sys\n\napp_dir = Path(__file__).parent\nsys.path.insert(0, str(app_dir.parent.parent.parent))\n\nfrom hhw_brick.applications.my_first_app.app import analyze, load_config\n\ndef test_data_loading():\n    \"\"\"Test data loading steps\"\"\"\n    print(\"Testing data loading...\\n\")\n\n    # Use test fixtures\n    fixtures = Path(__file__).parent.parent.parent.parent / \"tests\" / \"fixtures\"\n\n    # Find a qualified building\n    model_file = fixtures / \"Brick_Model_File\" / \"building_105_non-condensing_h.ttl\"\n    data_file = fixtures / \"TimeSeriesData\" / \"105hhw_system_data.csv\"\n\n    if not model_file.exists() or not data_file.exists():\n        print(\"Test files not found. Skipping test.\")\n        return\n\n    # Load config\n    config = load_config()\n\n    # Run analysis (only data loading part)\n    print(f\"Testing with: {model_file.name}\\n\")\n    results = analyze(str(model_file), str(data_file), config)\n\n    if results:\n        print(f\"\\n{'='*60}\")\n        print(\"\u2705 Data loading successful!\")\n        print(f\"{'='*60}\")\n        print(f\"Data shape: {results['data'].shape}\")\n        print(f\"Columns: {list(results['data'].columns)}\")\n        print(f\"First 5 rows:\")\n        print(results['data'].head())\n    else:\n        print(\"\\n\u274c Data loading failed\")\n\nif __name__ == \"__main__\":\n    test_data_loading()\n</code></pre> <p>Run the test: <pre><code>python test_analyze_part1.py\n</code></pre></p>"},{"location":"app-development/step-04-analyze-part1/#checkpoint_1","title":"Checkpoint","text":"<p>Before proceeding, verify:</p> <ul> <li> <code>analyze()</code> function exists</li> <li> Qualification step works</li> <li> Data loading succeeds</li> <li> Sensor mapping finds sensors</li> <li> Data extraction returns DataFrame</li> <li> Optional time filtering works</li> <li> Test script runs successfully</li> </ul>"},{"location":"app-development/step-04-analyze-part1/#next-steps","title":"Next Steps","text":"<p>\u2705 Data loading complete!</p> <p>\ud83d\udc49 Continue to Step 5: analyze Function - Part 2 (Analysis Logic)</p>"},{"location":"app-development/step-04-analyze-part1/#common-issues","title":"Common Issues","text":"<p>Issue: <code>ModuleNotFoundError: No module named 'hhw_brick.utils'</code> Solution: Check <code>sys.path.insert(0, ...)</code> is at top of file</p> <p>Issue: <code>KeyError</code> when accessing sensor URIs Solution: Verify <code>qualify()</code> returns correct keys in details dict</p> <p>Issue: <code>sensor_mapping</code> is empty Solution: - Check if CSV column names match Brick model labels - Ensure sensors have <code>brick:hasLabel</code> or <code>brick:timeseries</code> properties</p> <p>Issue: <code>df_extracted</code> has NaN values Solution: This is normal; we'll handle missing data in Step 5</p>"},{"location":"app-development/step-04-analyze-part1/#understanding-the-hhw-brick-utilities","title":"Understanding the HHW Brick Utilities","text":""},{"location":"app-development/step-04-analyze-part1/#load_data","title":"load_data()","text":"<pre><code>g, df = load_data(brick_model, timeseries_csv)\n</code></pre> <p>Returns: - <code>g</code>: RDF graph (rdflib.Graph) with Brick model - <code>df</code>: pandas DataFrame with time-series data (datetime index)</p>"},{"location":"app-development/step-04-analyze-part1/#map_sensors_to_columns","title":"map_sensors_to_columns()","text":"<pre><code>mapping = map_sensors_to_columns(graph, sensor_uris, dataframe)\n</code></pre> <p>Returns: Dict mapping sensor URIs to column names <pre><code>{\n    \"http://example.org#sensor1\": \"column_name_1\",\n    \"http://example.org#sensor2\": \"column_name_2\"\n}\n</code></pre></p>"},{"location":"app-development/step-04-analyze-part1/#extract_data_columns","title":"extract_data_columns()","text":"<pre><code>df_new = extract_data_columns(df, sensor_mapping, rename_map)\n</code></pre> <p>Returns: DataFrame with extracted and renamed columns</p>"},{"location":"app-development/step-04-analyze-part1/#filter_time_range","title":"filter_time_range()","text":"<pre><code>df_filtered = filter_time_range(df, start_time, end_time)\n</code></pre> <p>Parameters: - <code>start_time</code>: String \"YYYY-MM-DD\" or None - <code>end_time</code>: String \"YYYY-MM-DD\" or None</p> <p>Returns: Filtered DataFrame</p>"},{"location":"app-development/step-05-analyze-part2/","title":"Step 5: analyze Function - Part 2 (Analysis Logic)","text":"<p>Implement statistical analysis and anomaly detection.</p>"},{"location":"app-development/step-05-analyze-part2/#1-calculate-temperature-differential","title":"1. Calculate Temperature Differential","text":"<p>Continue the <code>analyze()</code> function from Step 4:</p> <pre><code>    # Step 6: Analyze\n    print(f\"{'='*60}\")\n    print(\"ANALYZE\")\n    print(f\"{'='*60}\\n\")\n\n    # Calculate temperature differential\n    df_extracted[\"temp_diff\"] = df_extracted[\"supply\"] - df_extracted[\"return\"]\n    df_clean = df_extracted.dropna().copy()\n\n    if len(df_clean) == 0:\n        print(\"\u2717 No valid data after removing NaN\\n\")\n        return None\n\n    print(f\"\u2713 Valid data points: {len(df_clean)}\")\n</code></pre> <p>Why dropna(): Removes rows with missing values</p>"},{"location":"app-development/step-05-analyze-part2/#2-compute-statistics","title":"2. Compute Statistics","text":"<pre><code>    # Get thresholds from config\n    threshold_min = config[\"analysis\"][\"threshold_min_delta\"]\n    threshold_max = config[\"analysis\"][\"threshold_max_delta\"]\n\n    # Calculate statistics\n    stats = {\n        \"count\": len(df_clean),\n        \"mean_temp_diff\": df_clean[\"temp_diff\"].mean(),\n        \"std_temp_diff\": df_clean[\"temp_diff\"].std(),\n        \"min_temp_diff\": df_clean[\"temp_diff\"].min(),\n        \"max_temp_diff\": df_clean[\"temp_diff\"].max(),\n        \"median_temp_diff\": df_clean[\"temp_diff\"].median(),\n        \"q25_temp_diff\": df_clean[\"temp_diff\"].quantile(0.25),\n        \"q75_temp_diff\": df_clean[\"temp_diff\"].quantile(0.75),\n        \"mean_supply_temp\": df_clean[\"supply\"].mean(),\n        \"mean_return_temp\": df_clean[\"return\"].mean(),\n    }\n</code></pre> <p>Statistics explained: - <code>mean()</code> - Average - <code>std()</code> - Standard deviation (spread) - <code>quantile(0.25)</code> - 25<sup>th</sup> percentile (Q1) - <code>median()</code> - 50<sup>th</sup> percentile</p>"},{"location":"app-development/step-05-analyze-part2/#3-detect-anomalies","title":"3. Detect Anomalies","text":"<pre><code>    # Anomaly detection\n    anomalies_low = df_clean[df_clean[\"temp_diff\"] &lt; threshold_min]\n    anomalies_high = df_clean[df_clean[\"temp_diff\"] &gt; threshold_max]\n\n    stats[\"anomalies_below_threshold\"] = len(anomalies_low)\n    stats[\"anomalies_above_threshold\"] = len(anomalies_high)\n    stats[\"anomaly_rate\"] = (\n        (stats[\"anomalies_below_threshold\"] + stats[\"anomalies_above_threshold\"])\n        / stats[\"count\"] * 100\n    )\n\n    # Print summary\n    print(f\"\\nStatistics:\")\n    print(f\"  Mean: {stats['mean_temp_diff']:.2f}\u00b0C\")\n    print(f\"  Std:  {stats['std_temp_diff']:.2f}\u00b0C\")\n    print(f\"  Range: [{stats['min_temp_diff']:.2f}, {stats['max_temp_diff']:.2f}]\u00b0C\")\n    print(f\"  Anomalies: {stats['anomaly_rate']:.2f}%\")\n</code></pre>"},{"location":"app-development/step-05-analyze-part2/#4-add-time-features","title":"4. Add Time Features","text":"<pre><code>    # Add time features for visualization\n    df_clean.loc[:, \"hour\"] = df_clean.index.hour\n    df_clean.loc[:, \"weekday\"] = df_clean.index.dayofweek\n    df_clean.loc[:, \"month\"] = df_clean.index.month\n</code></pre> <p>Time features: - <code>hour</code> - 0-23 - <code>weekday</code> - 0=Monday, 6=Sunday - <code>month</code> - 1-12</p>"},{"location":"app-development/step-05-analyze-part2/#5-save-results","title":"5. Save Results","text":"<pre><code>def save_results(results, config):\n    \"\"\"Save statistics and time-series to CSV/JSON\"\"\"\n    output_dir = Path(config[\"output\"][\"output_dir\"])\n    output_dir.mkdir(parents=True, exist_ok=True)\n    fmt = config[\"output\"][\"export_format\"]\n\n    print(f\"\\n{'='*60}\")\n    print(f\"SAVE: {output_dir}\")\n    print(f\"{'='*60}\\n\")\n\n    # Save stats\n    stats_file = output_dir / f\"stats.{fmt}\"\n    stats_df = pd.DataFrame([results[\"stats\"]])\n\n    if fmt == \"csv\":\n        stats_df.to_csv(stats_file, index=False)\n    else:\n        stats_df.to_json(stats_file, orient=\"records\", indent=2)\n    print(f\"\u2713 {stats_file.name}\")\n\n    # Save timeseries\n    ts_file = output_dir / f\"timeseries.{fmt}\"\n    if fmt == \"csv\":\n        results[\"data\"].to_csv(ts_file)\n    else:\n        results[\"data\"].to_json(ts_file, orient=\"index\", date_format=\"iso\")\n    print(f\"\u2713 {ts_file.name}\")\n</code></pre>"},{"location":"app-development/step-05-analyze-part2/#6-complete-analyze","title":"6. Complete analyze()","text":"<pre><code>    # Create results\n    results = {\"stats\": stats, \"data\": df_clean}\n\n    # Save and visualize\n    if config[\"output\"][\"save_results\"]:\n        save_results(results, config)\n\n    if config[\"output\"][\"generate_plots\"]:\n        generate_plots(results, config)  # Step 6\n\n    if config[\"output\"][\"generate_plotly_html\"]:\n        generate_plotly_html(results, config)  # Step 7\n\n    return results\n</code></pre>"},{"location":"app-development/step-05-analyze-part2/#7-test-complete-analysis","title":"7. Test Complete Analysis","text":"<p>Update your test:</p> <pre><code>\"\"\"Test complete analysis\"\"\"\nfrom hhw_brick.applications.my_first_app.app import analyze, load_config\n\nconfig = load_config()\nconfig[\"output\"][\"output_dir\"] = \"./test_output\"\n\nresults = analyze(\"building_29.ttl\", \"29hhw_system_data.csv\", config)\n\nif results:\n    print(\"\\n\u2705 Analysis complete!\")\n    print(f\"Mean temp diff: {results['stats']['mean_temp_diff']:.2f}\u00b0C\")\n    print(f\"Data points: {len(results['data'])}\")\n</code></pre>"},{"location":"app-development/step-05-analyze-part2/#checkpoint","title":"Checkpoint","text":"<ul> <li> Temperature differential calculated</li> <li> Statistics computed</li> <li> Anomaly detection implemented</li> <li> Time features added</li> <li> <code>save_results()</code> function created</li> <li> Test runs successfully</li> </ul>"},{"location":"app-development/step-05-analyze-part2/#next-step","title":"Next Step","text":"<p>\ud83d\udc49 Step 6: Matplotlib Visualization</p> <p>In this step, you'll implement the analysis logic - calculating statistics and processing data.</p>"},{"location":"app-development/step-05-analyze-part2/#goal-of-this-step","title":"Goal of This Step","text":"<ul> <li>Calculate temperature differential</li> <li>Compute statistical metrics</li> <li>Detect anomalies</li> <li>Add time-based features</li> <li>Complete the analyze() function</li> </ul>"},{"location":"app-development/step-05-analyze-part2/#step-51-add-analysis-section","title":"Step 5.1: Add Analysis Section","text":"<p>After Step 4 (data loading and extraction), add the analysis logic to <code>analyze()</code> function:</p> <p>Add this code to <code>app.py</code> after the time filtering section:</p> <pre><code>    # Step 6: Analyze data\n    print(f\"{'='*60}\")\n    print(f\"STEP 6: Analyze Data\")\n    print(f\"{'='*60}\\n\")\n\n    # Calculate temperature differential\n    df_extracted[\"temp_diff\"] = df_extracted[\"supply\"] - df_extracted[\"return\"]\n\n    # Remove rows with missing data\n    df_clean = df_extracted.dropna().copy()\n\n    print(f\"Valid data points: {len(df_clean)} (after removing NaN values)\")\n\n    if len(df_clean) == 0:\n        print(\"[FAIL] No valid data after cleaning\\n\")\n        return None\n</code></pre> <p>Understanding: - <code>df[\"supply\"] - df[\"return\"]</code> calculates the temperature difference - <code>dropna()</code> removes any rows with missing values - <code>.copy()</code> creates a copy to avoid pandas warnings</p>"},{"location":"app-development/step-05-analyze-part2/#step-52-calculate-statistics","title":"Step 5.2: Calculate Statistics","text":"<p>Add statistical calculations:</p> <pre><code>    # Get thresholds from config\n    threshold_min = config[\"analysis\"][\"threshold_min_delta\"]\n    threshold_max = config[\"analysis\"][\"threshold_max_delta\"]\n\n    # Calculate statistics\n    stats = {\n        \"count\": len(df_clean),\n        \"mean_temp_diff\": df_clean[\"temp_diff\"].mean(),\n        \"std_temp_diff\": df_clean[\"temp_diff\"].std(),\n        \"min_temp_diff\": df_clean[\"temp_diff\"].min(),\n        \"max_temp_diff\": df_clean[\"temp_diff\"].max(),\n        \"median_temp_diff\": df_clean[\"temp_diff\"].median(),\n        \"q25_temp_diff\": df_clean[\"temp_diff\"].quantile(0.25),\n        \"q75_temp_diff\": df_clean[\"temp_diff\"].quantile(0.75),\n        \"mean_supply_temp\": df_clean[\"supply\"].mean(),\n        \"mean_return_temp\": df_clean[\"return\"].mean(),\n    }\n\n    print(f\"\\nStatistics:\")\n    print(f\"  Mean temp diff:   {stats['mean_temp_diff']:.2f} \u00b0C\")\n    print(f\"  Std deviation:    {stats['std_temp_diff']:.2f} \u00b0C\")\n    print(f\"  Range:            [{stats['min_temp_diff']:.2f}, {stats['max_temp_diff']:.2f}] \u00b0C\")\n    print(f\"  Median:           {stats['median_temp_diff']:.2f} \u00b0C\")\n</code></pre> <p>Understanding Statistics: - <code>mean()</code> - Average value - <code>std()</code> - Standard deviation (spread) - <code>min()/max()</code> - Minimum and maximum values - <code>median()</code> - Middle value (50<sup>th</sup> percentile) - <code>quantile(0.25)</code> - 25<sup>th</sup> percentile (Q1) - <code>quantile(0.75)</code> - 75<sup>th</sup> percentile (Q3)</p>"},{"location":"app-development/step-05-analyze-part2/#step-53-anomaly-detection","title":"Step 5.3: Anomaly Detection","text":"<p>Detect values outside normal range:</p> <pre><code>    # Detect anomalies\n    anomalies_low = df_clean[df_clean[\"temp_diff\"] &lt; threshold_min]\n    anomalies_high = df_clean[df_clean[\"temp_diff\"] &gt; threshold_max]\n\n    stats[\"anomalies_below_threshold\"] = len(anomalies_low)\n    stats[\"anomalies_above_threshold\"] = len(anomalies_high)\n    stats[\"anomaly_rate\"] = (\n        (stats[\"anomalies_below_threshold\"] + stats[\"anomalies_above_threshold\"])\n        / stats[\"count\"]\n        * 100\n    )\n\n    print(f\"  Anomalies (low):  {stats['anomalies_below_threshold']} \"\n          f\"({stats['anomalies_below_threshold']/stats['count']*100:.1f}%)\")\n    print(f\"  Anomalies (high): {stats['anomalies_above_threshold']} \"\n          f\"({stats['anomalies_above_threshold']/stats['count']*100:.1f}%)\")\n    print(f\"  Total anomalies:  {stats['anomaly_rate']:.2f}%\")\n</code></pre> <p>Understanding Anomaly Detection: - <code>df[df[\"column\"] &lt; value]</code> - Filter rows below threshold - <code>df[df[\"column\"] &gt; value]</code> - Filter rows above threshold - Anomaly rate = (total anomalies / total points) \u00d7 100</p>"},{"location":"app-development/step-05-analyze-part2/#step-54-add-time-features","title":"Step 5.4: Add Time Features","text":"<p>Add time-based columns for analysis:</p> <pre><code>    # Add time-based features for visualization\n    df_clean.loc[:, \"hour\"] = df_clean.index.hour\n    df_clean.loc[:, \"weekday\"] = df_clean.index.dayofweek\n    df_clean.loc[:, \"month\"] = df_clean.index.month\n\n    print(f\"\\n[OK] Analysis complete!\")\n</code></pre> <p>Understanding Time Features: - <code>index.hour</code> - Hour of day (0-23) - <code>index.dayofweek</code> - Day of week (0=Monday, 6=Sunday) - <code>index.month</code> - Month (1-12) - These are used for time-pattern analysis in visualizations</p>"},{"location":"app-development/step-05-analyze-part2/#step-55-return-results","title":"Step 5.5: Return Results","text":"<p>Complete the analyze() function by returning results:</p> <pre><code>    # Create results dictionary\n    results = {\n        \"stats\": stats,\n        \"data\": df_clean\n    }\n\n    # Step 7: Output (save and visualize)\n    if config[\"output\"][\"save_results\"]:\n        save_results(results, config)\n\n    if config[\"output\"][\"generate_plots\"]:\n        generate_plots(results, config)\n\n    if config[\"output\"][\"generate_plotly_html\"]:\n        generate_plotly_html(results, config)\n\n    return results\n</code></pre>"},{"location":"app-development/step-05-analyze-part2/#step-56-implement-save_results","title":"Step 5.6: Implement save_results()","text":"<p>Add the function to save analysis results:</p> <pre><code>def save_results(results, config):\n    \"\"\"Save analysis results to CSV or JSON\"\"\"\n    output_dir = Path(config[\"output\"][\"output_dir\"])\n    output_dir.mkdir(parents=True, exist_ok=True)\n    export_format = config[\"output\"][\"export_format\"]\n\n    print(f\"\\n{'='*60}\")\n    print(f\"SAVE: Saving results to {output_dir}\")\n    print(f\"{'='*60}\\n\")\n\n    # Save statistics\n    stats_file = output_dir / f\"stats.{export_format}\"\n    stats_df = pd.DataFrame([results[\"stats\"]])\n\n    if export_format == \"csv\":\n        stats_df.to_csv(stats_file, index=False)\n    else:  # json\n        stats_df.to_json(stats_file, orient=\"records\", indent=2)\n\n    print(f\"  [OK] {stats_file.name}\")\n\n    # Save timeseries data\n    ts_file = output_dir / f\"timeseries.{export_format}\"\n\n    if export_format == \"csv\":\n        results[\"data\"].to_csv(ts_file)\n    else:  # json\n        results[\"data\"].to_json(ts_file, orient=\"index\", date_format=\"iso\")\n\n    print(f\"  [OK] {ts_file.name}\")\n</code></pre>"},{"location":"app-development/step-05-analyze-part2/#step-57-complete-analyze-function","title":"Step 5.7: Complete analyze() Function","text":"<p>Your complete <code>analyze()</code> function should look like this:</p> <pre><code>def analyze(brick_model_path, timeseries_data_path, config):\n    \"\"\"Execute analysis workflow\"\"\"\n\n    # Step 1: Qualify\n    qualified, qualify_result = qualify(brick_model_path)\n    if not qualified:\n        return None\n\n    # Step 2: Load data\n    g, df = load_data(brick_model_path, timeseries_data_path)\n\n    # Step 3: Map sensors\n    supply_uri = qualify_result[\"supply\"]\n    return_uri = qualify_result[\"return\"]\n    sensor_mapping = map_sensors_to_columns(g, [supply_uri, return_uri], df)\n\n    if len(sensor_mapping) != 2:\n        print(\"[FAIL] Sensor mapping failed\\n\")\n        return None\n\n    # Step 4: Extract data\n    df_extracted = extract_data_columns(\n        df, sensor_mapping,\n        rename_map={supply_uri: \"supply\", return_uri: \"return\"}\n    )\n\n    # Step 5: Filter time range (optional)\n    if config[\"time_range\"][\"start_time\"] or config[\"time_range\"][\"end_time\"]:\n        df_extracted = filter_time_range(\n            df_extracted,\n            config[\"time_range\"][\"start_time\"],\n            config[\"time_range\"][\"end_time\"]\n        )\n\n    # Step 6: Analyze\n    df_extracted[\"temp_diff\"] = df_extracted[\"supply\"] - df_extracted[\"return\"]\n    df_clean = df_extracted.dropna().copy()\n\n    if len(df_clean) == 0:\n        return None\n\n    # Calculate statistics\n    threshold_min = config[\"analysis\"][\"threshold_min_delta\"]\n    threshold_max = config[\"analysis\"][\"threshold_max_delta\"]\n\n    stats = {\n        \"count\": len(df_clean),\n        \"mean_temp_diff\": df_clean[\"temp_diff\"].mean(),\n        \"std_temp_diff\": df_clean[\"temp_diff\"].std(),\n        \"min_temp_diff\": df_clean[\"temp_diff\"].min(),\n        \"max_temp_diff\": df_clean[\"temp_diff\"].max(),\n        \"median_temp_diff\": df_clean[\"temp_diff\"].median(),\n        \"q25_temp_diff\": df_clean[\"temp_diff\"].quantile(0.25),\n        \"q75_temp_diff\": df_clean[\"temp_diff\"].quantile(0.75),\n        \"mean_supply_temp\": df_clean[\"supply\"].mean(),\n        \"mean_return_temp\": df_clean[\"return\"].mean(),\n        \"anomalies_below_threshold\": len(df_clean[df_clean[\"temp_diff\"] &lt; threshold_min]),\n        \"anomalies_above_threshold\": len(df_clean[df_clean[\"temp_diff\"] &gt; threshold_max]),\n    }\n    stats[\"anomaly_rate\"] = (\n        (stats[\"anomalies_below_threshold\"] + stats[\"anomalies_above_threshold\"])\n        / stats[\"count\"] * 100\n    )\n\n    # Add time features\n    df_clean.loc[:, \"hour\"] = df_clean.index.hour\n    df_clean.loc[:, \"weekday\"] = df_clean.index.dayofweek\n    df_clean.loc[:, \"month\"] = df_clean.index.month\n\n    # Create results\n    results = {\"stats\": stats, \"data\": df_clean}\n\n    # Step 7: Output\n    if config[\"output\"][\"save_results\"]:\n        save_results(results, config)\n\n    if config[\"output\"][\"generate_plots\"]:\n        generate_plots(results, config)\n\n    if config[\"output\"][\"generate_plotly_html\"]:\n        generate_plotly_html(results, config)\n\n    return results\n</code></pre>"},{"location":"app-development/step-05-analyze-part2/#step-58-test-the-analysis","title":"Step 5.8: Test the Analysis","text":"<p>Create a test script:</p> <pre><code>\"\"\"Test complete analyze function\"\"\"\nfrom pathlib import Path\nimport sys\n\napp_dir = Path(__file__).parent\nsys.path.insert(0, str(app_dir.parent.parent.parent))\n\nfrom hhw_brick.applications.my_first_app.app import analyze, load_config\n\ndef test_analyze():\n    \"\"\"Test complete analysis\"\"\"\n    print(\"Testing complete analyze function...\\n\")\n\n    fixtures = Path(__file__).parent.parent.parent.parent / \"tests\" / \"fixtures\"\n    model_file = fixtures / \"Brick_Model_File\" / \"building_29.ttl\"\n    data_file = fixtures / \"TimeSeriesData\" / \"29hhw_system_data.csv\"\n\n    if not model_file.exists() or not data_file.exists():\n        print(\"Test files not found\")\n        return\n\n    config = load_config()\n    config[\"output\"][\"output_dir\"] = \"./test_results\"\n\n    results = analyze(str(model_file), str(data_file), config)\n\n    if results:\n        print(f\"\\n{'='*60}\")\n        print(\"\u2705 Analysis complete!\")\n        print(f\"{'='*60}\")\n        print(f\"\\nStatistics:\")\n        for key, value in results[\"stats\"].items():\n            if isinstance(value, float):\n                print(f\"  {key}: {value:.2f}\")\n            else:\n                print(f\"  {key}: {value}\")\n\n        print(f\"\\nData shape: {results['data'].shape}\")\n        print(f\"Columns: {list(results['data'].columns)}\")\n    else:\n        print(\"\\n\u274c Analysis failed\")\n\nif __name__ == \"__main__\":\n    test_analyze()\n</code></pre>"},{"location":"app-development/step-05-analyze-part2/#checkpoint_1","title":"Checkpoint","text":"<p>Before proceeding, verify:</p> <ul> <li> Temperature differential calculated</li> <li> Statistics computed (mean, std, min, max, etc.)</li> <li> Anomaly detection implemented</li> <li> Time features added</li> <li> save_results() function created</li> <li> analyze() returns results dictionary</li> <li> Test script runs successfully</li> </ul>"},{"location":"app-development/step-05-analyze-part2/#next-steps","title":"Next Steps","text":"<p>\u2705 Analysis logic complete!</p> <p>\ud83d\udc49 Continue to Step 6: Matplotlib Visualization</p>"},{"location":"app-development/step-05-analyze-part2/#common-issues","title":"Common Issues","text":"<p>Issue: <code>KeyError: 'threshold_min_delta'</code> Solution: Make sure your <code>config.yaml</code> has the <code>analysis</code> section with these parameters</p> <p>Issue: All values are NaN after <code>dropna()</code> Solution: Check if your sensors are correctly mapped and have valid data</p> <p>Issue: Division by zero in anomaly rate Solution: Add check: <code>if stats['count'] &gt; 0:</code> before calculating rate</p> <p>Issue: <code>SettingWithCopyWarning</code> from pandas Solution: Use <code>.copy()</code> when creating df_clean and <code>.loc[]</code> for assignments</p>"},{"location":"app-development/step-05-analyze-part2/#summary","title":"Summary","text":"<p>You've now completed the core analysis logic:</p> <p>\u2705 Data Processing: Calculate temperature differential \u2705 Statistics: Mean, std, min, max, quantiles \u2705 Anomaly Detection: Find values outside thresholds \u2705 Time Features: Add hour, weekday, month columns \u2705 Save Results: Export to CSV or JSON  </p> <p>Next step: Create visualizations!</p>"},{"location":"app-development/step-06-visualization-matplotlib/","title":"Step 6: Matplotlib Visualization","text":"<p>Create professional static plots with matplotlib.</p>"},{"location":"app-development/step-06-visualization-matplotlib/#1-add-imports","title":"1. Add Imports","text":"<pre><code>import matplotlib.pyplot as plt\nimport seaborn as sns\n\n# Plot settings\nsns.set_style(\"whitegrid\")\nsns.set_palette(\"husl\")\nplt.rcParams[\"figure.figsize\"] = (14, 8)\nplt.rcParams[\"font.size\"] = 10\n</code></pre>"},{"location":"app-development/step-06-visualization-matplotlib/#2-implement-generate_plots","title":"2. Implement generate_plots()","text":"<pre><code>def generate_plots(results, config):\n    \"\"\"Generate matplotlib plots\"\"\"\n    output_dir = Path(config[\"output\"][\"output_dir\"])\n    output_dir.mkdir(parents=True, exist_ok=True)\n    fmt = config[\"output\"][\"plot_format\"]\n\n    print(f\"\\n{'='*60}\")\n    print(\"PLOTS\")\n    print(f\"{'='*60}\\n\")\n\n    df = results[\"data\"]\n    stats = results[\"stats\"]\n\n    # Generate 4 plots\n    plot_timeseries(df, stats, output_dir, fmt)\n    plot_distribution(df, stats, output_dir, fmt)\n    plot_heatmap(df, output_dir, fmt)\n    plot_hourly_pattern(df, output_dir, fmt)\n\n    print(\"\u2713 All plots generated\")\n</code></pre>"},{"location":"app-development/step-06-visualization-matplotlib/#3-time-series-plot","title":"3. Time-Series Plot","text":"<pre><code>def plot_timeseries(df, stats, output_dir, fmt):\n    \"\"\"Plot temperatures and differential over time\"\"\"\n    fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(14, 10), sharex=True)\n\n    # Plot 1: Supply and Return\n    ax1.plot(df.index, df[\"supply\"], label=\"Supply\", color=\"#e74c3c\", linewidth=1.5)\n    ax1.plot(df.index, df[\"return\"], label=\"Return\", color=\"#3498db\", linewidth=1.5)\n    ax1.set_ylabel(\"Temperature (\u00b0C)\")\n    ax1.set_title(\"Supply and Return Temperatures\", fontweight=\"bold\")\n    ax1.legend()\n    ax1.grid(True, alpha=0.3)\n\n    # Plot 2: Differential\n    ax2.plot(df.index, df[\"temp_diff\"], color=\"#9b59b6\", linewidth=1.5)\n    ax2.axhline(stats[\"mean_temp_diff\"], color=\"#27ae60\", linestyle=\"--\",\n                label=f\"Mean: {stats['mean_temp_diff']:.2f}\u00b0C\")\n    ax2.set_xlabel(\"Time\")\n    ax2.set_ylabel(\"Temperature Difference (\u00b0C)\")\n    ax2.set_title(\"Temperature Differential\", fontweight=\"bold\")\n    ax2.legend()\n    ax2.grid(True, alpha=0.3)\n\n    plt.tight_layout()\n    plt.savefig(output_dir / f\"timeseries.{fmt}\", dpi=300, bbox_inches=\"tight\")\n    plt.close()\n    print(f\"\u2713 timeseries.{fmt}\")\n</code></pre>"},{"location":"app-development/step-06-visualization-matplotlib/#4-distribution-histogram","title":"4. Distribution Histogram","text":"<pre><code>def plot_distribution(df, stats, output_dir, fmt):\n    \"\"\"Plot distribution histogram\"\"\"\n    fig, ax = plt.subplots(figsize=(12, 6))\n\n    ax.hist(df[\"temp_diff\"], bins=50, color=\"#3498db\", alpha=0.7, edgecolor=\"black\")\n    ax.axvline(stats[\"mean_temp_diff\"], color=\"#e74c3c\", linestyle=\"--\",\n               linewidth=2, label=f\"Mean: {stats['mean_temp_diff']:.2f}\u00b0C\")\n    ax.axvline(stats[\"median_temp_diff\"], color=\"#27ae60\", linestyle=\"--\",\n               linewidth=2, label=f\"Median: {stats['median_temp_diff']:.2f}\u00b0C\")\n\n    ax.set_xlabel(\"Temperature Difference (\u00b0C)\")\n    ax.set_ylabel(\"Frequency\")\n    ax.set_title(\"Distribution\", fontweight=\"bold\")\n    ax.legend()\n    ax.grid(True, alpha=0.3, axis=\"y\")\n\n    plt.tight_layout()\n    plt.savefig(output_dir / f\"distribution.{fmt}\", dpi=300, bbox_inches=\"tight\")\n    plt.close()\n    print(f\"\u2713 distribution.{fmt}\")\n</code></pre>"},{"location":"app-development/step-06-visualization-matplotlib/#5-heatmap","title":"5. Heatmap","text":"<pre><code>def plot_heatmap(df, output_dir, fmt):\n    \"\"\"Plot heatmap by hour and weekday\"\"\"\n    pivot = df.pivot_table(values=\"temp_diff\", index=\"hour\",\n                           columns=\"weekday\", aggfunc=\"mean\")\n\n    fig, ax = plt.subplots(figsize=(10, 8))\n    sns.heatmap(pivot, annot=True, fmt=\".1f\", cmap=\"RdYlBu_r\",\n                center=pivot.values.mean(),\n                cbar_kws={\"label\": \"Mean Temp Diff (\u00b0C)\"}, ax=ax)\n\n    ax.set_xlabel(\"Day of Week (0=Mon, 6=Sun)\")\n    ax.set_ylabel(\"Hour of Day\")\n    ax.set_title(\"Average by Hour and Weekday\", fontweight=\"bold\")\n\n    plt.tight_layout()\n    plt.savefig(output_dir / f\"heatmap.{fmt}\", dpi=300, bbox_inches=\"tight\")\n    plt.close()\n    print(f\"\u2713 heatmap.{fmt}\")\n</code></pre>"},{"location":"app-development/step-06-visualization-matplotlib/#6-hourly-pattern","title":"6. Hourly Pattern","text":"<pre><code>def plot_hourly_pattern(df, output_dir, fmt):\n    \"\"\"Plot hourly pattern with error bars\"\"\"\n    hourly = df.groupby(\"hour\")[\"temp_diff\"].agg([\"mean\", \"std\"])\n\n    fig, ax = plt.subplots(figsize=(12, 6))\n    ax.bar(hourly.index, hourly[\"mean\"], yerr=hourly[\"std\"],\n           color=\"#3498db\", alpha=0.7, error_kw={\"elinewidth\": 2, \"capsize\": 5})\n\n    ax.set_xlabel(\"Hour of Day\")\n    ax.set_ylabel(\"Mean Temperature Difference (\u00b0C)\")\n    ax.set_title(\"Hourly Pattern\", fontweight=\"bold\")\n    ax.set_xticks(range(24))\n    ax.grid(True, alpha=0.3, axis=\"y\")\n\n    plt.tight_layout()\n    plt.savefig(output_dir / f\"hourly_pattern.{fmt}\", dpi=300, bbox_inches=\"tight\")\n    plt.close()\n    print(f\"\u2713 hourly_pattern.{fmt}\")\n</code></pre>"},{"location":"app-development/step-06-visualization-matplotlib/#checkpoint","title":"Checkpoint","text":"<ul> <li> Matplotlib imports added</li> <li> 4 plot types implemented</li> <li> Plots save in correct format</li> <li> Test generates all plots</li> </ul>"},{"location":"app-development/step-06-visualization-matplotlib/#next-step","title":"Next Step","text":"<p>\ud83d\udc49 Step 7: Plotly HTML Visualization</p> <p>In this step, you'll create professional static plots using matplotlib and seaborn.</p>"},{"location":"app-development/step-06-visualization-matplotlib/#goal-of-this-step","title":"Goal of This Step","text":"<ul> <li>Generate time-series plots</li> <li>Create distribution histograms</li> <li>Build heatmaps for pattern analysis</li> <li>Save plots in multiple formats (PNG, PDF, SVG)</li> </ul>"},{"location":"app-development/step-06-visualization-matplotlib/#step-61-add-matplotlib-imports","title":"Step 6.1: Add Matplotlib Imports","text":"<p>At the top of your <code>app.py</code>, ensure you have these imports:</p> <pre><code>import matplotlib.pyplot as plt\nimport seaborn as sns\nimport numpy as np\n\n# Plot settings\nsns.set_style(\"whitegrid\")\nsns.set_palette(\"husl\")\nplt.rcParams[\"figure.figsize\"] = (14, 8)\nplt.rcParams[\"font.size\"] = 10\n</code></pre> <p>Understanding: - <code>sns.set_style(\"whitegrid\")</code> - Clean background with grid - <code>sns.set_palette(\"husl\")</code> - Colorful, distinguishable colors - <code>plt.rcParams</code> - Default figure size and font</p>"},{"location":"app-development/step-06-visualization-matplotlib/#step-62-implement-generate_plots","title":"Step 6.2: Implement generate_plots()","text":"<p>Create the main plotting function:</p> <pre><code>def generate_plots(results, config):\n    \"\"\"Generate matplotlib visualizations\"\"\"\n    output_dir = Path(config[\"output\"][\"output_dir\"])\n    output_dir.mkdir(parents=True, exist_ok=True)\n    plot_format = config[\"output\"][\"plot_format\"]\n\n    print(f\"\\n{'='*60}\")\n    print(f\"PLOTS: Generating matplotlib plots\")\n    print(f\"{'='*60}\\n\")\n\n    df = results[\"data\"]\n    stats = results[\"stats\"]\n\n    # Generate all plots\n    plot_timeseries(df, stats, output_dir, plot_format)\n    plot_distribution(df, stats, output_dir, plot_format)\n    plot_heatmap(df, output_dir, plot_format)\n    plot_hourly_pattern(df, output_dir, plot_format)\n\n    print(f\"\\n[OK] All plots generated\")\n</code></pre>"},{"location":"app-development/step-06-visualization-matplotlib/#step-63-time-series-plot","title":"Step 6.3: Time-Series Plot","text":"<p>Create a time-series visualization:</p> <pre><code>def plot_timeseries(df, stats, output_dir, plot_format):\n    \"\"\"Plot temperature differential over time\"\"\"\n    fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(14, 10), sharex=True)\n\n    # Plot 1: Supply and Return temperatures\n    ax1.plot(df.index, df[\"supply\"], label=\"Supply Temp\", color=\"#e74c3c\", linewidth=1.5)\n    ax1.plot(df.index, df[\"return\"], label=\"Return Temp\", color=\"#3498db\", linewidth=1.5)\n    ax1.set_ylabel(\"Temperature (\u00b0C)\", fontsize=12)\n    ax1.set_title(\"Supply and Return Temperatures\", fontsize=14, fontweight=\"bold\")\n    ax1.legend(loc=\"upper right\")\n    ax1.grid(True, alpha=0.3)\n\n    # Plot 2: Temperature differential\n    ax2.plot(df.index, df[\"temp_diff\"], label=\"Temp Diff\", color=\"#9b59b6\", linewidth=1.5)\n    ax2.axhline(y=stats[\"mean_temp_diff\"], color=\"#27ae60\", linestyle=\"--\",\n                label=f\"Mean: {stats['mean_temp_diff']:.2f}\u00b0C\")\n    ax2.set_xlabel(\"Time\", fontsize=12)\n    ax2.set_ylabel(\"Temperature Difference (\u00b0C)\", fontsize=12)\n    ax2.set_title(\"Temperature Differential\", fontsize=14, fontweight=\"bold\")\n    ax2.legend(loc=\"upper right\")\n    ax2.grid(True, alpha=0.3)\n\n    plt.tight_layout()\n    filepath = output_dir / f\"timeseries.{plot_format}\"\n    plt.savefig(filepath, dpi=300, bbox_inches=\"tight\")\n    plt.close()\n\n    print(f\"  [OK] {filepath.name}\")\n</code></pre> <p>Understanding: - <code>subplots(2, 1)</code> - Create 2 rows, 1 column of plots - <code>sharex=True</code> - Share x-axis between plots - <code>axhline()</code> - Horizontal line for mean - <code>dpi=300</code> - High resolution for publication - <code>bbox_inches=\"tight\"</code> - Remove extra whitespace</p>"},{"location":"app-development/step-06-visualization-matplotlib/#step-64-distribution-histogram","title":"Step 6.4: Distribution Histogram","text":"<p>Create a histogram showing value distribution:</p> <pre><code>def plot_distribution(df, stats, output_dir, plot_format):\n    \"\"\"Plot distribution of temperature differential\"\"\"\n    fig, ax = plt.subplots(figsize=(12, 6))\n\n    # Histogram\n    ax.hist(df[\"temp_diff\"], bins=50, color=\"#3498db\", alpha=0.7, edgecolor=\"black\")\n\n    # Add vertical lines for statistics\n    ax.axvline(stats[\"mean_temp_diff\"], color=\"#e74c3c\", linestyle=\"--\",\n               linewidth=2, label=f\"Mean: {stats['mean_temp_diff']:.2f}\u00b0C\")\n    ax.axvline(stats[\"median_temp_diff\"], color=\"#27ae60\", linestyle=\"--\",\n               linewidth=2, label=f\"Median: {stats['median_temp_diff']:.2f}\u00b0C\")\n\n    # Labels and title\n    ax.set_xlabel(\"Temperature Difference (\u00b0C)\", fontsize=12)\n    ax.set_ylabel(\"Frequency\", fontsize=12)\n    ax.set_title(\"Distribution of Temperature Differential\", fontsize=14, fontweight=\"bold\")\n    ax.legend()\n    ax.grid(True, alpha=0.3, axis=\"y\")\n\n    plt.tight_layout()\n    filepath = output_dir / f\"distribution.{plot_format}\"\n    plt.savefig(filepath, dpi=300, bbox_inches=\"tight\")\n    plt.close()\n\n    print(f\"  [OK] {filepath.name}\")\n</code></pre> <p>Understanding: - <code>bins=50</code> - Number of histogram bars - <code>alpha=0.7</code> - Transparency - <code>edgecolor=\"black\"</code> - Outline for each bar - <code>axvline()</code> - Vertical line for mean/median</p>"},{"location":"app-development/step-06-visualization-matplotlib/#step-65-heatmap","title":"Step 6.5: Heatmap","text":"<p>Create a heatmap showing patterns by hour and day:</p> <pre><code>def plot_heatmap(df, output_dir, plot_format):\n    \"\"\"Plot heatmap of temperature differential by hour and weekday\"\"\"\n    # Create pivot table\n    pivot = df.pivot_table(\n        values=\"temp_diff\",\n        index=\"hour\",\n        columns=\"weekday\",\n        aggfunc=\"mean\"\n    )\n\n    # Create heatmap\n    fig, ax = plt.subplots(figsize=(10, 8))\n    sns.heatmap(\n        pivot,\n        annot=True,\n        fmt=\".1f\",\n        cmap=\"RdYlBu_r\",\n        center=pivot.values.mean(),\n        cbar_kws={\"label\": \"Mean Temp Diff (\u00b0C)\"},\n        ax=ax\n    )\n\n    # Customize\n    ax.set_xlabel(\"Day of Week (0=Monday, 6=Sunday)\", fontsize=12)\n    ax.set_ylabel(\"Hour of Day\", fontsize=12)\n    ax.set_title(\"Average Temperature Differential by Hour and Weekday\",\n                 fontsize=14, fontweight=\"bold\")\n\n    plt.tight_layout()\n    filepath = output_dir / f\"heatmap.{plot_format}\"\n    plt.savefig(filepath, dpi=300, bbox_inches=\"tight\")\n    plt.close()\n\n    print(f\"  [OK] {filepath.name}\")\n</code></pre> <p>Understanding: - <code>pivot_table()</code> - Reorganize data into matrix - <code>sns.heatmap()</code> - Create colored grid - <code>annot=True</code> - Show values in cells - <code>fmt=\".1f\"</code> - Format numbers to 1 decimal - <code>cmap=\"RdYlBu_r\"</code> - Color scheme (red-yellow-blue reversed)</p>"},{"location":"app-development/step-06-visualization-matplotlib/#step-66-hourly-pattern-plot","title":"Step 6.6: Hourly Pattern Plot","text":"<p>Show how values change by hour:</p> <pre><code>def plot_hourly_pattern(df, output_dir, plot_format):\n    \"\"\"Plot hourly pattern of temperature differential\"\"\"\n    hourly_stats = df.groupby(\"hour\")[\"temp_diff\"].agg([\"mean\", \"std\", \"count\"])\n\n    fig, ax = plt.subplots(figsize=(12, 6))\n\n    # Bar plot with error bars\n    ax.bar(hourly_stats.index, hourly_stats[\"mean\"],\n           yerr=hourly_stats[\"std\"],\n           color=\"#3498db\", alpha=0.7,\n           error_kw={\"elinewidth\": 2, \"capsize\": 5})\n\n    ax.set_xlabel(\"Hour of Day\", fontsize=12)\n    ax.set_ylabel(\"Mean Temperature Difference (\u00b0C)\", fontsize=12)\n    ax.set_title(\"Hourly Pattern of Temperature Differential\",\n                 fontsize=14, fontweight=\"bold\")\n    ax.set_xticks(range(24))\n    ax.grid(True, alpha=0.3, axis=\"y\")\n\n    plt.tight_layout()\n    filepath = output_dir / f\"hourly_pattern.{plot_format}\"\n    plt.savefig(filepath, dpi=300, bbox_inches=\"tight\")\n    plt.close()\n\n    print(f\"  [OK] {filepath.name}\")\n</code></pre> <p>Understanding: - <code>groupby(\"hour\")</code> - Group data by hour - <code>.agg([\"mean\", \"std\"])</code> - Calculate multiple statistics - <code>yerr=</code> - Error bars showing standard deviation - <code>set_xticks()</code> - Set x-axis tick marks</p>"},{"location":"app-development/step-06-visualization-matplotlib/#step-67-update-config-for-plot-format","title":"Step 6.7: Update Config for Plot Format","text":"<p>In your <code>config.yaml</code>, users can choose output format:</p> <pre><code>output:\n  generate_plots: true\n  plot_format: \"png\"  # Options: png, pdf, svg\n</code></pre> <p>Formats: - PNG: Best for web, presentations, reports - PDF: Best for publications, vector graphics - SVG: Best for editing in vector graphics software</p>"},{"location":"app-development/step-06-visualization-matplotlib/#step-68-test-the-plots","title":"Step 6.8: Test the Plots","text":"<p>Update your test script to check plots:</p> <pre><code>def test_plots():\n    \"\"\"Test plotting functions\"\"\"\n    from hhw_brick.applications.my_first_app.app import analyze, load_config\n\n    fixtures = Path(__file__).parent.parent.parent.parent / \"tests\" / \"fixtures\"\n    model_file = fixtures / \"Brick_Model_File\" / \"building_29.ttl\"\n    data_file = fixtures / \"TimeSeriesData\" / \"29hhw_system_data.csv\"\n\n    config = load_config()\n    config[\"output\"][\"output_dir\"] = \"./test_plots\"\n    config[\"output\"][\"generate_plots\"] = True\n    config[\"output\"][\"plot_format\"] = \"png\"\n\n    results = analyze(str(model_file), str(data_file), config)\n\n    if results:\n        print(\"\\n\u2705 Plots generated successfully!\")\n        print(f\"Check folder: {config['output']['output_dir']}\")\n    else:\n        print(\"\\n\u274c Plot generation failed\")\n\nif __name__ == \"__main__\":\n    test_plots()\n</code></pre> <p>Run the test: <pre><code>python test_plots.py\n</code></pre></p> <p>Expected output: 4 plot files in <code>test_plots/</code> directory</p>"},{"location":"app-development/step-06-visualization-matplotlib/#step-69-complete-generate_plots-implementation","title":"Step 6.9: Complete generate_plots() Implementation","text":"<p>Your final <code>app.py</code> should have all these functions:</p> <pre><code>def generate_plots(results, config):\n    \"\"\"Generate matplotlib visualizations\"\"\"\n    # ...implementation from Step 6.2...\n\ndef plot_timeseries(df, stats, output_dir, plot_format):\n    \"\"\"Plot temperature differential over time\"\"\"\n    # ...implementation from Step 6.3...\n\ndef plot_distribution(df, stats, output_dir, plot_format):\n    \"\"\"Plot distribution of temperature differential\"\"\"\n    # ...implementation from Step 6.4...\n\ndef plot_heatmap(df, output_dir, plot_format):\n    \"\"\"Plot heatmap of temperature differential by hour and weekday\"\"\"\n    # ...implementation from Step 6.5...\n\ndef plot_hourly_pattern(df, output_dir, plot_format):\n    \"\"\"Plot hourly pattern of temperature differential\"\"\"\n    # ...implementation from Step 6.6...\n</code></pre>"},{"location":"app-development/step-06-visualization-matplotlib/#checkpoint_1","title":"Checkpoint","text":"<p>Before proceeding, verify:</p> <ul> <li> All imports added (matplotlib, seaborn)</li> <li> generate_plots() function created</li> <li> 4 plot types implemented:</li> <li> Time-series plot</li> <li> Distribution histogram</li> <li> Heatmap</li> <li> Hourly pattern</li> <li> Plots save in configured format</li> <li> Test script generates all plots</li> </ul>"},{"location":"app-development/step-06-visualization-matplotlib/#next-steps","title":"Next Steps","text":"<p>\u2705 Matplotlib visualization complete!</p> <p>\ud83d\udc49 Continue to Step 7: Plotly HTML Visualization</p>"},{"location":"app-development/step-06-visualization-matplotlib/#common-issues","title":"Common Issues","text":"<p>Issue: <code>ImportError: No module named 'matplotlib'</code> Solution: <code>pip install matplotlib seaborn</code></p> <p>Issue: Plots are blank or don't show Solution: Make sure to call <code>plt.close()</code> after <code>plt.savefig()</code></p> <p>Issue: Labels overlap or are cut off Solution: Use <code>plt.tight_layout()</code> before saving</p> <p>Issue: Low quality images Solution: Set <code>dpi=300</code> in <code>savefig()</code></p>"},{"location":"app-development/step-06-visualization-matplotlib/#customization-tips","title":"Customization Tips","text":""},{"location":"app-development/step-06-visualization-matplotlib/#change-colors","title":"Change Colors","text":"<pre><code># Use different color palettes\nsns.set_palette(\"Set2\")  # Pastel colors\nsns.set_palette(\"dark\")  # Dark colors\nsns.set_palette([\"#FF6B6B\", \"#4ECDC4\", \"#45B7D1\"])  # Custom colors\n</code></pre>"},{"location":"app-development/step-06-visualization-matplotlib/#change-figure-size","title":"Change Figure Size","text":"<pre><code>plt.figure(figsize=(16, 10))  # Larger\nplt.figure(figsize=(10, 6))   # Smaller\n</code></pre>"},{"location":"app-development/step-06-visualization-matplotlib/#add-more-statistics","title":"Add More Statistics","text":"<pre><code># Add min/max lines\nax.axhline(stats[\"min_temp_diff\"], color=\"blue\", linestyle=\":\", label=\"Min\")\nax.axhline(stats[\"max_temp_diff\"], color=\"red\", linestyle=\":\", label=\"Max\")\n</code></pre>"},{"location":"app-development/step-06-visualization-matplotlib/#summary","title":"Summary","text":"<p>You've created professional visualizations:</p> <p>\u2705 Time-Series: Temperature over time \u2705 Distribution: Histogram with statistics \u2705 Heatmap: Patterns by hour and day \u2705 Hourly Pattern: Average by hour with error bars \u2705 Multiple Formats: PNG, PDF, SVG support  </p> <p>Next: Interactive Plotly HTML visualizations!</p>"},{"location":"app-development/step-07-visualization-plotly/","title":"Step 7: Plotly HTML Visualization","text":"<p>Create interactive HTML visualizations with Plotly.</p>"},{"location":"app-development/step-07-visualization-plotly/#1-add-imports","title":"1. Add Imports","text":"<pre><code>import plotly.graph_objects as go\nfrom plotly.subplots import make_subplots\n</code></pre>"},{"location":"app-development/step-07-visualization-plotly/#2-implement-generate_plotly_html","title":"2. Implement generate_plotly_html()","text":"<pre><code>def generate_plotly_html(results, config):\n    \"\"\"Generate interactive Plotly HTML\"\"\"\n    output_dir = Path(config[\"output\"][\"output_dir\"])\n    output_dir.mkdir(parents=True, exist_ok=True)\n\n    print(f\"\\n{'='*60}\")\n    print(\"PLOTLY HTML\")\n    print(f\"{'='*60}\\n\")\n\n    df = results[\"data\"]\n    stats = results[\"stats\"]\n\n    create_dashboard(df, stats, output_dir)\n    create_timeseries(df, stats, output_dir)\n    create_heatmap(df, output_dir)\n    create_boxplot(df, stats, output_dir)\n\n    print(\"\u2713 All HTML generated\")\n</code></pre>"},{"location":"app-development/step-07-visualization-plotly/#3-interactive-dashboard","title":"3. Interactive Dashboard","text":"<pre><code>def create_dashboard(df, stats, output_dir):\n    \"\"\"Create 6-panel dashboard\"\"\"\n    fig = make_subplots(\n        rows=3, cols=2,\n        subplot_titles=(\"Supply &amp; Return\", \"Differential\", \"Distribution\",\n                       \"Hourly\", \"Box Plot\", \"Stats\"),\n        specs=[[{\"type\": \"scatter\"}, {\"type\": \"scatter\"}],\n               [{\"type\": \"histogram\"}, {\"type\": \"bar\"}],\n               [{\"type\": \"box\"}, {\"type\": \"table\"}]],\n        vertical_spacing=0.12, horizontal_spacing=0.10\n    )\n\n    # Panel 1: Supply &amp; Return\n    fig.add_trace(go.Scatter(x=df.index, y=df[\"supply\"], name=\"Supply\",\n                            line=dict(color=\"#e74c3c\")), row=1, col=1)\n    fig.add_trace(go.Scatter(x=df.index, y=df[\"return\"], name=\"Return\",\n                            line=dict(color=\"#3498db\")), row=1, col=1)\n\n    # Panel 2: Differential\n    fig.add_trace(go.Scatter(x=df.index, y=df[\"temp_diff\"], name=\"Diff\",\n                            line=dict(color=\"#9b59b6\")), row=1, col=2)\n\n    # Panel 3: Distribution\n    fig.add_trace(go.Histogram(x=df[\"temp_diff\"], name=\"Dist\",\n                              marker=dict(color=\"#3498db\")), row=2, col=1)\n\n    # Panel 4: Hourly\n    hourly = df.groupby(\"hour\")[\"temp_diff\"].mean()\n    fig.add_trace(go.Bar(x=hourly.index, y=hourly.values,\n                        marker=dict(color=\"#27ae60\")), row=2, col=2)\n\n    # Panel 5: Box plot\n    for hour in sorted(df[\"hour\"].unique()):\n        fig.add_trace(go.Box(y=df[df[\"hour\"]==hour][\"temp_diff\"],\n                            name=str(hour), showlegend=False), row=3, col=1)\n\n    # Panel 6: Stats table\n    stats_data = [\n        [\"Mean\", f\"{stats['mean_temp_diff']:.2f}\"],\n        [\"Std\", f\"{stats['std_temp_diff']:.2f}\"],\n        [\"Min\", f\"{stats['min_temp_diff']:.2f}\"],\n        [\"Max\", f\"{stats['max_temp_diff']:.2f}\"]\n    ]\n    fig.add_trace(go.Table(\n        header=dict(values=[\"Metric\", \"Value\"], fill_color=\"lightgray\"),\n        cells=dict(values=list(zip(*stats_data)), fill_color=\"white\")\n    ), row=3, col=2)\n\n    fig.update_layout(title=\"Dashboard\", showlegend=True, height=1200,\n                     template=\"plotly_white\")\n\n    fig.write_html(output_dir / \"dashboard_interactive.html\")\n    print(\"\u2713 dashboard_interactive.html\")\n</code></pre>"},{"location":"app-development/step-07-visualization-plotly/#4-detailed-time-series","title":"4. Detailed Time-Series","text":"<pre><code>def create_timeseries(df, stats, output_dir):\n    \"\"\"Interactive time-series with dual y-axes\"\"\"\n    fig = make_subplots(specs=[[{\"secondary_y\": True}]])\n\n    fig.add_trace(go.Scatter(x=df.index, y=df[\"supply\"], name=\"Supply\",\n                            line=dict(color=\"#e74c3c\", width=2)), secondary_y=False)\n    fig.add_trace(go.Scatter(x=df.index, y=df[\"return\"], name=\"Return\",\n                            line=dict(color=\"#3498db\", width=2)), secondary_y=False)\n    fig.add_trace(go.Scatter(x=df.index, y=df[\"temp_diff\"], name=\"Diff\",\n                            line=dict(color=\"#9b59b6\", width=2, dash=\"dash\")),\n                 secondary_y=True)\n\n    fig.add_hline(y=stats[\"mean_temp_diff\"], line_dash=\"dash\",\n                 line_color=\"#27ae60\", secondary_y=True)\n\n    fig.update_xaxes(title_text=\"Time\")\n    fig.update_yaxes(title_text=\"Temperature (\u00b0C)\", secondary_y=False)\n    fig.update_yaxes(title_text=\"Difference (\u00b0C)\", secondary_y=True)\n    fig.update_layout(title=\"Temperature Analysis\", hovermode=\"x unified\",\n                     template=\"plotly_white\", height=600)\n\n    fig.write_html(output_dir / \"timeseries_interactive.html\")\n    print(\"\u2713 timeseries_interactive.html\")\n</code></pre>"},{"location":"app-development/step-07-visualization-plotly/#5-interactive-heatmap","title":"5. Interactive Heatmap","text":"<pre><code>def create_heatmap(df, output_dir):\n    \"\"\"Interactive heatmap\"\"\"\n    pivot = df.pivot_table(values=\"temp_diff\", index=\"hour\",\n                          columns=\"weekday\", aggfunc=\"mean\")\n\n    fig = go.Figure(data=go.Heatmap(\n        z=pivot.values,\n        x=[\"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\", \"Sun\"],\n        y=list(range(24)),\n        colorscale=\"RdYlBu_r\",\n        colorbar=dict(title=\"Mean&lt;br&gt;Diff (\u00b0C)\")\n    ))\n\n    fig.update_layout(title=\"Patterns by Hour and Day\",\n                     xaxis_title=\"Day of Week\", yaxis_title=\"Hour\",\n                     template=\"plotly_white\", height=700)\n\n    fig.write_html(output_dir / \"heatmap_interactive.html\")\n    print(\"\u2713 heatmap_interactive.html\")\n</code></pre>"},{"location":"app-development/step-07-visualization-plotly/#6-box-plot","title":"6. Box Plot","text":"<pre><code>def create_boxplot(df, stats, output_dir):\n    \"\"\"Interactive box plot\"\"\"\n    fig = go.Figure()\n    fig.add_trace(go.Box(y=df[\"temp_diff\"], marker_color=\"#3498db\",\n                        boxmean=\"sd\"))\n\n    fig.add_annotation(\n        text=f\"Mean: {stats['mean_temp_diff']:.2f}\u00b0C&lt;br&gt;\"\n             f\"Median: {stats['median_temp_diff']:.2f}\u00b0C\",\n        xref=\"paper\", yref=\"paper\", x=0.98, y=0.98,\n        showarrow=False, bgcolor=\"lightgray\"\n    )\n\n    fig.update_layout(title=\"Distribution\", yaxis_title=\"Temp Diff (\u00b0C)\",\n                     template=\"plotly_white\", height=600)\n\n    fig.write_html(output_dir / \"boxplot_interactive.html\")\n    print(\"\u2713 boxplot_interactive.html\")\n</code></pre>"},{"location":"app-development/step-07-visualization-plotly/#interactive-features","title":"Interactive Features","text":"<p>All plots have: - \ud83d\udd0d Zoom: Box select or scroll - \ud83d\udc46 Pan: Click and drag - \ud83d\udcca Hover: Detailed tooltips - \ud83d\udc41\ufe0f Toggle: Click legend - \ud83d\udcf8 Export: Camera icon - \ud83d\udd04 Reset: Double-click</p>"},{"location":"app-development/step-07-visualization-plotly/#checkpoint","title":"Checkpoint","text":"<ul> <li> Plotly imports added</li> <li> Dashboard with 6 panels</li> <li> Time-series with dual axes</li> <li> Interactive heatmap</li> <li> Box plot with stats</li> <li> HTML files open in browser</li> </ul>"},{"location":"app-development/step-07-visualization-plotly/#next-step","title":"Next Step","text":"<p>\ud83d\udc49 Step 8: Testing Your Application</p> <p>In this step, you'll create interactive HTML visualizations using Plotly that users can open in web browsers.</p>"},{"location":"app-development/step-07-visualization-plotly/#goal-of-this-step","title":"Goal of This Step","text":"<ul> <li>Create interactive plots with zoom, pan, and hover</li> <li>Generate standalone HTML files</li> <li>Build comprehensive dashboards</li> <li>No server required - just open in browser!</li> </ul>"},{"location":"app-development/step-07-visualization-plotly/#step-71-add-plotly-imports","title":"Step 7.1: Add Plotly Imports","text":"<p>Add these imports to <code>app.py</code>:</p> <pre><code>import plotly.graph_objects as go\nfrom plotly.subplots import make_subplots\n</code></pre>"},{"location":"app-development/step-07-visualization-plotly/#step-72-implement-generate_plotly_html","title":"Step 7.2: Implement generate_plotly_html()","text":"<p>Create the main Plotly function:</p> <pre><code>def generate_plotly_html(results, config):\n    \"\"\"Generate interactive Plotly HTML visualizations\"\"\"\n    output_dir = Path(config[\"output\"][\"output_dir\"])\n    output_dir.mkdir(parents=True, exist_ok=True)\n\n    print(f\"\\n{'='*60}\")\n    print(f\"PLOTLY: Generating interactive HTML visualizations\")\n    print(f\"{'='*60}\\n\")\n\n    df = results[\"data\"]\n    stats = results[\"stats\"]\n\n    # Generate visualizations\n    create_dashboard(df, stats, output_dir)\n    create_timeseries(df, stats, output_dir)\n    create_heatmap(df, output_dir)\n    create_boxplot(df, stats, output_dir)\n\n    print(f\"\\n[OK] All HTML visualizations generated\")\n</code></pre>"},{"location":"app-development/step-07-visualization-plotly/#step-73-interactive-dashboard","title":"Step 7.3: Interactive Dashboard","text":"<p>Create a comprehensive dashboard with multiple subplots:</p> <pre><code>def create_dashboard(df, stats, output_dir):\n    \"\"\"Create interactive dashboard with multiple views\"\"\"\n    # Create figure with subplots\n    fig = make_subplots(\n        rows=3, cols=2,\n        subplot_titles=(\n            \"Supply &amp; Return Temperatures\",\n            \"Temperature Differential\",\n            \"Distribution\",\n            \"Hourly Pattern\",\n            \"Box Plot by Hour\",\n            \"Statistics Summary\"\n        ),\n        specs=[\n            [{\"type\": \"scatter\"}, {\"type\": \"scatter\"}],\n            [{\"type\": \"histogram\"}, {\"type\": \"bar\"}],\n            [{\"type\": \"box\"}, {\"type\": \"table\"}]\n        ],\n        vertical_spacing=0.12,\n        horizontal_spacing=0.10\n    )\n\n    # 1. Supply &amp; Return Temperatures\n    fig.add_trace(\n        go.Scatter(x=df.index, y=df[\"supply\"], name=\"Supply\",\n                   line=dict(color=\"#e74c3c\")),\n        row=1, col=1\n    )\n    fig.add_trace(\n        go.Scatter(x=df.index, y=df[\"return\"], name=\"Return\",\n                   line=dict(color=\"#3498db\")),\n        row=1, col=1\n    )\n\n    # 2. Temperature Differential\n    fig.add_trace(\n        go.Scatter(x=df.index, y=df[\"temp_diff\"], name=\"Temp Diff\",\n                   line=dict(color=\"#9b59b6\")),\n        row=1, col=2\n    )\n\n    # 3. Distribution\n    fig.add_trace(\n        go.Histogram(x=df[\"temp_diff\"], name=\"Distribution\",\n                     marker=dict(color=\"#3498db\")),\n        row=2, col=1\n    )\n\n    # 4. Hourly Pattern\n    hourly = df.groupby(\"hour\")[\"temp_diff\"].mean()\n    fig.add_trace(\n        go.Bar(x=hourly.index, y=hourly.values, name=\"Hourly Avg\",\n               marker=dict(color=\"#27ae60\")),\n        row=2, col=2\n    )\n\n    # 5. Box Plot by Hour\n    for hour in sorted(df[\"hour\"].unique()):\n        hour_data = df[df[\"hour\"] == hour][\"temp_diff\"]\n        fig.add_trace(\n            go.Box(y=hour_data, name=str(hour), showlegend=False),\n            row=3, col=1\n        )\n\n    # 6. Statistics Table\n    stats_data = [\n        [\"Mean\", f\"{stats['mean_temp_diff']:.2f} \u00b0C\"],\n        [\"Std Dev\", f\"{stats['std_temp_diff']:.2f} \u00b0C\"],\n        [\"Min\", f\"{stats['min_temp_diff']:.2f} \u00b0C\"],\n        [\"Max\", f\"{stats['max_temp_diff']:.2f} \u00b0C\"],\n        [\"Anomalies\", f\"{stats['anomaly_rate']:.2f}%\"]\n    ]\n    fig.add_trace(\n        go.Table(\n            header=dict(values=[\"Metric\", \"Value\"], fill_color=\"lightgray\"),\n            cells=dict(values=list(zip(*stats_data)), fill_color=\"white\")\n        ),\n        row=3, col=2\n    )\n\n    # Update layout\n    fig.update_layout(\n        title_text=\"Temperature Analysis Dashboard\",\n        showlegend=True,\n        height=1200,\n        template=\"plotly_white\"\n    )\n\n    # Save\n    filepath = output_dir / \"dashboard_interactive.html\"\n    fig.write_html(filepath)\n    print(f\"  [OK] {filepath.name}\")\n</code></pre> <p>Understanding: - <code>make_subplots()</code> - Create grid of plots - <code>add_trace()</code> - Add data to specific subplot - <code>row=, col=</code> - Position in grid - <code>write_html()</code> - Save as standalone HTML</p>"},{"location":"app-development/step-07-visualization-plotly/#step-74-detailed-time-series","title":"Step 7.4: Detailed Time-Series","text":"<p>Create an interactive time-series with dual y-axes:</p> <pre><code>def create_timeseries(df, stats, output_dir):\n    \"\"\"Create detailed interactive time-series\"\"\"\n    fig = make_subplots(specs=[[{\"secondary_y\": True}]])\n\n    # Temperature traces\n    fig.add_trace(\n        go.Scatter(x=df.index, y=df[\"supply\"], name=\"Supply Temp\",\n                   line=dict(color=\"#e74c3c\", width=2),\n                   hovertemplate=\"Time: %{x}&lt;br&gt;Supply: %{y:.2f}\u00b0C&lt;extra&gt;&lt;/extra&gt;\"),\n        secondary_y=False\n    )\n\n    fig.add_trace(\n        go.Scatter(x=df.index, y=df[\"return\"], name=\"Return Temp\",\n                   line=dict(color=\"#3498db\", width=2),\n                   hovertemplate=\"Time: %{x}&lt;br&gt;Return: %{y:.2f}\u00b0C&lt;extra&gt;&lt;/extra&gt;\"),\n        secondary_y=False\n    )\n\n    # Temperature difference on secondary axis\n    fig.add_trace(\n        go.Scatter(x=df.index, y=df[\"temp_diff\"], name=\"Temp Diff\",\n                   line=dict(color=\"#9b59b6\", width=2, dash=\"dash\"),\n                   hovertemplate=\"Time: %{x}&lt;br&gt;Diff: %{y:.2f}\u00b0C&lt;extra&gt;&lt;/extra&gt;\"),\n        secondary_y=True\n    )\n\n    # Add mean line\n    fig.add_hline(\n        y=stats[\"mean_temp_diff\"],\n        line_dash=\"dash\",\n        line_color=\"#27ae60\",\n        annotation_text=f\"Mean: {stats['mean_temp_diff']:.2f}\u00b0C\",\n        secondary_y=True\n    )\n\n    # Update axes\n    fig.update_xaxes(title_text=\"Time\")\n    fig.update_yaxes(title_text=\"Temperature (\u00b0C)\", secondary_y=False)\n    fig.update_yaxes(title_text=\"Temperature Difference (\u00b0C)\", secondary_y=True)\n\n    fig.update_layout(\n        title=\"Interactive Temperature Analysis\",\n        hovermode=\"x unified\",\n        template=\"plotly_white\",\n        height=600\n    )\n\n    filepath = output_dir / \"timeseries_interactive.html\"\n    fig.write_html(filepath)\n    print(f\"  [OK] {filepath.name}\")\n</code></pre> <p>Interactive Features: - Hover: See exact values - Zoom: Box select or scroll - Pan: Click and drag - Legend: Click to show/hide traces - Reset: Double-click to reset view</p>"},{"location":"app-development/step-07-visualization-plotly/#step-75-interactive-heatmap","title":"Step 7.5: Interactive Heatmap","text":"<pre><code>def create_heatmap(df, output_dir):\n    \"\"\"Create interactive heatmap\"\"\"\n    # Prepare data\n    pivot = df.pivot_table(\n        values=\"temp_diff\",\n        index=\"hour\",\n        columns=\"weekday\",\n        aggfunc=\"mean\"\n    )\n\n    # Create heatmap\n    fig = go.Figure(data=go.Heatmap(\n        z=pivot.values,\n        x=[\"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\", \"Sun\"],\n        y=list(range(24)),\n        colorscale=\"RdYlBu_r\",\n        hovertemplate=\"Weekday: %{x}&lt;br&gt;Hour: %{y}&lt;br&gt;Temp Diff: %{z:.2f}\u00b0C&lt;extra&gt;&lt;/extra&gt;\",\n        colorbar=dict(title=\"Mean Temp&lt;br&gt;Diff (\u00b0C)\")\n    ))\n\n    fig.update_layout(\n        title=\"Temperature Differential Patterns\",\n        xaxis_title=\"Day of Week\",\n        yaxis_title=\"Hour of Day\",\n        template=\"plotly_white\",\n        height=700\n    )\n\n    filepath = output_dir / \"heatmap_interactive.html\"\n    fig.write_html(filepath)\n    print(f\"  [OK] {filepath.name}\")\n</code></pre>"},{"location":"app-development/step-07-visualization-plotly/#step-76-box-plot","title":"Step 7.6: Box Plot","text":"<pre><code>def create_boxplot(df, stats, output_dir):\n    \"\"\"Create interactive box plot\"\"\"\n    fig = go.Figure()\n\n    # Add box plot\n    fig.add_trace(go.Box(\n        y=df[\"temp_diff\"],\n        name=\"Temperature Difference\",\n        marker_color=\"#3498db\",\n        boxmean=\"sd\"  # Show mean and standard deviation\n    ))\n\n    # Add statistics annotations\n    fig.add_annotation(\n        text=f\"Mean: {stats['mean_temp_diff']:.2f}\u00b0C&lt;br&gt;\"\n             f\"Median: {stats['median_temp_diff']:.2f}\u00b0C&lt;br&gt;\"\n             f\"Std: {stats['std_temp_diff']:.2f}\u00b0C\",\n        xref=\"paper\", yref=\"paper\",\n        x=0.98, y=0.98,\n        showarrow=False,\n        bgcolor=\"lightgray\",\n        bordercolor=\"black\",\n        borderwidth=1\n    )\n\n    fig.update_layout(\n        title=\"Temperature Differential Distribution\",\n        yaxis_title=\"Temperature Difference (\u00b0C)\",\n        template=\"plotly_white\",\n        height=600\n    )\n\n    filepath = output_dir / \"boxplot_interactive.html\"\n    fig.write_html(filepath)\n    print(f\"  [OK] {filepath.name}\")\n</code></pre>"},{"location":"app-development/step-07-visualization-plotly/#step-77-test-plotly-visualizations","title":"Step 7.7: Test Plotly Visualizations","text":"<pre><code>def test_plotly():\n    \"\"\"Test Plotly HTML generation\"\"\"\n    from hhw_brick.applications.my_first_app.app import analyze, load_config\n\n    fixtures = Path(__file__).parent.parent.parent.parent / \"tests\" / \"fixtures\"\n    model_file = fixtures / \"Brick_Model_File\" / \"building_29.ttl\"\n    data_file = fixtures / \"TimeSeriesData\" / \"29hhw_system_data.csv\"\n\n    config = load_config()\n    config[\"output\"][\"output_dir\"] = \"./test_plotly\"\n    config[\"output\"][\"generate_plotly_html\"] = True\n\n    results = analyze(str(model_file), str(data_file), config)\n\n    if results:\n        print(\"\\n\u2705 HTML visualizations generated!\")\n        print(f\"Open files in browser:\")\n        print(f\"  - dashboard_interactive.html\")\n        print(f\"  - timeseries_interactive.html\")\n        print(f\"  - heatmap_interactive.html\")\n        print(f\"  - boxplot_interactive.html\")\n\nif __name__ == \"__main__\":\n    test_plotly()\n</code></pre>"},{"location":"app-development/step-07-visualization-plotly/#step-78-update-config","title":"Step 7.8: Update Config","text":"<p>In <code>config.yaml</code>:</p> <pre><code>output:\n  generate_plotly_html: true  # Enable/disable Plotly HTML\n</code></pre>"},{"location":"app-development/step-07-visualization-plotly/#checkpoint_1","title":"Checkpoint","text":"<p>Before proceeding, verify:</p> <ul> <li> Plotly imports added</li> <li> generate_plotly_html() function created</li> <li> Dashboard with 6 subplots</li> <li> Interactive time-series</li> <li> Interactive heatmap</li> <li> Box plot with statistics</li> <li> HTML files open in browser</li> <li> Interactive features work (zoom, pan, hover)</li> </ul>"},{"location":"app-development/step-07-visualization-plotly/#next-steps","title":"Next Steps","text":"<p>\u2705 Plotly visualization complete!</p> <p>\ud83d\udc49 Continue to Step 8: Testing Your Application</p>"},{"location":"app-development/step-07-visualization-plotly/#plotly-features","title":"Plotly Features","text":""},{"location":"app-development/step-07-visualization-plotly/#interactive-controls","title":"Interactive Controls","text":"<p>All Plotly plots have: - \ud83d\udd0d Zoom: Box select or scroll wheel - \ud83d\udc46 Pan: Click and drag - \ud83d\udcca Hover: Detailed tooltips - \ud83d\udc41\ufe0f Toggle: Click legend to show/hide - \ud83d\udcf8 Export: Camera icon to save as PNG - \ud83d\udd04 Reset: Double-click to reset</p>"},{"location":"app-development/step-07-visualization-plotly/#customization","title":"Customization","text":"<pre><code># Change colors\nline=dict(color=\"#FF6B6B\", width=3)\n\n# Change hover\nhovertemplate=\"&lt;b&gt;%{x}&lt;/b&gt;&lt;br&gt;Value: %{y:.2f}&lt;extra&gt;&lt;/extra&gt;\"\n\n# Change layout\nfig.update_layout(template=\"plotly_dark\")  # Dark theme\n</code></pre>"},{"location":"app-development/step-07-visualization-plotly/#summary","title":"Summary","text":"<p>You've created interactive visualizations:</p> <p>\u2705 Dashboard: 6-panel comprehensive view \u2705 Time-Series: Dual y-axes with zoom \u2705 Heatmap: Pattern analysis \u2705 Box Plot: Statistical distribution \u2705 Standalone HTML: No server needed \u2705 Fully Interactive: Zoom, pan, hover  </p> <p>Next: Testing and deployment!</p>"},{"location":"app-development/step-08-testing/","title":"Step 8: Testing Your Application","text":"<p>Create a comprehensive test suite for your application.</p>"},{"location":"app-development/step-08-testing/#1-create-test-script","title":"1. Create Test Script","text":"<p>Create <code>test_app.py</code> in your app directory:</p> <pre><code>\"\"\"Comprehensive test suite\"\"\"\nfrom pathlib import Path\nimport sys\n\napp_dir = Path(__file__).parent\nsys.path.insert(0, str(app_dir.parent.parent.parent))\n\nfrom hhw_brick.applications.my_first_app.app import load_config, qualify, analyze\n\ndef test_load_config():\n    \"\"\"Test config loading\"\"\"\n    print(\"\\n\" + \"=\"*60)\n    print(\"TEST 1: Load Config\")\n    print(\"=\"*60)\n\n    try:\n        config = load_config()\n        assert \"analysis\" in config\n        assert \"output\" in config\n        print(\"\u2705 Config loaded\")\n        return True\n    except Exception as e:\n        print(f\"\u274c Failed: {e}\")\n        return False\n\ndef test_qualify():\n    \"\"\"Test qualification\"\"\"\n    print(\"\\n\" + \"=\"*60)\n    print(\"TEST 2: Qualify\")\n    print(\"=\"*60)\n\n    fixtures = Path(__file__).parent.parent.parent.parent / \"tests\" / \"fixtures\"\n    brick_dir = fixtures / \"Brick_Model_File\"\n\n    if not brick_dir.exists():\n        print(\"\u26a0\ufe0f  Test data not found\")\n        return True\n\n    passed = 0\n    for model_file in list(brick_dir.glob(\"*.ttl\"))[:3]:  # Test first 3\n        try:\n            qualified, _ = qualify(str(model_file))\n            if qualified:\n                passed += 1\n                print(f\"\u2705 {model_file.name}\")\n        except Exception as e:\n            print(f\"\u274c {model_file.name}: {e}\")\n\n    print(f\"\\n{passed} buildings qualified\")\n    return True\n\ndef test_analyze():\n    \"\"\"Test complete analysis\"\"\"\n    print(\"\\n\" + \"=\"*60)\n    print(\"TEST 3: Analyze\")\n    print(\"=\"*60)\n\n    fixtures = Path(__file__).parent.parent.parent.parent / \"tests\" / \"fixtures\"\n    model = fixtures / \"Brick_Model_File\" / \"building_29.ttl\"\n    data = fixtures / \"TimeSeriesData\" / \"29hhw_system_data.csv\"\n\n    if not model.exists():\n        print(\"\u26a0\ufe0f  Test files not found\")\n        return True\n\n    try:\n        config = load_config()\n        config[\"output\"][\"output_dir\"] = \"./test_output\"\n\n        results = analyze(str(model), str(data), config)\n\n        if results:\n            assert \"stats\" in results\n            assert \"data\" in results\n            print(f\"\\n\u2705 Analysis complete\")\n            print(f\"  Points: {results['stats']['count']}\")\n            print(f\"  Mean: {results['stats']['mean_temp_diff']:.2f}\u00b0C\")\n            return True\n        return False\n    except Exception as e:\n        print(f\"\u274c Failed: {e}\")\n        return False\n\ndef run_all_tests():\n    \"\"\"Run all tests\"\"\"\n    print(\"\\n\" + \"#\"*60)\n    print(\"# RUNNING TESTS\")\n    print(\"#\"*60)\n\n    results = [\n        (\"Config\", test_load_config()),\n        (\"Qualify\", test_qualify()),\n        (\"Analyze\", test_analyze())\n    ]\n\n    print(\"\\n\" + \"=\"*60)\n    print(\"SUMMARY\")\n    print(\"=\"*60)\n    for name, passed in results:\n        status = \"\u2705 PASS\" if passed else \"\u274c FAIL\"\n        print(f\"{status}: {name}\")\n\n    total = sum(1 for _, p in results if p)\n    print(f\"\\n{total}/{len(results)} tests passed\")\n\n    return total == len(results)\n\nif __name__ == \"__main__\":\n    success = run_all_tests()\n    sys.exit(0 if success else 1)\n</code></pre>"},{"location":"app-development/step-08-testing/#2-run-tests","title":"2. Run Tests","text":"<pre><code>python test_app.py\n</code></pre> <p>Expected output: <pre><code>============================================================\n# RUNNING TESTS\n============================================================\n\n============================================================\nTEST 1: Load Config\n============================================================\n\u2705 Config loaded\n\n============================================================\nTEST 2: Qualify\n============================================================\n\u2705 building_29.ttl\n\u2705 building_105.ttl\n\n2 buildings qualified\n\n============================================================\nTEST 3: Analyze\n============================================================\n\u2705 Analysis complete\n  Points: 26013\n  Mean: 0.60\u00b0C\n\n============================================================\nSUMMARY\n============================================================\n\u2705 PASS: Config\n\u2705 PASS: Qualify\n\u2705 PASS: Analyze\n\n3/3 tests passed\n</code></pre></p>"},{"location":"app-development/step-08-testing/#3-test-with-appsmanager","title":"3. Test with AppsManager","text":"<p>Verify integration:</p> <pre><code>\"\"\"Test AppsManager integration\"\"\"\nfrom hhw_brick import apps\n\n# List apps\nall_apps = apps.list_apps()\nassert \"my_first_app\" in [a[\"name\"] for a in all_apps]\nprint(\"\u2713 App discovered\")\n\n# Load app\napp = apps.load_app(\"my_first_app\")\nprint(\"\u2713 App loaded\")\n\n# Get config\nconfig = apps.get_default_config(\"my_first_app\")\nprint(\"\u2713 Config retrieved\")\n</code></pre>"},{"location":"app-development/step-08-testing/#checkpoint","title":"Checkpoint","text":"<ul> <li> Test script created</li> <li> All functions tested</li> <li> Integration with AppsManager verified</li> <li> All tests pass</li> </ul>"},{"location":"app-development/step-08-testing/#next-step","title":"Next Step","text":"<p>\ud83d\udc49 Step 9: Deployment &amp; Integration</p> <p>In this step, you'll learn how to test your application to ensure it works correctly.</p>"},{"location":"app-development/step-08-testing/#goal-of-this-step","title":"Goal of This Step","text":"<ul> <li>Test individual functions</li> <li>Test the complete workflow</li> <li>Handle errors gracefully</li> <li>Verify with multiple buildings</li> </ul>"},{"location":"app-development/step-08-testing/#step-81-create-test-script","title":"Step 8.1: Create Test Script","text":"<p>Create <code>test_app.py</code> in your application directory:</p> <pre><code>\"\"\"\nComprehensive test suite for my_first_app\n\"\"\"\n\nfrom pathlib import Path\nimport sys\n\n# Add parent directory to path\napp_dir = Path(__file__).parent\nsys.path.insert(0, str(app_dir.parent.parent.parent))\n\nfrom hhw_brick.applications.my_first_app.app import (\n    load_config,\n    qualify,\n    analyze\n)\n\ndef test_load_config():\n    \"\"\"Test configuration loading\"\"\"\n    print(\"\\n\" + \"=\"*60)\n    print(\"TEST 1: Load Config\")\n    print(\"=\"*60)\n\n    try:\n        config = load_config()\n        assert \"analysis\" in config\n        assert \"output\" in config\n        assert \"time_range\" in config\n        print(\"\u2705 Config loaded successfully\")\n        return True\n    except Exception as e:\n        print(f\"\u274c Config loading failed: {e}\")\n        return False\n\n\ndef test_qualify():\n    \"\"\"Test qualification function\"\"\"\n    print(\"\\n\" + \"=\"*60)\n    print(\"TEST 2: Qualify Buildings\")\n    print(\"=\"*60)\n\n    fixtures = Path(__file__).parent.parent.parent.parent / \"tests\" / \"fixtures\"\n    brick_dir = fixtures / \"Brick_Model_File\"\n\n    if not brick_dir.exists():\n        print(\"\u26a0\ufe0f  Test data not found, skipping\")\n        return True\n\n    passed = 0\n    failed = 0\n\n    for model_file in brick_dir.glob(\"*.ttl\"):\n        try:\n            qualified, details = qualify(str(model_file))\n            if qualified:\n                print(f\"\u2705 {model_file.name}: QUALIFIED\")\n                passed += 1\n            else:\n                print(f\"\u26a0\ufe0f  {model_file.name}: Not qualified\")\n        except Exception as e:\n            print(f\"\u274c {model_file.name}: ERROR - {e}\")\n            failed += 1\n\n    print(f\"\\nResults: {passed} qualified, {failed} errors\")\n    return failed == 0\n\n\ndef test_analyze():\n    \"\"\"Test complete analysis workflow\"\"\"\n    print(\"\\n\" + \"=\"*60)\n    print(\"TEST 3: Complete Analysis\")\n    print(\"=\"*60)\n\n    fixtures = Path(__file__).parent.parent.parent.parent / \"tests\" / \"fixtures\"\n\n    # Use a known good building\n    model_file = fixtures / \"Brick_Model_File\" / \"building_29.ttl\"\n    data_file = fixtures / \"TimeSeriesData\" / \"29hhw_system_data.csv\"\n\n    if not model_file.exists() or not data_file.exists():\n        print(\"\u26a0\ufe0f  Test files not found, skipping\")\n        return True\n\n    try:\n        config = load_config()\n        config[\"output\"][\"output_dir\"] = \"./test_output\"\n        config[\"output\"][\"generate_plots\"] = True\n        config[\"output\"][\"generate_plotly_html\"] = True\n\n        results = analyze(str(model_file), str(data_file), config)\n\n        if results:\n            assert \"stats\" in results\n            assert \"data\" in results\n            assert results[\"stats\"][\"count\"] &gt; 0\n\n            print(f\"\\n\u2705 Analysis completed successfully\")\n            print(f\"  Data points: {results['stats']['count']}\")\n            print(f\"  Mean temp diff: {results['stats']['mean_temp_diff']:.2f}\u00b0C\")\n            return True\n        else:\n            print(\"\u274c Analysis returned None\")\n            return False\n\n    except Exception as e:\n        print(f\"\u274c Analysis failed: {e}\")\n        import traceback\n        traceback.print_exc()\n        return False\n\n\ndef test_error_handling():\n    \"\"\"Test error handling with invalid inputs\"\"\"\n    print(\"\\n\" + \"=\"*60)\n    print(\"TEST 4: Error Handling\")\n    print(\"=\"*60)\n\n    try:\n        # Test with non-existent file\n        qualified, details = qualify(\"nonexistent.ttl\")\n        print(\"\u274c Should have raised an error\")\n        return False\n    except Exception as e:\n        print(f\"\u2705 Correctly handled invalid file: {type(e).__name__}\")\n        return True\n\n\ndef run_all_tests():\n    \"\"\"Run all tests\"\"\"\n    print(\"\\n\" + \"#\"*60)\n    print(\"# RUNNING ALL TESTS\")\n    print(\"#\"*60)\n\n    results = []\n    results.append((\"Load Config\", test_load_config()))\n    results.append((\"Qualify\", test_qualify()))\n    results.append((\"Analyze\", test_analyze()))\n    results.append((\"Error Handling\", test_error_handling()))\n\n    print(\"\\n\" + \"=\"*60)\n    print(\"TEST SUMMARY\")\n    print(\"=\"*60)\n\n    for test_name, passed in results:\n        status = \"\u2705 PASS\" if passed else \"\u274c FAIL\"\n        print(f\"{status}: {test_name}\")\n\n    total_passed = sum(1 for _, passed in results if passed)\n    total_tests = len(results)\n\n    print(f\"\\n{total_passed}/{total_tests} tests passed\")\n\n    if total_passed == total_tests:\n        print(\"\\n\ud83c\udf89 ALL TESTS PASSED!\")\n        return True\n    else:\n        print(f\"\\n\u26a0\ufe0f  {total_tests - total_passed} test(s) failed\")\n        return False\n\n\nif __name__ == \"__main__\":\n    success = run_all_tests()\n    sys.exit(0 if success else 1)\n</code></pre>"},{"location":"app-development/step-08-testing/#step-82-run-tests","title":"Step 8.2: Run Tests","text":"<p>Run your test suite:</p> <pre><code>python test_app.py\n</code></pre> <p>Expected Output: <pre><code>============================================================\n# RUNNING ALL TESTS\n============================================================\n\n============================================================\nTEST 1: Load Config\n============================================================\n\u2705 Config loaded successfully\n\n============================================================\nTEST 2: Qualify Buildings\n============================================================\n\u2705 building_29.ttl: QUALIFIED\n\u2705 building_105.ttl: QUALIFIED\n...\n\n============================================================\nTEST 3: Complete Analysis\n============================================================\n\u2705 Analysis completed successfully\n  Data points: 26013\n  Mean temp diff: 0.60\u00b0C\n\n============================================================\nTEST 4: Error Handling\n============================================================\n\u2705 Correctly handled invalid file: FileNotFoundError\n\n============================================================\nTEST SUMMARY\n============================================================\n\u2705 PASS: Load Config\n\u2705 PASS: Qualify\n\u2705 PASS: Analyze\n\u2705 PASS: Error Handling\n\n4/4 tests passed\n\n\ud83c\udf89 ALL TESTS PASSED!\n</code></pre></p>"},{"location":"app-development/step-08-testing/#step-83-integration-test-with-appsmanager","title":"Step 8.3: Integration Test with AppsManager","text":"<p>Test that your app works with the apps manager:</p> <pre><code>def test_with_apps_manager():\n    \"\"\"Test app through AppsManager\"\"\"\n    print(\"\\n\" + \"=\"*60)\n    print(\"TEST: AppsManager Integration\")\n    print(\"=\"*60)\n\n    from hhw_brick import apps\n\n    try:\n        # List apps\n        all_apps = apps.list_apps()\n        app_names = [app[\"name\"] for app in all_apps]\n\n        if \"my_first_app\" in app_names:\n            print(\"\u2705 App discovered by AppsManager\")\n        else:\n            print(\"\u274c App not found in app list\")\n            return False\n\n        # Load app\n        app = apps.load_app(\"my_first_app\")\n        print(\"\u2705 App loaded successfully\")\n\n        # Get default config\n        config = apps.get_default_config(\"my_first_app\")\n        print(\"\u2705 Default config retrieved\")\n\n        # Get app info\n        info = apps.get_app_info(\"my_first_app\")\n        print(f\"\u2705 App info: {len(info['functions'])} functions\")\n\n        return True\n\n    except Exception as e:\n        print(f\"\u274c Integration test failed: {e}\")\n        return False\n</code></pre>"},{"location":"app-development/step-08-testing/#step-84-add-error-handling-to-your-app","title":"Step 8.4: Add Error Handling to Your App","text":"<p>Update your <code>analyze()</code> function to handle errors gracefully:</p> <pre><code>def analyze(brick_model_path, timeseries_data_path, config):\n    \"\"\"Execute analysis workflow\"\"\"\n    try:\n        # Step 1: Qualify\n        qualified, qualify_result = qualify(brick_model_path)\n        if not qualified:\n            print(\"[INFO] Building does not qualify for this analysis\")\n            return None\n\n        # ...rest of implementation...\n\n    except FileNotFoundError as e:\n        print(f\"[ERROR] File not found: {e}\")\n        return None\n    except KeyError as e:\n        print(f\"[ERROR] Missing configuration key: {e}\")\n        return None\n    except Exception as e:\n        print(f\"[ERROR] Unexpected error during analysis: {e}\")\n        import traceback\n        traceback.print_exc()\n        return None\n</code></pre>"},{"location":"app-development/step-08-testing/#step-85-validate-outputs","title":"Step 8.5: Validate Outputs","text":"<p>Add validation to ensure outputs are correct:</p> <pre><code>def validate_results(results):\n    \"\"\"Validate analysis results\"\"\"\n    if results is None:\n        return False\n\n    # Check structure\n    if \"stats\" not in results or \"data\" not in results:\n        print(\"\u274c Invalid results structure\")\n        return False\n\n    # Check stats\n    stats = results[\"stats\"]\n    required_stats = [\n        \"count\", \"mean_temp_diff\", \"std_temp_diff\",\n        \"min_temp_diff\", \"max_temp_diff\"\n    ]\n\n    for stat in required_stats:\n        if stat not in stats:\n            print(f\"\u274c Missing stat: {stat}\")\n            return False\n\n    # Check data\n    data = results[\"data\"]\n    if data.empty:\n        print(\"\u274c No data in results\")\n        return False\n\n    required_columns = [\"supply\", \"return\", \"temp_diff\", \"hour\", \"weekday\"]\n    for col in required_columns:\n        if col not in data.columns:\n            print(f\"\u274c Missing column: {col}\")\n            return False\n\n    print(\"\u2705 Results validation passed\")\n    return True\n</code></pre>"},{"location":"app-development/step-08-testing/#checkpoint_1","title":"Checkpoint","text":"<p>Before proceeding, verify:</p> <ul> <li> Test script created</li> <li> All functions tested individually</li> <li> Complete workflow tested</li> <li> Error handling tested</li> <li> Integration with AppsManager tested</li> <li> Output validation implemented</li> <li> All tests pass</li> </ul>"},{"location":"app-development/step-08-testing/#next-steps","title":"Next Steps","text":"<p>\u2705 Testing complete!</p> <p>\ud83d\udc49 Continue to Step 9: Deployment &amp; Integration</p>"},{"location":"app-development/step-08-testing/#testing-best-practices","title":"Testing Best Practices","text":""},{"location":"app-development/step-08-testing/#do","title":"\u2705 Do","text":"<ul> <li>Test with multiple buildings</li> <li>Test error cases (missing files, bad data)</li> <li>Validate outputs</li> <li>Use assertions to check conditions</li> <li>Print clear success/failure messages</li> </ul>"},{"location":"app-development/step-08-testing/#dont","title":"\u274c Don't","text":"<ul> <li>Skip error handling</li> <li>Test only with one building</li> <li>Ignore test failures</li> <li>Make tests dependent on each other</li> <li>Hardcode file paths</li> </ul>"},{"location":"app-development/step-08-testing/#common-test-issues","title":"Common Test Issues","text":"<p>Issue: Tests can't find test data Solution: Use <code>Path(__file__).parent</code> to get relative paths</p> <p>Issue: Import errors Solution: Check <code>sys.path.insert(0, ...)</code> is correct</p> <p>Issue: Tests pass but app fails in production Solution: Test with diverse buildings and edge cases</p> <p>Issue: Plots not generated during tests Solution: Check output directory exists and is writable</p>"},{"location":"app-development/step-08-testing/#summary","title":"Summary","text":"<p>You've created a comprehensive test suite:</p> <p>\u2705 Unit Tests: Test individual functions \u2705 Integration Tests: Test complete workflow \u2705 Error Handling: Handle failures gracefully \u2705 Validation: Ensure outputs are correct \u2705 AppsManager: Verify app integration  </p> <p>Your app is now tested and ready for deployment!</p>"},{"location":"app-development/step-09-deployment/","title":"Step 9: Deployment &amp; Integration","text":"<p>Final steps to deploy and share your application.</p>"},{"location":"app-development/step-09-deployment/#1-verify-file-structure","title":"1. Verify File Structure","text":"<p>Ensure all required files are present:</p> <pre><code>my_first_app/\n\u251c\u2500\u2500 __init__.py          \u2705 Metadata and exports\n\u251c\u2500\u2500 app.py               \u2705 Complete implementation\n\u251c\u2500\u2500 config.yaml          \u2705 Default configuration\n\u251c\u2500\u2500 requirements.txt     \u2705 Dependencies\n\u2514\u2500\u2500 README.md            \u2705 Documentation\n</code></pre>"},{"location":"app-development/step-09-deployment/#2-update-readmemd","title":"2. Update README.md","text":"<p>Complete your user documentation:</p> <pre><code># My First Application\n\n## Overview\n\nAnalyzes temperature differential between supply and return water in hot water systems.\n\n## Requirements\n\nBuildings must have:\n- Hot Water Loop\n- Supply temperature sensor (Leaving_Hot_Water_Temperature_Sensor)\n- Return temperature sensor (Entering_Hot_Water_Temperature_Sensor)\n\n## Usage\n\n\\`\\`\\`python\nfrom hhw_brick import apps\n\napp = apps.load_app(\"my_first_app\")\n\n# Check qualification\nqualified, details = app.qualify(\"building.ttl\")\n\n# Run analysis\nif qualified:\n    config = app.load_config()\n    config[\"output\"][\"output_dir\"] = \"./results\"\n    results = app.analyze(\"building.ttl\", \"data.csv\", config)\n\\`\\`\\`\n\n## Output\n\n- `stats.csv` - Statistical summary\n- `timeseries.csv` - Processed data\n- `timeseries.png` - Temperature plots\n- `distribution.png` - Distribution histogram\n- `heatmap.png` - Hour/weekday patterns\n- `hourly_pattern.png` - Hourly averages\n- `dashboard_interactive.html` - Interactive dashboard\n- `timeseries_interactive.html` - Interactive timeseries\n- `heatmap_interactive.html` - Interactive heatmap\n- `boxplot_interactive.html` - Interactive box plot\n\n## Configuration\n\nEdit `config.yaml`:\n\n\\`\\`\\`yaml\nanalysis:\n  threshold_min_delta: 0.5\n  threshold_max_delta: 10.0\n\noutput:\n  output_dir: \"./results\"\n  export_format: \"csv\"      # csv or json\n  plot_format: \"png\"        # png, pdf, svg\n  generate_plots: true\n  generate_plotly_html: true\n\\`\\`\\`\n\n## Author\n\nYour Name - v1.0.0\n</code></pre>"},{"location":"app-development/step-09-deployment/#3-test-with-appsmanager","title":"3. Test with AppsManager","text":"<p>Verify integration:</p> <pre><code>\"\"\"Integration test\"\"\"\nfrom hhw_brick import apps\n\n# List apps\nall_apps = apps.list_apps()\nprint([app[\"name\"] for app in all_apps])\n\n# Load app\napp = apps.load_app(\"my_first_app\")\nprint(f\"Loaded: {app.__name__}\")\n\n# Get config\nconfig = apps.get_default_config(\"my_first_app\")\nprint(f\"Config: {list(config.keys())}\")\n\n# Get info\ninfo = apps.get_app_info(\"my_first_app\")\nprint(f\"Functions: {[f['name'] for f in info['functions']]}\")\n</code></pre> <p>Expected: <pre><code>['my_first_app', 'secondary_loop_temp_diff', 'primary_loop_temp_diff']\nLoaded: hhw_brick.applications.my_first_app.app\nConfig: ['analysis', 'output', 'time_range']\nFunctions: ['qualify', 'analyze', 'load_config']\n</code></pre></p>"},{"location":"app-development/step-09-deployment/#4-create-usage-example","title":"4. Create Usage Example","text":"<p>Add <code>example_usage.py</code>:</p> <pre><code>\"\"\"Example usage of my_first_app\"\"\"\nfrom pathlib import Path\nfrom hhw_brick import apps\n\n# Load application\napp = apps.load_app(\"my_first_app\")\n\n# Paths\nfixtures = Path(\"tests/fixtures\")\nmodel = fixtures / \"Brick_Model_File\" / \"building_29.ttl\"\ndata = fixtures / \"TimeSeriesData\" / \"29hhw_system_data.csv\"\n\n# Qualify\nqualified, details = app.qualify(str(model))\n\nif not qualified:\n    print(\"Building does not qualify\")\n    exit(1)\n\nprint(f\"\u2713 Building qualified\")\n\n# Configure\nconfig = app.load_config()\nconfig[\"output\"][\"output_dir\"] = \"./results/building_29\"\n\n# Analyze\nresults = app.analyze(str(model), str(data), config)\n\nif results:\n    print(f\"\\n\u2705 Analysis complete!\")\n    print(f\"  Mean: {results['stats']['mean_temp_diff']:.2f}\u00b0C\")\n    print(f\"  Output: {config['output']['output_dir']}\")\n</code></pre>"},{"location":"app-development/step-09-deployment/#5-deployment-checklist","title":"5. Deployment Checklist","text":"<p>Before sharing:</p> <ul> <li> All 5 files present and complete</li> <li> <code>__init__.py</code> has correct metadata</li> <li> <code>README.md</code> has usage examples</li> <li> All tests pass</li> <li> Works with AppsManager</li> <li> Example usage provided</li> <li> Error messages are clear</li> </ul>"},{"location":"app-development/step-09-deployment/#6-sharing-your-app","title":"6. Sharing Your App","text":""},{"location":"app-development/step-09-deployment/#option-1-contribute-to-hhw-brick","title":"Option 1: Contribute to HHW Brick","text":"<pre><code>cd HHW_brick\ngit checkout -b feature/my-first-app\ngit add hhw_brick/applications/my_first_app/\ngit commit -m \"Add my_first_app application\"\ngit push origin feature/my-first-app\n# Then create Pull Request on GitHub\n</code></pre>"},{"location":"app-development/step-09-deployment/#option-2-standalone-package","title":"Option 2: Standalone Package","text":"<p>Create <code>setup.py</code>:</p> <pre><code>from setuptools import setup, find_packages\n\nsetup(\n    name=\"my-first-app\",\n    version=\"1.0.0\",\n    packages=find_packages(),\n    install_requires=[\n        \"hhw-brick&gt;=0.1.0\",\n        \"pandas&gt;=1.3.0\",\n        \"matplotlib&gt;=3.5.0\",\n        \"plotly&gt;=5.0.0\",\n    ]\n)\n</code></pre>"},{"location":"app-development/step-09-deployment/#congratulations","title":"\ud83c\udf89 Congratulations!","text":"<p>You've completed the Application Development Guide!</p>"},{"location":"app-development/step-09-deployment/#what-you-built","title":"What You Built","text":"<p>\u2705 Complete Application - Building qualification - Data processing - Statistical analysis - Matplotlib plots (4 types) - Plotly HTML (4 interactive) - Results export</p> <p>\u2705 Professional Package - Proper structure - Comprehensive tests - Complete documentation - Framework integration</p> <p>\u2705 Portable &amp; Reusable - Works on any qualified building - Configurable parameters - Easy to extend</p>"},{"location":"app-development/step-09-deployment/#next-steps","title":"Next Steps","text":"<p>Enhance: - Add more analysis metrics - Implement advanced SPARQL - Create custom visualizations</p> <p>Learn More: - Study: <code>secondary_loop_temp_diff</code>, <code>primary_loop_temp_diff</code> - Explore: https://docs.brickschema.org/ - Learn SPARQL: https://www.w3.org/TR/sparql11-query/</p> <p>Contribute: - Share your app - Help improve docs - Report bugs</p>"},{"location":"app-development/step-09-deployment/#resources","title":"Resources","text":"<ul> <li>HHW Brick: https://github.com/CenterForTheBuiltEnvironment/HHW_brick</li> <li>Brick Schema: https://brickschema.org/</li> <li>SPARQL: https://www.w3.org/TR/sparql11-query/</li> <li>Plotly: https://plotly.com/python/</li> </ul> <p>Thank you for building with HHW Brick! \ud83d\ude80</p> <p>In this final step, you'll learn how to deploy your application and integrate it with the HHW Brick framework.</p>"},{"location":"app-development/step-09-deployment/#goal-of-this-step","title":"Goal of This Step","text":"<ul> <li>Register your app with AppsManager</li> <li>Create proper documentation</li> <li>Share your application</li> <li>Best practices for maintenance</li> </ul>"},{"location":"app-development/step-09-deployment/#step-91-verify-app-structure","title":"Step 9.1: Verify App Structure","text":"<p>Ensure your application has all required files:</p> <pre><code>hhw_brick/applications/my_first_app/\n\u251c\u2500\u2500 __init__.py          \u2705 Package metadata\n\u251c\u2500\u2500 app.py               \u2705 Main application code\n\u251c\u2500\u2500 config.yaml          \u2705 Default configuration\n\u251c\u2500\u2500 requirements.txt     \u2705 Dependencies\n\u2514\u2500\u2500 README.md            \u2705 Documentation\n</code></pre>"},{"location":"app-development/step-09-deployment/#step-92-update-initpy","title":"Step 9.2: Update init.py","text":"<p>Ensure your <code>__init__.py</code> is complete:</p> <pre><code>\"\"\"\nMy First Application\n\nTemperature differential analysis for hot water systems.\n\nAuthor: Your Name\n\"\"\"\n\nfrom .app import qualify, analyze, load_config\n\n__all__ = [\"qualify\", \"analyze\", \"load_config\"]\n\n# Application metadata\n__app_name__ = \"my_first_app\"\n__version__ = \"1.0.0\"\n__description__ = \"Temperature differential analysis\"\n__author__ = \"Your Name\"\n__email__ = \"your.email@example.com\"\n</code></pre>"},{"location":"app-development/step-09-deployment/#step-93-complete-readmemd","title":"Step 9.3: Complete README.md","text":"<p>Create comprehensive user documentation:</p> <pre><code># My First Application\n\n## Overview\n\nAnalyzes temperature differential between supply and return water in hot water systems.\n\n## Features\n\n- \u2705 Automatic sensor discovery using SPARQL\n- \u2705 Statistical analysis (mean, std, min, max)\n- \u2705 Anomaly detection\n- \u2705 Matplotlib visualizations (PNG/PDF/SVG)\n- \u2705 Interactive Plotly HTML dashboards\n\n## Requirements\n\nBuildings must have:\n- Hot Water Loop (primary or secondary)\n- Supply temperature sensor (Leaving_Hot_Water_Temperature_Sensor)\n- Return temperature sensor (Entering_Hot_Water_Temperature_Sensor)\n\n## Installation\n\n```bash\n# Install dependencies\npip install -r requirements.txt\n</code></pre>"},{"location":"app-development/step-09-deployment/#usage","title":"Usage","text":""},{"location":"app-development/step-09-deployment/#method-1-through-appsmanager","title":"Method 1: Through AppsManager","text":"<pre><code>from hhw_brick import apps\n\n# Load application\napp = apps.load_app(\"my_first_app\")\n\n# Check if building qualifies\nqualified, details = app.qualify(\"building.ttl\")\n\nif qualified:\n    # Load and customize config\n    config = apps.get_default_config(\"my_first_app\")\n    config[\"output\"][\"output_dir\"] = \"./my_results\"\n\n    # Run analysis\n    results = app.analyze(\"building.ttl\", \"data.csv\", config)\n</code></pre>"},{"location":"app-development/step-09-deployment/#method-2-command-line","title":"Method 2: Command Line","text":"<pre><code>python -m hhw_brick.applications.my_first_app.app \\\n    building.ttl \\\n    timeseries.csv \\\n    --output-dir ./results\n</code></pre>"},{"location":"app-development/step-09-deployment/#configuration","title":"Configuration","text":"<p>Edit <code>config.yaml</code> or pass custom configuration:</p> <pre><code>analysis:\n  threshold_min_delta: 0.5   # Minimum expected differential\n  threshold_max_delta: 10.0  # Maximum expected differential\n\noutput:\n  save_results: true\n  output_dir: \"./results\"\n  export_format: \"csv\"       # csv or json\n  generate_plots: true\n  plot_format: \"png\"         # png, pdf, or svg\n  generate_plotly_html: true\n\ntime_range:\n  start_time: null           # YYYY-MM-DD or null\n  end_time: null             # YYYY-MM-DD or null\n</code></pre>"},{"location":"app-development/step-09-deployment/#output","title":"Output","text":"<p>The application generates:</p> <p>Data Files: - <code>stats.csv</code> - Statistical summary - <code>timeseries.csv</code> - Processed time-series data</p> <p>Matplotlib Plots (if enabled): - <code>timeseries.png</code> - Supply, return, and differential - <code>distribution.png</code> - Histogram with statistics - <code>heatmap.png</code> - Hourly/weekday patterns - <code>hourly_pattern.png</code> - Average by hour</p> <p>Plotly HTML (if enabled): - <code>dashboard_interactive.html</code> - 6-panel dashboard - <code>timeseries_interactive.html</code> - Detailed time-series - <code>heatmap_interactive.html</code> - Pattern analysis - <code>boxplot_interactive.html</code> - Distribution</p>"},{"location":"app-development/step-09-deployment/#examples","title":"Examples","text":"<p>See <code>tests/test_app.py</code> for example usage.</p>"},{"location":"app-development/step-09-deployment/#troubleshooting","title":"Troubleshooting","text":"<p>Building not qualified: - Check if Brick model has required sensors - Verify sensor types match expected classes - Ensure sensors are properly linked to loop</p> <p>No data after analysis: - Check time range in config - Verify sensor names match data columns - Check for missing data (NaN values)</p> <p>Plots not generated: - Ensure output directory is writable - Check matplotlib/plotly are installed - Verify <code>generate_plots</code> is true in config</p>"},{"location":"app-development/step-09-deployment/#version-history","title":"Version History","text":"<ul> <li>1.0.0 (2025-01-04): Initial release</li> </ul>"},{"location":"app-development/step-09-deployment/#author","title":"Author","text":"<p>Your Name (your.email@example.com)</p>"},{"location":"app-development/step-09-deployment/#license","title":"License","text":"<p>MIT License <pre><code>---\n\n## Step 9.4: Test with AppsManager\n\nVerify your app works with the framework:\n\n```python\n\"\"\"Test app integration\"\"\"\nfrom hhw_brick import apps\n\n# 1. List all apps\nall_apps = apps.list_apps()\nprint(f\"Available apps: {[app['name'] for app in all_apps]}\")\n\n# 2. Get app info\ninfo = apps.get_app_info(\"my_first_app\")\nprint(f\"App: {info['name']}\")\nprint(f\"Functions: {[f['name'] for f in info['functions']]}\")\n\n# 3. Load app\napp = apps.load_app(\"my_first_app\")\nprint(f\"Loaded: {app.__name__}\")\n\n# 4. Get default config\nconfig = apps.get_default_config(\"my_first_app\")\nprint(f\"Config sections: {list(config.keys())}\")\n</code></pre></p> <p>Expected output: <pre><code>Available apps: ['my_first_app', 'secondary_loop_temp_diff', 'primary_loop_temp_diff']\nApp: my_first_app\nFunctions: ['qualify', 'analyze', 'load_config']\nLoaded: hhw_brick.applications.my_first_app.app\nConfig sections: ['analysis', 'output', 'time_range']\n</code></pre></p>"},{"location":"app-development/step-09-deployment/#step-95-create-usage-examples","title":"Step 9.5: Create Usage Examples","text":"<p>Add example scripts to help users:</p> <p>Create <code>examples/run_my_app.py</code>:</p> <pre><code>\"\"\"\nExample: Run my_first_app on a single building\n\"\"\"\nfrom pathlib import Path\nfrom hhw_brick import apps\n\n# Configuration\nBUILDING_NUMBER = 29\nfixtures = Path(\"tests/fixtures\")\n\n# Paths\nbrick_model = fixtures / \"Brick_Model_File\" / f\"building_{BUILDING_NUMBER}.ttl\"\ntimeseries = fixtures / \"TimeSeriesData\" / f\"{BUILDING_NUMBER}hhw_system_data.csv\"\n\n# Load application\nprint(f\"Loading application: my_first_app\")\napp = apps.load_app(\"my_first_app\")\n\n# Step 1: Qualify\nprint(f\"\\nStep 1: Checking if building {BUILDING_NUMBER} qualifies...\")\nqualified, details = app.qualify(str(brick_model))\n\nif not qualified:\n    print(f\"\u274c Building {BUILDING_NUMBER} does not qualify\")\n    exit(1)\n\nprint(f\"\u2705 Building {BUILDING_NUMBER} qualifies!\")\n\n# Step 2: Configure\nprint(f\"\\nStep 2: Loading configuration...\")\nconfig = apps.get_default_config(\"my_first_app\")\nconfig[\"output\"][\"output_dir\"] = f\"./results/building_{BUILDING_NUMBER}\"\nprint(f\"\u2705 Configuration loaded\")\n\n# Step 3: Analyze\nprint(f\"\\nStep 3: Running analysis...\")\nresults = app.analyze(str(brick_model), str(timeseries), config)\n\nif results:\n    print(f\"\\n\u2705 Analysis complete!\")\n    print(f\"  Data points: {results['stats']['count']}\")\n    print(f\"  Mean temp diff: {results['stats']['mean_temp_diff']:.2f}\u00b0C\")\n    print(f\"  Output: {config['output']['output_dir']}\")\nelse:\n    print(f\"\\n\u274c Analysis failed\")\n</code></pre>"},{"location":"app-development/step-09-deployment/#step-96-optional-add-to-git","title":"Step 9.6: Optional: Add to Git","text":"<p>If contributing to HHW Brick:</p> <pre><code>cd HHW_brick\ngit add hhw_brick/applications/my_first_app/\ngit commit -m \"Add my_first_app application\"\ngit push origin feature/my-first-app\n</code></pre>"},{"location":"app-development/step-09-deployment/#step-97-share-your-application","title":"Step 9.7: Share Your Application","text":""},{"location":"app-development/step-09-deployment/#option-1-contribute-to-hhw-brick_1","title":"Option 1: Contribute to HHW Brick","text":"<ol> <li>Fork the repository</li> <li>Create a feature branch</li> <li>Add your application</li> <li>Submit a pull request</li> </ol>"},{"location":"app-development/step-09-deployment/#option-2-standalone-package_1","title":"Option 2: Standalone Package","text":"<p>Create your own package:</p> <pre><code># setup.py\nfrom setuptools import setup, find_packages\n\nsetup(\n    name=\"my-first-app\",\n    version=\"1.0.0\",\n    packages=find_packages(),\n    install_requires=[\n        \"hhw-brick&gt;=0.1.0\",\n        \"pandas&gt;=1.3.0\",\n        \"matplotlib&gt;=3.5.0\",\n        \"plotly&gt;=5.0.0\",\n    ],\n    entry_points={\n        \"hhw_brick.applications\": [\n            \"my_first_app = my_first_app:__all__\"\n        ]\n    }\n)\n</code></pre>"},{"location":"app-development/step-09-deployment/#step-98-maintenance","title":"Step 9.8: Maintenance","text":""},{"location":"app-development/step-09-deployment/#version-updates","title":"Version Updates","text":"<p>When updating your app:</p> <ol> <li>Update version in <code>__init__.py</code></li> <li>Update README.md with changelog</li> <li>Test thoroughly</li> <li>Update documentation if API changes</li> </ol>"},{"location":"app-development/step-09-deployment/#bug-fixes","title":"Bug Fixes","text":"<ol> <li>Create issue describing bug</li> <li>Write test that reproduces bug</li> <li>Fix the bug</li> <li>Verify test passes</li> <li>Update version (patch number)</li> </ol>"},{"location":"app-development/step-09-deployment/#deployment-checklist","title":"Deployment Checklist","text":"<p>Before releasing your application:</p> <ul> <li> All files present (<code>__init__.py</code>, <code>app.py</code>, <code>config.yaml</code>, <code>requirements.txt</code>, <code>README.md</code>)</li> <li> Metadata complete in <code>__init__.py</code></li> <li> README.md has usage examples</li> <li> All tests pass</li> <li> App works with AppsManager</li> <li> Default config is sensible</li> <li> Example scripts provided</li> <li> Error messages are clear</li> <li> Documentation is accurate</li> </ul>"},{"location":"app-development/step-09-deployment/#congratulations_1","title":"Congratulations! \ud83c\udf89","text":"<p>You've completed the Application Development Guide!</p>"},{"location":"app-development/step-09-deployment/#what-youve-built","title":"What You've Built","text":"<p>\u2705 Complete Analytics Application - Qualify buildings based on sensors - Load and process data - Calculate statistics - Detect anomalies - Generate visualizations (matplotlib + Plotly) - Save results</p> <p>\u2705 Professional Package - Proper structure - Comprehensive tests - Complete documentation - Framework integration</p> <p>\u2705 Reusable and Portable - Works on any qualified building - Configurable parameters - Easy to extend</p>"},{"location":"app-development/step-09-deployment/#next-steps_1","title":"Next Steps","text":""},{"location":"app-development/step-09-deployment/#enhance-your-application","title":"Enhance Your Application","text":"<ul> <li>Add more analysis metrics</li> <li>Implement advanced SPARQL queries</li> <li>Create custom visualizations</li> <li>Add machine learning features</li> </ul>"},{"location":"app-development/step-09-deployment/#learn-more","title":"Learn More","text":"<ul> <li>Study existing apps: <code>secondary_loop_temp_diff</code>, <code>primary_loop_temp_diff</code></li> <li>Explore Brick Schema: https://docs.brickschema.org/</li> <li>Learn advanced SPARQL: https://www.w3.org/TR/sparql11-query/</li> </ul>"},{"location":"app-development/step-09-deployment/#contribute","title":"Contribute","text":"<ul> <li>Share your application with the community</li> <li>Help improve documentation</li> <li>Report bugs and suggest features</li> </ul>"},{"location":"app-development/step-09-deployment/#resources_1","title":"Resources","text":"<ul> <li>HHW Brick GitHub: https://github.com/CenterForTheBuiltEnvironment/HHW_brick</li> <li>Brick Schema: https://brickschema.org/</li> <li>SPARQL Tutorial: https://www.w3.org/TR/sparql11-query/</li> <li>Plotly Python: https://plotly.com/python/</li> </ul> <p>Thank you for building with HHW Brick! \ud83d\ude80</p> <p>Have questions? Open an issue on GitHub or start a discussion.</p> <p>Happy coding! \ud83d\udc68\u200d\ud83d\udcbb\ud83d\udc69\u200d\ud83d\udcbb</p>"},{"location":"apps/","title":"Available Applications","text":"<p>HHW Brick includes portable analytics applications that work across different buildings using semantic queries.</p>"},{"location":"apps/#application-list","title":"Application List","text":"\ud83d\udd04 Secondary Loop Temperature Analysis <p>Status: Production Ready</p> <p>Complexity: \u2b50\u2b50 Medium</p> <p>Analyzes temperature differentials in secondary hot water loops to identify efficiency issues and operating patterns.</p> View Details \u2192 \ud83d\udd25 Primary Loop Temperature Analysis <p>Status: Production Ready</p> <p>Complexity: \u2b50\u2b50 Medium</p> <p>Analyzes temperature differentials in primary loops with boilers, including anomaly detection and performance metrics.</p> View Details \u2192"},{"location":"apps/#how-applications-work","title":"How Applications Work","text":"<p>Qualification: Each app checks if a building has required sensors using SPARQL queries.</p> <p>Analysis: Apps automatically discover sensors in Brick models and map them to time-series data.</p> <p>Outputs: Statistical reports, CSV files, and interactive visualizations (PNG + HTML).</p>"},{"location":"apps/#running-applications","title":"Running Applications","text":"<pre><code>from hhw_brick import apps\n\n# Load application\napp = apps.load_app(\"secondary_loop_temp_diff\")\n\n# Check qualification\nif app.qualify(\"building.ttl\"):\n    # Run analysis\n    results = app.analyze(\"building.ttl\", \"timeseries.csv\", config)\n</code></pre> <p>See User Guide - Running Apps for detailed instructions.</p>"},{"location":"apps/#creating-your-own-app","title":"Creating Your Own App","text":"<p>Want to build custom analytics? Follow our step-by-step tutorial:</p> <p>\ud83d\udc49 Application Development Guide</p>"},{"location":"apps/#application-status-legend","title":"Application Status Legend","text":"<ul> <li>\u2705 Production Ready: Tested on 100+ buildings</li> <li>\ud83e\uddea Beta: Under active development</li> <li>\ud83d\udccb Planned: Coming soon</li> </ul>"},{"location":"apps/primary-loop/","title":"Primary Loop Temperature Differential Analysis App","text":""},{"location":"apps/primary-loop/#overview","title":"Overview","text":"<p>This application analyzes the temperature differential between supply and return water in primary loops of hot water systems with boilers. It is specifically designed for boiler systems where: - Primary loop connects boilers to heat exchangers - Temperature differentials are typically larger than secondary loops - Analysis helps identify boiler efficiency and loop performance</p>"},{"location":"apps/primary-loop/#features","title":"Features","text":"<p>\u2705 Automatic Point Detection: Checks if Brick model contains required supply and return temperature sensors on primary loop \u2705 Boiler System Validation: Ensures the loop has boilers (characteristic of primary loops) \u2705 Flexible Configuration: Supports custom time ranges, thresholds, and output formats \u2705 Multiple Sensor Type Support: Automatically recognizes equivalent sensor types \u2705 Rich Statistical Analysis: Computes mean, standard deviation, quantiles, etc. \u2705 Visualization Plots: Auto-generates timeseries, distribution, and hourly statistics plots \u2705 Anomaly Detection: Identifies temperature differentials outside normal range  </p>"},{"location":"apps/primary-loop/#key-differences-from-secondary-loop-app","title":"Key Differences from Secondary Loop App","text":"Feature Primary Loop Secondary Loop Loop Type Primary loop with boilers Secondary loop Typical \u0394T 2-20\u00b0C (larger) 0.5-10\u00b0C (smaller) Equipment Must have boilers No boilers Use Case Boiler efficiency analysis Distribution system analysis"},{"location":"apps/primary-loop/#installation","title":"Installation","text":"<pre><code>pip install -r requirements.txt\n</code></pre> <p>Main dependencies: - pandas - numpy - matplotlib - seaborn - rdflib - brickschema - pyyaml</p>"},{"location":"apps/primary-loop/#quick-start","title":"Quick Start","text":""},{"location":"apps/primary-loop/#1-check-if-building-qualifies","title":"1. Check if Building Qualifies","text":"<p>The building must have: - A primary loop with boilers - Supply temperature sensor on primary loop - Return temperature sensor on primary loop</p> <pre><code>from hhw_brick.applications.primary_loop_temp_diff.app import qualify\n\nqualified, result = qualify('path/to/brick_model.ttl')\nif qualified:\n    print(f\"\u2713 Building qualified for primary loop analysis\")\n    print(f\"  Loop: {result['loop']}\")\n    print(f\"  Supply: {result['supply']}\")\n    print(f\"  Return: {result['return']}\")\n</code></pre>"},{"location":"apps/primary-loop/#2-run-basic-analysis","title":"2. Run Basic Analysis","text":"<pre><code>python app.py brick_model.ttl timeseries_data.csv\n</code></pre>"},{"location":"apps/primary-loop/#3-use-custom-configuration","title":"3. Use Custom Configuration","text":"<pre><code>python app.py brick_model.ttl timeseries_data.csv --config config.yaml\n</code></pre>"},{"location":"apps/primary-loop/#python-api-usage","title":"Python API Usage","text":""},{"location":"apps/primary-loop/#simple-usage","title":"Simple Usage","text":"<pre><code>from hhw_brick.applications.primary_loop_temp_diff.app import analyze, load_config\n\n# Load configuration\nconfig = load_config('config.yaml')\n\n# Run analysis\nresults = analyze(\n    brick_model_path='path/to/brick_model.ttl',\n    timeseries_data_path='path/to/timeseries_data.csv',\n    config=config\n)\n\nif results:\n    print(f\"\u2713 Analysis completed!\")\n    print(f\"  Mean temp differential: {results['stats']['mean_temp_diff']:.2f}\u00b0C\")\n    print(f\"  Anomaly rate: {results['stats']['anomaly_rate']:.2f}%\")\n</code></pre>"},{"location":"apps/primary-loop/#custom-configuration-in-code","title":"Custom Configuration in Code","text":"<pre><code>from hhw_brick.applications.primary_loop_temp_diff.app import analyze\n\nconfig = {\n    'time_range': {\n        'start_time': '2018-01-01',\n        'end_time': '2018-12-31',\n    },\n    'analysis': {\n        'threshold_min_delta': 2.0,   # Minimum temp diff threshold (\u00b0C)\n        'threshold_max_delta': 20.0,  # Maximum temp diff threshold (\u00b0C)\n    },\n    'output': {\n        'save_results': True,\n        'output_dir': './results',\n        'export_format': 'csv',  # 'csv' or 'json'\n        'generate_plots': True,\n        'plot_format': 'png',    # 'png', 'pdf', 'svg'\n    }\n}\n\nresults = analyze('model.ttl', 'data.csv', config)\n</code></pre>"},{"location":"apps/primary-loop/#configuration-options","title":"Configuration Options","text":""},{"location":"apps/primary-loop/#analysis-parameters","title":"Analysis Parameters","text":"<ul> <li><code>threshold_min_delta</code>: Minimum temperature differential (default: 2.0\u00b0C)</li> <li>Below this value is considered anomalous</li> <li> <p>Primary loops typically need higher thresholds than secondary loops</p> </li> <li> <p><code>threshold_max_delta</code>: Maximum temperature differential (default: 20.0\u00b0C)</p> </li> <li>Above this value is considered anomalous</li> </ul>"},{"location":"apps/primary-loop/#output-settings","title":"Output Settings","text":"<ul> <li><code>save_results</code>: Whether to save analysis results (default: true)</li> <li><code>output_dir</code>: Directory for output files (default: './results')</li> <li><code>export_format</code>: 'csv' or 'json' (default: 'csv')</li> <li><code>generate_plots</code>: Whether to generate visualizations (default: true)</li> <li><code>plot_format</code>: 'png', 'pdf', or 'svg' (default: 'png')</li> </ul>"},{"location":"apps/primary-loop/#time-range","title":"Time Range","text":"<ul> <li><code>start_time</code>: Start date in 'YYYY-MM-DD' format (null = use all data)</li> <li><code>end_time</code>: End date in 'YYYY-MM-DD' format (null = use all data)</li> </ul>"},{"location":"apps/primary-loop/#output-files","title":"Output Files","text":""},{"location":"apps/primary-loop/#statistics-file","title":"Statistics File","text":"<p><code>primary_loop_temp_diff_stats.csv</code> or <code>.json</code></p> <p>Contains: - Mean, median, std deviation of temperature differential - Min/max values - Quartiles (Q25, Q75) - Mean supply and return temperatures - Anomaly counts and rates</p>"},{"location":"apps/primary-loop/#timeseries-file","title":"Timeseries File","text":"<p><code>primary_loop_temp_diff_timeseries.csv</code> or <code>.json</code></p> <p>Contains: - Timestamp - Supply temperature - Return temperature - Temperature differential - Hour, weekday, month (for analysis)</p>"},{"location":"apps/primary-loop/#visualization-plots","title":"Visualization Plots","text":"<ol> <li>primary_loop_timeseries.png</li> <li>Supply and return temperatures over time</li> <li> <p>Temperature differential over time with mean/median lines</p> </li> <li> <p>primary_loop_distribution.png</p> </li> <li>Histogram of temperature differentials</li> <li>Box plot</li> <li> <p>Cumulative distribution function</p> </li> <li> <p>primary_loop_time_analysis.png</p> </li> <li>Temperature differential by hour of day</li> <li>Temperature differential by day of week</li> <li>Temperature differential by month</li> <li> <p>Scatter plot: supply vs return temperature</p> </li> <li> <p>primary_loop_heatmap.png</p> </li> <li>Heatmap of temperature differential by hour and day of week</li> </ol>"},{"location":"apps/primary-loop/#supported-sensor-types","title":"Supported Sensor Types","text":""},{"location":"apps/primary-loop/#supply-temperature-sensors","title":"Supply Temperature Sensors","text":"<ul> <li><code>Supply_Water_Temperature_Sensor</code></li> <li><code>Leaving_Hot_Water_Temperature_Sensor</code></li> <li><code>Hot_Water_Supply_Temperature_Sensor</code></li> </ul>"},{"location":"apps/primary-loop/#return-temperature-sensors","title":"Return Temperature Sensors","text":"<ul> <li><code>Return_Water_Temperature_Sensor</code></li> <li><code>Entering_Hot_Water_Temperature_Sensor</code></li> <li><code>Hot_Water_Return_Temperature_Sensor</code></li> </ul>"},{"location":"apps/primary-loop/#example-workflow","title":"Example Workflow","text":"<pre><code>from hhw_brick.applications.primary_loop_temp_diff.app import qualify, analyze, load_config\n\n# Step 1: Check qualification\nbrick_model = 'building_105_non-condensing_h.ttl'\ntimeseries = 'building_105_timeseries.csv'\n\nqualified, qualify_result = qualify(brick_model)\n\nif not qualified:\n    print(\"\u2717 Building does not have required sensors on primary loop\")\n    exit(1)\n\n# Step 2: Load configuration\nconfig = load_config('config.yaml')\n\n# Optional: customize config\nconfig['time_range']['start_time'] = '2018-06-01'\nconfig['time_range']['end_time'] = '2018-08-31'\nconfig['output']['output_dir'] = './summer_analysis'\n\n# Step 3: Run analysis\nresults = analyze(brick_model, timeseries, config)\n\n# Step 4: Review results\nif results:\n    stats = results['stats']\n    print(f\"\\n=== Primary Loop Analysis Results ===\")\n    print(f\"Mean Temperature Differential: {stats['mean_temp_diff']:.2f}\u00b0C\")\n    print(f\"Standard Deviation: {stats['std_temp_diff']:.2f}\u00b0C\")\n    print(f\"Mean Supply Temperature: {stats['mean_supply_temp']:.2f}\u00b0C\")\n    print(f\"Mean Return Temperature: {stats['mean_return_temp']:.2f}\u00b0C\")\n    print(f\"Anomaly Rate: {stats['anomaly_rate']:.2f}%\")\n    print(f\"\\nResults saved to: {config['output']['output_dir']}\")\n</code></pre>"},{"location":"apps/primary-loop/#interpretation-guidelines","title":"Interpretation Guidelines","text":""},{"location":"apps/primary-loop/#normal-operation","title":"Normal Operation","text":"<ul> <li>\u0394T Range: 2-15\u00b0C is typical for primary loops</li> <li>Higher \u0394T: Indicates good heat transfer from boiler to secondary loop</li> <li>Stable \u0394T: Suggests consistent boiler operation</li> </ul>"},{"location":"apps/primary-loop/#potential-issues","title":"Potential Issues","text":"<ul> <li>\u0394T &lt; 2\u00b0C: Possible issues:</li> <li>Low load on the system</li> <li>Boiler not operating efficiently</li> <li> <p>Excessive flow rate</p> </li> <li> <p>\u0394T &gt; 20\u00b0C: Possible issues:</p> </li> <li>Very high load</li> <li>Flow rate too low</li> <li> <p>Sensor calibration issues</p> </li> <li> <p>High Variability: May indicate:</p> </li> <li>Cycling boiler operation</li> <li>Variable load patterns</li> <li>Control system issues</li> </ul>"},{"location":"apps/primary-loop/#troubleshooting","title":"Troubleshooting","text":""},{"location":"apps/primary-loop/#building-not-qualified","title":"Building Not Qualified","text":"<p>Error: \"Building NOT qualified - Missing: Supply and return temperature sensors on primary loop with boiler\"</p> <p>Solutions: 1. Verify the Brick model has a primary loop defined 2. Check that the primary loop has <code>brick:hasPart</code> relationships to temperature sensors 3. Ensure the primary loop contains boilers 4. Verify sensor types match the supported list</p>"},{"location":"apps/primary-loop/#no-data-points-found","title":"No Data Points Found","text":"<p>Error: \"Failed to map sensors to data columns\"</p> <p>Solutions: 1. Check that sensor URIs in Brick model match column names in timeseries data 2. Verify timeseries CSV file has correct format 3. Ensure data columns exist for the identified sensors</p>"},{"location":"apps/primary-loop/#all-data-filtered-out","title":"All Data Filtered Out","text":"<p>Issue: Analysis shows 0 valid data points</p> <p>Solutions: 1. Check time range in configuration 2. Verify data quality (remove NaN/null values) 3. Check data types in CSV file</p>"},{"location":"apps/primary-loop/#license","title":"License","text":"<p>Part of the HHW Brick package.</p>"},{"location":"apps/secondary-loop/","title":"Secondary Loop Temperature Differential Analysis App","text":""},{"location":"apps/secondary-loop/#overview","title":"Overview","text":"<p>This application analyzes the temperature differential between supply and return water in heating hot water secondary loops. It can: - Automatically detect required temperature sensors in Brick models - Load and analyze time-series data - Generate statistical summaries and visualizations - Identify anomalous temperature differential conditions</p>"},{"location":"apps/secondary-loop/#features","title":"Features","text":"<p>\u2705 Automatic Point Detection: Checks if Brick model contains required supply and return temperature sensors \u2705 Flexible Configuration: Supports custom time ranges, thresholds, and output formats \u2705 Multiple Sensor Type Support: Automatically recognizes equivalent sensor types \u2705 Rich Statistical Analysis: Calculates mean, standard deviation, percentiles, etc. \u2705 Visualization Charts: Auto-generates time series plots, distribution plots, and hourly statistics \u2705 Anomaly Detection: Identifies temperature differentials outside normal ranges  </p>"},{"location":"apps/secondary-loop/#installation","title":"Installation","text":"<pre><code>pip install hhw-brick\n</code></pre> <p>Main dependencies: - pandas - numpy - matplotlib - seaborn - rdflib - brickschema - pyyaml</p>"},{"location":"apps/secondary-loop/#quick-start","title":"Quick Start","text":""},{"location":"apps/secondary-loop/#1-check-if-building-qualifies","title":"1. Check if Building Qualifies","text":"<pre><code>from hhw_brick import apps\n\n# Load the app\napp = apps.load_app(\"secondary_loop_temp_diff\")\n\n# Check if building has required sensors\nqualified, result = app.qualify(\"path/to/brick_model.ttl\")\n\nif qualified:\n    print(\"\u2705 Building can run this analysis\")\nelse:\n    print(\"\u274c Building missing required sensors\")\n</code></pre>"},{"location":"apps/secondary-loop/#2-run-basic-analysis","title":"2. Run Basic Analysis","text":"<pre><code>from hhw_brick import apps\n\n# Load app\napp = apps.load_app(\"secondary_loop_temp_diff\")\n\n# Run analysis\nresults = app.analyze(\n    brick_model_path=\"path/to/brick_model.ttl\",\n    timeseries_data_path=\"path/to/timeseries_data.csv\"\n)\n\n# Check results\nif results['status'] == 'success':\n    print(\"Analysis completed successfully!\")\n    print(f\"Summary: {results['summary']}\")\n</code></pre>"},{"location":"apps/secondary-loop/#3-use-custom-configuration","title":"3. Use Custom Configuration","text":"<pre><code>from hhw_brick import apps\n\n# Create custom configuration\nconfig = {\n    'time_range': {\n        'start_time': '2018-01-01',\n        'end_time': '2018-12-31',\n    },\n    'analysis': {\n        'threshold_min_delta': 1.0,  # Minimum temp diff threshold (\u00b0C)\n        'threshold_max_delta': 10.0,  # Maximum temp diff threshold (\u00b0C)\n    },\n    'output': {\n        'save_results': True,\n        'output_dir': './results',\n        'export_format': 'csv',  # 'csv' or 'json'\n        'generate_plots': True,\n        'plot_format': 'png',  # 'png', 'pdf', 'svg'\n    }\n}\n\n# Load app\napp = apps.load_app(\"secondary_loop_temp_diff\")\n\n# Run with custom config\nresults = app.analyze(\n    brick_model_path=\"path/to/brick_model.ttl\",\n    timeseries_data_path=\"path/to/timeseries_data.csv\",\n    config=config\n)\n</code></pre>"},{"location":"apps/secondary-loop/#input-requirements","title":"Input Requirements","text":""},{"location":"apps/secondary-loop/#brick-model-ttl","title":"Brick Model (.ttl)","text":"<p>Must contain one of the following sensor types:</p> <p>Supply Water Temperature Sensor (any one): - <code>Supply_Water_Temperature_Sensor</code> - <code>Leaving_Hot_Water_Temperature_Sensor</code> - <code>Hot_Water_Supply_Temperature_Sensor</code></p> <p>Return Water Temperature Sensor (any one): - <code>Return_Water_Temperature_Sensor</code> - <code>Entering_Hot_Water_Temperature_Sensor</code> - <code>Hot_Water_Return_Temperature_Sensor</code></p>"},{"location":"apps/secondary-loop/#time-series-data-csv","title":"Time-Series Data (.csv)","text":"<p>Must include the following columns: - <code>datetime_UTC</code>: Timestamp (ISO format) - Column names matching sensor references in Brick model</p> <p>Example: <pre><code>datetime_UTC,sup,ret,flow,hw\n2018-01-01T08:00:00Z,58.9,57.7,17.9,91854.7\n2018-01-01T09:00:00Z,59.2,57.9,17.9,100117.1\n</code></pre></p>"},{"location":"apps/secondary-loop/#output-results","title":"Output Results","text":""},{"location":"apps/secondary-loop/#statistical-file-csvjson","title":"Statistical File (CSV/JSON)","text":"<p>Contains the following metrics: - <code>count</code>: Number of valid data points - <code>mean_temp_diff</code>: Average temperature differential - <code>std_temp_diff</code>: Standard deviation of temperature differential - <code>min_temp_diff</code>, <code>max_temp_diff</code>: Range of temperature differential - <code>median_temp_diff</code>: Median temperature differential - <code>q25_temp_diff</code>, <code>q75_temp_diff</code>: 25<sup>th</sup> and 75<sup>th</sup> percentiles - <code>mean_supply_temp</code>: Average supply temperature - <code>mean_return_temp</code>: Average return temperature - <code>anomalies_below_threshold</code>: Count of anomalies below threshold - <code>anomalies_above_threshold</code>: Count of anomalies above threshold - <code>anomaly_rate</code>: Percentage of anomalies (%)</p>"},{"location":"apps/secondary-loop/#time-series-file-csvjson","title":"Time-Series File (CSV/JSON)","text":"<p>Contains all time points with: - Supply temperature (<code>sup</code>) - Return temperature (<code>ret</code>) - Temperature differential (<code>temp_diff</code>) - Time features (hour, day of week, month, etc.)</p>"},{"location":"apps/secondary-loop/#visualization-charts-pngpdfsvg","title":"Visualization Charts (PNG/PDF/SVG)","text":"<ol> <li>Time Series Plot: Shows supply temperature, return temperature, and differential over time</li> <li>Distribution Plot: Histogram and box plot of temperature differential</li> <li>Hourly Statistics: Bar chart of average differential by hour of day</li> </ol>"},{"location":"apps/secondary-loop/#configuration-file-example-configyaml","title":"Configuration File Example (config.yaml)","text":"<pre><code>time_range:\n  start_time: \"2018-01-01\"\n  end_time: \"2018-12-31\"\n\nanalysis:\n  resolution: \"1H\"\n  threshold_min_delta: 1.0\n  threshold_max_delta: 10.0\n\noutput:\n  save_results: true\n  output_dir: \"./results\"\n  export_format: \"csv\"\n  generate_plots: true\n  plot_format: \"png\"\n</code></pre>"},{"location":"apps/secondary-loop/#api-reference","title":"API Reference","text":""},{"location":"apps/secondary-loop/#qualifybrick_model_path-str-tuplebool-dict","title":"qualify(brick_model_path: str) -&gt; Tuple[bool, Dict]","text":"<p>Check if the building qualifies for this analysis.</p> <p>Parameters: - <code>brick_model_path</code>: Path to Brick model TTL file</p> <p>Returns: - Tuple of (qualified: bool, result: dict)</p>"},{"location":"apps/secondary-loop/#analyzebrick_model_path-str-timeseries_data_path-str-config-optionaldict-none-dict","title":"analyze(brick_model_path: str, timeseries_data_path: str, config: Optional[Dict] = None) -&gt; Dict","text":"<p>Run the temperature differential analysis.</p> <p>Parameters: - <code>brick_model_path</code>: Path to Brick model TTL file - <code>timeseries_data_path</code>: Path to time-series CSV file - <code>config</code>: Optional configuration dictionary</p> <p>Returns: - Dictionary with analysis results</p>"},{"location":"apps/secondary-loop/#load_configconfig_path-str-dict","title":"load_config(config_path: str) -&gt; Dict","text":"<p>Load configuration from YAML file.</p> <p>Parameters: - <code>config_path</code>: Path to configuration YAML file</p> <p>Returns: - Configuration dictionary</p>"},{"location":"apps/secondary-loop/#troubleshooting","title":"Troubleshooting","text":""},{"location":"apps/secondary-loop/#missing-sensors-error","title":"Missing Sensors Error","text":"<p>If you get \"Building missing required sensors\", verify that your Brick model contains the appropriate temperature sensor types. Use the <code>qualify()</code> function to see which sensors are missing.</p>"},{"location":"apps/secondary-loop/#data-column-not-found","title":"Data Column Not Found","text":"<p>Ensure that the column names in your time-series CSV match the <code>ref:hasExternalReference</code> values in your Brick model.</p>"},{"location":"apps/secondary-loop/#empty-results","title":"Empty Results","text":"<p>Check that your time range overlaps with available data, and that the data contains valid numeric values.</p>"},{"location":"apps/secondary-loop/#license","title":"License","text":"<p>MIT License - See LICENSE file for details.</p>"},{"location":"apps/secondary-loop/#author","title":"Author","text":"<p>Mingchen Li (liwei74123@gmail.com)</p>"},{"location":"examples/","title":"Examples","text":"<p>Ready-to-run code examples demonstrating HHW Brick's core features.</p>"},{"location":"examples/#philosophy","title":"Philosophy","text":"<p>These examples are designed to be:</p> <ul> <li>\u2705 Complete - Run as-is with included test data</li> <li>\u2705 Progressive - Build from simple to advanced</li> <li>\u2705 Practical - Real-world use cases</li> <li>\u2705 Educational - Learn by doing</li> </ul>"},{"location":"examples/#examples-overview","title":"Examples Overview","text":""},{"location":"examples/#conversion-examples-1","title":"\ud83d\udd04 Conversion (Examples 1)","text":"<p>01 - Convert CSV to Brick Convert building data from CSV to Brick Schema models. Includes single building and batch conversion.</p> <p>What you'll learn: Basic conversion workflow, batch processing</p>"},{"location":"examples/#validation-examples-2-4","title":"\u2705 Validation (Examples 2-4)","text":"<p>02 - Ontology Validation Validate Brick models against the Brick Schema ontology.</p> <p>What you'll learn: Model validation, SHACL compliance checking</p> <p>03 - Point Count Validation Verify that all sensors from CSV were converted correctly.</p> <p>What you'll learn: Data integrity checks, sensor counting</p> <p>04 - Equipment Count Validation Validate equipment (boilers, pumps, weather stations) in models.</p> <p>What you'll learn: Equipment verification, system completeness</p>"},{"location":"examples/#advanced-validation-example-5","title":"\ud83d\udd0d Advanced Validation (Example 5)","text":"<p>05 - Subgraph Pattern Matching Use SPARQL patterns to validate system topology and structure.</p> <p>What you'll learn: SPARQL queries, structural validation, pattern matching</p>"},{"location":"examples/#portable-analytics-examples-6-8","title":"\ud83d\udcca Portable Analytics (Examples 6-8)","text":"<p>06 - Application Management Discover, load, and inspect available analytics applications.</p> <p>What you'll learn: App discovery, configuration, requirements</p> <p>07 - Run Application Execute portable analytics on a single building.</p> <p>What you'll learn: Building qualification, running analysis, interpreting results</p> <p>08 - Batch Run Application Run analytics across multiple buildings in parallel.</p> <p>What you'll learn: Batch processing, parallel execution, aggregated results</p>"},{"location":"examples/#quick-start","title":"Quick Start","text":""},{"location":"examples/#prerequisites","title":"Prerequisites","text":"<p>Install HHW Brick in editable mode:</p> <pre><code>git clone https://github.com/CenterForTheBuiltEnvironment/HHW_brick.git\ncd HHW_brick\npip install -e .\n</code></pre>"},{"location":"examples/#run-examples","title":"Run Examples","text":"<p>All examples use test data from <code>tests/fixtures/</code>:</p> <pre><code># Run any example\npython examples/01_convert_csv_to_brick.py\npython examples/02_ontology_validation.py\n# ... etc\n</code></pre>"},{"location":"examples/#test-data-included","title":"Test Data Included","text":"<ul> <li>\u2705 <code>metadata.csv</code> - 10 buildings, 5 system types</li> <li>\u2705 <code>vars_available_by_building.csv</code> - Sensor availability</li> <li>\u2705 <code>TimeSeriesData/</code> - Sample timeseries for analytics</li> <li>\u2705 Pre-generated Brick models in <code>Brick_Model_File/</code></li> </ul>"},{"location":"examples/#example-workflow","title":"Example Workflow","text":"<pre><code>graph LR\n    A[01: Convert&lt;br/&gt;CSV to Brick] --&gt; B[02: Validate&lt;br/&gt;Ontology]\n    B --&gt; C[03-04: Validate&lt;br/&gt;Points &amp; Equipment]\n    C --&gt; D[05: Validate&lt;br/&gt;Structure]\n    D --&gt; E[06: Discover&lt;br/&gt;Apps]\n    E --&gt; F[07: Run&lt;br/&gt;Single Building]\n    F --&gt; G[08: Batch&lt;br/&gt;Run All]\n\n    style A fill:#e3f2fd\n    style B fill:#fff9c4\n    style C fill:#fff9c4\n    style D fill:#fff9c4\n    style E fill:#c8e6c9\n    style F fill:#c8e6c9\n    style G fill:#c8e6c9</code></pre>"},{"location":"examples/#learning-path","title":"Learning Path","text":""},{"location":"examples/#beginner-start-here","title":"Beginner (Start Here)","text":"<ol> <li>Example 01 - Learn basic conversion</li> <li>Example 02 - Validate your models</li> <li>Example 07 - Run your first analysis</li> </ol>"},{"location":"examples/#intermediate","title":"Intermediate","text":"<ol> <li>Example 03 - Verify data completeness</li> <li>Example 06 - Explore available apps</li> <li>Example 08 - Scale to multiple buildings</li> </ol>"},{"location":"examples/#advanced","title":"Advanced","text":"<ol> <li>Example 05 - Advanced SPARQL validation</li> <li>Example 04 - Deep equipment checks</li> </ol>"},{"location":"examples/#common-patterns","title":"Common Patterns","text":""},{"location":"examples/#convert-validate-analyze","title":"Convert \u2192 Validate \u2192 Analyze","text":"<p>Most workflows follow this pattern:</p> <pre><code>from hhw_brick import CSVToBrickConverter, BrickModelValidator, apps\n\n# 1. Convert\nconverter = CSVToBrickConverter()\nmodel = converter.convert_to_brick(\n    metadata_csv=\"metadata.csv\",\n    vars_csv=\"vars.csv\",\n    building_tag=\"105\",\n    output_path=\"building_105.ttl\"\n)\n\n# 2. Validate\nvalidator = BrickModelValidator()\nreport = validator.validate_ontology(\"building_105.ttl\")\nprint(f\"Valid: {report['valid']}\")\n\n# 3. Analyze\napp = apps.load_app(\"secondary_loop_temp_diff\")\nqualified, details = app.qualify(\"building_105.ttl\")\nif qualified:\n    results = app.analyze(\n        brick_model_path=\"building_105.ttl\",\n        timeseries_path=\"timeseries.csv\"\n    )\n</code></pre>"},{"location":"examples/#tips-for-using-examples","title":"Tips for Using Examples","text":"<ol> <li>Run in order - Examples build on each other</li> <li>Read the code - Each example has detailed comments</li> <li>Modify and experiment - Try different buildings or parameters</li> <li>Check output - Look at generated files to understand results</li> </ol>"},{"location":"examples/#next-steps","title":"Next Steps","text":"<ul> <li>\ud83d\udcd6 User Guide - Detailed documentation</li> <li>\ud83d\ude80 Quick Start - Step-by-step tutorial</li> <li>\ud83d\udcca CSV Format - Data preparation guide</li> </ul> <p>Ready? \u2192 Start with Example 01: Convert CSV to Brick</p>"},{"location":"examples/01-convert-csv-to-brick/","title":"Example 01: Convert CSV to Brick","text":"<p>Convert building data from CSV format to Brick Schema models.</p>"},{"location":"examples/01-convert-csv-to-brick/#what-youll-learn","title":"What You'll Learn","text":"<ul> <li>\u2705 Convert a single building to Brick</li> <li>\u2705 Batch convert multiple buildings</li> <li>\u2705 Specify input CSV files</li> <li>\u2705 Auto-detect system types</li> </ul>"},{"location":"examples/01-convert-csv-to-brick/#overview","title":"Overview","text":"<p>This example demonstrates the core conversion workflow:</p> <pre><code>graph LR\n    A[CSV Files] --&gt;|CSVToBrickConverter| B[Single Building]\n    A --&gt;|BatchConverter| C[Multiple Buildings]\n    B --&gt; D[Brick .ttl File]\n    C --&gt; E[Multiple .ttl Files]\n\n    style A fill:#e3f2fd\n    style B fill:#fff9c4\n    style C fill:#fff9c4\n    style D fill:#c8e6c9\n    style E fill:#c8e6c9</code></pre>"},{"location":"examples/01-convert-csv-to-brick/#prerequisites","title":"Prerequisites","text":"<p>Test data is included in <code>tests/fixtures/</code>:</p> <ul> <li><code>metadata.csv</code> - Building characteristics</li> <li><code>vars_available_by_building.csv</code> - Sensor availability</li> </ul>"},{"location":"examples/01-convert-csv-to-brick/#part-1-single-building-conversion","title":"Part 1: Single Building Conversion","text":"<p>Convert one building to a Brick model:</p> <pre><code>from pathlib import Path\nfrom hhw_brick import CSVToBrickConverter\n\n# Prepare paths\nfixtures = Path(\"tests/fixtures\")\nmetadata_csv = fixtures / \"metadata.csv\"\nvars_csv = fixtures / \"vars_available_by_building.csv\"\noutput_dir = fixtures / \"Brick_Model_File\"\noutput_dir.mkdir(exist_ok=True)\n\n# Convert building #29\nbuilding_id = \"29\"\nconverter = CSVToBrickConverter()\n\nresult = converter.convert_to_brick(\n    metadata_csv=str(metadata_csv),\n    vars_csv=str(vars_csv),\n    building_tag=building_id,\n    output_path=str(output_dir / f\"building_{building_id}.ttl\")\n)\n\nprint(f\"\u2713 Created {len(result)} RDF triples\")\n</code></pre> <p>Output: <pre><code>\u2713 Created 60 RDF triples\n\u2713 Output: building_29.ttl\n</code></pre></p>"},{"location":"examples/01-convert-csv-to-brick/#part-2-batch-conversion","title":"Part 2: Batch Conversion","text":"<p>Convert all buildings at once:</p> <pre><code>from hhw_brick import BatchConverter\n\n# Batch convert all buildings\nbatch_converter = BatchConverter()\n\nresults = batch_converter.convert_all_buildings(\n    metadata_csv=str(metadata_csv),\n    vars_csv=str(vars_csv),\n    output_dir=str(output_dir),\n    show_progress=True  # Show progress bar\n)\n\nprint(f\"Converted: {results['successful']} / {results['total']}\")\nprint(f\"Total triples: {results['total_triples']}\")\n</code></pre> <p>Output: <pre><code>Converting buildings: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 10/10\n\u2713 Converted: 10 / 10\n\u2713 Total triples: 842\n</code></pre></p>"},{"location":"examples/01-convert-csv-to-brick/#key-features","title":"Key Features","text":""},{"location":"examples/01-convert-csv-to-brick/#auto-detection","title":"Auto-Detection","text":"<p>System type is automatically detected from <code>metadata.csv</code>:</p> Building System Column Detected Type 29 District HW District Hot Water 53 Condensing Condensing Boiler 105 Non-condensing Non-Condensing Boiler"},{"location":"examples/01-convert-csv-to-brick/#output-files","title":"Output Files","text":"<p>Generated Brick models follow naming convention:</p> <pre><code>building_{tag}_{system_type}_{org}.ttl\n</code></pre> <p>Examples: - <code>building_29_district_hw_z.ttl</code> - <code>building_53_condensing_x.ttl</code> - <code>building_105_non_condensing_h.ttl</code></p>"},{"location":"examples/01-convert-csv-to-brick/#complete-example","title":"Complete Example","text":"<p>Run the full example:</p> <pre><code>python examples/01_convert_csv_to_brick.py\n</code></pre> <p>Expected Output:</p> <pre><code>Example 1: CSV to Brick Conversion\n============================================================\n\n============================================================\nPart 1: Convert Single Building\n============================================================\n\n\u2713 Converting building 29...\n\u2713 Success!\n  - Building ID: 29\n  - RDF Triples: 60 statements\n  - Output: building_29_district_hw_z.ttl\n\n============================================================\nPart 2: Batch Convert Multiple Buildings\n============================================================\n\n\u2713 Converting all District HW buildings...\nConverting buildings: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 10/10\n\n\u2713 Success!\n  - Buildings converted: 10 / 10\n  - Total RDF triples: 842 statements\n\n  Generated files:\n    - building_29_district_hw_z.ttl\n    - building_34_district_hw_z.ttl\n    - building_53_condensing_x.ttl\n    - building_55_condensing_bf.ttl\n    - building_56_district_steam_x.ttl\n    - building_58_district_steam_x.ttl\n    - building_105_non_condensing_h.ttl\n    - building_110_non_condensing_ad.ttl\n    - building_124_boiler_ar.ttl\n    - building_127_condensing_m.ttl\n\n============================================================\nSummary\n============================================================\n  - All Brick models are saved to: tests/fixtures/Brick_Model_File\n\n\u2713 Done! You can now use these Brick models for analysis.\n</code></pre>"},{"location":"examples/01-convert-csv-to-brick/#whats-generated","title":"What's Generated?","text":"<p>Each <code>.ttl</code> file contains:</p> <ul> <li>\ud83c\udfe2 Building entity (RealEstateCore)</li> <li>\u2699\ufe0f Equipment (Boilers, pumps, heat exchangers)</li> <li>\ud83c\udf21\ufe0f Sensors (Temperature, flow, pressure)</li> <li>\ud83d\udd17 Relationships (hasPoint, feeds, isPartOf)</li> </ul> <p>Example RDF triples:</p> <pre><code>:Building_29 a rec:Building .\n:Boiler_Primary a brick:Boiler ;\n    brick:hasPoint :HW_Supply_Temp, :HW_Return_Temp .\n:HW_Supply_Temp a brick:Hot_Water_Supply_Temperature_Sensor .\n</code></pre>"},{"location":"examples/01-convert-csv-to-brick/#next-steps","title":"Next Steps","text":"<ul> <li>Validate models \u2192 Example 02: Ontology Validation</li> <li>Verify sensors \u2192 Example 03: Point Count Validation</li> <li>Run analytics \u2192 Example 07: Run Application</li> </ul> <p>\ud83d\udcc2 Source Code: <code>examples/01_convert_csv_to_brick.py</code></p>"},{"location":"examples/02-ontology-validation/","title":"Example 02: Ontology Validation","text":"<p>Validate Brick models against the Brick Schema ontology.</p>"},{"location":"examples/02-ontology-validation/#what-youll-learn","title":"What You'll Learn","text":"<ul> <li>\u2705 Validate a single Brick model</li> <li>\u2705 Batch validate multiple models</li> <li>\u2705 Interpret validation results</li> <li>\u2705 Use parallel processing for speed</li> </ul>"},{"location":"examples/02-ontology-validation/#overview","title":"Overview","text":"<p>Validation ensures your Brick models conform to the official Brick Schema:</p> <pre><code>graph LR\n    A[Brick Model .ttl] --&gt;|Validator| B{SHACL Check}\n    B --&gt;|Pass| C[\u2713 Valid Model]\n    B --&gt;|Fail| D[\u2717 Violations Found]\n\n    style A fill:#e3f2fd\n    style B fill:#fff9c4\n    style C fill:#c8e6c9\n    style D fill:#ffcdd2</code></pre>"},{"location":"examples/02-ontology-validation/#part-1-single-model-validation","title":"Part 1: Single Model Validation","text":"<p>Validate one Brick model:</p> <pre><code>from pathlib import Path\nfrom hhw_brick import BrickModelValidator\n\n# Path to Brick model from Example 01\nmodel_file = Path(\"tests/fixtures/Brick_Model_File/building_29.ttl\")\n\n# Create validator\nvalidator = BrickModelValidator(use_local_brick=True)\n\n# Validate\nresult = validator.validate_ontology(str(model_file))\n\nif result['valid']:\n    print(f\"\u2713 Valid! Accuracy: {result['accuracy_percentage']}%\")\nelse:\n    print(f\"\u2717 Invalid! Error: {result.get('error', 'Unknown')}\")\n</code></pre> <p>Output: <pre><code>\u2713 Valid! Accuracy: 100.0%\n</code></pre></p>"},{"location":"examples/02-ontology-validation/#part-2-batch-validation-parallel","title":"Part 2: Batch Validation (Parallel)","text":"<p>Validate multiple models with parallel processing:</p> <pre><code># Batch validate all models in directory\nbatch_result = validator.batch_validate_ontology(\n    test_data_dir=\"tests/fixtures/Brick_Model_File\",\n    max_workers=15  # Parallel workers (optional)\n)\n\nprint(f\"Valid: {batch_result['passed_files']} / {batch_result['total_files']}\")\nprint(f\"Overall accuracy: {batch_result['overall_accuracy']:.1f}%\")\n</code></pre> <p>Output: <pre><code>Validating 10 models (parallel processing)...\n\u2713 Valid: 10 / 10\n\u2713 Overall accuracy: 100.0%\n</code></pre></p>"},{"location":"examples/02-ontology-validation/#validation-report-structure","title":"Validation Report Structure","text":"<pre><code>{\n    'ttl_file_path': 'building_29.ttl',\n    'valid': True,\n    'accuracy_percentage': 100.0,\n    'success': True,\n    'validation_report': 'All checks passed',\n    'error': None  # or error message if failed\n}\n</code></pre>"},{"location":"examples/02-ontology-validation/#run-complete-example","title":"Run Complete Example","text":"<pre><code>python examples/02_ontology_validation.py\n</code></pre> <p>Expected Output:</p> <pre><code>Example 2: Brick Model Validation\n============================================================\n\n============================================================\nPart 1: Validate Single Brick Model\n============================================================\n\n\u2713 Validating building_29_district_hw_z.ttl...\n\u2713 Valid! Model follows Brick schema rules.\n\n============================================================\nPart 2: Batch Validate Multiple Models\n============================================================\n\n\u2713 Validating 10 Brick models...\n  (Using parallel processing for faster validation)\n\n\u2713 Validation complete!\n\nResults:\n  - Total models: 10\n  - Valid: 10\n  - Invalid: 0\n  - Overall accuracy: 100.0%\n\n============================================================\nSummary\n============================================================\n\n  \u2713 Validated 10 Brick models using parallel processing\n  \u2713 All models checked against Brick schema\n  \u2713 Overall accuracy: 100.0%\n</code></pre>"},{"location":"examples/02-ontology-validation/#performance-tips","title":"Performance Tips","text":"<ul> <li>\u26a1 Parallel Processing: Automatically uses CPU count - 1 workers</li> <li>\u26a1 Adjust Workers: Set <code>max_workers</code> parameter (default: 15)</li> <li>\u26a1 Local Schema: Use <code>use_local_brick=True</code> for faster validation</li> </ul>"},{"location":"examples/02-ontology-validation/#next-steps","title":"Next Steps","text":"<ul> <li>Verify sensors \u2192 Example 03: Point Count Validation</li> <li>Check equipment \u2192 Example 04: Equipment Count Validation</li> <li>Structural validation \u2192 Example 05: Subgraph Pattern Matching</li> </ul> <p>\ud83d\udcc2 Source Code: <code>examples/02_ontology_validation.py</code></p>"},{"location":"examples/03-point-count-validation/","title":"Example 03: Point Count Validation","text":"<p>Verify that all sensors from CSV were converted correctly to Brick models.</p>"},{"location":"examples/03-point-count-validation/#what-youll-learn","title":"What You'll Learn","text":"<ul> <li>\u2705 Generate ground truth from CSV data</li> <li>\u2705 Validate point counts in Brick models</li> <li>\u2705 Batch validate multiple models</li> <li>\u2705 Ensure data completeness</li> </ul>"},{"location":"examples/03-point-count-validation/#overview","title":"Overview","text":"<p>Point count validation ensures no sensors were lost during conversion:</p> <pre><code>graph LR\n    A[CSV Data] --&gt;|Calculate| B[Ground Truth]\n    C[Brick Model] --&gt;|Count Points| D[Actual Count]\n    B --&gt;|Compare| E{Match?}\n    D --&gt;|Compare| E\n    E --&gt;|Yes| F[\u2713 Complete]\n    E --&gt;|No| G[\u2717 Missing Data]\n\n    style A fill:#e3f2fd\n    style C fill:#e3f2fd\n    style B fill:#fff9c4\n    style D fill:#fff9c4\n    style F fill:#c8e6c9\n    style G fill:#ffcdd2</code></pre>"},{"location":"examples/03-point-count-validation/#part-1-generate-ground-truth","title":"Part 1: Generate Ground Truth","text":"<p>Calculate expected counts from source CSV:</p> <pre><code>from pathlib import Path\nfrom hhw_brick.validation import GroundTruthCalculator\n\nfixtures = Path(\"tests/fixtures\")\n\n# Generate ground truth\ncalculator = GroundTruthCalculator()\nground_truth = calculator.calculate(\n    metadata_csv=str(fixtures / \"metadata.csv\"),\n    vars_csv=str(fixtures / \"vars_available_by_building.csv\"),\n    output_csv=str(fixtures / \"ground_truth.csv\")\n)\n\nprint(f\"Buildings: {len(ground_truth)}\")\n</code></pre> <p>Output: <pre><code>\u2713 Ground truth generated!\n  - Total buildings: 10\n  Sample (first 3):\n    Building 29: 4 points, 0 boilers, 1 pumps\n    Building 34: 4 points, 0 boilers, 1 pumps\n    Building 53: 8 points, 2 boilers, 1 pumps\n</code></pre></p>"},{"location":"examples/03-point-count-validation/#part-2-validate-single-building","title":"Part 2: Validate Single Building","text":"<p>Check one model against ground truth:</p> <pre><code>from hhw_brick import BrickModelValidator\n\nvalidator = BrickModelValidator(\n    ground_truth_csv_path=\"tests/fixtures/ground_truth.csv\"\n)\n\nresult = validator.validate_point_count(\n    \"tests/fixtures/Brick_Model_File/building_29_district_hw_z.ttl\"\n)\n\nif result['success']:\n    print(f\"\u2713 Match! Expected: {result['expected_point_count']}, \"\n          f\"Actual: {result['actual_point_count']}\")\n</code></pre> <p>Output: <pre><code>\u2713 Point counts match! Model is correct.\n  Expected: 4 points\n  Actual: 4 points\n  Accuracy: 100.0%\n</code></pre></p>"},{"location":"examples/03-point-count-validation/#part-3-batch-validation-parallel","title":"Part 3: Batch Validation (Parallel)","text":"<p>Validate all models with parallel processing:</p> <pre><code>batch_results = validator.batch_validate_point_count(\n    test_data_dir=\"tests/fixtures/Brick_Model_File\",\n    max_workers=4\n)\n\nprint(f\"Matched: {batch_results['matched_files']} / {batch_results['total_files']}\")\nprint(f\"Accuracy: {batch_results['overall_accuracy']:.1f}%\")\n</code></pre> <p>Output: <pre><code>\u2713 Batch validation complete!\n  Matched: 10 / 10\n  Overall accuracy: 100.0%\n</code></pre></p>"},{"location":"examples/03-point-count-validation/#run-complete-example","title":"Run Complete Example","text":"<pre><code>python examples/03_point_count_validation.py\n</code></pre> <p>Expected Output:</p> <pre><code>Example 3: Count and Validate Points\n============================================================\n\n============================================================\nPart 1: Generate Ground Truth\n============================================================\n\n\u2713 Calculating expected counts from CSV data...\n\u2713 Ground truth generated!\n  - Saved to: ground_truth.csv\n  - Total buildings: 10\n\n  Sample (first 3 buildings):\n    Building 29: 4 points, 0 boilers, 1 pumps\n    Building 34: 4 points, 0 boilers, 1 pumps\n    Building 53: 8 points, 2 boilers, 1 pumps\n\n============================================================\nPart 2: Validate Single Building\n============================================================\n\n\u2713 Validating building 29...\n\u2713 Validation complete!\n  \u2713 Point counts match! Model is correct.\n\n  Details:\n    Expected points: 4\n    Actual points: 4\n    Match: \u2713 Yes\n    Accuracy: 100.0%\n\n============================================================\nPart 3: Batch Validate Multiple Buildings\n============================================================\n\n\u2713 Running batch validation on all models...\n  (Using parallel processing for faster validation)\n\n\u2713 Batch validation complete!\n\nSummary:\n  - Total models: 10\n  - Matched (correct): 10\n  - Mismatched: 0\n  - Overall accuracy: 100.0%\n\n============================================================\nSummary\n============================================================\n\n  \u2713 Generated ground truth from CSV data\n  \u2713 Validated 10 Brick models using parallel processing\n  \u2713 Overall accuracy: 100.0%\n  \u2713 Ground truth saved: ground_truth.csv\n</code></pre>"},{"location":"examples/03-point-count-validation/#ground-truth-csv-format","title":"Ground Truth CSV Format","text":"<p>Generated file contains expected counts:</p> tag point_count boiler_count pump_count weather_station_count 29 4 0 1 1 53 8 2 1 1 105 5 3 1 1"},{"location":"examples/03-point-count-validation/#next-steps","title":"Next Steps","text":"<ul> <li>Check equipment \u2192 Example 04: Equipment Count Validation</li> <li>Structural validation \u2192 Example 05: Subgraph Pattern Matching</li> </ul> <p>\ud83d\udcc2 Source Code: <code>examples/03_point_count_validation.py</code></p>"},{"location":"examples/04-equipment-count-validation/","title":"Example 04: Equipment Count Validation","text":"<p>Validate equipment (boilers, pumps, weather stations) in Brick models.</p>"},{"location":"examples/04-equipment-count-validation/#what-youll-learn","title":"What You'll Learn","text":"<ul> <li>\u2705 Validate equipment counts</li> <li>\u2705 Check boilers, pumps, weather stations</li> <li>\u2705 Batch equipment validation</li> <li>\u2705 Verify system completeness</li> </ul>"},{"location":"examples/04-equipment-count-validation/#overview","title":"Overview","text":"<p>Equipment validation ensures all physical devices are modeled correctly:</p> <pre><code>graph TD\n    A[Ground Truth] --&gt; B[Expected Boilers]\n    A --&gt; C[Expected Pumps]\n    A --&gt; D[Expected Weather Stations]\n\n    E[Brick Model] --&gt; F[Actual Boilers]\n    E --&gt; G[Actual Pumps]\n    E --&gt; H[Actual Weather Stations]\n\n    B -.Compare.- F\n    C -.Compare.- G\n    D -.Compare.- H\n\n    style A fill:#fff9c4\n    style E fill:#e3f2fd\n    style F fill:#c8e6c9\n    style G fill:#c8e6c9\n    style H fill:#c8e6c9</code></pre>"},{"location":"examples/04-equipment-count-validation/#part-1-generate-ground-truth","title":"Part 1: Generate Ground Truth","text":"<pre><code>from hhw_brick.validation import GroundTruthCalculator\n\ncalculator = GroundTruthCalculator()\nground_truth = calculator.calculate(\n    metadata_csv=\"tests/fixtures/metadata.csv\",\n    vars_csv=\"tests/fixtures/vars_available_by_building.csv\",\n    output_csv=\"tests/fixtures/ground_truth.csv\"\n)\n</code></pre> <p>Output: <pre><code>Sample (first 3 buildings):\n  Building 29: 0 boilers, 1 pumps, 1 weather stations\n  Building 53: 2 boilers, 1 pumps, 1 weather stations\n  Building 105: 3 boilers, 1 pumps, 1 weather stations\n</code></pre></p>"},{"location":"examples/04-equipment-count-validation/#part-2-validate-single-building","title":"Part 2: Validate Single Building","text":"<pre><code>from hhw_brick import BrickModelValidator\n\nvalidator = BrickModelValidator(\n    ground_truth_csv_path=\"tests/fixtures/ground_truth.csv\"\n)\n\nresult = validator.validate_equipment_count(\n    \"tests/fixtures/Brick_Model_File/building_29_district_hw_z.ttl\"\n)\n\nif result['overall_success']:\n    print(\"\u2713 All equipment counts match!\")\n</code></pre> <p>Output: <pre><code>\u2713 All equipment counts match!\n\nEquipment Details:\n  \u2713 Boilers: 0 / 0 (actual/expected)\n  \u2713 Pumps: 1 / 1 (actual/expected)\n  \u2713 Weather Stations: 1 / 1 (actual/expected)\n</code></pre></p>"},{"location":"examples/04-equipment-count-validation/#part-3-batch-validation","title":"Part 3: Batch Validation","text":"<pre><code>batch_results = validator.batch_validate_equipment_count(\n    test_data_dir=\"tests/fixtures/Brick_Model_File\",\n    max_workers=4\n)\n\nprint(f\"Accuracy: {batch_results['overall_accuracy']:.1f}%\")\n</code></pre>"},{"location":"examples/04-equipment-count-validation/#run-complete-example","title":"Run Complete Example","text":"<pre><code>python examples/04_equipment_count_validation.py\n</code></pre>"},{"location":"examples/04-equipment-count-validation/#next-steps","title":"Next Steps","text":"<ul> <li>Structural validation \u2192 Example 05: Subgraph Pattern Matching</li> <li>Discover apps \u2192 Example 06: Application Management</li> </ul> <p>\ud83d\udcc2 Source Code: <code>examples/04_equipment_count_validation.py</code></p>"},{"location":"examples/05-subgraph-pattern-matching/","title":"Example 05: Subgraph Pattern Matching","text":"<p>Use SPARQL patterns to validate system topology and structure.</p>"},{"location":"examples/05-subgraph-pattern-matching/#what-youll-learn","title":"What You'll Learn","text":"<ul> <li>\u2705 Define SPARQL validation patterns</li> <li>\u2705 Check system structure</li> <li>\u2705 Validate relationships</li> <li>\u2705 Advanced structural validation</li> </ul>"},{"location":"examples/05-subgraph-pattern-matching/#overview","title":"Overview","text":"<p>Pattern matching validates system topology using SPARQL:</p> <pre><code>graph LR\n    A[Define Pattern] --&gt; B[SPARQL Query]\n    C[Brick Model] --&gt; B\n    B --&gt; D{Pattern Match?}\n    D --&gt;|Yes| E[\u2713 Valid Structure]\n    D --&gt;|No| F[\u2717 Structural Issue]\n\n    style A fill:#fff9c4\n    style C fill:#e3f2fd\n    style E fill:#c8e6c9\n    style F fill:#ffcdd2</code></pre>"},{"location":"examples/05-subgraph-pattern-matching/#example-pattern","title":"Example Pattern","text":"<p>Validate boiler has supply and return sensors:</p> <pre><code>from hhw_brick.validation import SubgraphPatternValidator\n\nvalidator = SubgraphPatternValidator()\n\n# Define pattern\npattern = \"\"\"\nSELECT ?boiler ?supply ?return WHERE {\n    ?boiler a brick:Boiler .\n    ?boiler brick:hasPoint ?supply .\n    ?boiler brick:hasPoint ?return .\n    ?supply a brick:Hot_Water_Supply_Temperature_Sensor .\n    ?return a brick:Hot_Water_Return_Temperature_Sensor .\n}\n\"\"\"\n\n# Validate\nresult = validator.validate_pattern(\n    ttl_file_path=\"building_105.ttl\",\n    pattern_query=pattern,\n    min_matches=1\n)\n\nif result['valid']:\n    print(f\"\u2713 Pattern matched! Found {result['match_count']} instances\")\n</code></pre>"},{"location":"examples/05-subgraph-pattern-matching/#run-example","title":"Run Example","text":"<pre><code>python examples/05_subgraph_pattern_matching.py\n</code></pre>"},{"location":"examples/05-subgraph-pattern-matching/#next-steps","title":"Next Steps","text":"<ul> <li>Discover apps \u2192 Example 06: Application Management</li> </ul> <p>\ud83d\udcc2 Source Code: <code>examples/05_subgraph_pattern_matching.py</code></p>"},{"location":"examples/06-application-management/","title":"Example 06: Application Management","text":"<p>Discover, load, and inspect available analytics applications.</p>"},{"location":"examples/06-application-management/#what-youll-learn","title":"What You'll Learn","text":"<ul> <li>\u2705 Discover available apps</li> <li>\u2705 Load applications</li> <li>\u2705 Inspect app requirements</li> <li>\u2705 View app configuration</li> </ul>"},{"location":"examples/06-application-management/#discover-apps","title":"Discover Apps","text":"<p>List all available analytics applications:</p> <pre><code>from hhw_brick import apps\n\n# List all apps\navailable = apps.list_apps()\n\nfor app_info in available:\n    print(f\"- {app_info['name']}: {app_info.get('description', '')}\")\n</code></pre> <p>Output: <pre><code>Available applications:\n  - primary_loop_temp_diff\n  - secondary_loop_temp_diff\n</code></pre></p>"},{"location":"examples/06-application-management/#load-and-inspect-app","title":"Load and Inspect App","text":"<pre><code># Load an application\napp = apps.load_app(\"secondary_loop_temp_diff\")\n\n# Get app info\ninfo = app.get_info()\nprint(f\"Name: {info['name']}\")\nprint(f\"Description: {info['description']}\")\nprint(f\"Required sensors: {info['required_brick_classes']}\")\n</code></pre> <p>Output: <pre><code>Name: secondary_loop_temp_diff\nDescription: Secondary loop temperature difference analysis\nRequired sensors:\n  - brick:Hot_Water_Supply_Temperature_Sensor\n  - brick:Hot_Water_Return_Temperature_Sensor\n</code></pre></p>"},{"location":"examples/06-application-management/#run-example","title":"Run Example","text":"<pre><code>python examples/06_application_management.py\n</code></pre>"},{"location":"examples/06-application-management/#next-steps","title":"Next Steps","text":"<ul> <li>Run analysis \u2192 Example 07: Run Application</li> </ul> <p>\ud83d\udcc2 Source Code: <code>examples/06_application_management.py</code></p>"},{"location":"examples/07-run-application/","title":"Example 07: Run Application","text":"<p>Execute portable analytics on a single building.</p>"},{"location":"examples/07-run-application/#what-youll-learn","title":"What You'll Learn","text":"<ul> <li>\u2705 Check building qualification</li> <li>\u2705 Run analytics application</li> <li>\u2705 Interpret results</li> <li>\u2705 Save analysis output</li> </ul>"},{"location":"examples/07-run-application/#workflow","title":"Workflow","text":"<pre><code>graph LR\n    A[Load App] --&gt; B[Check Qualification]\n    B --&gt;|Qualified| C[Run Analysis]\n    B --&gt;|Not Qualified| D[Skip]\n    C --&gt; E[Save Results]\n\n    style A fill:#e3f2fd\n    style B fill:#fff9c4\n    style C fill:#c8e6c9\n    style E fill:#c8e6c9\n    style D fill:#ffcdd2</code></pre>"},{"location":"examples/07-run-application/#complete-example","title":"Complete Example","text":"<pre><code>from hhw_brick import apps\n\n# Load application\napp = apps.load_app(\"secondary_loop_temp_diff\")\n\n# Check if building qualifies\nqualified, details = app.qualify(\"building_105.ttl\")\n\nif qualified:\n    print(\"\u2713 Building qualifies!\")\n\n    # Run analysis\n    results = app.analyze(\n        brick_model_path=\"building_105.ttl\",\n        timeseries_path=\"timeseries.csv\",\n        output_dir=\"results/\"\n    )\n\n    print(f\"\u2713 Analysis complete!\")\n    print(f\"  Results saved to: {results['output_path']}\")\nelse:\n    print(f\"\u2717 Building not qualified\")\n    print(f\"  Missing: {details.get('missing', [])}\")\n</code></pre> <p>Output: <pre><code>\u2713 Building qualifies!\n\nRunning analysis...\n  - Processing 1000 hours of data\n  - Calculating temperature differences\n  - Generating visualizations\n\n\u2713 Analysis complete!\n  Results saved to: results/secondary_loop_temp_diff_105.csv\n</code></pre></p>"},{"location":"examples/07-run-application/#run-example","title":"Run Example","text":"<pre><code>python examples/07_run_application.py\n</code></pre>"},{"location":"examples/07-run-application/#next-steps","title":"Next Steps","text":"<ul> <li>Batch processing \u2192 Example 08: Batch Run Application</li> </ul> <p>\ud83d\udcc2 Source Code: <code>examples/07_run_application.py</code></p>"},{"location":"examples/08-batch-run-application/","title":"Example 08: Batch Run Application","text":"<p>Run analytics across multiple buildings in parallel.</p>"},{"location":"examples/08-batch-run-application/#what-youll-learn","title":"What You'll Learn","text":"<ul> <li>\u2705 Batch process multiple buildings</li> <li>\u2705 Parallel execution</li> <li>\u2705 Aggregate results</li> <li>\u2705 Handle qualification failures</li> </ul>"},{"location":"examples/08-batch-run-application/#workflow","title":"Workflow","text":"<pre><code>graph TD\n    A[Load App] --&gt; B[Discover Buildings]\n    B --&gt; C{For Each Building}\n    C --&gt; D[Check Qualification]\n    D --&gt;|Qualified| E[Run Analysis]\n    D --&gt;|Not Qualified| F[Skip]\n    E --&gt; G[Collect Results]\n    F --&gt; G\n    G --&gt; H[Aggregate Results]\n\n    style A fill:#e3f2fd\n    style C fill:#fff9c4\n    style E fill:#c8e6c9\n    style H fill:#c8e6c9</code></pre>"},{"location":"examples/08-batch-run-application/#complete-example","title":"Complete Example","text":"<pre><code>from pathlib import Path\nfrom hhw_brick import apps\n\n# Load application\napp = apps.load_app(\"secondary_loop_temp_diff\")\n\n# Find all Brick models\nbrick_models = list(Path(\"tests/fixtures/Brick_Model_File\").glob(\"*.ttl\"))\n\nprint(f\"Found {len(brick_models)} buildings\")\n\n# Batch run with parallel processing\nresults = []\nqualified_count = 0\n\nfor model in brick_models:\n    # Check qualification\n    qualified, details = app.qualify(str(model))\n\n    if qualified:\n        qualified_count += 1\n        # Run analysis\n        result = app.analyze(\n            brick_model_path=str(model),\n            timeseries_path=f\"timeseries/{model.stem}.csv\",\n            output_dir=\"results/\"\n        )\n        results.append(result)\n\nprint(f\"\\n\u2713 Batch analysis complete!\")\nprint(f\"  Qualified: {qualified_count} / {len(brick_models)}\")\nprint(f\"  Analyzed: {len(results)} buildings\")\n</code></pre> <p>Output: <pre><code>Found 10 buildings\n\nProcessing buildings:\n  \u2713 building_29: Qualified, analyzed\n  \u2717 building_34: Not qualified (missing flow sensor)\n  \u2713 building_53: Qualified, analyzed\n  \u2713 building_55: Qualified, analyzed\n  ...\n\n\u2713 Batch analysis complete!\n  Qualified: 8 / 10\n  Analyzed: 8 buildings\n  Results saved to: results/\n</code></pre></p>"},{"location":"examples/08-batch-run-application/#aggregated-results","title":"Aggregated Results","text":"<p>Combine results from multiple buildings:</p> <pre><code>import pandas as pd\n\n# Load all result files\nall_results = []\nfor result_file in Path(\"results/\").glob(\"*.csv\"):\n    df = pd.read_csv(result_file)\n    df['building'] = result_file.stem\n    all_results.append(df)\n\n# Combine\ncombined = pd.concat(all_results, ignore_index=True)\ncombined.to_csv(\"results/combined_results.csv\", index=False)\n\nprint(f\"\u2713 Combined {len(all_results)} buildings\")\nprint(f\"  Total records: {len(combined)}\")\n</code></pre>"},{"location":"examples/08-batch-run-application/#run-example","title":"Run Example","text":"<pre><code>python examples/08_batch_run_application.py\n</code></pre>"},{"location":"examples/08-batch-run-application/#performance-tips","title":"Performance Tips","text":"<ul> <li>\u26a1 Use parallel processing for large datasets</li> <li>\u26a1 Pre-check qualification to avoid wasted computation</li> <li>\u26a1 Process timeseries data in chunks</li> </ul>"},{"location":"examples/08-batch-run-application/#next-steps","title":"Next Steps","text":"<ul> <li>Learn more \u2192 User Guide</li> <li>Custom apps \u2192 Application Development Guide</li> </ul> <p>\ud83d\udcc2 Source Code: <code>examples/08_batch_run_application.py</code></p>"},{"location":"getting-started/","title":"Getting Started","text":"<p>Welcome to HHW Brick! This comprehensive guide will take you from installation to running your first portable analytics application on heating hot water system data.</p>"},{"location":"getting-started/#what-youll-learn","title":"What You'll Learn","text":"<p>In this Getting Started section, you'll master:</p> <ol> <li>Installation - Set up the hhw_brick package on your system</li> <li>Understanding Brick Schema - Learn the semantic ontology powering interoperability</li> <li>CSV Data Format - Prepare your data files with proper structure</li> <li>Quick Start - Complete workflow: Convert \u2192 Validate \u2192 Analyze in 10 minutes</li> </ol> <p>By the end of this guide, you'll be able to:</p> <ul> <li>\u2705 Convert CSV building data to standardized Brick Schema models</li> <li>\u2705 Validate models for correctness and completeness</li> <li>\u2705 Run analytics applications without writing building-specific code</li> <li>\u2705 Process multiple buildings in parallel with batch operations</li> </ul>"},{"location":"getting-started/#what-is-hhw-brick","title":"What is HHW Brick?","text":"<p>HHW Brick (<code>hhw_brick</code>) is a Python toolkit for converting, validating, and analyzing heating hot water system data using the Brick Schema semantic standard.</p>"},{"location":"getting-started/#the-problem-data-chaos","title":"The Problem: Data Chaos","text":"<pre><code>graph TB\n    subgraph \"Building A\"\n        A1[HW_Supply_Temp]\n        A2[HW_Return_Temp]\n        A3[HW_Flow_Rate]\n    end\n\n    subgraph \"Building B\"\n        B1[SupplyTempHotWater]\n        B2[ReturnTemp_HW]\n        B3[FlowRateHW]\n    end\n\n    subgraph \"Building C\"\n        C1[HWST_01]\n        C2[HWRT_01]\n        C3[HWF_01]\n    end\n\n    style A1 fill:#ffcdd2\n    style A2 fill:#ffcdd2\n    style A3 fill:#ffcdd2\n    style B1 fill:#ffcdd2\n    style B2 fill:#ffcdd2\n    style B3 fill:#ffcdd2\n    style C1 fill:#ffcdd2\n    style C2 fill:#ffcdd2\n    style C3 fill:#ffcdd2</code></pre> <p>Different names for the same sensors \u2192 Impossible to write reusable analytics!</p>"},{"location":"getting-started/#our-solution-semantic-standardization","title":"Our Solution: Semantic Standardization","text":"<pre><code>graph TB\n    subgraph \"Building A\"\n        A1[HW_Supply_Temp]\n        A2[HW_Return_Temp]\n    end\n\n    subgraph \"Building B\"\n        B1[SupplyTempHotWater]\n        B2[ReturnTemp_HW]\n    end\n\n    subgraph \"Building C\"\n        C1[HWST_01]\n        C2[HWRT_01]\n    end\n\n    A1 --&gt;|Convert| S1[brick:Hot_Water_Supply_Temperature_Sensor]\n    B1 --&gt;|Convert| S1\n    C1 --&gt;|Convert| S1\n\n    A2 --&gt;|Convert| S2[brick:Hot_Water_Return_Temperature_Sensor]\n    B2 --&gt;|Convert| S2\n    C2 --&gt;|Convert| S2\n\n    S1 --&gt; App[Portable Analytics]\n    S2 --&gt; App\n\n    style S1 fill:#c8e6c9\n    style S2 fill:#c8e6c9\n    style App fill:#90caf9</code></pre> <p>Same semantic meaning \u2192 Write analytics once, run everywhere!</p>"},{"location":"getting-started/#core-capabilities","title":"Core Capabilities","text":"<p>HHW Brick (<code>hhw_brick</code>) is a Python package that provides three integrated capabilities:</p>"},{"location":"getting-started/#conversion","title":"\ud83d\udd04 Conversion","text":"<p>Transform heating hot water system equipment data from CSV format into standardized Brick Schema 1.4 RDF models.</p> <ul> <li>5 System Types Supported: Condensing boilers, non-condensing boilers, generic boilers, district hot water, district steam</li> <li>Automatic Detection: System type identification and sensor mapping</li> <li>Batch Processing: Convert hundreds of buildings in parallel</li> <li>Flexible Input: Works with varying CSV structures and sensor availability</li> <li>Test Data: We provide test data in <code>tests/fixtures/</code> to get you started</li> </ul>"},{"location":"getting-started/#validation","title":"\u2705 Validation","text":"<p>Ensure your Brick models are correct through comprehensive multi-level validation.</p> <ul> <li>Ontology Validation: SHACL-based compliance with Brick Schema 1.4</li> <li>Point Count Validation: Verify all sensors were converted correctly</li> <li>Equipment Count Validation: Validate boilers, pumps, and weather stations</li> <li>Structural Validation: Pattern matching for system topology</li> <li>Ground Truth Comparison: Independent validation against source CSV data</li> </ul>"},{"location":"getting-started/#portable-analytics","title":"\ud83d\udcca Portable Analytics","text":"<p>Run analytics applications that work across any qualified building without recoding.</p> <ul> <li>Auto-Discovery: SPARQL queries find required sensors automatically</li> <li>Building-Agnostic: No hardcoded point names or building IDs</li> <li>Qualification Checks: Automatically verify buildings have required equipment</li> <li>Pre-Built Apps: Temperature difference analysis for primary/secondary loops</li> <li>Extensible Framework: Build your own portable applications</li> </ul>"},{"location":"getting-started/#prerequisites","title":"Prerequisites","text":"<p>Before you begin, ensure you have:</p> <ul> <li>Python 3.8 or higher installed on your system</li> <li>Basic Python knowledge - understanding of variables, functions, and imports</li> <li>Git installed for cloning the repository</li> <li>CSV data files with building equipment metadata and sensor availability</li> <li>We provide test data in <code>tests/fixtures/</code> to get you started</li> <li>Or download sample data from https://doi.org/10.5061/dryad.t4b8gtj8n</li> </ul> <p>Optional but Recommended:</p> <ul> <li>Virtual environment tool (venv or conda)</li> <li>Text editor or IDE (VS Code, PyCharm, etc.)</li> <li>Basic understanding of RDF/semantic web (helpful but not required)</li> </ul>"},{"location":"getting-started/#three-step-workflow","title":"Three-Step Workflow","text":"<p>HHW Brick follows a simple three-step workflow:</p> <pre><code>graph LR\n    A[CSV Files] --&gt;|1. Convert| B[Brick Model]\n    B --&gt;|2. Validate| C[Validated Model]\n    C --&gt;|3. Analyze| D[Insights]\n\n    style A fill:#e3f2fd\n    style B fill:#fff9c4\n    style C fill:#c8e6c9\n    style D fill:#f8bbd0</code></pre> <ol> <li>Convert - Transform CSV to Brick Schema</li> <li>Validate - Ensure model correctness</li> <li>Analyze - Deploy portable analytics</li> </ol>"},{"location":"getting-started/#package-architecture","title":"Package Architecture","text":"<pre><code>graph LR\n    subgraph Input\n        CSV[CSV Files]\n        TS[Timeseries Data]\n    end\n\n    subgraph \"HHW Brick Package\"\n        direction TB\n        CONV[\ud83d\udd04 Conversion Module]\n        VAL[\u2705 Validation Module]\n        APP[\ud83d\udcca Analytics Module]\n\n        CONV --&gt;|TTL Models| VAL\n        VAL --&gt;|Validated Models| APP\n    end\n\n    subgraph Output\n        TTL[Brick Models&lt;br/&gt;.ttl files]\n        REP[Validation Reports]\n        RES[Analysis Results]\n    end\n\n    CSV --&gt; CONV\n    CONV --&gt; TTL\n    VAL --&gt; REP\n    TS --&gt; APP\n    APP --&gt; RES\n\n    style CONV fill:#fff9c4\n    style VAL fill:#c8e6c9\n    style APP fill:#bbdefb\n    style TTL fill:#e1f5fe\n    style REP fill:#f0f4c3\n    style RES fill:#ffe0b2</code></pre>"},{"location":"getting-started/#package-components","title":"Package Components","text":"<p>The package consists of three main modules:</p>"},{"location":"getting-started/#1-conversion-module","title":"1. \ud83d\udd04 Conversion Module","text":"<p>Transform CSV data to Brick Schema models.</p> <p>Key Classes: <code>CSVToBrickConverter</code>, <code>BatchConverter</code></p> <p>Supported System Types:</p> <pre><code>graph LR\n    subgraph \"5 Supported System Types\"\n        C[\ud83d\udd25 Condensing&lt;br/&gt;Boiler]\n        NC[\ud83d\udd25 Non-Condensing&lt;br/&gt;Boiler]\n        G[\ud83d\udd25 Generic&lt;br/&gt;Boiler]\n        DH[\ud83c\udfe2 District&lt;br/&gt;Hot Water]\n        DS[\ud83d\udca8 District&lt;br/&gt;Steam]\n    end\n\n    style C fill:#ffccbc\n    style NC fill:#ffccbc\n    style G fill:#ffccbc\n    style DH fill:#b3e5fc\n    style DS fill:#b2dfdb</code></pre> <p>Capabilities:</p> <ul> <li>\u26a1 Single building conversion</li> <li>\ud83d\ude80 Batch conversion with parallel processing</li> <li>\ud83e\udd16 Automatic system type detection</li> <li>\ud83d\udccb Flexible CSV input handling</li> </ul> <p>\ud83d\udc49 Learn more in Quick Start</p>"},{"location":"getting-started/#2-validation-module","title":"2. \u2705 Validation Module","text":"<p>Ensure your Brick models are correct and complete.</p> <p>Key Classes: <code>BrickModelValidator</code>, <code>GroundTruthCalculator</code></p> <p>Multi-Level Validation Process:</p> <pre><code>graph TD\n    M[Brick Model] --&gt; V1[\ud83d\udccb Ontology Validation]\n    M --&gt; V2[\ud83d\udd22 Point Count Validation]\n    M --&gt; V3[\u2699\ufe0f Equipment Count Validation]\n    M --&gt; V4[\ud83d\udd0d Structural Validation]\n\n    V1 --&gt; R1{SHACL&lt;br/&gt;Conformance?}\n    V2 --&gt; R2{Counts&lt;br/&gt;Match?}\n    V3 --&gt; R3{Equipment&lt;br/&gt;Present?}\n    V4 --&gt; R4{Pattern&lt;br/&gt;Match?}\n\n    R1 --&gt;|\u2713| PASS[\u2705 Valid Model]\n    R2 --&gt;|\u2713| PASS\n    R3 --&gt;|\u2713| PASS\n    R4 --&gt;|\u2713| PASS\n\n    R1 --&gt;|\u2717| FAIL[\u26a0\ufe0f Issues Found]\n    R2 --&gt;|\u2717| FAIL\n    R3 --&gt;|\u2717| FAIL\n    R4 --&gt;|\u2717| FAIL\n\n    style M fill:#e3f2fd\n    style V1 fill:#fff9c4\n    style V2 fill:#fff9c4\n    style V3 fill:#fff9c4\n    style V4 fill:#fff9c4\n    style PASS fill:#c8e6c9\n    style FAIL fill:#ffcdd2</code></pre> <p>Validation Layers:</p> <ul> <li>\ud83d\udccb Ontology: SHACL-based Brick Schema 1.4 compliance</li> <li>\ud83d\udd22 Point Count: All sensors converted correctly</li> <li>\u2699\ufe0f Equipment Count: Boilers, pumps, weather stations validated</li> <li>\ud83d\udd0d Structural: System topology pattern matching</li> </ul> <p>\ud83d\udc49 Learn more in Validation Guide</p>"},{"location":"getting-started/#3-portable-analytics-module","title":"3. \ud83d\udcca Portable Analytics Module","text":"<p>Run analytics applications that work across any qualified building.</p> <p>Key Interface: <code>apps</code> manager</p> <p>Traditional vs. Portable Analytics:</p> <pre><code>graph TB\n    subgraph \"\u274c Traditional Approach\"\n        T1[Building A] --&gt;|Custom Code A| TA[Analytics A]\n        T2[Building B] --&gt;|Custom Code B| TB[Analytics B]\n        T3[Building C] --&gt;|Custom Code C| TC[Analytics C]\n    end\n\n    subgraph \"\u2705 Portable Approach\"\n        P1[Building A&lt;br/&gt;Brick Model] --&gt;|Same Code| PA[Portable&lt;br/&gt;Analytics]\n        P2[Building B&lt;br/&gt;Brick Model] --&gt;|Same Code| PA\n        P3[Building C&lt;br/&gt;Brick Model] --&gt;|Same Code| PA\n    end\n\n    style T1 fill:#ffcdd2\n    style T2 fill:#ffcdd2\n    style T3 fill:#ffcdd2\n    style TA fill:#ffcdd2\n    style TB fill:#ffcdd2\n    style TC fill:#ffcdd2\n\n    style P1 fill:#c8e6c9\n    style P2 fill:#c8e6c9\n    style P3 fill:#c8e6c9\n    style PA fill:#90caf9</code></pre> <p>How It Works:</p> <pre><code>graph LR\n    APP[Analytics App] --&gt;|1. SPARQL Query| BM[Brick Model]\n    BM --&gt;|2. Auto-Discover| SENS[Required&lt;br/&gt;Sensors]\n    SENS --&gt;|3. Qualify| CHECK{Has All&lt;br/&gt;Sensors?}\n    CHECK --&gt;|\u2713 Yes| RUN[4. Run Analysis]\n    CHECK --&gt;|\u2717 No| SKIP[Skip Building]\n\n    style APP fill:#90caf9\n    style BM fill:#fff9c4\n    style SENS fill:#ffe0b2\n    style RUN fill:#c8e6c9\n    style SKIP fill:#ffcdd2</code></pre> <p>Why Portable?</p> <ul> <li>\u2705 No hardcoded point names - SPARQL auto-discovers sensors</li> <li>\u2705 Building-agnostic - Same code on any qualified building</li> <li>\u2705 Auto-qualification - Checks requirements automatically</li> <li>\u2705 One-click deployment - No recoding needed</li> </ul> <p>Available Applications:</p> <ul> <li>\ud83c\udf21\ufe0f <code>secondary_loop_temp_diff</code> - Secondary loop \u0394T analysis</li> <li>\ud83d\udd25 <code>primary_loop_temp_diff</code> - Primary loop \u0394T analysis</li> </ul> <p>\ud83d\udc49 Learn more in Applications Guide</p>"},{"location":"getting-started/#next-steps","title":"Next Steps","text":"<p>Ready to get started? Follow this path:</p> <ol> <li>\ud83d\udce5 Install the Package - Set up hhw_brick on your system</li> <li>\ud83d\udcda Understanding Brick - Learn what Brick Schema is and why it matters</li> <li>\ud83d\udccb CSV Format Guide - Understand the required data structure</li> <li>\u26a1 Quick Start Guide - Complete workflow: Convert \u2192 Validate \u2192 Analyze</li> </ol>"},{"location":"getting-started/#need-help","title":"Need Help?","text":"<ul> <li>Check the FAQ for common questions</li> <li>See User Guide for detailed documentation</li> </ul> <p>Let's begin! Head over to Installation \u2192</p>"},{"location":"getting-started/csv-format/","title":"CSV Data Format","text":"<p>Prepare your CSV files for Brick model conversion and analytics.</p> <p>\ud83d\udcca Reference Dataset: Hydronic Heating Systems in 216 Commercial Buildings \ud83d\udcc4 Research Paper: Raftery et al. (2024), Energy and Buildings</p>"},{"location":"getting-started/csv-format/#required-files","title":"Required Files","text":""},{"location":"getting-started/csv-format/#for-conversion-brick-model-generation","title":"For Conversion (Brick Model Generation)","text":"<ol> <li><code>metadata.csv</code> - Building characteristics</li> <li><code>vars_available_by_building.csv</code> - Sensor availability (which sensors exist)</li> </ol>"},{"location":"getting-started/csv-format/#for-analytics-optional","title":"For Analytics (Optional)","text":"<ol> <li>Timeseries CSV files - Actual sensor measurements over time (e.g., <code>105hhw_system_data.csv</code>)</li> </ol>"},{"location":"getting-started/csv-format/#file-1-metadatacsv","title":"File 1: metadata.csv","text":""},{"location":"getting-started/csv-format/#minimum-required-columns","title":"Minimum Required Columns","text":"Column Description Example <code>tag</code> Unique building ID <code>105</code> <code>system</code> Heating system type <code>Non-condensing</code>"},{"location":"getting-started/csv-format/#system-types-must-use-one","title":"System Types (Must Use One)","text":"<ul> <li><code>Condensing</code> - Condensing gas boiler</li> <li><code>Non-condensing</code> - Non-condensing gas boiler  </li> <li><code>Boiler</code> - Boiler (type unknown)</li> <li><code>District HW</code> - District hot water system</li> <li><code>District Steam</code> - District steam system</li> </ul>"},{"location":"getting-started/csv-format/#optional-metadata-columns","title":"Optional Metadata Columns","text":"Column Description Type <code>org</code> Organization identifier string <code>area</code> Gross floor area (m\u00b2) float <code>year</code> Year of construction integer <code>bldg_type</code> Building type string <code>climate</code> ASHRAE climate zone string <code>t_hdd</code> Heating design day temp (\u00b0C) float <code>b_number</code> Number of boilers integer <code>b_manufacturer</code> Boiler manufacturer string <code>b_model</code> Boiler model string <code>b_input</code> Boiler input power (W) float <code>b_output</code> Boiler output power (W) float <code>b_efficiency</code> Boiler efficiency (fraction) float <code>b_min_turndown</code> Min turndown (fraction) float <code>b_min_flow</code> Min flow requirement (l/s) float <code>b_redundancy</code> Redundancy level (fraction) float <code>design_supply</code> Design supply temp (\u00b0C) float <code>design_return</code> Design return temp (\u00b0C) float"},{"location":"getting-started/csv-format/#minimum-example","title":"Minimum Example","text":"tag system 105 Non-condensing 127 Condensing"},{"location":"getting-started/csv-format/#complete-example","title":"Complete Example","text":"tag system org area bldg_type year b_number design_supply design_return 29 District HW Z 13000 EventSpace 1960 NA NA NA 53 Condensing X 7700 Museum 2020 2 71.1 54.4 105 Non-condensing H 46000 Office 1980 3 87.8 NA 127 Condensing M 26000 Other 2020 2 60 37.8"},{"location":"getting-started/csv-format/#file-2-vars_available_by_buildingcsv","title":"File 2: vars_available_by_building.csv","text":""},{"location":"getting-started/csv-format/#purpose","title":"Purpose","text":"<p>Indicates which sensor types are available for each building (not the actual data values).</p>"},{"location":"getting-started/csv-format/#required-column-order","title":"Required Column Order","text":"<p>\u26a0\ufe0f IMPORTANT: The converter skips the first 3 columns and treats all remaining columns as sensor availability flags.</p> <p>Standard format (matching test fixtures):</p> Column Position Column Name Required 1 <code>tag</code> \u2705 Yes 2 <code>org</code> Optional (ignored) 3 <code>datetime</code> Optional (ignored) 4+ Sensor columns Sensor availability <p>Minimum format (if you omit <code>org</code> and <code>datetime</code>):</p> <p>You can use any placeholder columns in positions 2-3, or structure your file to have <code>tag</code> first, then two dummy columns, then sensors.</p>"},{"location":"getting-started/csv-format/#sensor-availability-columns","title":"Sensor Availability Columns","text":"<p>Values: - <code>1</code> or <code>1.0</code> = Sensor exists for this building - <code>0</code>, blank, or missing = Sensor does not exist</p> <p>Temperature Sensors: - <code>sup</code>, <code>ret</code> - Primary supply/return temperature - <code>sup1</code>-<code>sup4</code>, <code>ret1</code>-<code>ret4</code> - Individual boiler temperatures - <code>supp</code>, <code>retp</code> - Primary circuit temperatures - <code>t_out</code> - Outdoor air temperature - <code>sup_stpt</code> - Supply temperature setpoint</p> <p>Flow &amp; Pressure: - <code>flow</code> - Building flow rate - <code>flowp</code> - Primary circuit flow - <code>dp</code> - Differential pressure - <code>dp_stpt</code> - Differential pressure setpoint</p> <p>Heating Power: - <code>hw</code> - Heating power/load</p> <p>Pump Data: - <code>pmp1_pwr</code>, <code>pmp2_pwr</code> - Pump power consumption - <code>pmp1_spd</code>, <code>pmp2_spd</code> - Pump speed - <code>pmp1_vfd</code>, <code>pmp2_vfd</code> - VFD output frequency - <code>pmp_spd</code> - Generic pump speed</p> <p>Boiler Data: - <code>fire1</code>-<code>fire4</code> - Individual boiler firing rates</p> <p>System State: - <code>enab</code> - System enable signal - <code>oper</code> - System operating state (estimated)</p> <p>Energy Consumption: - <code>gas</code> - Natural gas consumption (boiler plant) - <code>gas_u</code> - Natural gas consumption (utility meter)</p>"},{"location":"getting-started/csv-format/#minimum-example_1","title":"Minimum Example","text":"<p>\u26a0\ufe0f Must have at least 3 columns before sensor columns:</p> tag org datetime ret sup 105 A 1 1 1 127 B 1 1 1 <p>Or use placeholder columns:</p> tag placeholder1 placeholder2 ret sup 105 - - 1 1 127 - - 1 1"},{"location":"getting-started/csv-format/#complete-example_1","title":"Complete Example","text":"tag org datetime ret sup hw flow t_out pmp1_pwr enab oper 29 Z 1 1.0 1.0 1.0 1.0 1.0 0 0 1 53 X 1 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1 105 H 1 1.0 1.0 1.0 1.0 1.0 1.0 0 1 127 M 1 1.0 1.0 1.0 0 1.0 1.0 0 1"},{"location":"getting-started/csv-format/#file-3-timeseries-data-for-analytics","title":"File 3: Timeseries Data (For Analytics)","text":""},{"location":"getting-started/csv-format/#purpose_1","title":"Purpose","text":"<p>Actual sensor measurements over time for running analytics applications.</p>"},{"location":"getting-started/csv-format/#file-naming","title":"File Naming","text":"<p>Format: <code>{building_tag}hhw_system_data.csv</code></p> <p>Examples: - <code>105hhw_system_data.csv</code> - Data for building 105 - <code>127hhw_system_data.csv</code> - Data for building 127</p>"},{"location":"getting-started/csv-format/#required-columns","title":"Required Columns","text":"Column Description Type <code>dt</code> Local date date (YYYY-MM-DD) <code>datetime_UTC</code> UTC timestamp ISO8601 string"},{"location":"getting-started/csv-format/#optional-time-features","title":"Optional Time Features","text":"Column Description <code>yr</code> Year <code>season</code> Season (Winter, Spring, Summer, Fall) <code>mnth</code> Month (Jan, Feb, ...) <code>wd</code> Weekday (Mon, Tue, ...) <code>hr</code> Hour of day (0-23)"},{"location":"getting-started/csv-format/#sensor-data-columns","title":"Sensor Data Columns","text":"<p>Temperature (\u00b0C): - <code>sup</code> - Supply water temperature - <code>ret</code> - Return water temperature - <code>sup_stpt</code> - Supply temperature setpoint - <code>t_out</code> - Outdoor air temperature</p> <p>Flow (l/s): - <code>flow</code> - Water flow rate</p> <p>Power (W): - <code>hw</code> - Heating power/load</p> <p>System State: - <code>oper</code> - Operating state (0-1, fractional values allowed)</p>"},{"location":"getting-started/csv-format/#example","title":"Example","text":"dt datetime_UTC sup ret flow hw oper t_out 2020-02-05 2020-02-05T13:00:00Z 85.2 72.1 12.5 685000 1 7.5 2020-02-05 2020-02-05T14:00:00Z 84.8 71.9 12.3 678000 1 7.6 2020-02-05 2020-02-05T15:00:00Z 85.0 72.0 12.4 680000 1 8.2 <p>Note: - Typically hourly data - <code>NA</code> values indicate missing data - See Timeseries Data Guide for examples</p>"},{"location":"getting-started/csv-format/#quick-validation","title":"Quick Validation","text":"<pre><code>import pandas as pd\n\n# Check conversion files\nmeta = pd.read_csv(\"metadata.csv\")\nvars_df = pd.read_csv(\"vars_available_by_building.csv\")\n\nassert 'tag' in meta.columns, \"Missing 'tag' in metadata.csv\"\nassert 'system' in meta.columns, \"Missing 'system' in metadata.csv\"\nassert 'tag' in vars_df.columns, \"Missing 'tag' in vars_available_by_building.csv\"\n\nprint(f\"\u2713 Buildings: {len(meta)}\")\nprint(f\"\u2713 Tags match: {set(meta['tag']) == set(vars_df['tag'])}\")\nprint(f\"\u2713 Available sensors: {[c for c in vars_df.columns if c not in ['tag','org','datetime']][:5]}...\")\n\n# Check timeseries file (if exists)\ntry:\n    ts = pd.read_csv(\"105hhw_system_data.csv\")\n    print(f\"\u2713 Timeseries records: {len(ts)}\")\n    print(f\"\u2713 Timeseries columns: {list(ts.columns)}\")\nexcept FileNotFoundError:\n    print(\"\u2139 No timeseries file found (optional for conversion)\")\n</code></pre>"},{"location":"getting-started/csv-format/#common-issues","title":"Common Issues","text":""},{"location":"getting-started/csv-format/#missing-required-column-in-metadatacsv","title":"\u274c Missing required column in metadata.csv","text":"tag 105 <p>Fix: Add <code>system</code> column</p> tag system 105 Non-condensing"},{"location":"getting-started/csv-format/#invalid-system-type","title":"\u274c Invalid system type","text":"tag system 105 MyBoiler <p>Fix: Use valid system type</p> tag system 105 Non-condensing"},{"location":"getting-started/csv-format/#tag-mismatch-between-files","title":"\u274c Tag mismatch between files","text":"<pre><code>metadata.csv has: 105, 127\nvars.csv has: 105, 128\n</code></pre> <p>Fix: Ensure all tags match exactly</p>"},{"location":"getting-started/csv-format/#data-sources","title":"Data Sources","text":"<ul> <li>\ud83d\udcca Public Dataset: Dryad Repository - 216 buildings</li> <li>\ud83d\udcc4 Research Paper: Raftery et al. (2024)</li> <li>\ud83e\uddea Test Files: GitHub Fixtures</li> <li>\u23f1\ufe0f Timeseries Examples: TimeSeriesData/</li> </ul>"},{"location":"getting-started/csv-format/#next-steps","title":"Next Steps","text":"<ul> <li>\u26a1 Quick Start - Convert your first building</li> <li>\ud83d\udcda Understanding Brick - Learn concepts</li> </ul> <p>Ready? \u2192 Start converting</p>"},{"location":"getting-started/installation/","title":"Installation","text":"<p>Get hhw_brick installed and ready to use.</p>"},{"location":"getting-started/installation/#requirements","title":"Requirements","text":""},{"location":"getting-started/installation/#python-version","title":"Python Version","text":"<ul> <li>Python 3.8 or higher is required</li> <li>Python 3.10 is recommended for best performance</li> </ul> <p>Check your Python version:</p> <pre><code>python --version\n</code></pre>"},{"location":"getting-started/installation/#operating-systems","title":"Operating Systems","text":"<p>HHW Brick works on:</p> <ul> <li>\u2705 Windows 10/11</li> <li>\u2705 macOS 10.15+</li> <li>\u2705 Linux (Ubuntu 20.04+, Debian, CentOS, etc.)</li> </ul>"},{"location":"getting-started/installation/#installation-methods","title":"Installation Methods","text":""},{"location":"getting-started/installation/#method-1-install-from-source-recommended","title":"Method 1: Install from Source (Recommended)","text":"<p>Currently, the package is not yet published to PyPI. Install from source:</p> <pre><code># Clone the repository\ngit clone https://github.com/CenterForTheBuiltEnvironment/HHW_brick.git\ncd HHW_brick\n\n# Install in editable mode\npip install -e .\n</code></pre> <p>The <code>-e</code> flag installs in editable mode, so changes to the source code are immediately reflected.</p>"},{"location":"getting-started/installation/#method-2-install-from-pypi-coming-soon","title":"Method 2: Install from PyPI (Coming Soon)","text":"<p>Once published to PyPI, you'll be able to install with:</p> <pre><code>pip install hhw-brick\n</code></pre> <p>This installs the latest stable version.</p>"},{"location":"getting-started/installation/#verify-installation","title":"Verify Installation","text":"<p>Check that the package is installed correctly:</p> <pre><code>import hhw_brick\nprint(hhw_brick.__version__)\n</code></pre> <p>Expected output: <pre><code>0.1.0\n</code></pre></p> <p>Test the main components:</p> <pre><code>from hhw_brick import CSVToBrickConverter, BatchConverter, apps\n\nprint(\"\u2713 Conversion module loaded\")\nprint(f\"\u2713 Available apps: {len(apps.list_apps())} applications\")\n</code></pre>"},{"location":"getting-started/installation/#dependencies","title":"Dependencies","text":"<p>HHW Brick automatically installs these dependencies:</p>"},{"location":"getting-started/installation/#core-dependencies","title":"Core Dependencies","text":"Package Version Purpose rdflib \u22656.2.0, &lt;7.0.0 RDF graph processing pandas \u22651.3.0, &lt;3.0.0 Data manipulation pyyaml \u22655.4.0, &lt;7.0.0 Configuration files brickschema \u22650.6.0, &lt;0.7.0 Brick ontology support"},{"location":"getting-started/installation/#analytics-utilities","title":"Analytics &amp; Utilities","text":"Package Version Purpose tqdm \u22654.0.0 Progress bars jsonschema \u22654.0.0 JSON validation requests \u22652.28.0 HTTP requests matplotlib \u22653.5.0 Visualization seaborn \u22650.11.0 Statistical visualization <p>All dependencies are automatically installed when you run <code>pip install -e .</code></p>"},{"location":"getting-started/installation/#virtual-environment-recommended","title":"Virtual Environment (Recommended)","text":"<p>It's recommended to use a virtual environment to avoid dependency conflicts:</p>"},{"location":"getting-started/installation/#using-venv","title":"Using venv","text":"<pre><code># Create virtual environment\npython -m venv venv\n\n# Activate (Windows)\nvenv\\Scripts\\activate\n\n# Activate (Linux/Mac)\nsource venv/bin/activate\n\n# Clone and install package\ngit clone https://github.com/CenterForTheBuiltEnvironment/HHW_brick.git\ncd HHW_brick\npip install -e .\n</code></pre>"},{"location":"getting-started/installation/#using-conda","title":"Using conda","text":"<pre><code># Create environment\nconda create -n hhw_brick python=3.10\n\n# Activate\nconda activate hhw_brick\n\n# Clone and install package\ngit clone https://github.com/CenterForTheBuiltEnvironment/HHW_brick.git\ncd HHW_brick\npip install -e .\n</code></pre>"},{"location":"getting-started/installation/#troubleshooting","title":"Troubleshooting","text":""},{"location":"getting-started/installation/#issue-pip-command-not-found","title":"Issue: \"pip: command not found\"","text":"<p>Solution: Install pip or use <code>python -m pip</code> instead:</p> <pre><code>python -m pip install -e .\n</code></pre>"},{"location":"getting-started/installation/#issue-permission-denied","title":"Issue: \"Permission denied\"","text":"<p>Solution: Use a virtual environment (recommended) or add <code>--user</code> flag:</p> <pre><code>pip install --user -e .\n</code></pre>"},{"location":"getting-started/installation/#issue-git-not-installed","title":"Issue: Git not installed","text":"<p>Solution: Install Git first: - Windows: Download from git-scm.com - Mac: <code>brew install git</code> or install Xcode Command Line Tools - Linux: <code>sudo apt-get install git</code> (Ubuntu/Debian)</p>"},{"location":"getting-started/installation/#issue-dependency-conflicts","title":"Issue: Dependency conflicts","text":"<p>Solution: Install in a clean virtual environment:</p> <pre><code>python -m venv fresh_env\nfresh_env\\Scripts\\activate  # Windows\nsource fresh_env/bin/activate  # Linux/Mac\ncd HHW_brick\npip install -e .\n</code></pre>"},{"location":"getting-started/installation/#issue-import-errors-after-installation","title":"Issue: Import errors after installation","text":"<p>Solution: Verify the installation:</p> <pre><code>pip list | grep hhw-brick\n# Should show: hhw-brick  0.1.0  /path/to/HHW_brick\n</code></pre>"},{"location":"getting-started/installation/#development-installation","title":"Development Installation","text":"<p>For contributors and developers who want to modify the code:</p> <pre><code># Clone repository\ngit clone https://github.com/CenterForTheBuiltEnvironment/HHW_brick.git\ncd HHW_brick\n\n# Install development dependencies\npip install -r requirements-dev.txt\n\n# Install in editable mode\npip install -e .\n\n# Run tests to verify\npytest\n</code></pre> <p>Development dependencies include: - pytest - Testing framework - pytest-cov - Code coverage - black - Code formatter - flake8 - Linter - mkdocs - Documentation</p> <p>See Contributing Guide for more details on contributing to the project.</p>"},{"location":"getting-started/installation/#uninstallation","title":"Uninstallation","text":"<p>To remove the package:</p> <pre><code>pip uninstall hhw-brick\n</code></pre>"},{"location":"getting-started/installation/#next-steps","title":"Next Steps","text":"<p>Now that you have the package installed:</p> <ol> <li>Understanding Brick - Learn about Brick Schema ontology</li> <li>CSV Format - Prepare your data files</li> <li>Quick Start - Convert your first building (complete workflow)</li> </ol> <p>Installation complete! Continue to Understanding Brick \u2192</p>"},{"location":"getting-started/quick-start/","title":"Quick Start: Complete Workflow","text":"<p>This guide walks you through the complete HHW Brick workflow in 10 minutes:</p> <p>Convert CSV data \u2192 Validate Brick model \u2192 Analyze with portable analytics</p>"},{"location":"getting-started/quick-start/#what-youll-build","title":"What You'll Build","text":"<p>By the end of this guide, you'll have:</p> <ul> <li>\u2705 Converted a building from CSV to Brick Schema format</li> <li>\u2705 Validated the model for correctness and completeness</li> <li>\u2705 Run a portable analytics application on the building</li> <li>\u2705 Understood the complete workflow</li> </ul>"},{"location":"getting-started/quick-start/#step-1-install-the-package","title":"Step 1: Install the Package","text":"<p>If you haven't already, clone the repository and install in editable mode:</p> <pre><code># Clone the repository\ngit clone https://github.com/CenterForTheBuiltEnvironment/HHW_brick.git\ncd HHW_brick\n\n# Install in editable mode\npip install -e .\n</code></pre> <p>Note: Once published to PyPI, you'll be able to install with <code>pip install hhw-brick</code>.</p>"},{"location":"getting-started/quick-start/#step-2-prepare-your-data","title":"Step 2: Prepare Your Data","text":"<p>You need two types of CSV files for the complete workflow:</p>"},{"location":"getting-started/quick-start/#a-building-metadata-for-conversion","title":"A. Building Metadata (for conversion)","text":"<ol> <li>metadata.csv - Building information (system type, organization, etc.)</li> <li>vars_available_by_building.csv - Sensor/point availability for each building</li> </ol>"},{"location":"getting-started/quick-start/#b-timeseries-data-for-analytics","title":"B. Timeseries Data (for analytics)","text":"<ol> <li>[building]_timeseries.csv - Time-indexed sensor readings (used in Step 6)</li> </ol> <p>For this tutorial, we'll use the included test data for metadata (Steps 3-5).</p>"},{"location":"getting-started/quick-start/#download-test-data","title":"Download Test Data","text":"<p>The package includes test data in the repository:</p> <p>Download from GitHub \u2192</p> <p>You can find: - <code>metadata.csv</code> - Building metadata - <code>vars_available_by_building.csv</code> - Sensor availability data - <code>TimeSeriesData/*.csv</code> - Example timeseries data (for Step 6 analytics)</p> <p>Or if you've cloned the repository, they're located at:</p> <pre><code>tests/fixtures/metadata.csv\ntests/fixtures/vars_available_by_building.csv\ntests/fixtures/TimeSeriesData/building_105_timeseries.csv  (example)\n</code></pre> <p>Or create a simple example:</p> <pre><code>import pandas as pd\n\n# Create metadata.csv\nmetadata = pd.DataFrame({\n    'tag': [105],\n    'system': ['Non-condensing'],\n    'org': ['Organization A']\n})\nmetadata.to_csv('metadata.csv', index=False)\n\n# Create vars_available_by_building.csv\n# IMPORTANT: First 3 columns are skipped, sensors start from column 4\nvars_data = pd.DataFrame({\n    'tag': [105],\n    'org': ['A'],  # Column 2 (skipped)\n    'datetime': [1],  # Column 3 (skipped)\n    'sup': [1],  # Column 4+ are sensors\n    'ret': [1],\n    'hw': [1],\n    'flow': [1]\n})\nvars_data.to_csv('vars_available_by_building.csv', index=False)\n</code></pre>"},{"location":"getting-started/quick-start/#step-3-convert-your-first-building","title":"Step 3: Convert Your First Building","text":"<p>Create a Python script (<code>my_first_conversion.py</code>):</p> <pre><code>from hhw_brick import CSVToBrickConverter\n\n# Create the converter\nconverter = CSVToBrickConverter()\n\n# Convert building #105\nresult = converter.convert_to_brick(\n    metadata_csv=\"metadata.csv\",\n    vars_csv=\"vars_available_by_building.csv\",\n    building_tag=\"105\",  # Building ID to convert\n    output_path=\"building_105.ttl\"\n)\n\nprint(f\"\u2713 Conversion complete!\")\nprint(f\"\u2713 Created {len(result)} RDF triples\")\nprint(f\"\u2713 Output: building_105.ttl\")\n</code></pre> <p>Run it:</p> <pre><code>python my_first_conversion.py\n</code></pre> <p>Expected output:</p> <pre><code>\u2713 Conversion complete!\n\u2713 Created 156 RDF triples\n\u2713 Output: building_105.ttl\n</code></pre>"},{"location":"getting-started/quick-start/#step-4-inspect-the-output","title":"Step 4: Inspect the Output","text":"<p>Your <code>building_105.ttl</code> file now contains a Brick model. Let's peek inside:</p> <pre><code>from rdflib import Graph\n\n# Load the Brick model\ng = Graph()\ng.parse(\"building_105.ttl\", format=\"turtle\")\n\n# Count elements\nprint(f\"Total statements: {len(g)}\")\n\n# Query for equipment\nquery = \"\"\"\nSELECT ?equip ?type WHERE {\n    ?equip a ?type .\n    FILTER(STRSTARTS(STR(?type), \"https://brickschema.org/schema/Brick#\"))\n}\n\"\"\"\nfor row in g.query(query):\n    print(f\"  - {row.equip.split('#')[-1]}: {row.type.split('#')[-1]}\")\n</code></pre>"},{"location":"getting-started/quick-start/#step-5-validate-the-model","title":"Step 5: Validate the Model","text":"<p>Ensure your model is correct and complete:</p> <pre><code>from hhw_brick import BrickModelValidator\n\n# Create validator\nvalidator = BrickModelValidator()\n\n# Validate the model\nreport = validator.validate_ontology(\"building_105.ttl\")\n\nif report['valid']:\n    print(\"\u2713 Model passed ontology validation!\")\n    print(f\"  - Accuracy: {report['accuracy_percentage']}%\")\nelse:\n    print(\"\u26a0 Validation found issues:\")\n    print(f\"  - Error: {report.get('error', 'Unknown')}\")\n</code></pre> <p>Expected output:</p> <pre><code>\u2713 Model passed ontology validation!\n  - Accuracy: 100.0%\n</code></pre>"},{"location":"getting-started/quick-start/#step-6-run-portable-analytics","title":"Step 6: Run Portable Analytics","text":"<p>Now for the key advantage of Brick Schema - run analytics that work across any building!</p>"},{"location":"getting-started/quick-start/#discover-available-applications","title":"Discover Available Applications","text":"<pre><code>from hhw_brick import apps\n\n# List all available applications\navailable = apps.list_apps()\nprint(\"Available applications:\")\nfor app_info in available:\n    print(f\"  - {app_info['name']}: {app_info['description']}\")\n</code></pre> <p>Expected output:</p> <pre><code>Available applications:\n  - secondary_loop_temp_diff: Analyzes temperature difference in secondary loop\n  - primary_loop_temp_diff: Analyzes temperature difference in primary loop\n</code></pre>"},{"location":"getting-started/quick-start/#check-if-building-qualifies","title":"Check if Building Qualifies","text":"<pre><code># Load an application\napp = apps.load_app(\"secondary_loop_temp_diff\")\n\n# Check if building has required equipment\nqualified, details = app.qualify(\"building_105.ttl\")\n\nif qualified:\n    print(\"\u2713 Building qualifies for this analysis!\")\n    print(f\"  Required sensors: {details['required_sensors']}\")\n    print(f\"  Found sensors: {details['found_sensors']}\")\nelse:\n    print(\"\u2717 Building does not qualify\")\n    print(f\"  Missing: {details['missing']}\")\n</code></pre>"},{"location":"getting-started/quick-start/#prepare-timeseries-data","title":"Prepare Timeseries Data","text":"<p>To run analytics, you need timeseries data in CSV format with timestamps and sensor readings:</p> <p>Example timeseries CSV format:</p> <pre><code>dt,datetime_UTC,sup,ret,flow,hw,t_out\n2020-02-05,2020-02-05T13:00:00Z,85.2,72.1,12.5,685000,7.5\n2020-02-05,2020-02-05T14:00:00Z,84.8,71.9,12.3,678000,7.6\n2020-02-05,2020-02-05T15:00:00Z,85.0,72.0,12.4,680000,8.2\n...\n</code></pre> <p>Required columns:</p> <ul> <li><code>dt</code> - Local date (YYYY-MM-DD format)</li> <li><code>datetime_UTC</code> - UTC timestamp (ISO8601 format)</li> </ul> <p>Sensor columns (match your vars file sensor names):</p> <ul> <li><code>sup</code> - Supply water temperature (\u00b0C)</li> <li><code>ret</code> - Return water temperature (\u00b0C)</li> <li><code>flow</code> - Flow rate (l/s)</li> <li><code>hw</code> - Heating power (W)</li> <li><code>t_out</code> - Outdoor air temperature (\u00b0C)</li> <li><code>oper</code> - Operating state (0-1)</li> </ul> <p>Download example timeseries data:</p> <p>Example Timeseries Data \u2192</p> <p>Or create a simple example:</p> <pre><code>import pandas as pd\nimport numpy as np\n\n# Create sample timeseries data\ndates = pd.date_range('2020-01-01', periods=1000, freq='1H')\ndf = pd.DataFrame({\n    'dt': dates.date,  # Local date\n    'datetime_UTC': dates.strftime('%Y-%m-%dT%H:%M:%SZ'),  # UTC timestamp\n    'sup': np.random.normal(85, 5, 1000),  # Supply temp (\u00b0C)\n    'ret': np.random.normal(72, 5, 1000),  # Return temp (\u00b0C)\n    'flow': np.random.normal(12, 2, 1000),  # Flow rate (l/s)\n    'hw': np.random.normal(680000, 50000, 1000),  # Heating power (W)\n    't_out': np.random.normal(10, 5, 1000),  # Outdoor temp (\u00b0C)\n    'oper': np.random.choice([0, 1], 1000, p=[0.2, 0.8])  # Operating state\n})\ndf.to_csv('building_105_timeseries.csv', index=False)\n</code></pre>"},{"location":"getting-started/quick-start/#run-analysis","title":"Run Analysis","text":"<p>With timeseries data ready, run the complete analysis:</p> <pre><code># Get default configuration\nconfig = apps.get_default_config(\"secondary_loop_temp_diff\")\n\n# Customize configuration if needed\nconfig[\"analysis_period\"] = \"2023-01-01 to 2023-12-31\"\nconfig[\"output_directory\"] = \"results/\"\n\n# Run the analysis\nresults = app.analyze(\n    brick_model=\"building_105.ttl\",\n    timeseries_csv=\"building_105_timeseries.csv\",\n    config=config\n)\n\nprint(\"\u2713 Analysis complete!\")\nprint(f\"  - Temperature difference mean: {results['mean_temp_diff']:.2f}\u00b0F\")\nprint(f\"  - Anomalies detected: {results['anomaly_count']}\")\nprint(f\"  - Report saved to: {results['output_path']}\")\n</code></pre> <p>Expected output:</p> <pre><code>\u2713 Analysis complete!\n  - Temperature difference mean: 20.35\u00b0F\n  - Anomalies detected: 12\n  - Report saved to: results/building_105_analysis.html\n</code></pre> <p>Note: For detailed timeseries format requirements and advanced analysis options, see Applications Guide.</p>"},{"location":"getting-started/quick-start/#what-just-happened","title":"What Just Happened?","text":"<p>You completed the complete HHW Brick workflow:</p> <pre><code>graph LR\n    A[CSV Files] --&gt;|1. Convert| B[Brick Model]\n    B --&gt;|2. Validate| C[Validated Model]\n    C --&gt;|3. Qualify| D[Check Requirements]\n    D --&gt;|4. Analyze| E[Insights]\n\n    style A fill:#e1f5ff\n    style B fill:#fff9c4\n    style C fill:#c8e6c9\n    style D fill:#ffe0b2\n    style E fill:#f8bbd0</code></pre>"},{"location":"getting-started/quick-start/#step-by-step-breakdown","title":"Step-by-Step Breakdown","text":"<p>1. Conversion (CSV \u2192 Brick) - Read CSV files containing equipment metadata and sensor availability - Identified system type (e.g., \"Non-condensing boiler\") - Mapped CSV columns to Brick Schema classes and relationships - Generated RDF triples in Turtle format</p> <p>2. Validation (Quality Check) - Verified model conforms to Brick Schema 1.4 ontology - Checked point counts match source CSV data - Validated equipment relationships and structure</p> <p>3. Analytics (Portable Application) - Used SPARQL to auto-discover required sensors in the model - Checked if building has necessary equipment for analysis - Ready to run analytics without hardcoded point names</p> <p>Key Insight: You created a standardized, validated, analysis-ready building model!</p>"},{"location":"getting-started/quick-start/#why-this-matters","title":"Why This Matters","text":"<p>Traditional building analytics require manual recoding for each building:</p> <pre><code># \u274c Traditional approach - hardcoded point names\nsupply_temp = data[\"HW_Supply_Temp\"]  # Only works for this building!\nreturn_temp = data[\"HWReturnTemp\"]    # Different name in next building\n</code></pre> <p>With HHW Brick, analytics are portable:</p> <pre><code># \u2705 Brick approach - semantic queries\nquery = \"\"\"\nSELECT ?sensor WHERE {\n    ?sensor a brick:Hot_Water_Supply_Temperature_Sensor .\n}\n\"\"\"\n# Works on ANY building with Brick model!\n</code></pre> <p>Result: Write analytics once, deploy across hundreds of buildings.</p>"},{"location":"getting-started/quick-start/#next-steps","title":"Next Steps","text":"<p>Congratulations! You've completed the full workflow. Now dive deeper:</p>"},{"location":"getting-started/quick-start/#deepen-your-understanding","title":"\ud83d\udcda Deepen Your Understanding","text":"<ul> <li>Understanding Brick Schema - Learn the ontology concepts</li> <li>CSV Data Format - Master the input data structure</li> </ul>"},{"location":"getting-started/quick-start/#master-the-tools","title":"\ud83d\udd27 Master the Tools","text":"<ul> <li>Conversion Guide - Advanced conversion techniques</li> <li>Single building conversion with custom options</li> <li>Batch conversion for multiple buildings</li> <li> <p>Supported system types and configurations</p> </li> <li> <p>Validation Guide - Ensure model quality</p> </li> <li>Ontology conformance validation</li> <li>Point count validation</li> <li> <p>Equipment structure validation</p> </li> <li> <p>Applications Guide - Build portable analytics</p> </li> <li>Creating custom analytics apps</li> <li>Timeseries data format requirements</li> <li>Configuration and deployment</li> </ul>"},{"location":"getting-started/quick-start/#see-more-examples","title":"\ud83d\udca1 See More Examples","text":"<ul> <li>Example Scripts - Copy-paste ready code</li> <li><code>01_convert_csv_to_brick.py</code> - Basic conversion</li> <li><code>02_ontology_validation.py</code> - Validation examples</li> <li><code>06_application_management.py</code> - App discovery and loading</li> <li><code>07_run_application.py</code> - Running analytics</li> </ul>"},{"location":"getting-started/quick-start/#common-next-tasks","title":"Common Next Tasks","text":""},{"location":"getting-started/quick-start/#convert-multiple-buildings","title":"Convert Multiple Buildings","text":"<pre><code>from hhw_brick import BatchConverter\n\nbatch = BatchConverter()\nresults = batch.convert_all_buildings(\n    metadata_csv=\"metadata.csv\",\n    vars_csv=\"vars_available_by_building.csv\",\n    output_dir=\"brick_models/\",\n    show_progress=True\n)\n\nprint(f\"Converted {results['successful']} buildings\")\n</code></pre>"},{"location":"getting-started/quick-start/#filter-by-system-type","title":"Filter by System Type","text":"<pre><code># Convert only condensing systems\nresult = converter.convert_to_brick(\n    metadata_csv=\"metadata.csv\",\n    vars_csv=\"vars_available_by_building.csv\",\n    system_type=\"Condensing\",  # Filter\n    output_path=\"condensing_buildings.ttl\"\n)\n</code></pre>"},{"location":"getting-started/quick-start/#run-an-analytics-application","title":"Run an Analytics Application","text":"<pre><code>from hhw_brick import apps\n\n# Load temperature difference analysis app\napp = apps.load_app(\"secondary_loop_temp_diff\")\n\n# Check if building qualifies\nqualified, details = app.qualify(\"building_105.ttl\")\n\nif qualified:\n    # Run analysis (need timeseries data)\n    results = app.analyze(model, timeseries_data, config)\n</code></pre>"},{"location":"getting-started/quick-start/#troubleshooting","title":"Troubleshooting","text":""},{"location":"getting-started/quick-start/#error-filenotfounderror","title":"Error: \"FileNotFoundError\"","text":"<p>Make sure your CSV files exist:</p> <pre><code>import os\nprint(os.path.exists(\"metadata.csv\"))  # Should be True\n</code></pre>"},{"location":"getting-started/quick-start/#error-no-data-found-for-building-tag","title":"Error: \"No data found for building tag\"","text":"<p>Check that the building ID exists in your CSV:</p> <pre><code>import pandas as pd\ndf = pd.read_csv(\"metadata.csv\")\nprint(df['tag'].unique())  # List all building IDs\n</code></pre>"},{"location":"getting-started/quick-start/#warning-could-not-convert-value-to-float","title":"Warning: \"Could not convert value to float\"","text":"<p>Some sensor values might be missing (NA). This is normal and the converter handles it automatically.</p>"},{"location":"getting-started/quick-start/#complete-example-script","title":"Complete Example Script","text":"<p>Here's a complete end-to-end script you can copy and run:</p> <pre><code>\"\"\"\nHHW Brick - Complete Workflow Example\n\nThis script demonstrates the complete workflow:\n1. Convert CSV to Brick model\n2. Validate the model\n3. Check analytics qualification\n\"\"\"\n\nfrom hhw_brick import CSVToBrickConverter, BrickModelValidator, apps\nfrom pathlib import Path\n\ndef main():\n    print(\"=\" * 60)\n    print(\"HHW Brick - Complete Workflow\")\n    print(\"=\" * 60)\n\n    # Configuration\n    metadata_csv = \"metadata.csv\"\n    vars_csv = \"vars_available_by_building.csv\"\n    building_tag = \"105\"\n    output_file = f\"building_{building_tag}.ttl\"\n\n    # Step 1: Convert CSV to Brick\n    print(\"\\n[Step 1/3] Converting CSV to Brick Schema...\")\n    converter = CSVToBrickConverter()\n    graph = converter.convert_to_brick(\n        metadata_csv=metadata_csv,\n        vars_csv=vars_csv,\n        building_tag=building_tag,\n        output_path=output_file\n    )\n    print(f\"\u2713 Created {len(graph)} RDF triples\")\n    print(f\"\u2713 Saved to: {output_file}\")\n\n    # Step 2: Validate the model\n    print(\"\\n[Step 2/3] Validating Brick model...\")\n    validator = BrickModelValidator()\n    report = validator.validate_ontology(output_file)\n\n    is_valid = report.get('valid', False)\n    if is_valid:\n        print(\"\u2713 Model passed ontology validation!\")\n    else:\n        print(\"\u26a0 Validation issues found:\")\n        print(f\"  Error: {report.get('error', 'Unknown')}\")\n\n    # Step 3: Check analytics qualification\n    print(\"\\n[Step 3/3] Checking analytics qualification...\")\n\n    # Discover available apps\n    available_apps = apps.list_apps()\n    print(f\"Found {len(available_apps)} analytics applications\")\n\n    # Test qualification for each app\n    for app_info in available_apps:\n        app_name = app_info['name']\n        try:\n            app = apps.load_app(app_name)\n            qualified, details = app.qualify(output_file)\n\n            if qualified:\n                print(f\"  \u2713 {app_name}: QUALIFIED\")\n            else:\n                print(f\"  \u2717 {app_name}: Not qualified\")\n                if 'missing' in details:\n                    print(f\"    Missing: {', '.join(details['missing'][:3])}\")\n        except Exception as e:\n            print(f\"  ! {app_name}: Error - {e}\")\n\n    # Summary\n    print(\"\\n\" + \"=\" * 60)\n    print(\"Summary\")\n    print(\"=\" * 60)\n    print(f\"Input:  {metadata_csv}, {vars_csv}\")\n    print(f\"Output: {output_file} ({Path(output_file).stat().st_size / 1024:.1f} KB)\")\n    print(f\"Status: {'Valid' if is_valid else 'Has warnings'}\")\n    print(\"\\n\u2713 Complete workflow finished!\")\n    print(\"\\nNext: View the TTL file or run analytics with timeseries data\")\n\nif __name__ == \"__main__\":\n    main()\n</code></pre> <p>Run it:</p> <pre><code>python complete_workflow.py\n</code></pre> <p>Expected output:</p> <pre><code>============================================================\nHHW Brick - Complete Workflow\n============================================================\n\n[Step 1/3] Converting CSV to Brick Schema...\n\u2713 Created 156 RDF triples\n\u2713 Saved to: building_105.ttl\n\n[Step 2/3] Validating Brick model...\n\u2713 Model passed ontology validation!\n\n[Step 3/3] Checking analytics qualification...\nFound 2 analytics applications\n  \u2713 secondary_loop_temp_diff: QUALIFIED\n  \u2713 primary_loop_temp_diff: QUALIFIED\n\n============================================================\nSummary\n============================================================\nInput:  metadata.csv, vars_available_by_building.csv\nOutput: building_105.ttl (12.3 KB)\nStatus: Valid\n\n\u2713 Complete workflow finished!\n\nNext: View the TTL file or run analytics with timeseries data\n</code></pre> <p>\ud83c\udf89 Congratulations! You've completed the HHW Brick quick start and experienced the full workflow.</p> <p>What's Next?</p> <ul> <li>\ud83d\udcd6 Understanding Brick Schema - Learn the concepts</li> <li>\ud83d\udccb CSV Data Format - Master the input format  </li> <li>\ud83d\udd27 User Guide - Advanced features</li> <li>\ud83d\udcbb Example Scripts - More code samples</li> </ul>"},{"location":"getting-started/understanding-brick/","title":"Understanding Brick Schema","text":"<p>Learn what Brick Schema is and why it matters for portable analytics.</p>"},{"location":"getting-started/understanding-brick/#the-problem","title":"The Problem","text":"<p>Different buildings use different names for the same sensor:</p> Building A Building B Building C <code>HW_Supply_Temp</code> <code>SupplyTempHotWater</code> <code>HWST_01</code> <p>Result: Custom code for EACH building \ud83d\udd34</p>"},{"location":"getting-started/understanding-brick/#the-solution","title":"The Solution","text":"<p>Brick provides one standard name:</p> <pre><code>All buildings \u2192 brick:Hot_Water_Supply_Temperature_Sensor\n</code></pre> <p>Result: Code ONCE, works EVERYWHERE \u2705</p>"},{"location":"getting-started/understanding-brick/#real-example","title":"Real Example","text":"<p>From official Brick documentation:</p> <p></p> <p>What you see:</p> <ul> <li>\ud83c\udfe2 Buildings &amp; spaces</li> <li>\u2699\ufe0f Equipment (boilers, pumps)</li> <li>\ud83c\udf21\ufe0f Sensors (temperature, flow)</li> <li>\ud83d\udd17 Relationships (connections)</li> </ul> <p>HHW Brick creates this from your CSV automatically!</p>"},{"location":"getting-started/understanding-brick/#how-it-works","title":"How It Works","text":"<p>Your CSV:</p> <pre><code>tag,system,hw_supply_temp,hw_return_temp\n105,Non-condensing,1,1\n</code></pre> <p>Generated Brick:</p> <pre><code># Equipment\n:Boiler_01 a brick:Boiler .\n\n# Sensors\n:Supply_Temp a brick:Hot_Water_Supply_Temperature_Sensor .\n:Return_Temp a brick:Hot_Water_Return_Temperature_Sensor .\n\n# Relationships\n:Boiler_01 brick:hasPoint :Supply_Temp, :Return_Temp .\n</code></pre>"},{"location":"getting-started/understanding-brick/#why-this-matters","title":"Why This Matters","text":"<p>Traditional \u274c:</p> <pre><code># Building A\nsupply = data[\"HW_Supply_Temp\"]\n\n# Building B - different code!\nsupply = data[\"SupplyTempHotWater\"]\n</code></pre> <p>Brick \u2705:</p> <pre><code># Works on ALL buildings!\nquery = \"\"\"\nSELECT ?supply WHERE {\n    ?supply a brick:Hot_Water_Supply_Temperature_Sensor .\n}\n\"\"\"\n</code></pre>"},{"location":"getting-started/understanding-brick/#portable-analytics","title":"Portable Analytics","text":"<pre><code>def analyze_any_building(brick_model):\n    \"\"\"Same code for building 1, 2, 3... 100!\"\"\"\n\n    query = \"\"\"\n    SELECT ?supply ?return WHERE {\n        ?supply a brick:Hot_Water_Supply_Temperature_Sensor .\n        ?return a brick:Hot_Water_Return_Temperature_Sensor .\n    }\n    \"\"\"\n    # Auto-discovers sensors, calculates \u0394T\n</code></pre> <p>Time saved: 90% reduction \ud83d\ude80</p>"},{"location":"getting-started/understanding-brick/#what-hhw-brick-does","title":"What HHW Brick Does","text":"<ol> <li>\u2705 You provide CSV files</li> <li>\u2705 Converts to Brick Schema</li> <li>\u2705 Run analytics on ANY building</li> </ol>"},{"location":"getting-started/understanding-brick/#faq","title":"FAQ","text":"<p>Q: Do I need to know Brick/RDF/SPARQL? A: No! HHW Brick handles everything.</p> <p>Q: What if my system isn't supported? A: Use \"Generic Boiler\" or request it.</p>"},{"location":"getting-started/understanding-brick/#learn-more","title":"Learn More","text":"<ul> <li>\ud83c\udf10 Brick Website</li> <li>\ud83d\udd0d Browse Classes</li> <li>\ud83d\udccb CSV Format</li> <li>\u26a1 Quick Start</li> </ul> <p>Key Takeaway</p> <p>Brick = one language for ALL buildings \u2192 Write once, deploy everywhere \ud83d\ude80</p> <p>Next: Prepare your CSV \u2192</p>"},{"location":"user-guide/","title":"User Guide","text":"<p>Welcome to the HHW Brick Application User Guide! This comprehensive guide covers all features and functionalities of the package.</p>"},{"location":"user-guide/#overview","title":"Overview","text":"<p>The User Guide is organized into the following sections:</p>"},{"location":"user-guide/#csv-to-brick-conversion","title":"CSV to Brick Conversion","text":"<p>Learn how to convert your building equipment data from CSV format to Brick ontology models.</p> <ul> <li>Basic Usage - Simple conversion examples</li> <li>Batch Processing - Convert multiple files</li> <li>Configuration - Customize conversion settings</li> </ul>"},{"location":"user-guide/#model-validation","title":"Model Validation","text":"<p>Ensure your Brick models meet quality standards and specifications.</p> <ul> <li>Ontology Validation - Validate against Brick schema</li> <li>Subgraph Matching - Pattern-based validation</li> <li>Point Count Validation - Verify data completeness</li> </ul>"},{"location":"user-guide/#analytics-applications","title":"Analytics Applications","text":"<p>Use pre-built or custom analytics applications to analyze building systems.</p> <ul> <li>Available Apps - Browse built-in applications</li> <li>Running Applications - Execute analysis workflows</li> <li>Batch Analysis - Process multiple buildings</li> </ul>"},{"location":"user-guide/#command-line-interface","title":"Command Line Interface","text":"<p>Use the powerful CLI for quick operations and automation.</p> <ul> <li>Commands Reference - Complete command documentation</li> <li>Examples - Practical CLI usage examples</li> </ul>"},{"location":"user-guide/#common-workflows","title":"Common Workflows","text":""},{"location":"user-guide/#basic-workflow","title":"Basic Workflow","text":"<pre><code>graph LR\n    A[CSV Data] --&gt;|convert| B[Brick Model]\n    B --&gt;|validate| C[Validated Model]\n    C --&gt;|analyze| D[Results]\n\n    style A fill:#e1f5ff\n    style B fill:#fff9c4\n    style C fill:#c8e6c9\n    style D fill:#f8bbd0</code></pre> <ol> <li>Convert CSV data to Brick model</li> <li>Validate the generated model</li> <li>Analyze using applications</li> <li>Export results</li> </ol>"},{"location":"user-guide/#advanced-workflow","title":"Advanced Workflow","text":"<pre><code>graph TD\n    A[Multiple CSV Files] --&gt;|Batch Convert| B[Multiple Brick Models]\n    B --&gt;|Batch Validate| C[Valid Models]\n    C --&gt;|Qualify Buildings| D{Meet Criteria?}\n    D --&gt;|Yes| E[Run Analytics]\n    D --&gt;|No| F[Skip]\n    E --&gt;|Batch Process| G[Analysis Results]\n\n    style A fill:#e1f5ff\n    style C fill:#c8e6c9\n    style G fill:#f8bbd0</code></pre> <ol> <li>Batch convert multiple CSV files</li> <li>Batch validate all models</li> <li>Qualify buildings for analysis</li> <li>Run analytics on qualified buildings</li> <li>Aggregate results</li> </ol>"},{"location":"user-guide/#quick-navigation","title":"Quick Navigation","text":"<ul> <li> <p> Conversion</p> <p>Transform CSV to Brick models</p> </li> <li> <p> Validation</p> <p>Verify model quality</p> </li> <li> <p> Applications</p> <p>Analyze building systems</p> </li> <li> <p>:material-terminal: CLI</p> <p>Use command-line tools</p> </li> </ul>"},{"location":"user-guide/#need-more-help","title":"Need More Help?","text":"<ul> <li>New to Brick? Check out Core Concepts</li> <li>Looking for code examples? Browse Examples</li> <li>Want to build your own apps? See Developer Guide</li> <li>Have questions? Visit the FAQ</li> </ul> <p>Ready to start? Pick a topic above or continue to CSV to Brick Conversion \u2192</p>"},{"location":"user-guide/conversion_method_comparison/","title":"Conversion Method Comparison: HHW_brick vs. Other Tools","text":""},{"location":"user-guide/conversion_method_comparison/#executive-summary","title":"Executive Summary","text":"<p>HHW_brick's conversion approach offers significant advantages for HVAC practitioners by minimizing manual input requirements and leveraging domain knowledge to automatically infer equipment relationships. This document compares HHW_brick with three popular Brick model generation tools.</p>"},{"location":"user-guide/conversion_method_comparison/#comparison-table","title":"Comparison Table","text":"Feature HHW_brick Brickify CSV-to-Brick Rule-Based Builder User Input Required Minimal (CSV with point names only) Medium (YAML config + data) Medium (Template + CSV) High (Python code) Equipment Relationships Auto-inferred from system type Manual specification required Manual specification required Manual coding required HVAC Domain Knowledge Built-in templates User provides User provides User implements Learning Curve Low (CSV familiarity) Medium (YAML + Brick) Medium (Template syntax) High (Python + Brick) Configuration Complexity Low (system type selection) High (YAML operations) Medium (Template rules) High (Decorator functions) Reusability High (generic templates) Medium (per-project configs) Medium (per-case templates) Low (custom code) Error Prone Low (fewer inputs) Medium (config errors) Medium (template errors) High (coding errors)"},{"location":"user-guide/conversion_method_comparison/#detailed-analysis","title":"Detailed Analysis","text":""},{"location":"user-guide/conversion_method_comparison/#1-input-requirements","title":"1. Input Requirements","text":""},{"location":"user-guide/conversion_method_comparison/#hhw_brick","title":"HHW_brick","text":"<p>Minimal Input Approach</p> <pre><code># metadata.csv - Only system type needed\nbuildingNumber,system_type\n29,district_hw_z\n\n# vars_available_by_building.csv - Just point names\nbuildingNumber,availableSensorList\n29,\"bldg_29_boiler_loop_01_hhws_temp,bldg_29_boiler_loop_01_hhwr_temp\"\n</code></pre> <p>Key Advantage: Users only provide: - System type (e.g., \"district_hw_z\") - Sensor/point names</p> <p>Equipment relationships automatically inferred from built-in domain templates.</p>"},{"location":"user-guide/conversion_method_comparison/#brickify","title":"Brickify","text":"<p>Medium Input with Manual Relationships</p> <pre><code># template.yml - User must specify ALL relationships\nnamespace_prefixes:\n  brick: \"https://brickschema.org/schema/Brick#\"\noperations:\n  - data: |-\n      bldg:{Boiler} rdf:type brick:Boiler ;\n                    brick:hasPoint bldg:{supply_temp} ;\n                    brick:hasPoint bldg:{return_temp} ;\n                    brick:feeds bldg:{Loop} .\n      bldg:{Loop} rdf:type brick:Hot_Water_Loop ;\n                  brick:hasPart bldg:{supply_temp} .\n      bldg:{supply_temp} rdf:type brick:Supply_Water_Temperature_Sensor .\n      bldg:{return_temp} rdf:type brick:Return_Water_Temperature_Sensor .\n</code></pre> <pre><code># data.csv - Must include relationship columns\nBoiler,Loop,supply_temp,return_temp\nboiler_1,loop_1,supply_1,return_1\n</code></pre> <p>Issue: Users must: 1. Understand Brick ontology deeply 2. Manually specify every relationship (hasPoint, feeds, hasPart) 3. Create YAML configs for each building type</p>"},{"location":"user-guide/conversion_method_comparison/#csv-to-brick","title":"CSV-to-Brick","text":"<p>Template-Based with Position Dependencies</p> <pre><code># template.txt - Position-based substitution\nbrick = https://brickschema.org/schema/1.1/Brick#\nbldg = http://example.org/building#\n\nbldg:$1 rdf:type brick:Boiler .\nbldg:$1 brick:hasPoint bldg:$2 .\nbldg:$2 rdf:type brick:Supply_Water_Temperature_Sensor .\nbldg:$1 brick:hasPoint bldg:$3 .\nbldg:$3 rdf:type brick:Return_Water_Temperature_Sensor .\nbldg:$1 brick:feeds bldg:$4 .\nbldg:$4 rdf:type brick:Hot_Water_Loop .\n</code></pre> <pre><code># data.csv - Column order matters!\nboiler_1,supply_1,return_1,loop_1\n</code></pre> <p>Issues: - Column position dependency (error-prone) - Must manually define all relationships - No reusability across different system types</p>"},{"location":"user-guide/conversion_method_comparison/#rule-based-model-builder","title":"Rule-Based Model Builder","text":"<p>Programmatic with High Complexity</p> <pre><code># Custom Python code required\n@tags(\"Boiler\", \"Supply_Temp\", \"Return_Temp\")\ndef add_boiler_system(row):\n    boiler = row.get(\"Boiler\")\n    supply = row.get(\"Supply_Temp\")\n    return_temp = row.get(\"Return_Temp\")\n\n    # Manual relationship coding\n    G.add((BLDG[boiler], A, BRICK.Boiler))\n    G.add((BLDG[boiler], BRICK.hasPoint, BLDG[supply]))\n    G.add((BLDG[supply], A, BRICK.Supply_Water_Temperature_Sensor))\n    G.add((BLDG[boiler], BRICK.hasPoint, BLDG[return_temp]))\n    G.add((BLDG[return_temp], A, BRICK.Return_Water_Temperature_Sensor))\n\n    # Must also code loop relationships\n    loop = f\"{boiler}_loop\"\n    G.add((BLDG[loop], A, BRICK.Hot_Water_Loop))\n    G.add((BLDG[boiler], BRICK.feeds, BLDG[loop]))\n\n@fixedpoint(\"G\")\ndef connect_loops_to_zones(row):\n    # More complex relationship coding...\n    pass\n</code></pre> <p>Issues: - Requires Python programming skills - Must understand RDFlib and Brick ontology - High maintenance burden - Not accessible to non-programmers</p>"},{"location":"user-guide/conversion_method_comparison/#2-domain-knowledge-integration","title":"2. Domain Knowledge Integration","text":""},{"location":"user-guide/conversion_method_comparison/#hhw_brick-built-in-hvac-templates","title":"HHW_brick: Built-in HVAC Templates","text":"<p>Pre-built templates for common HVAC systems:</p> <pre><code># templates/district_hw_z.yaml (maintained by developers)\nequipment_hierarchy:\n  boiler:\n    type: \"Boiler\"\n    contains:\n      - primary_loop\n  primary_loop:\n    type: \"Hot_Water_Loop\"\n    feeds:\n      - heat_exchanger\n  heat_exchanger:\n    type: \"Heat_Exchanger\"\n    contains:\n      - secondary_loop\n  secondary_loop:\n    type: \"Hot_Water_Loop\"\n    feeds:\n      - zones\n\nsensor_associations:\n  boiler:\n    - \"Supply_Water_Temperature_Sensor\"\n    - \"Return_Water_Temperature_Sensor\"\n  primary_loop:\n    - \"Supply_Water_Temperature_Sensor\"\n    - \"Return_Water_Temperature_Sensor\"\n  # ...auto-inferred relationships\n</code></pre> <p>Advantage: - Domain experts encode HVAC knowledge once - End users benefit without needing expertise - Consistent, validated structures</p>"},{"location":"user-guide/conversion_method_comparison/#other-tools-user-provided-knowledge","title":"Other Tools: User-Provided Knowledge","text":"<p>Brickify, CSV-to-Brick, Rule-Based Builder all require: - Users to be Brick ontology experts - Users to understand HVAC system hierarchies - Manual encoding of relationships for each project</p> <p>Result: Higher error rate, inconsistency, longer development time</p>"},{"location":"user-guide/conversion_method_comparison/#3-use-case-scenario","title":"3. Use Case Scenario","text":""},{"location":"user-guide/conversion_method_comparison/#scenario-converting-50-buildings-with-district-hot-water-systems","title":"Scenario: Converting 50 Buildings with District Hot Water Systems","text":""},{"location":"user-guide/conversion_method_comparison/#with-hhw_brick","title":"With HHW_brick","text":"<pre><code># One-time setup (5 minutes)\nfrom hhw_brick import BatchConverter\n\nconverter = BatchConverter()\nconverter.convert_all_buildings(\n    metadata_csv=\"buildings.csv\",      # Just building IDs + system types\n    vars_csv=\"sensors.csv\",            # Just sensor names\n    output_dir=\"brick_models/\",\n)\n# Done! All 50 buildings converted with correct relationships\n</code></pre> <p>Time: ~5 minutes Expertise: Basic CSV skills Maintenance: None (templates maintained by package)</p>"},{"location":"user-guide/conversion_method_comparison/#with-brickify","title":"With Brickify","text":"<pre><code># Must create YAML config (30-60 minutes per system type)\n# template.yml - detailed operations\noperations:\n  - data: |-\n      # 50+ lines of relationship definitions\n      # Must get ALL relationships correct\n      # ...\n</code></pre> <p>Then: <pre><code># Must run for each building individually\nbrickify building_1.csv --config template.yml --output bldg_1.ttl\nbrickify building_2.csv --config template.yml --output bldg_2.ttl\n# ... repeat 50 times or script it\n</code></pre></p> <p>Time: 1-2 hours initial setup + 30 minutes execution Expertise: YAML, Brick ontology, HVAC systems Maintenance: Update YAML when building types change</p>"},{"location":"user-guide/conversion_method_comparison/#with-csv-to-brick","title":"With CSV-to-Brick","text":"<pre><code># Must create template (20-40 minutes)\n# Must ensure CSV columns match template positions\n# Template breaks if CSV structure changes\n\n# Must run for each building\n./csv-to-brick building_1.csv template.txt &gt; bldg_1.ttl\n./csv-to-brick building_2.csv template.txt &gt; bldg_2.ttl\n# ... repeat 50 times\n</code></pre> <p>Time: 30-60 minutes setup + 30 minutes execution Expertise: Template syntax, Brick ontology Maintenance: Update template for structure changes</p>"},{"location":"user-guide/conversion_method_comparison/#with-rule-based-model-builder","title":"With Rule-Based Model Builder","text":"<pre><code># Must write Python code (2-4 hours)\n# Requires understanding of:\n# - Python decorators\n# - RDFlib\n# - Brick ontology\n# - HVAC system hierarchies\n\n@tags(\"Boiler\")\ndef add_boiler(row):\n    # 100+ lines of relationship code\n    # ...\n\n@fixedpoint(\"G\")\ndef connect_systems(row):\n    # Complex relationship logic\n    # ...\n\n# Must handle data loading and processing\n# ... more code ...\n</code></pre> <p>Time: 2-4 hours coding + debugging Expertise: Python, RDFlib, Brick, HVAC Maintenance: Update code for any changes</p>"},{"location":"user-guide/conversion_method_comparison/#4-error-analysis","title":"4. Error Analysis","text":""},{"location":"user-guide/conversion_method_comparison/#common-errors-by-tool","title":"Common Errors by Tool","text":"Error Type HHW_brick Brickify CSV-to-Brick Rule-Based Missing relationships \u2713 Prevented (auto-inferred) \u2717 Common \u2717 Common \u2717 Common Incorrect equipment hierarchy \u2713 Prevented (validated templates) \u2717 Possible \u2717 Possible \u2717 Common Type mismatches \u2713 Caught early \u2717 Runtime errors \u2717 Runtime errors \u2717 Runtime errors Column position errors N/A N/A \u2717 Very common N/A Syntax errors N/A \u2717 YAML errors \u2717 Template errors \u2717 Python errors"},{"location":"user-guide/conversion_method_comparison/#5-scalability-reusability","title":"5. Scalability &amp; Reusability","text":""},{"location":"user-guide/conversion_method_comparison/#hhw_brick_1","title":"HHW_brick","text":"<p>\u2713 Highly Reusable - Generic templates work across all buildings of same type - No per-project configuration needed - Add new system types by creating one template file</p>"},{"location":"user-guide/conversion_method_comparison/#brickify_1","title":"Brickify","text":"<p>\u25b3 Moderately Reusable - YAML configs can be reused for similar buildings - May need adjustments for variations - Requires Brick expertise to modify</p>"},{"location":"user-guide/conversion_method_comparison/#csv-to-brick_1","title":"CSV-to-Brick","text":"<p>\u25b3 Moderately Reusable - Templates work if CSV structure stays constant - Fragile to data structure changes - Position-dependent (error-prone)</p>"},{"location":"user-guide/conversion_method_comparison/#rule-based-builder","title":"Rule-Based Builder","text":"<p>\u2717 Low Reusability - Code is often project-specific - Requires programmer to adapt for new cases - High maintenance burden</p>"},{"location":"user-guide/conversion_method_comparison/#conclusion-does-hhw_bricks-claim-stand","title":"Conclusion: Does HHW_brick's Claim Stand?","text":""},{"location":"user-guide/conversion_method_comparison/#as-an-hvac-and-ontology-expert-yes-the-claim-is-valid","title":"As an HVAC and Ontology Expert, YES - The Claim is Valid","text":"<p>HHW_brick's key innovation is the separation of concerns:</p> <ol> <li>Domain experts (HVAC + Brick ontology specialists) encode knowledge once in templates</li> <li>End users (building operators, energy analysts) only provide minimal data</li> <li>Equipment relationships are auto-inferred from validated, reusable templates</li> </ol>"},{"location":"user-guide/conversion_method_comparison/#specific-advantages","title":"Specific Advantages","text":"<p>\u2713 Minimized Input: Only need system type + sensor names (vs. full relationship specifications)</p> <p>\u2713 Domain Knowledge Built-in: HVAC system hierarchies pre-encoded (vs. user must know)</p> <p>\u2713 Reduced Errors: Auto-inference prevents missing/incorrect relationships</p> <p>\u2713 Lower Barrier: Accessible to HVAC practitioners without Brick expertise</p> <p>\u2713 Scalability: Same template works for any number of buildings</p> <p>\u2713 Maintainability: Update template once, all buildings benefit</p>"},{"location":"user-guide/conversion_method_comparison/#when-other-tools-may-be-better","title":"When Other Tools May Be Better","text":"<ul> <li>Brickify: When you have highly custom, one-off system configurations</li> <li>CSV-to-Brick: When you need extreme simplicity for very basic models</li> <li>Rule-Based Builder: When you need maximum flexibility and have programming resources</li> </ul>"},{"location":"user-guide/conversion_method_comparison/#for-hvac-building-systems-hhw_brick-is-superior","title":"For HVAC Building Systems: HHW_brick is Superior","text":"<p>For the specific use case of HVAC building systems (which is the target domain), HHW_brick's approach is demonstrably superior because:</p> <ol> <li>HVAC systems follow well-defined patterns \u2192 Templates capture this</li> <li>Users are domain experts in HVAC, not ontologies \u2192 Minimal input works</li> <li>Consistency and correctness matter \u2192 Auto-inference reduces errors</li> <li>Scale matters \u2192 Batch processing with templates is efficient</li> </ol>"},{"location":"user-guide/conversion_method_comparison/#recommendations","title":"Recommendations","text":""},{"location":"user-guide/conversion_method_comparison/#for-your-paperdocumentation","title":"For Your Paper/Documentation","text":"<p>Strong Claims You Can Make:</p> <ol> <li>\u2713 \"Minimizes user input by eliminating the need to manually specify equipment relationships\"</li> <li>\u2713 \"Leverages built-in HVAC domain knowledge through reusable templates\"</li> <li>\u2713 \"Reduces error rates by auto-inferring system hierarchies from validated patterns\"</li> <li>\u2713 \"Lowers the expertise barrier for HVAC practitioners\"</li> </ol> <p>Quantifiable Advantages:</p> <ul> <li>Input reduction: ~80% fewer fields required (only system type vs. full relationship specs)</li> <li>Time savings: 5 minutes vs. 1-4 hours for batch conversion</li> <li>Error reduction: Prevents common relationship errors through validation</li> <li>Accessibility: No Brick ontology expertise required for end users</li> </ul>"},{"location":"user-guide/conversion_method_comparison/#example-comparison-code","title":"Example Comparison Code","text":"<p>See <code>examples/09_complete_pipeline_batch.py</code> for a complete HHW_brick workflow that demonstrates:</p> <ol> <li>Batch conversion with minimal input</li> <li>Automated validation</li> <li>Application execution</li> </ol> <p>Compare this with the equivalent implementations required in other tools (shown above).</p>"},{"location":"user-guide/plotly-visualization-cn/","title":"Plotly \u4ea4\u4e92\u5f0f\u53ef\u89c6\u5316\u529f\u80fd","text":""},{"location":"user-guide/plotly-visualization-cn/#_1","title":"\u529f\u80fd\u6982\u8ff0","text":"<p>HHW Brick \u6846\u67b6\u73b0\u5df2\u652f\u6301\u4f7f\u7528 Plotly \u751f\u6210\u4ea4\u4e92\u5f0f HTML \u53ef\u89c6\u5316\uff0c\u9664\u4e86\u4f20\u7edf\u7684\u9759\u6001 matplotlib \u56fe\u8868\u4e4b\u5916\uff0c\u8fd8\u63d0\u4f9b\u4e86\u66f4\u52a0\u5f3a\u5927\u7684\u4ea4\u4e92\u5f0f\u6570\u636e\u63a2\u7d22\u80fd\u529b\u3002</p>"},{"location":"user-guide/plotly-visualization-cn/#_2","title":"\u4e3b\u8981\u7279\u6027","text":"<p>\u2728 4 \u79cd\u4ea4\u4e92\u5f0f\u53ef\u89c6\u5316\u7c7b\u578b\uff1a 1. \u7efc\u5408\u4eea\u8868\u677f - \u5305\u542b 6 \u4e2a\u5b50\u56fe\u7684\u591a\u9762\u677f\u5c55\u793a 2. \u8be6\u7ec6\u65f6\u95f4\u5e8f\u5217 - \u53cc Y \u8f74\u6e29\u5ea6\u5206\u6790\u56fe 3. \u70ed\u529b\u56fe - \u5c0f\u65f6 vs \u661f\u671f\u7684\u6a21\u5f0f\u5206\u6790 4. \u7bb1\u7ebf\u56fe - \u7edf\u8ba1\u5206\u5e03\u5206\u6790</p> <p>\ud83c\udfaf \u4ea4\u4e92\u529f\u80fd\uff1a - \u7f29\u653e\u548c\u5e73\u79fb\u6570\u636e - \u60ac\u505c\u663e\u793a\u8be6\u7ec6\u4fe1\u606f - \u70b9\u51fb\u56fe\u4f8b\u5207\u6362\u663e\u793a/\u9690\u85cf - \u5bfc\u51fa\u9ad8\u8d28\u91cf\u56fe\u7247 - \u4ee5\u72ec\u7acb HTML \u6587\u4ef6\u5206\u4eab</p>"},{"location":"user-guide/plotly-visualization-cn/#_3","title":"\u5feb\u901f\u5f00\u59cb","text":""},{"location":"user-guide/plotly-visualization-cn/#1-plotly","title":"1. \u542f\u7528 Plotly \u53ef\u89c6\u5316","text":"<p>\u5728\u914d\u7f6e\u6587\u4ef6 <code>config.yaml</code> \u4e2d\uff1a</p> <pre><code>output:\n  generate_plotly_html: true  # \u542f\u7528 Plotly\n  output_dir: \"./results\"     # \u8f93\u51fa\u76ee\u5f55\n</code></pre>"},{"location":"user-guide/plotly-visualization-cn/#2-python","title":"2. Python \u4ee3\u7801\u4f7f\u7528","text":"<pre><code>from hhw_brick.applications.primary_loop_temp_diff.app import analyze, load_config\n\n# \u52a0\u8f7d\u914d\u7f6e\nconfig = load_config()\nconfig[\"output\"][\"generate_plotly_html\"] = True  # \u542f\u7528 Plotly\n\n# \u8fd0\u884c\u5206\u6790\nresults = analyze(\n    \"brick_model.ttl\",\n    \"timeseries.csv\",\n    config\n)\n</code></pre>"},{"location":"user-guide/plotly-visualization-cn/#3","title":"3. \u547d\u4ee4\u884c\u4f7f\u7528","text":"<pre><code># \u8fd0\u884c\u4e3b\u5faa\u73af\u5206\u6790\uff08\u81ea\u52a8\u751f\u6210 Plotly \u53ef\u89c6\u5316\uff09\npython -m hhw_brick.applications.primary_loop_temp_diff.app \\\n    brick_model.ttl \\\n    timeseries.csv \\\n    --output-dir ./results\n</code></pre>"},{"location":"user-guide/plotly-visualization-cn/#4","title":"4. \u4f7f\u7528\u793a\u4f8b\u811a\u672c","text":"<pre><code>cd examples\npython 09_plotly_visualization.py\n</code></pre>"},{"location":"user-guide/plotly-visualization-cn/#_4","title":"\u751f\u6210\u7684\u6587\u4ef6","text":"<p>\u8fd0\u884c\u5206\u6790\u540e\uff0c\u4f1a\u5728\u8f93\u51fa\u76ee\u5f55\u751f\u6210\u4ee5\u4e0b\u6587\u4ef6\uff1a</p> <pre><code>results/\n\u251c\u2500\u2500 primary_loop_interactive_dashboard.html      # \ud83d\udcca \u7efc\u5408\u4eea\u8868\u677f\n\u251c\u2500\u2500 primary_loop_timeseries_interactive.html     # \ud83d\udcc8 \u8be6\u7ec6\u65f6\u95f4\u5e8f\u5217\n\u251c\u2500\u2500 primary_loop_heatmap_interactive.html        # \ud83d\udd25 \u6a21\u5f0f\u70ed\u529b\u56fe\n\u251c\u2500\u2500 primary_loop_boxplot_interactive.html        # \ud83d\udce6 \u5206\u5e03\u7bb1\u7ebf\u56fe\n\u2514\u2500\u2500 [\u5176\u4ed6 CSV \u548c PNG \u6587\u4ef6]\n</code></pre>"},{"location":"user-guide/plotly-visualization-cn/#_5","title":"\u53ef\u89c6\u5316\u8be6\u60c5","text":""},{"location":"user-guide/plotly-visualization-cn/#1-dashboard","title":"1. \u7efc\u5408\u4eea\u8868\u677f\uff08Dashboard\uff09","text":"<p>\u5305\u542b 6 \u4e2a\u5b50\u56fe\uff1a - \u4f9b\u6c34\u548c\u56de\u6c34\u6e29\u5ea6 - \u65f6\u95f4\u5e8f\u5217\u5bf9\u6bd4 - \u6e29\u5dee\u53d8\u5316 - \u6e29\u5ea6\u5dee\u5f02\u8d8b\u52bf\uff0c\u5e26\u5e73\u5747\u7ebf - \u5206\u5e03\u76f4\u65b9\u56fe - \u6e29\u5dee\u5206\u5e03\u7edf\u8ba1 - \u4f9b\u6c34 vs \u56de\u6c34\u6563\u70b9\u56fe - \u76f8\u5173\u6027\u5206\u6790 - \u5c0f\u65f6\u6a21\u5f0f - \u6309\u5c0f\u65f6\u7edf\u8ba1\u7684\u6e29\u5dee\u5747\u503c - \u661f\u671f\u6a21\u5f0f - \u6309\u661f\u671f\u7edf\u8ba1\u7684\u6e29\u5dee\u5747\u503c</p> <p>\u7279\u70b9\uff1a\u4e00\u6b21\u67e5\u770b\u6240\u6709\u5173\u952e\u6307\u6807</p>"},{"location":"user-guide/plotly-visualization-cn/#2-timeseries","title":"2. \u8be6\u7ec6\u65f6\u95f4\u5e8f\u5217\uff08Timeseries\uff09","text":"<p>\u53cc Y \u8f74\u8bbe\u8ba1\uff1a - \u5de6\u8f74\uff1a\u4f9b\u6c34\u6e29\u5ea6\uff08\u7ea2\u8272\uff09\u548c\u56de\u6c34\u6e29\u5ea6\uff08\u84dd\u8272\uff09 - \u53f3\u8f74\uff1a\u6e29\u5ea6\u5dee\u5f02\uff08\u7d2b\u8272\uff09 - \u9608\u503c\u7ebf\uff1a\u6700\u5c0f\u548c\u6700\u5927\u9608\u503c\u6807\u8bb0</p> <p>\u7279\u70b9\uff1a\u53ef\u4ee5\u540c\u65f6\u89c2\u5bdf\u6e29\u5ea6\u548c\u6e29\u5dee\u7684\u53d8\u5316\u8d8b\u52bf</p>"},{"location":"user-guide/plotly-visualization-cn/#3-heatmap","title":"3. \u70ed\u529b\u56fe\uff08Heatmap\uff09","text":"<p>\u4e8c\u7ef4\u6a21\u5f0f\u5206\u6790\uff1a - X \u8f74\uff1a\u661f\u671f\uff08\u5468\u4e00\u5230\u5468\u65e5\uff09 - Y \u8f74\uff1a\u5c0f\u65f6\uff080-23\uff09 - \u989c\u8272\uff1a\u5e73\u5747\u6e29\u5dee\u503c</p> <p>\u7279\u70b9\uff1a\u5feb\u901f\u8bc6\u522b\u65f6\u95f4\u6a21\u5f0f\u548c\u5f02\u5e38\u65f6\u6bb5</p>"},{"location":"user-guide/plotly-visualization-cn/#4-box-plot","title":"4. \u7bb1\u7ebf\u56fe\uff08Box Plot\uff09","text":"<p>\u7edf\u8ba1\u5206\u5e03\u5c55\u793a\uff1a - \u56db\u5206\u4f4d\u6570 - \u4e2d\u4f4d\u6570\u548c\u5747\u503c - \u5f02\u5e38\u503c\u6807\u8bb0 - \u6807\u51c6\u5dee\u8303\u56f4</p> <p>\u7279\u70b9\uff1a\u7406\u89e3\u6570\u636e\u5206\u5e03\u548c\u79bb\u6563\u7a0b\u5ea6</p>"},{"location":"user-guide/plotly-visualization-cn/#_6","title":"\u4ea4\u4e92\u64cd\u4f5c","text":""},{"location":"user-guide/plotly-visualization-cn/#_7","title":"\u57fa\u672c\u64cd\u4f5c","text":"<ul> <li>\u5e73\u79fb\uff1a\u70b9\u51fb\u5e76\u62d6\u52a8\u56fe\u8868</li> <li>\u7f29\u653e\uff1a\u6eda\u8f6e\u653e\u5927/\u7f29\u5c0f</li> <li>\u91cd\u7f6e\uff1a\u53cc\u51fb\u56fe\u8868</li> <li>\u5207\u6362\uff1a\u70b9\u51fb\u56fe\u4f8b\u9690\u85cf/\u663e\u793a\u6570\u636e\u7cfb\u5217</li> <li>\u60ac\u505c\uff1a\u9f20\u6807\u79fb\u5230\u6570\u636e\u70b9\u67e5\u770b\u8be6\u60c5</li> <li>\u4e0b\u8f7d\uff1a\u70b9\u51fb\u76f8\u673a\u56fe\u6807\u4fdd\u5b58\u4e3a PNG</li> </ul>"},{"location":"user-guide/plotly-visualization-cn/#_8","title":"\u9ad8\u7ea7\u529f\u80fd","text":"<ul> <li>\u6846\u9009\u7f29\u653e\uff1a\u5de5\u5177\u680f\u9009\u62e9\u6846\u9009\u5de5\u5177</li> <li>\u81ea\u52a8\u7f29\u653e\uff1a\u5de5\u5177\u680f\u7684 Autoscale \u6309\u94ae</li> <li>\u6bd4\u8f83\u6a21\u5f0f\uff1a\u663e\u793a\u591a\u4e2a\u6570\u636e\u7cfb\u5217\u8fdb\u884c\u5bf9\u6bd4</li> </ul>"},{"location":"user-guide/plotly-visualization-cn/#_9","title":"\u914d\u7f6e\u9009\u9879","text":""},{"location":"user-guide/plotly-visualization-cn/#plotly-matplotlib","title":"\u53ea\u751f\u6210 Plotly\uff08\u4e0d\u751f\u6210 matplotlib\uff09","text":"<pre><code>config = load_config()\nconfig[\"output\"][\"generate_plots\"] = False        # \u7981\u7528 matplotlib\nconfig[\"output\"][\"generate_plotly_html\"] = True   # \u53ea\u7528 Plotly\n</code></pre>"},{"location":"user-guide/plotly-visualization-cn/#_10","title":"\u81ea\u5b9a\u4e49\u8f93\u51fa\u76ee\u5f55","text":"<pre><code>config[\"output\"][\"output_dir\"] = \"./my_results\"\n</code></pre>"},{"location":"user-guide/plotly-visualization-cn/#_11","title":"\u81ea\u5b9a\u4e49\u6570\u636e\u683c\u5f0f","text":"<pre><code>config[\"output\"][\"export_format\"] = \"json\"  # \u6216 \"csv\"\n</code></pre>"},{"location":"user-guide/plotly-visualization-cn/#_12","title":"\u5e94\u7528\u652f\u6301","text":"<p>\u5f53\u524d\u652f\u6301 Plotly \u53ef\u89c6\u5316\u7684\u5e94\u7528\uff1a</p> <ol> <li>\u2705 primary_loop_temp_diff - \u4e3b\u5faa\u73af\u6e29\u5dee\u5206\u6790</li> <li>\u2705 secondary_loop_temp_diff - \u6b21\u5faa\u73af\u6e29\u5dee\u5206\u6790</li> </ol> <p>\u6240\u6709\u65b0\u7684\u5206\u6790\u5e94\u7528\u90fd\u5c06\u9ed8\u8ba4\u652f\u6301 Plotly \u53ef\u89c6\u5316\u3002</p>"},{"location":"user-guide/plotly-visualization-cn/#_13","title":"\u4f18\u52bf","text":""},{"location":"user-guide/plotly-visualization-cn/#_14","title":"\ud83d\udcca \u6570\u636e\u63a2\u7d22","text":"<ul> <li>\u5feb\u901f\u7f29\u653e\u5230\u7279\u5b9a\u65f6\u95f4\u6bb5</li> <li>\u60ac\u505c\u67e5\u770b\u7cbe\u786e\u6570\u503c</li> <li>\u8f7b\u677e\u8bc6\u522b\u5f02\u5e38\u503c</li> </ul>"},{"location":"user-guide/plotly-visualization-cn/#_15","title":"\ud83c\udfa8 \u4e13\u4e1a\u5c55\u793a","text":"<ul> <li>\u73b0\u4ee3\u5316\u3001\u7f8e\u89c2\u7684\u53ef\u89c6\u5316</li> <li>\u65e0\u9700 PowerPoint\uff0c\u76f4\u63a5\u5728\u6d4f\u89c8\u5668\u4e2d\u5c55\u793a</li> <li>\u6f14\u793a\u8fc7\u7a0b\u4e2d\u5b9e\u65f6\u4ea4\u4e92</li> </ul>"},{"location":"user-guide/plotly-visualization-cn/#_16","title":"\ud83d\udcc4 \u62a5\u544a\u96c6\u6210","text":"<ul> <li>\u5d4c\u5165\u5230 HTML \u62a5\u544a\u4e2d</li> <li>\u72ec\u7acb\u6587\u4ef6\uff0c\u65e0\u5916\u90e8\u4f9d\u8d56</li> <li>\u4efb\u4f55\u8bbe\u5907\u548c\u6d4f\u89c8\u5668\u90fd\u80fd\u67e5\u770b</li> </ul>"},{"location":"user-guide/plotly-visualization-cn/#_17","title":"\ud83d\udc65 \u534f\u4f5c\u5171\u4eab","text":"<ul> <li>\u901a\u8fc7\u90ae\u4ef6\u6216\u4e91\u5b58\u50a8\u8f7b\u677e\u5206\u4eab</li> <li>\u65e0\u9700\u5b89\u88c5 Python \u5373\u53ef\u67e5\u770b</li> <li>\u56e2\u961f\u6210\u5458\u53ef\u4ee5\u4ea4\u4e92\u5f0f\u63a2\u7d22\u6570\u636e</li> </ul>"},{"location":"user-guide/plotly-visualization-cn/#_18","title":"\u6027\u80fd\u63d0\u793a","text":"<ul> <li>\u5927\u6570\u636e\u96c6\uff1aPlotly \u53ef\u4ee5\u5904\u7406\u7ea6 10 \u4e07\u4e2a\u6570\u636e\u70b9\u3002\u66f4\u5927\u7684\u6570\u636e\u96c6\u5efa\u8bae\u964d\u91c7\u6837</li> <li>\u6587\u4ef6\u5927\u5c0f\uff1aHTML \u6587\u4ef6\u901a\u5e38\u5728 500KB - 5MB \u4e4b\u95f4</li> <li>\u52a0\u8f7d\u65f6\u95f4\uff1a\u5178\u578b\u6570\u636e\u96c6\u7684\u521d\u59cb\u52a0\u8f7d\u65f6\u95f4\u4e3a 1-3 \u79d2</li> </ul>"},{"location":"user-guide/plotly-visualization-cn/#_19","title":"\u793a\u4f8b\u4ee3\u7801","text":"<p>\u67e5\u770b\u5b8c\u6574\u793a\u4f8b\uff1a</p> <pre><code>examples/09_plotly_visualization.py  # Plotly \u4e13\u7528\u793a\u4f8b\nexamples/07_run_application.py       # \u7a0b\u5e8f\u5316\u8fd0\u884c\u5e94\u7528\n</code></pre>"},{"location":"user-guide/plotly-visualization-cn/#_20","title":"\u6587\u6863","text":"<p>\u8be6\u7ec6\u6587\u6863\u8bf7\u53c2\u8003\uff1a - <code>docs/user-guide/plotly-visualization.md</code> - \u5b8c\u6574\u82f1\u6587\u6587\u6863</p>"},{"location":"user-guide/plotly-visualization-cn/#_21","title":"\u4f9d\u8d56","text":"<pre><code># \u81ea\u52a8\u5305\u542b\u5728 requirements.txt \u4e2d\nplotly&gt;=5.0.0\n</code></pre>"},{"location":"user-guide/plotly-visualization-cn/#_22","title":"\u6280\u672f\u652f\u6301","text":"<p>\u5982\u6709\u95ee\u9898\uff0c\u8bf7\u67e5\u770b\uff1a 1. \u751f\u6210\u7684 HTML \u6587\u4ef6\u4e2d\u7684\u4ea4\u4e92\u5f0f\u5e2e\u52a9 2. \u6587\u6863\u4e2d\u7684\u6545\u969c\u6392\u9664\u90e8\u5206 3. Plotly \u5b98\u65b9\u6587\u6863\uff1ahttps://plotly.com/python/</p> <p>\u63d0\u793a\uff1aPlotly \u53ef\u89c6\u5316\u9ed8\u8ba4\u542f\u7528\uff0c\u65e0\u9700\u989d\u5916\u914d\u7f6e\u5373\u53ef\u4f7f\u7528\uff01</p>"},{"location":"user-guide/plotly-visualization/","title":"Plotly Interactive Visualization","text":""},{"location":"user-guide/plotly-visualization/#overview","title":"Overview","text":"<p>HHW Brick framework now supports generating interactive HTML visualizations using Plotly, in addition to the traditional static matplotlib plots.</p> <p>Interactive visualizations allow you to: - Zoom and pan through data - Hover over data points for detailed information - Toggle traces on/off by clicking legend items - Export high-quality images - Share results as standalone HTML files that can be viewed in any web browser</p>"},{"location":"user-guide/plotly-visualization/#features","title":"Features","text":"<p>Each application that supports Plotly visualization generates 4 interactive HTML files:</p>"},{"location":"user-guide/plotly-visualization/#1-comprehensive-dashboard","title":"1. Comprehensive Dashboard","text":"<p>A multi-panel dashboard with 6 subplots showing: - Supply and return temperature timeseries - Temperature differential timeseries - Distribution histogram - Supply vs return scatter plot - Hourly pattern analysis - Weekly pattern analysis</p> <p>File: <code>*_interactive_dashboard.html</code></p>"},{"location":"user-guide/plotly-visualization/#2-detailed-timeseries","title":"2. Detailed Timeseries","text":"<p>Dual y-axis plot showing: - Supply temperature (left axis) - Return temperature (left axis) - Temperature differential (right axis) - Threshold lines for anomaly detection</p> <p>File: <code>*_timeseries_interactive.html</code></p>"},{"location":"user-guide/plotly-visualization/#3-heatmap-visualization","title":"3. Heatmap Visualization","text":"<p>Interactive heatmap showing temperature differential patterns: - Hour of day (y-axis) - Day of week (x-axis) - Color intensity represents mean temperature differential</p> <p>File: <code>*_heatmap_interactive.html</code></p>"},{"location":"user-guide/plotly-visualization/#4-box-plot-distribution","title":"4. Box Plot Distribution","text":"<p>Statistical distribution analysis with: - Box plot showing quartiles - Mean and standard deviation indicators - Interactive hover for detailed statistics</p> <p>File: <code>*_boxplot_interactive.html</code></p>"},{"location":"user-guide/plotly-visualization/#configuration","title":"Configuration","text":""},{"location":"user-guide/plotly-visualization/#enabledisable-plotly-visualization","title":"Enable/Disable Plotly Visualization","text":"<p>In your application's <code>config.yaml</code>:</p> <pre><code>output:\n  generate_plotly_html: true  # Set to false to disable\n  output_dir: \"./results\"\n</code></pre>"},{"location":"user-guide/plotly-visualization/#python-code-configuration","title":"Python Code Configuration","text":"<pre><code>from hhw_brick.applications.primary_loop_temp_diff.app import analyze, load_config\n\nconfig = load_config()\nconfig[\"output\"][\"generate_plotly_html\"] = True  # Enable Plotly HTML\nconfig[\"output\"][\"generate_plots\"] = True        # Also generate matplotlib plots\nconfig[\"output\"][\"output_dir\"] = \"./results\"\n\nresults = analyze(brick_model_path, timeseries_path, config)\n</code></pre>"},{"location":"user-guide/plotly-visualization/#usage-examples","title":"Usage Examples","text":""},{"location":"user-guide/plotly-visualization/#example-1-basic-usage-with-default-settings","title":"Example 1: Basic Usage with Default Settings","text":"<pre><code>from hhw_brick.applications.primary_loop_temp_diff.app import analyze, load_config\n\n# Load default configuration (Plotly enabled by default)\nconfig = load_config()\n\n# Run analysis\nresults = analyze(\n    \"path/to/brick_model.ttl\",\n    \"path/to/timeseries.csv\",\n    config\n)\n</code></pre>"},{"location":"user-guide/plotly-visualization/#example-2-plotly-only-no-matplotlib","title":"Example 2: Plotly Only (No Matplotlib)","text":"<pre><code>config = load_config()\nconfig[\"output\"][\"generate_plots\"] = False        # Disable matplotlib\nconfig[\"output\"][\"generate_plotly_html\"] = True   # Keep Plotly enabled\n\nresults = analyze(brick_model_path, timeseries_path, config)\n</code></pre>"},{"location":"user-guide/plotly-visualization/#example-3-command-line-usage","title":"Example 3: Command Line Usage","text":"<pre><code># Run primary loop analysis (generates both matplotlib and Plotly visualizations)\npython -m hhw_brick.applications.primary_loop_temp_diff.app \\\n    brick_model.ttl \\\n    timeseries.csv \\\n    --output-dir ./results\n\n# Run secondary loop analysis\npython -m hhw_brick.applications.secondary_loop_temp_diff.app \\\n    brick_model.ttl \\\n    timeseries.csv \\\n    --output-dir ./results\n</code></pre>"},{"location":"user-guide/plotly-visualization/#example-4-using-the-dedicated-example-script","title":"Example 4: Using the Dedicated Example Script","text":"<pre><code># Navigate to examples directory\ncd examples\n\n# Run the Plotly visualization example\npython 09_plotly_visualization.py\n</code></pre>"},{"location":"user-guide/plotly-visualization/#output-files","title":"Output Files","text":"<p>After running an analysis with Plotly enabled, you'll find these files in your output directory:</p> <pre><code>results/\n\u251c\u2500\u2500 primary_loop_interactive_dashboard.html      # Main dashboard\n\u251c\u2500\u2500 primary_loop_timeseries_interactive.html     # Detailed timeseries\n\u251c\u2500\u2500 primary_loop_heatmap_interactive.html        # Pattern heatmap\n\u251c\u2500\u2500 primary_loop_boxplot_interactive.html        # Distribution analysis\n\u251c\u2500\u2500 primary_loop_temp_diff_stats.csv             # Statistics (CSV)\n\u251c\u2500\u2500 primary_loop_temp_diff_timeseries.csv        # Raw data (CSV)\n\u2514\u2500\u2500 [matplotlib PNG files if enabled]\n</code></pre>"},{"location":"user-guide/plotly-visualization/#viewing-interactive-html-files","title":"Viewing Interactive HTML Files","text":"<ol> <li> <p>Open in Web Browser: Double-click any <code>.html</code> file to open it in your default web browser</p> </li> <li> <p>Interactive Controls:</p> </li> <li>Pan: Click and drag on the plot</li> <li>Zoom: Use scroll wheel or box zoom (toolbar)</li> <li>Reset: Double-click on the plot</li> <li>Toggle Traces: Click legend items to show/hide data series</li> <li>Hover: Move cursor over data points for details</li> <li> <p>Download: Click camera icon to save as PNG</p> </li> <li> <p>Sharing: HTML files are standalone and can be:</p> </li> <li>Emailed to colleagues</li> <li>Uploaded to web servers</li> <li>Embedded in reports</li> <li>Viewed offline</li> </ol>"},{"location":"user-guide/plotly-visualization/#customization","title":"Customization","text":""},{"location":"user-guide/plotly-visualization/#modifying-plotly-visualizations","title":"Modifying Plotly Visualizations","text":"<p>To customize the Plotly visualizations, edit the <code>generate_plotly_html()</code> function in your application's <code>app.py</code>:</p> <pre><code>def generate_plotly_html(results, config):\n    # Customize colors\n    supply_color = '#e74c3c'  # Red for supply\n    return_color = '#3498db'  # Blue for return\n\n    # Customize layout\n    fig.update_layout(\n        title_text=\"My Custom Title\",\n        template='plotly_dark',  # Try: plotly, plotly_white, plotly_dark\n        height=1600,             # Adjust height\n    )\n\n    # Customize hover templates\n    hovertemplate='&lt;b&gt;Custom&lt;/b&gt;&lt;br&gt;Time: %{x}&lt;br&gt;Value: %{y:.2f}\u00b0C&lt;extra&gt;&lt;/extra&gt;'\n</code></pre>"},{"location":"user-guide/plotly-visualization/#available-plotly-templates","title":"Available Plotly Templates","text":"<ul> <li><code>plotly</code> (default)</li> <li><code>plotly_white</code></li> <li><code>plotly_dark</code></li> <li><code>ggplot2</code></li> <li><code>seaborn</code></li> <li><code>simple_white</code></li> </ul>"},{"location":"user-guide/plotly-visualization/#benefits-of-interactive-visualization","title":"Benefits of Interactive Visualization","text":""},{"location":"user-guide/plotly-visualization/#for-data-exploration","title":"For Data Exploration","text":"<ul> <li>Quickly zoom into specific time periods</li> <li>Identify outliers and anomalies by hovering</li> <li>Compare multiple time periods side-by-side</li> </ul>"},{"location":"user-guide/plotly-visualization/#for-presentations","title":"For Presentations","text":"<ul> <li>Professional, modern visualizations</li> <li>No need for PowerPoint - just open in browser</li> <li>Real-time interaction during presentations</li> </ul>"},{"location":"user-guide/plotly-visualization/#for-reports","title":"For Reports","text":"<ul> <li>Embed in HTML reports</li> <li>Self-contained files (no external dependencies)</li> <li>Works on any device with a web browser</li> </ul>"},{"location":"user-guide/plotly-visualization/#for-collaboration","title":"For Collaboration","text":"<ul> <li>Easy to share via email or cloud storage</li> <li>Anyone can view without installing Python</li> <li>Interactive exploration of data</li> </ul>"},{"location":"user-guide/plotly-visualization/#performance-considerations","title":"Performance Considerations","text":"<ul> <li>Large Datasets: Plotly handles up to ~100k points well. For larger datasets, consider:</li> <li>Downsampling data</li> <li> <p>Using WebGL rendering: <code>fig.update_traces(mode='lines+markers', marker=dict(size=2), line=dict(width=1))</code></p> </li> <li> <p>File Size: HTML files range from 500KB to 5MB depending on data size</p> </li> <li> <p>Loading Time: Initial load takes 1-3 seconds for typical datasets</p> </li> </ul>"},{"location":"user-guide/plotly-visualization/#troubleshooting","title":"Troubleshooting","text":""},{"location":"user-guide/plotly-visualization/#issue-html-file-wont-open","title":"Issue: HTML file won't open","text":"<p>Solution: Make sure you have a modern web browser (Chrome, Firefox, Edge, Safari)</p>"},{"location":"user-guide/plotly-visualization/#issue-visualization-is-slow","title":"Issue: Visualization is slow","text":"<p>Solution: Reduce data points or use WebGL rendering</p>"},{"location":"user-guide/plotly-visualization/#issue-colors-dont-match-matplotlib-plots","title":"Issue: Colors don't match matplotlib plots","text":"<p>Solution: Customize colors in <code>generate_plotly_html()</code> function</p>"},{"location":"user-guide/plotly-visualization/#issue-missing-data-in-plots","title":"Issue: Missing data in plots","text":"<p>Solution: Check that data preprocessing is consistent between matplotlib and Plotly functions</p>"},{"location":"user-guide/plotly-visualization/#api-reference","title":"API Reference","text":""},{"location":"user-guide/plotly-visualization/#configuration-options","title":"Configuration Options","text":"<pre><code>config = {\n    \"output\": {\n        \"generate_plotly_html\": bool,  # Enable/disable Plotly HTML generation\n        \"output_dir\": str,              # Output directory path\n        \"save_results\": bool,           # Save CSV/JSON results\n        \"generate_plots\": bool,         # Enable/disable matplotlib plots\n    }\n}\n</code></pre>"},{"location":"user-guide/plotly-visualization/#generated-functions","title":"Generated Functions","text":"<p>Both <code>primary_loop_temp_diff</code> and <code>secondary_loop_temp_diff</code> applications include:</p> <ul> <li><code>generate_plotly_html(results, config)</code>: Main function to generate all HTML files</li> <li>Parameters:<ul> <li><code>results</code>: Dictionary containing <code>stats</code> and <code>data</code> from analysis</li> <li><code>config</code>: Configuration dictionary</li> </ul> </li> <li>Returns: None (saves files to disk)</li> </ul>"},{"location":"user-guide/plotly-visualization/#examples-in-repository","title":"Examples in Repository","text":"<p>See the following examples for complete working code:</p> <ul> <li><code>examples/09_plotly_visualization.py</code> - Dedicated Plotly example</li> <li><code>examples/06_application_management.py</code> - Application framework usage</li> <li><code>examples/07_run_application.py</code> - Running applications programmatically</li> </ul>"},{"location":"user-guide/plotly-visualization/#further-reading","title":"Further Reading","text":"<ul> <li>Plotly Python Documentation</li> <li>Plotly Figure Reference</li> <li>Plotly Subplots</li> <li>Plotly Styling</li> </ul>"},{"location":"user-guide/applications/","title":"Analytics Applications","text":"<p>Run analytics on validated Brick models to extract insights from building data.</p>"},{"location":"user-guide/applications/#overview","title":"Overview","text":"<p>HHW Brick Application provides a pluggable application framework for running analytics on building systems. Applications are self-contained modules that:</p> <ul> <li>Qualify buildings - Check if building has required sensors</li> <li>Analyze data - Perform calculations and generate insights</li> <li>Generate outputs - Create reports, plots, and metrics</li> </ul>"},{"location":"user-guide/applications/#available-applications","title":"Available Applications","text":""},{"location":"user-guide/applications/#current-applications","title":"Current Applications","text":"<p>The package includes two built-in applications:</p> Application Purpose Required Sensors secondary_loop_temp_diff Analyze secondary loop temperature difference Secondary supply, return temps primary_loop_temp_diff Analyze primary loop temperature difference Primary supply, return temps <p>More applications can be added by developers. See Developer Guide.</p>"},{"location":"user-guide/applications/#quick-start","title":"Quick Start","text":""},{"location":"user-guide/applications/#4-step-workflow","title":"4-Step Workflow","text":"<p>From <code>examples/07_run_application.py</code>:</p> <pre><code>from hhw_brick import apps\n\n# Step 1: Load application\napp = apps.load_app(\"secondary_loop_temp_diff\")\n\n# Step 2: Qualify building (check if it has required sensors)\nqualified, details = app.qualify(\"building_105.ttl\")\n\nif qualified:\n    # Step 3: Load configuration\n    config = apps.get_default_config(\"secondary_loop_temp_diff\")\n\n    # Step 4: Run analysis\n    results = app.analyze(\n        brick_model_path=\"building_105.ttl\",\n        timeseries_data_path=\"building_105_data.csv\",\n        config=config\n    )\n\n    print(f\"Analysis complete: {results['summary']}\")\n</code></pre>"},{"location":"user-guide/applications/#apps-manager","title":"Apps Manager","text":""},{"location":"user-guide/applications/#discover-applications","title":"Discover Applications","text":"<p>From <code>examples/06_application_management.py</code>:</p> <pre><code>from hhw_brick import apps\n\n# List all available applications\navailable_apps = apps.list_apps()\n\nprint(f\"Found {len(available_apps)} applications:\")\nfor app_info in available_apps:\n    print(f\"  \u2022 {app_info['name']}\")\n    print(f\"    {app_info['description']}\")\n</code></pre> <p>Expected output: <pre><code>Found 2 applications:\n  \u2022 secondary_loop_temp_diff\n    Analyzes temperature difference in secondary hot water loop\n  \u2022 primary_loop_temp_diff\n    Analyzes temperature difference in primary hot water loop\n</code></pre></p>"},{"location":"user-guide/applications/#load-application","title":"Load Application","text":"<pre><code># Load by name\napp = apps.load_app(\"secondary_loop_temp_diff\")\n\n# Now you can use app.qualify() and app.analyze()\n</code></pre>"},{"location":"user-guide/applications/#get-application-info","title":"Get Application Info","text":"<pre><code># Get detailed information\ninfo = apps.get_app_info(\"secondary_loop_temp_diff\")\n\nprint(f\"Name: {info['name']}\")\nprint(f\"Description: {info['description']}\")\nprint(f\"Functions: {[f['name'] for f in info['functions']]}\")\n</code></pre>"},{"location":"user-guide/applications/#get-default-configuration","title":"Get Default Configuration","text":"<pre><code># Get default config template\nconfig = apps.get_default_config(\"secondary_loop_temp_diff\")\n\n# Customize\nconfig['output']['output_dir'] = './my_results'\nconfig['output']['generate_plots'] = True\n\n# Save for later use\nimport yaml\nwith open('my_config.yaml', 'w') as f:\n    yaml.dump(config, f)\n</code></pre>"},{"location":"user-guide/applications/#application-lifecycle","title":"Application Lifecycle","text":""},{"location":"user-guide/applications/#complete-workflow","title":"Complete Workflow","text":"<pre><code>graph TD\n    A[Load App] --&gt;|apps.load_app| B[Qualify Building]\n    B --&gt;|app.qualify| C{Has Required&lt;br/&gt;Sensors?}\n    C --&gt;|No| D[Skip Building]\n    C --&gt;|Yes| E[Load Config]\n    E --&gt;|apps.get_default_config| F[Run Analysis]\n    F --&gt;|app.analyze| G[Generate Results]\n    G --&gt; H[Save Outputs]\n\n    style A fill:#e1f5ff\n    style C fill:#fff9c4\n    style G fill:#c8e6c9\n    style D fill:#ffcdd2</code></pre>"},{"location":"user-guide/applications/#step-by-step-example","title":"Step-by-Step Example","text":"<pre><code>\"\"\"\nComplete application workflow\nBased on examples/07_run_application.py\n\"\"\"\n\nfrom pathlib import Path\nfrom hhw_brick import apps\nimport yaml\n\ndef run_application_workflow(building_id, app_name):\n    \"\"\"Complete workflow for running an application.\"\"\"\n\n    # Paths\n    model_file = f\"brick_models/building_{building_id}.ttl\"\n    data_file = f\"timeseries_data/{building_id}_data.csv\"\n\n    print(f\"Running {app_name} on building {building_id}\")\n    print(\"=\"*60)\n\n    # ===== Step 1: Load Application =====\n    print(\"\\nStep 1: Load Application\")\n    app = apps.load_app(app_name)\n    print(f\"\u2713 Loaded {app_name}\")\n\n    # ===== Step 2: Qualify Building =====\n    print(\"\\nStep 2: Qualify Building\")\n    qualified, details = app.qualify(model_file)\n\n    if not qualified:\n        print(f\"\u2717 Building {building_id} not qualified\")\n        print(f\"  Reason: {details.get('reason', 'Missing required sensors')}\")\n        return None\n\n    print(f\"\u2713 Building {building_id} qualified\")\n    print(f\"  Found sensors:\")\n    for sensor_type, sensor_uri in details.items():\n        if sensor_uri and 'http' in str(sensor_uri):\n            sensor_name = str(sensor_uri).split('#')[-1]\n            print(f\"    - {sensor_type}: {sensor_name}\")\n\n    # ===== Step 3: Load Configuration =====\n    print(\"\\nStep 3: Load Configuration\")\n    config = apps.get_default_config(app_name)\n\n    # Customize config\n    config['output']['output_dir'] = f\"./results/{app_name}\"\n    config['output']['generate_plots'] = True\n\n    # Save config (optional)\n    config_file = f\"{app_name}_config.yaml\"\n    with open(config_file, 'w') as f:\n        yaml.dump(config, f)\n    print(f\"\u2713 Configuration ready\")\n    print(f\"  Output: {config['output']['output_dir']}\")\n\n    # ===== Step 4: Run Analysis =====\n    print(\"\\nStep 4: Run Analysis\")\n    print(f\"  Model: {model_file}\")\n    print(f\"  Data: {data_file}\")\n\n    results = app.analyze(\n        brick_model_path=model_file,\n        timeseries_data_path=data_file,\n        config=config\n    )\n\n    # ===== Display Results =====\n    print(\"\\n\" + \"=\"*60)\n    print(\"Analysis Results\")\n    print(\"=\"*60)\n\n    if 'summary' in results:\n        print(\"\\nSummary:\")\n        for key, value in results['summary'].items():\n            print(f\"  {key}: {value}\")\n\n    if 'outputs' in results:\n        print(\"\\nGenerated Files:\")\n        for output in results['outputs']:\n            print(f\"  \u2713 {output}\")\n\n    return results\n\n# Run it\nif __name__ == \"__main__\":\n    results = run_application_workflow(\n        building_id=\"105\",\n        app_name=\"secondary_loop_temp_diff\"\n    )\n</code></pre>"},{"location":"user-guide/applications/#batch-application","title":"Batch Application","text":""},{"location":"user-guide/applications/#qualify-multiple-buildings","title":"Qualify Multiple Buildings","text":"<p>From <code>examples/06_application_management.py</code>:</p> <pre><code>from hhw_brick import apps\n\n# Check all buildings in a directory\nbatch_results = apps.qualify_buildings(\"brick_models/\")\n\n# Analyze results\nfor building in batch_results:\n    building_name = Path(building['model']).stem\n    print(f\"\\nBuilding: {building_name}\")\n\n    for result in building['results']:\n        app_name = result['app']\n        qualified = result['qualified']\n\n        status = \"\u2713\" if qualified else \"\u2717\"\n        print(f\"  {status} {app_name}\")\n</code></pre>"},{"location":"user-guide/applications/#build-qualification-matrix","title":"Build Qualification Matrix","text":"<pre><code>\"\"\"\nCreate a matrix showing which buildings qualify for which apps\n\"\"\"\n\nfrom pathlib import Path\nfrom hhw_brick import apps\n\n# Batch qualify\nbatch_results = apps.qualify_buildings(\"brick_models/\")\n\n# Build matrix\napp_matrix = {}  # app -&gt; list of qualified buildings\nbuilding_matrix = {}  # building -&gt; list of qualified apps\n\nfor building in batch_results:\n    building_name = Path(building['model']).stem\n    building_matrix[building_name] = []\n\n    for r in building['results']:\n        app_name = r['app']\n\n        if app_name not in app_matrix:\n            app_matrix[app_name] = []\n\n        if r['qualified']:\n            app_matrix[app_name].append(building_name)\n            building_matrix[building_name].append(app_name)\n\n# Display by application\nprint(\"By Application:\")\nfor app_name, buildings in app_matrix.items():\n    print(f\"  {app_name}:\")\n    print(f\"    Qualified: {len(buildings)}/{len(batch_results)} buildings\")\n    for b in buildings[:5]:  # Show first 5\n        print(f\"      \u2713 {b}\")\n\n# Display by building\nprint(\"\\nBy Building:\")\nfor building_name, apps_list in building_matrix.items():\n    if apps_list:\n        print(f\"  {building_name}: {', '.join(apps_list)}\")\n</code></pre>"},{"location":"user-guide/applications/#batch-run-applications","title":"Batch Run Applications","text":"<pre><code>\"\"\"\nRun applications on all qualified buildings\n\"\"\"\n\nfrom hhw_brick import apps\nfrom pathlib import Path\nimport yaml\n\ndef batch_run_application(app_name, model_dir, data_dir, output_dir):\n    \"\"\"Run application on all qualified buildings.\"\"\"\n\n    # Load app\n    app = apps.load_app(app_name)\n    config = apps.get_default_config(app_name)\n\n    # Find all models\n    model_files = list(Path(model_dir).glob(\"*.ttl\"))\n\n    results_summary = {\n        'total': len(model_files),\n        'qualified': 0,\n        'analyzed': 0,\n        'failed': 0,\n        'results': []\n    }\n\n    for model_file in model_files:\n        building_id = model_file.stem.split('_')[1]  # Extract ID\n\n        # Qualify\n        qualified, details = app.qualify(str(model_file))\n\n        if not qualified:\n            continue\n\n        results_summary['qualified'] += 1\n\n        # Find corresponding data file\n        data_file = Path(data_dir) / f\"{building_id}_data.csv\"\n\n        if not data_file.exists():\n            print(f\"\u26a0 Data file not found for building {building_id}\")\n            results_summary['failed'] += 1\n            continue\n\n        try:\n            # Run analysis\n            result = app.analyze(\n                brick_model_path=str(model_file),\n                timeseries_data_path=str(data_file),\n                config=config\n            )\n\n            results_summary['analyzed'] += 1\n            results_summary['results'].append({\n                'building_id': building_id,\n                'status': 'success',\n                'summary': result.get('summary', {})\n            })\n\n            print(f\"\u2713 Building {building_id}\")\n\n        except Exception as e:\n            results_summary['failed'] += 1\n            results_summary['results'].append({\n                'building_id': building_id,\n                'status': 'failed',\n                'error': str(e)\n            })\n\n            print(f\"\u2717 Building {building_id}: {e}\")\n\n    # Summary\n    print(f\"\\n{'='*60}\")\n    print(f\"Batch Analysis Summary - {app_name}\")\n    print(f\"{'='*60}\")\n    print(f\"Total buildings: {results_summary['total']}\")\n    print(f\"Qualified: {results_summary['qualified']}\")\n    print(f\"Analyzed: {results_summary['analyzed']}\")\n    print(f\"Failed: {results_summary['failed']}\")\n\n    return results_summary\n\n# Use it\nresults = batch_run_application(\n    app_name=\"secondary_loop_temp_diff\",\n    model_dir=\"brick_models/\",\n    data_dir=\"timeseries_data/\",\n    output_dir=\"analysis_results/\"\n)\n</code></pre>"},{"location":"user-guide/applications/#application-interface","title":"Application Interface","text":""},{"location":"user-guide/applications/#standard-interface","title":"Standard Interface","text":"<p>All applications follow the same interface:</p> <pre><code># All apps have these three functions:\n\n__all__ = ['qualify', 'analyze', 'load_config']\n\ndef qualify(brick_model_path: str) -&gt; Tuple[bool, Dict]:\n    \"\"\"\n    Check if building has required sensors.\n\n    Returns:\n        (qualified, details) tuple\n        - qualified: True if building can use this app\n        - details: Dict with sensor URIs or qualification info\n    \"\"\"\n    pass\n\ndef analyze(brick_model_path: str,\n           timeseries_data_path: str,\n           config: Dict) -&gt; Dict:\n    \"\"\"\n    Run analysis on building data.\n\n    Returns:\n        Dict with analysis results, including:\n        - summary: Key metrics\n        - outputs: List of generated files\n        - data: Detailed results\n    \"\"\"\n    pass\n\ndef load_config(config_path: str = None) -&gt; Dict:\n    \"\"\"\n    Load application configuration.\n\n    Returns:\n        Configuration dictionary\n    \"\"\"\n    pass\n</code></pre>"},{"location":"user-guide/applications/#common-patterns","title":"Common Patterns","text":""},{"location":"user-guide/applications/#pattern-1-single-building-analysis","title":"Pattern 1: Single Building Analysis","text":"<pre><code># Load app\napp = apps.load_app(\"secondary_loop_temp_diff\")\n\n# Qualify\nqualified, details = app.qualify(\"building_105.ttl\")\n\nif qualified:\n    # Load config\n    config = apps.get_default_config(\"secondary_loop_temp_diff\")\n\n    # Run\n    results = app.analyze(\n        \"building_105.ttl\",\n        \"building_105_data.csv\",\n        config\n    )\n</code></pre>"},{"location":"user-guide/applications/#pattern-2-try-multiple-apps","title":"Pattern 2: Try Multiple Apps","text":"<pre><code># Try all apps on one building\navailable_apps = apps.list_apps()\nmodel_path = \"building_105.ttl\"\n\nfor app_info in available_apps:\n    app = apps.load_app(app_info['name'])\n    qualified, details = app.qualify(model_path)\n\n    if qualified:\n        print(f\"\u2713 Can run: {app_info['name']}\")\n        # Run it...\n    else:\n        print(f\"\u2717 Cannot run: {app_info['name']}\")\n</code></pre>"},{"location":"user-guide/applications/#pattern-3-conditional-analysis","title":"Pattern 3: Conditional Analysis","text":"<pre><code># Run different apps based on system type\nfrom hhw_brick.validation import SubgraphPatternValidator\n\npattern_validator = SubgraphPatternValidator()\nresult = pattern_validator.check_pattern_2_district_system(model_path)\n\nif result['matched']:\n    # District system - use district-specific apps\n    app = apps.load_app(\"district_efficiency\")\nelse:\n    # Boiler system - use boiler-specific apps  \n    app = apps.load_app(\"boiler_efficiency\")\n\n# Then qualify and analyze...\n</code></pre>"},{"location":"user-guide/applications/#configuration-management","title":"Configuration Management","text":""},{"location":"user-guide/applications/#default-configuration","title":"Default Configuration","text":"<pre><code># Get default config\nconfig = apps.get_default_config(\"secondary_loop_temp_diff\")\n\n# Typical structure:\n{\n    'analysis': {\n        'time_window': '1D',\n        'aggregation': 'mean'\n    },\n    'output': {\n        'save_results': True,\n        'output_dir': './results',\n        'generate_plots': True\n    }\n}\n</code></pre>"},{"location":"user-guide/applications/#custom-configuration","title":"Custom Configuration","text":"<pre><code>import yaml\n\n# Load and customize\nconfig = apps.get_default_config(\"secondary_loop_temp_diff\")\nconfig['output']['output_dir'] = './custom_results'\nconfig['output']['generate_plots'] = False\nconfig['analysis']['time_window'] = '6H'\n\n# Save\nwith open('custom_config.yaml', 'w') as f:\n    yaml.dump(config, f)\n\n# Load later\nwith open('custom_config.yaml', 'r') as f:\n    config = yaml.safe_load(f)\n\n# Use it\nresults = app.analyze(model_path, data_path, config)\n</code></pre>"},{"location":"user-guide/applications/#output-management","title":"Output Management","text":""},{"location":"user-guide/applications/#typical-outputs","title":"Typical Outputs","text":"<p>Applications generate various outputs:</p> <pre><code>results = app.analyze(model_path, data_path, config)\n\n# Results structure\n{\n    'summary': {\n        'mean_temp_diff': 5.2,\n        'max_temp_diff': 12.1,\n        'data_points': 8760\n    },\n    'outputs': [\n        'results/temp_diff_plot.png',\n        'results/statistics.csv',\n        'results/hourly_data.csv'\n    ],\n    'data': {\n        # Detailed results...\n    }\n}\n</code></pre>"},{"location":"user-guide/applications/#handling-outputs","title":"Handling Outputs","text":"<pre><code># Check generated files\nif 'outputs' in results:\n    print(\"Generated files:\")\n    for output_file in results['outputs']:\n        if Path(output_file).exists():\n            print(f\"  \u2713 {output_file}\")\n        else:\n            print(f\"  \u2717 {output_file} (not found)\")\n\n# Access summary metrics\nif 'summary' in results:\n    for metric, value in results['summary'].items():\n        print(f\"{metric}: {value}\")\n</code></pre>"},{"location":"user-guide/applications/#troubleshooting","title":"Troubleshooting","text":""},{"location":"user-guide/applications/#issue-app-not-found","title":"Issue: \"App not found\"","text":"<p>Solution: <pre><code># List available apps\nprint(apps.list_apps())\n\n# Use exact name\napp = apps.load_app(\"secondary_loop_temp_diff\")  # Correct\n# app = apps.load_app(\"secondary_loop\")  # Wrong\n</code></pre></p>"},{"location":"user-guide/applications/#issue-building-not-qualified","title":"Issue: Building not qualified","text":"<p>Investigation: <pre><code>qualified, details = app.qualify(\"building_105.ttl\")\n\nif not qualified:\n    print(\"Qualification failed:\")\n    print(f\"  Reason: {details.get('reason', 'Unknown')}\")\n    print(f\"  Missing: {details.get('missing', [])}\")\n</code></pre></p>"},{"location":"user-guide/applications/#issue-analysis-fails","title":"Issue: Analysis fails","text":"<p>Check: 1. Data file exists and is readable 2. Data format matches expected format 3. Configuration is valid</p> <pre><code># Debug\ntry:\n    results = app.analyze(model_path, data_path, config)\nexcept FileNotFoundError as e:\n    print(f\"File not found: {e}\")\nexcept Exception as e:\n    print(f\"Analysis failed: {e}\")\n    import traceback\n    traceback.print_exc()\n</code></pre>"},{"location":"user-guide/applications/#best-practices","title":"Best Practices","text":""},{"location":"user-guide/applications/#1-always-qualify-first","title":"1. Always Qualify First","text":"<pre><code># Good \u2713\nqualified, details = app.qualify(model_path)\nif qualified:\n    results = app.analyze(model_path, data_path, config)\n\n# Bad \u2717\n# Skip qualification - might fail\nresults = app.analyze(model_path, data_path, config)\n</code></pre>"},{"location":"user-guide/applications/#2-use-configuration-files","title":"2. Use Configuration Files","text":"<pre><code># Good \u2713 - Reusable configuration\nconfig = yaml.safe_load(open('config.yaml'))\nresults = app.analyze(model_path, data_path, config)\n\n# Bad \u2717 - Hard-coded config\nconfig = {'output': {'output_dir': './results'}}\n</code></pre>"},{"location":"user-guide/applications/#3-handle-failures-gracefully","title":"3. Handle Failures Gracefully","text":"<pre><code># Good \u2713\ntry:\n    results = app.analyze(model_path, data_path, config)\n    save_results(results)\nexcept Exception as e:\n    log_error(f\"Analysis failed: {e}\")\n    notify_admin()\n\n# Bad \u2717\nresults = app.analyze(model_path, data_path, config)\n# No error handling\n</code></pre>"},{"location":"user-guide/applications/#next-steps","title":"Next Steps","text":"<p>Learn about specific applications:</p> <ul> <li>Apps Manager - Detailed apps manager API</li> <li>Secondary Loop Temp Diff - Temperature difference analysis</li> <li>Primary Loop Temp Diff - Primary loop analysis</li> <li>Running Apps - Complete guide to running applications</li> </ul> <p>Or explore related topics:</p> <ul> <li>Developer Guide - Create your own applications</li> <li>Examples - Working code samples</li> </ul> <p>Continue to: Apps Manager Details \u2192</p>"},{"location":"user-guide/applications/apps-manager/","title":"Apps Manager","text":"<p>Detailed guide to the Apps Manager API for discovering and managing analytics applications.</p>"},{"location":"user-guide/applications/apps-manager/#overview","title":"Overview","text":"<p>The Apps Manager (<code>apps</code>) provides a simple interface to:</p> <ul> <li>Discover available applications</li> <li>Load applications dynamically</li> <li>Get information about applications</li> <li>Manage configurations</li> <li>Batch qualify buildings</li> </ul>"},{"location":"user-guide/applications/apps-manager/#importing-apps-manager","title":"Importing Apps Manager","text":"<pre><code>from hhw_brick import apps\n</code></pre> <p>The <code>apps</code> object is a singleton instance of <code>AppsManager</code> that provides all functionality.</p>"},{"location":"user-guide/applications/apps-manager/#core-functions","title":"Core Functions","text":""},{"location":"user-guide/applications/apps-manager/#list_apps","title":"list_apps()","text":"<p>List all available analytics applications.</p> <p>Signature: <pre><code>def list_apps() -&gt; List[Dict[str, str]]\n</code></pre></p> <p>Returns: <pre><code>[\n    {\n        'name': 'secondary_loop_temp_diff',\n        'description': 'Analyzes temperature difference in secondary hot water loop',\n        'path': '/path/to/app'\n    },\n    # ... more apps\n]\n</code></pre></p> <p>Example: <pre><code>from hhw_brick import apps\n\n# List all apps\navailable = apps.list_apps()\n\nprint(f\"Found {len(available)} applications:\")\nfor app in available:\n    print(f\"  \u2022 {app['name']}\")\n    print(f\"    {app['description']}\")\n</code></pre></p> <p>Output: <pre><code>Found 2 applications:\n  \u2022 secondary_loop_temp_diff\n    Analyzes temperature difference in secondary hot water loop\n  \u2022 primary_loop_temp_diff\n    Analyzes temperature difference in primary hot water loop\n</code></pre></p>"},{"location":"user-guide/applications/apps-manager/#load_app","title":"load_app()","text":"<p>Load an application by name.</p> <p>Signature: <pre><code>def load_app(app_name: str) -&gt; Module\n</code></pre></p> <p>Parameters: - <code>app_name</code> (str): Name of the application (e.g., \"secondary_loop_temp_diff\")</p> <p>Returns: - App module with <code>qualify()</code>, <code>analyze()</code>, and <code>load_config()</code> functions</p> <p>Example: <pre><code># Load application\napp = apps.load_app(\"secondary_loop_temp_diff\")\n\n# Now you can use app functions\nqualified, details = app.qualify(\"building_105.ttl\")\n</code></pre></p> <p>Raises: - <code>ImportError</code>: If app not found or cannot be loaded</p> <pre><code>try:\n    app = apps.load_app(\"non_existent_app\")\nexcept ImportError as e:\n    print(f\"Error: {e}\")\n</code></pre>"},{"location":"user-guide/applications/apps-manager/#get_app_info","title":"get_app_info()","text":"<p>Get detailed information about an application.</p> <p>Signature: <pre><code>def get_app_info(app_name: str) -&gt; Dict[str, Any]\n</code></pre></p> <p>Returns: <pre><code>{\n    'name': 'secondary_loop_temp_diff',\n    'description': 'Analyzes temperature difference in secondary hot water loop',\n    'functions': [\n        {'name': 'qualify', 'signature': '...'},\n        {'name': 'analyze', 'signature': '...'},\n        {'name': 'load_config', 'signature': '...'}\n    ]\n}\n</code></pre></p> <p>Example: <pre><code>info = apps.get_app_info(\"secondary_loop_temp_diff\")\n\nprint(f\"App: {info['name']}\")\nprint(f\"Description: {info['description']}\")\nprint(f\"Functions:\")\nfor func in info['functions']:\n    print(f\"  - {func['name']}\")\n</code></pre></p>"},{"location":"user-guide/applications/apps-manager/#get_default_config","title":"get_default_config()","text":"<p>Get default configuration template for an application.</p> <p>Signature: <pre><code>def get_default_config(app_name: str) -&gt; Dict[str, Any]\n</code></pre></p> <p>Returns: <pre><code>{\n    'analysis': {\n        'threshold_min_delta': 0.5,\n        'threshold_max_delta': 10.0\n    },\n    'output': {\n        'save_results': True,\n        'output_dir': './results',\n        'generate_plots': True\n    }\n}\n</code></pre></p> <p>Example: <pre><code># Get default config\nconfig = apps.get_default_config(\"secondary_loop_temp_diff\")\n\n# Customize\nconfig['output']['output_dir'] = './my_results'\nconfig['analysis']['threshold_min_delta'] = 1.0\n\n# Use it\nresults = app.analyze(model_path, data_path, config)\n</code></pre></p>"},{"location":"user-guide/applications/apps-manager/#batch-operations","title":"Batch Operations","text":""},{"location":"user-guide/applications/apps-manager/#qualify_building","title":"qualify_building()","text":"<p>Qualify a single building against all available applications.</p> <p>Signature: <pre><code>def qualify_building(model_path: str, verbose: bool = True) -&gt; Dict\n</code></pre></p> <p>Parameters: - <code>model_path</code> (str): Path to Brick model file - <code>verbose</code> (bool): Print detailed output (default: True)</p> <p>Returns: <pre><code>{\n    'model': 'building_105.ttl',\n    'results': [\n        {\n            'app': 'secondary_loop_temp_diff',\n            'qualified': True,\n            'details': {...}\n        },\n        {\n            'app': 'primary_loop_temp_diff',\n            'qualified': False,\n            'details': {...}\n        }\n    ]\n}\n</code></pre></p> <p>Example: <pre><code>from hhw_brick import apps\n\n# Qualify one building\nresult = apps.qualify_building(\"building_105.ttl\")\n\nprint(f\"Building: {result['model']}\")\nfor r in result['results']:\n    status = \"\u2713\" if r['qualified'] else \"\u2717\"\n    print(f\"  {status} {r['app']}\")\n</code></pre></p> <p>With verbose=False: <pre><code># Silent qualification (no print output)\nresult = apps.qualify_building(\"building_105.ttl\", verbose=False)\n\n# Process results programmatically\nqualified_apps = [\n    r['app'] for r in result['results'] if r['qualified']\n]\nprint(f\"Qualified for: {', '.join(qualified_apps)}\")\n</code></pre></p>"},{"location":"user-guide/applications/apps-manager/#qualify_buildings","title":"qualify_buildings()","text":"<p>Qualify multiple buildings against all applications.</p> <p>Signature: <pre><code>def qualify_buildings(model_dir: str, verbose: bool = False) -&gt; List[Dict]\n</code></pre></p> <p>Parameters: - <code>model_dir</code> (str): Directory containing Brick model files - <code>verbose</code> (bool): Print progress (default: False)</p> <p>Returns: <pre><code>[\n    {\n        'model': 'building_105.ttl',\n        'results': [\n            {'app': 'secondary_loop_temp_diff', 'qualified': True, 'details': {...}},\n            {'app': 'primary_loop_temp_diff', 'qualified': False, 'details': {...}}\n        ]\n    },\n    # ... more buildings\n]\n</code></pre></p> <p>Example: <pre><code>from hhw_brick import apps\nfrom pathlib import Path\n\n# Batch qualify\nbatch_results = apps.qualify_buildings(\"brick_models/\")\n\n# Analyze results\nfor building in batch_results:\n    building_name = Path(building['model']).stem\n    qualified_apps = [\n        r['app'] for r in building['results'] if r['qualified']\n    ]\n\n    if qualified_apps:\n        print(f\"{building_name}: {', '.join(qualified_apps)}\")\n    else:\n        print(f\"{building_name}: No apps available\")\n</code></pre></p>"},{"location":"user-guide/applications/apps-manager/#advanced-usage","title":"Advanced Usage","text":""},{"location":"user-guide/applications/apps-manager/#building-qualification-matrix","title":"Building Qualification Matrix","text":"<p>Create a comprehensive view of which buildings qualify for which apps:</p> <pre><code>\"\"\"\nBuild a qualification matrix\n\"\"\"\nfrom hhw_brick import apps\nfrom pathlib import Path\n\ndef build_qualification_matrix(model_dir):\n    \"\"\"Build matrix of buildings vs applications.\"\"\"\n\n    # Batch qualify\n    batch_results = apps.qualify_buildings(model_dir)\n\n    # Initialize matrices\n    app_to_buildings = {}  # app -&gt; [buildings]\n    building_to_apps = {}  # building -&gt; [apps]\n\n    # Process results\n    for building in batch_results:\n        building_name = Path(building['model']).stem\n        building_to_apps[building_name] = []\n\n        for result in building['results']:\n            app_name = result['app']\n\n            # Initialize app entry\n            if app_name not in app_to_buildings:\n                app_to_buildings[app_name] = []\n\n            # Record qualification\n            if result['qualified']:\n                app_to_buildings[app_name].append(building_name)\n                building_to_apps[building_name].append(app_name)\n\n    return {\n        'by_app': app_to_buildings,\n        'by_building': building_to_apps,\n        'total_buildings': len(batch_results)\n    }\n\n# Use it\nmatrix = build_qualification_matrix(\"brick_models/\")\n\n# Display by application\nprint(\"Qualification by Application:\")\nfor app_name, buildings in matrix['by_app'].items():\n    pct = len(buildings) / matrix['total_buildings'] * 100\n    print(f\"  {app_name}:\")\n    print(f\"    {len(buildings)}/{matrix['total_buildings']} ({pct:.1f}%)\")\n\n# Display by building\nprint(\"\\nQualification by Building:\")\nfor building, apps_list in matrix['by_building'].items():\n    if apps_list:\n        print(f\"  {building}: {', '.join(apps_list)}\")\n</code></pre>"},{"location":"user-guide/applications/apps-manager/#export-qualification-results","title":"Export Qualification Results","text":"<p>Save qualification results to CSV:</p> <pre><code>\"\"\"\nExport qualification matrix to CSV\n\"\"\"\nimport pandas as pd\nfrom hhw_brick import apps\n\ndef export_qualification_matrix(model_dir, output_csv):\n    \"\"\"Export qualification results to CSV.\"\"\"\n\n    batch_results = apps.qualify_buildings(model_dir)\n\n    # Flatten results for CSV\n    rows = []\n    for building in batch_results:\n        building_name = Path(building['model']).stem\n\n        for result in building['results']:\n            rows.append({\n                'building': building_name,\n                'application': result['app'],\n                'qualified': result['qualified']\n            })\n\n    # Create DataFrame\n    df = pd.DataFrame(rows)\n\n    # Pivot for matrix view\n    matrix = df.pivot(\n        index='building',\n        columns='application',\n        values='qualified'\n    )\n\n    # Save\n    matrix.to_csv(output_csv)\n    print(f\"Saved qualification matrix to: {output_csv}\")\n\n    # Summary\n    print(f\"\\nSummary:\")\n    for app in matrix.columns:\n        qualified_count = matrix[app].sum()\n        total = len(matrix)\n        print(f\"  {app}: {qualified_count}/{total} buildings\")\n\n    return matrix\n\n# Use it\nmatrix = export_qualification_matrix(\n    \"brick_models/\",\n    \"qualification_matrix.csv\"\n)\n</code></pre>"},{"location":"user-guide/applications/apps-manager/#dynamic-app-loading","title":"Dynamic App Loading","text":"<p>Load apps dynamically based on conditions:</p> <pre><code>\"\"\"\nDynamically select and load apps\n\"\"\"\nfrom hhw_brick import apps\n\ndef select_app_for_building(model_path, preferred_apps=None):\n    \"\"\"\n    Select best app for a building.\n\n    Args:\n        model_path: Path to Brick model\n        preferred_apps: List of preferred app names (in priority order)\n\n    Returns:\n        Tuple of (app_module, app_name) or (None, None)\n    \"\"\"\n    # Get all available apps\n    available = apps.list_apps()\n\n    # Set default preference\n    if preferred_apps is None:\n        preferred_apps = [a['name'] for a in available]\n\n    # Try apps in order of preference\n    for app_name in preferred_apps:\n        try:\n            app = apps.load_app(app_name)\n            qualified, details = app.qualify(model_path)\n\n            if qualified:\n                return app, app_name\n        except Exception as e:\n            print(f\"Error loading {app_name}: {e}\")\n            continue\n\n    return None, None\n\n# Use it\nmodel_path = \"building_105.ttl\"\npreferred = [\"secondary_loop_temp_diff\", \"primary_loop_temp_diff\"]\n\napp, app_name = select_app_for_building(model_path, preferred)\n\nif app:\n    print(f\"Selected: {app_name}\")\n    # Run analysis\n    config = apps.get_default_config(app_name)\n    results = app.analyze(model_path, data_path, config)\nelse:\n    print(\"No suitable app found\")\n</code></pre>"},{"location":"user-guide/applications/apps-manager/#configuration-management","title":"Configuration Management","text":""},{"location":"user-guide/applications/apps-manager/#load-configuration-from-file","title":"Load Configuration from File","text":"<pre><code>import yaml\n\n# Create config file\nconfig = apps.get_default_config(\"secondary_loop_temp_diff\")\nwith open('my_config.yaml', 'w') as f:\n    yaml.dump(config, f)\n\n# Load and use\nwith open('my_config.yaml', 'r') as f:\n    config = yaml.safe_load(f)\n\nresults = app.analyze(model_path, data_path, config)\n</code></pre>"},{"location":"user-guide/applications/apps-manager/#configuration-templates","title":"Configuration Templates","text":"<pre><code>\"\"\"\nCreate configuration templates for all apps\n\"\"\"\nfrom hhw_brick import apps\nimport yaml\nfrom pathlib import Path\n\ndef create_config_templates(output_dir):\n    \"\"\"Create config templates for all apps.\"\"\"\n\n    output_path = Path(output_dir)\n    output_path.mkdir(exist_ok=True)\n\n    available = apps.list_apps()\n\n    for app_info in available:\n        app_name = app_info['name']\n        config = apps.get_default_config(app_name)\n\n        config_file = output_path / f\"{app_name}_config.yaml\"\n        with open(config_file, 'w') as f:\n            yaml.dump(config, f, default_flow_style=False)\n\n        print(f\"Created: {config_file}\")\n\n# Use it\ncreate_config_templates(\"config_templates/\")\n</code></pre>"},{"location":"user-guide/applications/apps-manager/#error-handling","title":"Error Handling","text":""},{"location":"user-guide/applications/apps-manager/#handle-missing-apps","title":"Handle Missing Apps","text":"<pre><code>from hhw_brick import apps\n\napp_name = \"my_custom_app\"\n\ntry:\n    app = apps.load_app(app_name)\nexcept ImportError:\n    print(f\"App '{app_name}' not found\")\n    print(\"Available apps:\")\n    for a in apps.list_apps():\n        print(f\"  - {a['name']}\")\n</code></pre>"},{"location":"user-guide/applications/apps-manager/#handle-qualification-failures","title":"Handle Qualification Failures","text":"<pre><code>app = apps.load_app(\"secondary_loop_temp_diff\")\nqualified, details = app.qualify(\"building_105.ttl\")\n\nif not qualified:\n    print(\"Building not qualified\")\n\n    # Check details for reason\n    if 'reason' in details:\n        print(f\"Reason: {details['reason']}\")\n\n    if 'missing' in details:\n        print(f\"Missing: {details['missing']}\")\n</code></pre>"},{"location":"user-guide/applications/apps-manager/#best-practices","title":"Best Practices","text":""},{"location":"user-guide/applications/apps-manager/#1-check-available-apps-first","title":"1. Check Available Apps First","text":"<pre><code># Good \u2713\navailable = apps.list_apps()\nif available:\n    app = apps.load_app(available[0]['name'])\n\n# Bad \u2717\napp = apps.load_app(\"some_app\")  # Might not exist\n</code></pre>"},{"location":"user-guide/applications/apps-manager/#2-always-qualify-before-analyzing","title":"2. Always Qualify Before Analyzing","text":"<pre><code># Good \u2713\nqualified, details = app.qualify(model_path)\nif qualified:\n    results = app.analyze(model_path, data_path, config)\n\n# Bad \u2717\nresults = app.analyze(model_path, data_path, config)  # Might fail\n</code></pre>"},{"location":"user-guide/applications/apps-manager/#3-use-configuration-files","title":"3. Use Configuration Files","text":"<pre><code># Good \u2713 - Maintainable\nconfig = yaml.safe_load(open('config.yaml'))\n\n# Bad \u2717 - Hard-coded\nconfig = {'output': {'output_dir': './results'}}\n</code></pre>"},{"location":"user-guide/applications/apps-manager/#4-handle-errors-gracefully","title":"4. Handle Errors Gracefully","text":"<pre><code># Good \u2713\ntry:\n    app = apps.load_app(app_name)\n    qualified, details = app.qualify(model_path)\n    if qualified:\n        results = app.analyze(model_path, data_path, config)\nexcept ImportError:\n    print(f\"App not found: {app_name}\")\nexcept FileNotFoundError:\n    print(f\"File not found\")\nexcept Exception as e:\n    print(f\"Error: {e}\")\n</code></pre>"},{"location":"user-guide/applications/apps-manager/#api-reference-summary","title":"API Reference Summary","text":"Function Purpose Returns <code>list_apps()</code> List all applications List of app info dicts <code>load_app(name)</code> Load an application App module <code>get_app_info(name)</code> Get app details Info dict <code>get_default_config(name)</code> Get default config Config dict <code>qualify_building(path)</code> Qualify one building Qualification result <code>qualify_buildings(dir)</code> Qualify multiple buildings List of results"},{"location":"user-guide/applications/apps-manager/#next-steps","title":"Next Steps","text":"<ul> <li>Secondary Loop App - Learn about temperature difference analysis</li> <li>Running Apps - Complete guide to running applications</li> <li>Developer Guide - Create your own apps</li> </ul> <p>Continue to: Secondary Loop Temperature Difference \u2192</p>"},{"location":"user-guide/applications/running-apps/","title":"Running Applications","text":"<p>Complete guide to running analytics applications on building data.</p>"},{"location":"user-guide/applications/running-apps/#overview","title":"Overview","text":"<p>This guide covers the complete workflow for running applications, including:</p> <ul> <li>Preparation - Setting up data and models</li> <li>Qualification - Checking building compatibility</li> <li>Configuration - Customizing analysis parameters</li> <li>Execution - Running the analysis</li> <li>Results - Understanding and using outputs</li> </ul>"},{"location":"user-guide/applications/running-apps/#complete-workflow","title":"Complete Workflow","text":""},{"location":"user-guide/applications/running-apps/#end-to-end-example","title":"End-to-End Example","text":"<p>Based on <code>examples/07_run_application.py</code>:</p> <pre><code>\"\"\"\nComplete workflow: Convert \u2192 Validate \u2192 Analyze\n\"\"\"\n\nfrom pathlib import Path\nfrom hhw_brick import (\n    CSVToBrickConverter,\n    BrickModelValidator,\n    apps\n)\nimport yaml\n\ndef complete_workflow(building_id):\n    \"\"\"Complete workflow from CSV to analysis results.\"\"\"\n\n    # ===== Step 1: Convert CSV to Brick =====\n    print(\"Step 1: Convert CSV to Brick\")\n    print(\"=\"*60)\n\n    converter = CSVToBrickConverter()\n    model_file = f\"building_{building_id}.ttl\"\n\n    converter.convert_to_brick(\n        metadata_csv=\"metadata.csv\",\n        vars_csv=\"vars.csv\",\n        building_tag=building_id,\n        output_path=model_file\n    )\n    print(f\"\u2713 Created Brick model: {model_file}\\n\")\n\n    # ===== Step 2: Validate Model =====\n    print(\"Step 2: Validate Model\")\n    print(\"=\"*60)\n\n    validator = BrickModelValidator(use_local_brick=True)\n    is_valid = validator.validate_ontology(model_file)['valid']\n\n    if not is_valid:\n        print(\"\u2717 Model validation failed\\n\")\n        return None\n\n    print(f\"\u2713 Model is valid\\n\")\n\n    # ===== Step 3: Discover Available Apps =====\n    print(\"Step 3: Discover Available Apps\")\n    print(\"=\"*60)\n\n    available_apps = apps.list_apps()\n    print(f\"Found {len(available_apps)} applications:\")\n    for app_info in available_apps:\n        print(f\"  \u2022 {app_info['name']}\")\n    print()\n\n    # ===== Step 4: Qualify Building =====\n    print(\"Step 4: Qualify Building\")\n    print(\"=\"*60)\n\n    result = apps.qualify_building(model_file, verbose=False)\n\n    qualified_apps = [\n        r['app'] for r in result['results'] if r['qualified']\n    ]\n\n    if not qualified_apps:\n        print(f\"\u2717 Building {building_id} not qualified for any apps\\n\")\n        return None\n\n    print(f\"\u2713 Qualified for: {', '.join(qualified_apps)}\\n\")\n\n    # ===== Step 5: Run Analysis =====\n    print(\"Step 5: Run Analysis\")\n    print(\"=\"*60)\n\n    app_name = qualified_apps[0]  # Use first qualified app\n    app = apps.load_app(app_name)\n\n    # Load config\n    config = apps.get_default_config(app_name)\n    config['output']['output_dir'] = f\"./results/building_{building_id}\"\n\n    # Run analysis\n    data_file = f\"{building_id}_data.csv\"\n    results = app.analyze(model_file, data_file, config)\n\n    print(f\"\u2713 Analysis complete: {app_name}\")\n    print(f\"\\nSummary:\")\n    for key, value in results['summary'].items():\n        print(f\"  {key}: {value}\")\n\n    print(f\"\\nOutputs:\")\n    for output in results['outputs']:\n        print(f\"  - {output}\")\n\n    return results\n\n# Run it\nif __name__ == \"__main__\":\n    results = complete_workflow(\"105\")\n</code></pre>"},{"location":"user-guide/applications/running-apps/#preparation","title":"Preparation","text":""},{"location":"user-guide/applications/running-apps/#required-files","title":"Required Files","text":"<p>Before running an application, prepare:</p> File Description Example Brick Model TTL file with building model <code>building_105.ttl</code> Timeseries Data CSV with sensor data <code>105_data.csv</code> Configuration (optional) YAML with analysis settings <code>config.yaml</code>"},{"location":"user-guide/applications/running-apps/#data-file-requirements","title":"Data File Requirements","text":"<p>Timeseries CSV format:</p> <pre><code>datetime,secondary_supply_temp,secondary_return_temp,flow_rate\n2024-01-01 00:00:00,70.5,65.3,150.2\n2024-01-01 01:00:00,71.2,66.1,155.8\n2024-01-01 02:00:00,69.8,64.7,148.3\n...\n</code></pre> <p>Requirements: - \u2713 <code>datetime</code> column (timestamp) - \u2713 Sensor data columns (names can vary) - \u2713 Numeric values - \u2713 No missing critical timestamps</p>"},{"location":"user-guide/applications/running-apps/#verify-data-quality","title":"Verify Data Quality","text":"<pre><code>import pandas as pd\n\n# Load data\ndf = pd.read_csv(\"105_data.csv\", parse_dates=['datetime'])\n\n# Check quality\nprint(f\"Data points: {len(df)}\")\nprint(f\"Date range: {df['datetime'].min()} to {df['datetime'].max()}\")\nprint(f\"Columns: {df.columns.tolist()}\")\n\n# Check for missing values\nmissing = df.isnull().sum()\nif missing.any():\n    print(\"\\nMissing values:\")\n    print(missing[missing &gt; 0])\n</code></pre>"},{"location":"user-guide/applications/running-apps/#application-types","title":"Application Types","text":""},{"location":"user-guide/applications/running-apps/#primary-loop-temperature-difference","title":"Primary Loop Temperature Difference","text":"<p>Analyzes primary loop (boiler-side) temperature difference.</p> <p>Required Sensors: - Primary supply temperature - Primary return temperature</p> <p>Use Cases: - Boiler efficiency monitoring - Primary loop performance - Heat exchanger effectiveness</p> <p>Quick Example: <pre><code>app = apps.load_app(\"primary_loop_temp_diff\")\n\n# Qualify\nqualified, details = app.qualify(\"building_105.ttl\")\n\nif qualified:\n    # Get config\n    config = apps.get_default_config(\"primary_loop_temp_diff\")\n\n    # Run\n    results = app.analyze(\n        \"building_105.ttl\",\n        \"105_data.csv\",\n        config\n    )\n\n    print(f\"Primary loop temp diff: {results['summary']['mean_temp_diff']:.2f}\u00b0C\")\n</code></pre></p> <p>Similar to Secondary Loop:</p> <p>The primary loop app works identically to the secondary loop app, but: - Looks for primary loop sensors (not secondary) - Analyzes boiler-side temperatures - Useful for boiler systems (not district systems)</p> <p>See Secondary Loop for detailed documentation - the workflow is the same.</p>"},{"location":"user-guide/applications/running-apps/#secondary-loop-temperature-difference","title":"Secondary Loop Temperature Difference","text":"<p>See Secondary Loop App for complete documentation.</p>"},{"location":"user-guide/applications/running-apps/#batch-processing","title":"Batch Processing","text":""},{"location":"user-guide/applications/running-apps/#run-on-multiple-buildings","title":"Run on Multiple Buildings","text":"<pre><code>\"\"\"\nBatch process multiple buildings\n\"\"\"\nfrom pathlib import Path\nfrom hhw_brick import apps\n\ndef batch_run_app(app_name, model_dir, data_dir, output_base):\n    \"\"\"Run app on all qualified buildings.\"\"\"\n\n    # Load app\n    app = apps.load_app(app_name)\n    base_config = apps.get_default_config(app_name)\n\n    # Find models\n    model_files = list(Path(model_dir).glob(\"*.ttl\"))\n\n    results_summary = []\n\n    for model_file in model_files:\n        building_id = model_file.stem.split('_')[1]\n\n        # Qualify\n        qualified, details = app.qualify(str(model_file))\n        if not qualified:\n            print(f\"\u2298 Building {building_id}: Not qualified\")\n            continue\n\n        # Find data\n        data_file = Path(data_dir) / f\"{building_id}_data.csv\"\n        if not data_file.exists():\n            print(f\"\u2298 Building {building_id}: Data file not found\")\n            continue\n\n        # Configure\n        config = base_config.copy()\n        config['output']['output_dir'] = f\"{output_base}/building_{building_id}\"\n\n        # Run\n        try:\n            results = app.analyze(str(model_file), str(data_file), config)\n\n            results_summary.append({\n                'building_id': building_id,\n                'status': 'success',\n                'mean_temp_diff': results['summary']['mean_temp_diff'],\n                'data_points': results['summary']['data_points']\n            })\n\n            print(f\"\u2713 Building {building_id}: {results['summary']['mean_temp_diff']:.2f}\u00b0C\")\n\n        except Exception as e:\n            results_summary.append({\n                'building_id': building_id,\n                'status': 'failed',\n                'error': str(e)\n            })\n            print(f\"\u2717 Building {building_id}: {e}\")\n\n    # Summary\n    print(f\"\\n{'='*60}\")\n    print(f\"Batch Analysis Summary - {app_name}\")\n    print(f\"{'='*60}\")\n\n    successful = [r for r in results_summary if r['status'] == 'success']\n    failed = [r for r in results_summary if r['status'] == 'failed']\n\n    print(f\"Total: {len(model_files)}\")\n    print(f\"Analyzed: {len(successful)}\")\n    print(f\"Failed: {len(failed)}\")\n\n    if successful:\n        avg_temp_diff = sum(r['mean_temp_diff'] for r in successful) / len(successful)\n        print(f\"\\nAverage temp diff: {avg_temp_diff:.2f}\u00b0C\")\n\n    return results_summary\n\n# Use it\nresults = batch_run_app(\n    app_name=\"secondary_loop_temp_diff\",\n    model_dir=\"brick_models/\",\n    data_dir=\"timeseries_data/\",\n    output_base=\"./results\"\n)\n</code></pre>"},{"location":"user-guide/applications/running-apps/#parallel-batch-processing","title":"Parallel Batch Processing","text":"<pre><code>\"\"\"\nRun apps in parallel for faster processing\n\"\"\"\nfrom concurrent.futures import ProcessPoolExecutor, as_completed\nfrom hhw_brick import apps\n\ndef analyze_one_building(args):\n    \"\"\"Analyze one building (for parallel processing).\"\"\"\n    model_file, data_file, app_name, config = args\n\n    try:\n        app = apps.load_app(app_name)\n        results = app.analyze(str(model_file), str(data_file), config)\n        return {\n            'building': model_file.stem,\n            'status': 'success',\n            'summary': results['summary']\n        }\n    except Exception as e:\n        return {\n            'building': model_file.stem,\n            'status': 'failed',\n            'error': str(e)\n        }\n\ndef parallel_batch_run(app_name, model_dir, data_dir, max_workers=4):\n    \"\"\"Run app in parallel.\"\"\"\n\n    from pathlib import Path\n\n    app = apps.load_app(app_name)\n    config = apps.get_default_config(app_name)\n\n    # Prepare tasks\n    tasks = []\n    for model_file in Path(model_dir).glob(\"*.ttl\"):\n        building_id = model_file.stem.split('_')[1]\n\n        # Qualify\n        qualified, _ = app.qualify(str(model_file))\n        if not qualified:\n            continue\n\n        # Find data\n        data_file = Path(data_dir) / f\"{building_id}_data.csv\"\n        if not data_file.exists():\n            continue\n\n        # Configure\n        bldg_config = config.copy()\n        bldg_config['output']['output_dir'] = f\"./results/building_{building_id}\"\n\n        tasks.append((model_file, data_file, app_name, bldg_config))\n\n    # Execute in parallel\n    results = []\n    with ProcessPoolExecutor(max_workers=max_workers) as executor:\n        futures = {\n            executor.submit(analyze_one_building, task): task[0]\n            for task in tasks\n        }\n\n        for future in as_completed(futures):\n            result = future.result()\n            results.append(result)\n\n            status = \"\u2713\" if result['status'] == 'success' else \"\u2717\"\n            print(f\"{status} {result['building']}\")\n\n    return results\n\n# Use it\nresults = parallel_batch_run(\n    \"secondary_loop_temp_diff\",\n    \"brick_models/\",\n    \"timeseries_data/\",\n    max_workers=8\n)\n</code></pre>"},{"location":"user-guide/applications/running-apps/#configuration-management","title":"Configuration Management","text":""},{"location":"user-guide/applications/running-apps/#configuration-file-structure","title":"Configuration File Structure","text":"<pre><code># app_config.yaml\n\nanalysis:\n  # Analysis-specific parameters\n  threshold_min_delta: 0.5\n  threshold_max_delta: 10.0\n\noutput:\n  # Output settings\n  save_results: true\n  output_dir: ./results\n  export_format: csv\n  generate_plots: true\n  plot_format: png\n\ntime_range:\n  # Optional time filtering\n  start_time: \"2024-01-01 00:00:00\"\n  end_time: \"2024-12-31 23:59:59\"\n</code></pre>"},{"location":"user-guide/applications/running-apps/#using-configuration-files","title":"Using Configuration Files","text":"<pre><code>import yaml\n\n# Load config from file\nwith open('app_config.yaml', 'r') as f:\n    config = yaml.safe_load(f)\n\n# Use it\nresults = app.analyze(model_path, data_path, config)\n</code></pre>"},{"location":"user-guide/applications/running-apps/#dynamic-configuration","title":"Dynamic Configuration","text":"<pre><code>\"\"\"\nGenerate configs for different scenarios\n\"\"\"\n\ndef create_seasonal_configs(base_config, year=2024):\n    \"\"\"Create configs for seasonal analysis.\"\"\"\n\n    seasons = {\n        'winter': ('01-01', '03-31'),\n        'spring': ('04-01', '06-30'),\n        'summer': ('07-01', '09-30'),\n        'fall': ('10-01', '12-31')\n    }\n\n    configs = {}\n    for season, (start, end) in seasons.items():\n        config = base_config.copy()\n        config['time_range']['start_time'] = f\"{year}-{start} 00:00:00\"\n        config['time_range']['end_time'] = f\"{year}-{end} 23:59:59\"\n        config['output']['output_dir'] = f\"./results/{season}_{year}\"\n        configs[season] = config\n\n    return configs\n\n# Use it\nbase = apps.get_default_config(\"secondary_loop_temp_diff\")\nseasonal_configs = create_seasonal_configs(base, 2024)\n\nfor season, config in seasonal_configs.items():\n    results = app.analyze(model_path, data_path, config)\n    print(f\"{season}: {results['summary']['mean_temp_diff']:.2f}\u00b0C\")\n</code></pre>"},{"location":"user-guide/applications/running-apps/#results-management","title":"Results Management","text":""},{"location":"user-guide/applications/running-apps/#saving-results","title":"Saving Results","text":"<pre><code>\"\"\"\nSave and organize results\n\"\"\"\nimport json\nfrom datetime import datetime\n\ndef save_analysis_results(results, building_id, app_name, output_dir):\n    \"\"\"Save results with metadata.\"\"\"\n\n    from pathlib import Path\n    import pandas as pd\n\n    output_path = Path(output_dir)\n    output_path.mkdir(parents=True, exist_ok=True)\n\n    # Save summary as JSON\n    summary_file = output_path / f\"{building_id}_{app_name}_summary.json\"\n    summary_data = {\n        'building_id': building_id,\n        'app_name': app_name,\n        'analysis_date': datetime.now().isoformat(),\n        'summary': results['summary']\n    }\n    with open(summary_file, 'w') as f:\n        json.dump(summary_data, f, indent=2)\n\n    # Save detailed data as CSV\n    if 'data' in results:\n        data_file = output_path / f\"{building_id}_{app_name}_data.csv\"\n        df = pd.DataFrame(results['data'])\n        df.to_csv(data_file, index=False)\n\n    print(f\"Saved results to: {output_dir}\")\n\n# Use it\nresults = app.analyze(model_path, data_path, config)\nsave_analysis_results(results, \"105\", \"secondary_loop_temp_diff\", \"./results\")\n</code></pre>"},{"location":"user-guide/applications/running-apps/#aggregating-results","title":"Aggregating Results","text":"<pre><code>\"\"\"\nAggregate results from multiple buildings\n\"\"\"\nimport pandas as pd\n\ndef aggregate_building_results(results_dir):\n    \"\"\"Aggregate results from multiple analyses.\"\"\"\n\n    from pathlib import Path\n    import json\n\n    summary_files = Path(results_dir).rglob(\"*_summary.json\")\n\n    all_results = []\n    for file in summary_files:\n        with open(file, 'r') as f:\n            data = json.load(f)\n            all_results.append({\n                'building_id': data['building_id'],\n                'app': data['app_name'],\n                **data['summary']\n            })\n\n    # Create DataFrame\n    df = pd.DataFrame(all_results)\n\n    # Calculate statistics\n    print(\"Aggregated Results:\")\n    print(f\"  Total buildings: {len(df)}\")\n    print(f\"  Average temp diff: {df['mean_temp_diff'].mean():.2f}\u00b0C\")\n    print(f\"  Min temp diff: {df['mean_temp_diff'].min():.2f}\u00b0C\")\n    print(f\"  Max temp diff: {df['mean_temp_diff'].max():.2f}\u00b0C\")\n\n    # Save aggregate\n    df.to_csv(Path(results_dir) / \"aggregate_results.csv\", index=False)\n\n    return df\n\n# Use it\naggregate_df = aggregate_building_results(\"./results\")\n</code></pre>"},{"location":"user-guide/applications/running-apps/#error-handling","title":"Error Handling","text":""},{"location":"user-guide/applications/running-apps/#robust-execution","title":"Robust Execution","text":"<pre><code>\"\"\"\nProduction-ready application runner\n\"\"\"\nimport logging\nfrom pathlib import Path\n\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\ndef safe_run_app(model_path, data_path, app_name, config):\n    \"\"\"Run app with comprehensive error handling.\"\"\"\n\n    from hhw_brick import apps\n\n    try:\n        # Load app\n        app = apps.load_app(app_name)\n        logger.info(f\"Loaded app: {app_name}\")\n\n    except ImportError as e:\n        logger.error(f\"App not found: {app_name}\")\n        return None\n\n    try:\n        # Qualify\n        qualified, details = app.qualify(model_path)\n\n        if not qualified:\n            logger.warning(f\"Building not qualified for {app_name}\")\n            return None\n\n        logger.info(f\"Building qualified\")\n\n    except FileNotFoundError:\n        logger.error(f\"Model file not found: {model_path}\")\n        return None\n    except Exception as e:\n        logger.error(f\"Qualification failed: {e}\")\n        return None\n\n    try:\n        # Analyze\n        results = app.analyze(model_path, data_path, config)\n        logger.info(f\"Analysis complete\")\n        return results\n\n    except FileNotFoundError:\n        logger.error(f\"Data file not found: {data_path}\")\n        return None\n    except KeyError as e:\n        logger.error(f\"Missing data column: {e}\")\n        return None\n    except Exception as e:\n        logger.error(f\"Analysis failed: {e}\", exc_info=True)\n        return None\n\n# Use it\nresults = safe_run_app(\n    \"building_105.ttl\",\n    \"105_data.csv\",\n    \"secondary_loop_temp_diff\",\n    config\n)\n\nif results:\n    print(\"\u2713 Analysis successful\")\nelse:\n    print(\"\u2717 Analysis failed - check logs\")\n</code></pre>"},{"location":"user-guide/applications/running-apps/#best-practices","title":"Best Practices","text":""},{"location":"user-guide/applications/running-apps/#1-validate-before-analyzing","title":"1. Validate Before Analyzing","text":"<pre><code># Good \u2713\nvalidator = BrickModelValidator(use_local_brick=True)\nif validator.validate_ontology(model_path)['valid']:\n    results = app.analyze(model_path, data_path, config)\n\n# Bad \u2717\nresults = app.analyze(model_path, data_path, config)  # Might fail\n</code></pre>"},{"location":"user-guide/applications/running-apps/#2-check-data-quality","title":"2. Check Data Quality","text":"<pre><code># Good \u2713\ndf = pd.read_csv(data_path)\nif len(df) &lt; 100:\n    print(\"Warning: Limited data points\")\nif df.isnull().any().any():\n    print(\"Warning: Missing values detected\")\n\n# Then analyze\nresults = app.analyze(model_path, data_path, config)\n</code></pre>"},{"location":"user-guide/applications/running-apps/#3-use-configuration-files","title":"3. Use Configuration Files","text":"<pre><code># Good \u2713 - Reproducible\nconfig = yaml.safe_load(open('config.yaml'))\nresults = app.analyze(model_path, data_path, config)\n\n# Save config with results\nwith open('results/config_used.yaml', 'w') as f:\n    yaml.dump(config, f)\n</code></pre>"},{"location":"user-guide/applications/running-apps/#4-handle-failures-gracefully","title":"4. Handle Failures Gracefully","text":"<pre><code># Good \u2713\nfor building in buildings:\n    try:\n        results = app.analyze(building.model, building.data, config)\n        save_results(results)\n    except Exception as e:\n        logger.error(f\"Failed: {building.id} - {e}\")\n        continue  # Continue with next building\n</code></pre>"},{"location":"user-guide/applications/running-apps/#next-steps","title":"Next Steps","text":"<ul> <li>Developer Guide - Create your own applications</li> <li>Examples - More code samples</li> <li>API Reference - Complete API docs</li> </ul> <p>Applications documentation complete! \ud83c\udf89</p> <p>Ready to analyze your building data! Start with Apps Manager or Secondary Loop.</p>"},{"location":"user-guide/applications/secondary-loop/","title":"Secondary Loop Temperature Difference","text":"<p>Analyze temperature difference between supply and return water in secondary hot water loops.</p>"},{"location":"user-guide/applications/secondary-loop/#overview","title":"Overview","text":"<p>The Secondary Loop Temperature Difference application analyzes the temperature differential in building secondary loops. This helps:</p> <ul> <li>Monitor performance - Track loop efficiency</li> <li>Identify issues - Detect circulation problems</li> <li>Optimize operation - Understand load patterns</li> <li>Save energy - Find opportunities for improvement</li> </ul>"},{"location":"user-guide/applications/secondary-loop/#what-it-does","title":"What It Does","text":""},{"location":"user-guide/applications/secondary-loop/#analysis","title":"Analysis","text":"<pre><code>graph LR\n    SS[Secondary&lt;br/&gt;Supply Temp] --&gt;|Subtract| TD[Temperature&lt;br/&gt;Difference]\n    SR[Secondary&lt;br/&gt;Return Temp] --&gt;|Subtract| TD\n    TD --&gt; A[Analysis]\n    A --&gt; M[Metrics]\n    A --&gt; P[Plots]\n    A --&gt; R[Reports]\n\n    style SS fill:#ff9800\n    style SR fill:#2196f3\n    style TD fill:#4caf50</code></pre> <p>Calculates: - Temperature difference: Supply - Return - Statistical metrics: Mean, max, min, std dev - Time-series analysis: Trends over time - Visualizations: Plots and charts</p>"},{"location":"user-guide/applications/secondary-loop/#required-sensors","title":"Required Sensors","text":"<p>The building must have both sensors on the same secondary loop:</p> Sensor Type Brick Class Purpose Supply Temperature <code>Supply_Water_Temperature_Sensor</code> or<code>Leaving_Hot_Water_Temperature_Sensor</code> or<code>Hot_Water_Supply_Temperature_Sensor</code> Measures temperature leaving loop Return Temperature <code>Return_Water_Temperature_Sensor</code> or<code>Entering_Hot_Water_Temperature_Sensor</code> or<code>Hot_Water_Return_Temperature_Sensor</code> Measures temperature returning to loop <p>Secondary Loop Only</p> <p>This app specifically looks for sensors on secondary loops (not primary loops). It identifies secondary loops by checking if the equipment URI contains \"secondary\".</p>"},{"location":"user-guide/applications/secondary-loop/#quick-start","title":"Quick Start","text":""},{"location":"user-guide/applications/secondary-loop/#basic-usage","title":"Basic Usage","text":"<pre><code>from hhw_brick import apps\n\n# Load app\napp = apps.load_app(\"secondary_loop_temp_diff\")\n\n# Qualify building\nqualified, details = app.qualify(\"building_105.ttl\")\n\nif qualified:\n    # Get config\n    config = apps.get_default_config(\"secondary_loop_temp_diff\")\n\n    # Run analysis\n    results = app.analyze(\n        brick_model_path=\"building_105.ttl\",\n        timeseries_data_path=\"building_105_data.csv\",\n        config=config\n    )\n\n    # View results\n    print(f\"Mean Temp Diff: {results['summary']['mean_temp_diff']:.2f}\u00b0C\")\n    print(f\"Max Temp Diff: {results['summary']['max_temp_diff']:.2f}\u00b0C\")\n</code></pre>"},{"location":"user-guide/applications/secondary-loop/#qualification","title":"Qualification","text":""},{"location":"user-guide/applications/secondary-loop/#qualify","title":"qualify()","text":"<p>Check if building has required sensors.</p> <p>Signature: <pre><code>def qualify(brick_model_path: str) -&gt; Tuple[bool, Dict]\n</code></pre></p> <p>Returns: <pre><code>(True, {\n    'loop': 'https://hhws.example.org#Secondary_Loop',\n    'supply': 'https://hhws.example.org#Secondary_Supply_Temp',\n    'return': 'https://hhws.example.org#Secondary_Return_Temp'\n})\n</code></pre></p> <p>Example: <pre><code>qualified, details = app.qualify(\"building_105.ttl\")\n\nif qualified:\n    print(\"\u2713 Building qualified\")\n    print(f\"  Loop: {details['loop'].split('#')[-1]}\")\n    print(f\"  Supply: {details['supply'].split('#')[-1]}\")\n    print(f\"  Return: {details['return'].split('#')[-1]}\")\nelse:\n    print(\"\u2717 Building not qualified\")\n    print(\"  Missing secondary loop sensors\")\n</code></pre></p>"},{"location":"user-guide/applications/secondary-loop/#what-gets-checked","title":"What Gets Checked","text":"<p>The qualification process:</p> <ol> <li>Loads Brick model - Parses TTL file</li> <li>Finds secondary loops - Looks for <code>Hot_Water_Loop</code> entities with \"secondary\" in URI</li> <li>Searches for sensors - Finds supply and return temperature sensors</li> <li>Validates pairing - Ensures both sensors are on the same loop</li> </ol> <p>SPARQL Query Used: <pre><code>SELECT ?equipment ?supply ?return WHERE {\n    # Find secondary hot water loops\n    ?equipment rdf:type/rdfs:subClassOf* brick:Hot_Water_Loop .\n    FILTER(CONTAINS(LCASE(STR(?equipment)), \"secondary\"))\n\n    # Find supply temperature sensor\n    ?supply rdf:type/rdfs:subClassOf* ?supply_type .\n    VALUES ?supply_type {\n        brick:Supply_Water_Temperature_Sensor\n        brick:Leaving_Hot_Water_Temperature_Sensor\n        brick:Hot_Water_Supply_Temperature_Sensor\n    }\n\n    # Find return temperature sensor\n    ?return rdf:type/rdfs:subClassOf* ?return_type .\n    VALUES ?return_type {\n        brick:Return_Water_Temperature_Sensor\n        brick:Entering_Hot_Water_Temperature_Sensor\n        brick:Hot_Water_Return_Temperature_Sensor\n    }\n\n    # Both must be associated with the loop\n    {\n        ?equipment brick:hasPart ?supply .\n        ?equipment brick:hasPart ?return .\n    } UNION {\n        ?supply brick:isPointOf ?equipment .\n        ?return brick:isPointOf ?equipment .\n    }\n}\n</code></pre></p>"},{"location":"user-guide/applications/secondary-loop/#analysis_1","title":"Analysis","text":""},{"location":"user-guide/applications/secondary-loop/#analyze","title":"analyze()","text":"<p>Run temperature difference analysis.</p> <p>Signature: <pre><code>def analyze(\n    brick_model_path: str,\n    timeseries_data_path: str,\n    config: Dict\n) -&gt; Dict\n</code></pre></p> <p>Parameters: - <code>brick_model_path</code> (str): Path to Brick model TTL file - <code>timeseries_data_path</code> (str): Path to CSV data file - <code>config</code> (dict): Configuration dictionary</p> <p>Returns: <pre><code>{\n    'summary': {\n        'mean_temp_diff': 5.2,\n        'max_temp_diff': 12.1,\n        'min_temp_diff': 0.3,\n        'std_temp_diff': 2.1,\n        'data_points': 8760\n    },\n    'outputs': [\n        'results/temp_diff_plot.png',\n        'results/statistics.csv',\n        'results/hourly_data.csv'\n    ],\n    'data': {\n        'timestamps': [...],\n        'temp_diff': [...],\n        'supply_temp': [...],\n        'return_temp': [...]\n    }\n}\n</code></pre></p>"},{"location":"user-guide/applications/secondary-loop/#analysis-workflow","title":"Analysis Workflow","text":"<pre><code>graph TD\n    A[Load Brick Model] --&gt; B[Qualify Sensors]\n    B --&gt; C[Load Timeseries Data]\n    C --&gt; D[Map Sensors to Columns]\n    D --&gt; E[Calculate Temp Diff]\n    E --&gt; F[Compute Statistics]\n    F --&gt; G[Generate Plots]\n    G --&gt; H[Save Results]\n\n    style A fill:#e1f5ff\n    style E fill:#fff9c4\n    style H fill:#c8e6c9</code></pre> <p>Steps:</p> <ol> <li>QUALIFY - Check for required sensors</li> <li>FETCH - Load timeseries data</li> <li>MAP - Match sensors to data columns</li> <li>CALCULATE - Compute temperature difference</li> <li>ANALYZE - Calculate statistics</li> <li>VISUALIZE - Generate plots</li> <li>OUTPUT - Save results</li> </ol>"},{"location":"user-guide/applications/secondary-loop/#configuration","title":"Configuration","text":""},{"location":"user-guide/applications/secondary-loop/#default-configuration","title":"Default Configuration","text":"<pre><code>analysis:\n  threshold_min_delta: 0.5    # Minimum expected temp diff (\u00b0C)\n  threshold_max_delta: 10.0   # Maximum expected temp diff (\u00b0C)\n\noutput:\n  save_results: true\n  output_dir: ./results\n  export_format: csv\n  generate_plots: true\n  plot_format: png\n\ntime_range:\n  start_time: null  # Optional: \"2024-01-01 00:00:00\"\n  end_time: null    # Optional: \"2024-12-31 23:59:59\"\n</code></pre>"},{"location":"user-guide/applications/secondary-loop/#configuration-options","title":"Configuration Options","text":"Parameter Type Default Description <code>analysis.threshold_min_delta</code> float 0.5 Minimum expected temperature difference (\u00b0C) <code>analysis.threshold_max_delta</code> float 10.0 Maximum expected temperature difference (\u00b0C) <code>output.save_results</code> bool true Save analysis results to files <code>output.output_dir</code> str \"./results\" Directory for output files <code>output.export_format</code> str \"csv\" Format for data export (csv, excel) <code>output.generate_plots</code> bool true Generate visualization plots <code>output.plot_format</code> str \"png\" Plot image format (png, pdf, svg) <code>time_range.start_time</code> str null Start time for analysis (ISO format) <code>time_range.end_time</code> str null End time for analysis (ISO format)"},{"location":"user-guide/applications/secondary-loop/#custom-configuration","title":"Custom Configuration","text":"<pre><code>import yaml\n\n# Load default\nconfig = apps.get_default_config(\"secondary_loop_temp_diff\")\n\n# Customize\nconfig['analysis']['threshold_min_delta'] = 1.0\nconfig['analysis']['threshold_max_delta'] = 15.0\nconfig['output']['output_dir'] = './custom_results'\nconfig['output']['generate_plots'] = True\nconfig['time_range']['start_time'] = \"2024-01-01 00:00:00\"\nconfig['time_range']['end_time'] = \"2024-03-31 23:59:59\"\n\n# Save\nwith open('custom_config.yaml', 'w') as f:\n    yaml.dump(config, f)\n\n# Use it\nresults = app.analyze(model_path, data_path, config)\n</code></pre>"},{"location":"user-guide/applications/secondary-loop/#data-format","title":"Data Format","text":""},{"location":"user-guide/applications/secondary-loop/#timeseries-data-csv","title":"Timeseries Data CSV","text":"<p>Expected format:</p> <pre><code>datetime,secondary_supply_temp,secondary_return_temp\n2024-01-01 00:00:00,70.5,65.3\n2024-01-01 01:00:00,71.2,66.1\n2024-01-01 02:00:00,69.8,64.7\n...\n</code></pre> <p>Requirements: - datetime column - Timestamp for each row - Temperature columns - Sensor data (column names will be matched to Brick model) - Numeric values - Temperature in \u00b0C or \u00b0F - Regular intervals - Hourly, 15-min, etc. (any interval works)</p>"},{"location":"user-guide/applications/secondary-loop/#column-mapping","title":"Column Mapping","text":"<p>The app automatically maps Brick sensors to CSV columns:</p> <pre><code># Brick model has:\n# :Secondary_Supply_Temp a brick:Supply_Water_Temperature_Sensor\n\n# CSV column might be:\n# \"secondary_supply_temp\" or \"sup_temp_sec\" or \"sec_loop_supply\"\n\n# App automatically finds the match!\n</code></pre>"},{"location":"user-guide/applications/secondary-loop/#results","title":"Results","text":""},{"location":"user-guide/applications/secondary-loop/#summary-metrics","title":"Summary Metrics","text":"<pre><code>results['summary'] = {\n    'mean_temp_diff': 5.2,      # Average temperature difference\n    'max_temp_diff': 12.1,      # Maximum observed\n    'min_temp_diff': 0.3,       # Minimum observed\n    'std_temp_diff': 2.1,       # Standard deviation\n    'data_points': 8760,        # Number of data points analyzed\n    'start_time': '2024-01-01', # Analysis period start\n    'end_time': '2024-12-31'    # Analysis period end\n}\n</code></pre>"},{"location":"user-guide/applications/secondary-loop/#generated-files","title":"Generated Files","text":"<p>Typical outputs (when <code>save_results=true</code>):</p> <pre><code>results/\n\u251c\u2500\u2500 temp_diff_plot.png          # Time-series plot\n\u251c\u2500\u2500 statistics.csv              # Statistical summary\n\u251c\u2500\u2500 hourly_data.csv            # Detailed hourly results\n\u2514\u2500\u2500 distribution_plot.png       # Temperature difference distribution\n</code></pre>"},{"location":"user-guide/applications/secondary-loop/#visualizations","title":"Visualizations","text":"<p>Time-Series Plot: Shows temperature difference over time with supply and return temperatures.</p> <p>Distribution Plot: Histogram of temperature differences showing frequency distribution.</p>"},{"location":"user-guide/applications/secondary-loop/#examples","title":"Examples","text":""},{"location":"user-guide/applications/secondary-loop/#basic-analysis","title":"Basic Analysis","text":"<pre><code>from hhw_brick import apps\n\napp = apps.load_app(\"secondary_loop_temp_diff\")\n\n# Qualify\nqualified, details = app.qualify(\"building_105.ttl\")\n\nif qualified:\n    # Run with defaults\n    config = apps.get_default_config(\"secondary_loop_temp_diff\")\n    results = app.analyze(\n        \"building_105.ttl\",\n        \"building_105_data.csv\",\n        config\n    )\n\n    # Print summary\n    print(\"Analysis Summary:\")\n    for key, value in results['summary'].items():\n        print(f\"  {key}: {value}\")\n</code></pre>"},{"location":"user-guide/applications/secondary-loop/#time-range-analysis","title":"Time-Range Analysis","text":"<pre><code># Analyze specific time period\nconfig = apps.get_default_config(\"secondary_loop_temp_diff\")\nconfig['time_range']['start_time'] = \"2024-06-01 00:00:00\"\nconfig['time_range']['end_time'] = \"2024-08-31 23:59:59\"\n\nresults = app.analyze(model_path, data_path, config)\nprint(f\"Summer average temp diff: {results['summary']['mean_temp_diff']:.2f}\u00b0C\")\n</code></pre>"},{"location":"user-guide/applications/secondary-loop/#custom-output-directory","title":"Custom Output Directory","text":"<pre><code># Save to specific directory\nconfig = apps.get_default_config(\"secondary_loop_temp_diff\")\nconfig['output']['output_dir'] = f\"./results/building_105\"\nconfig['output']['generate_plots'] = True\n\nresults = app.analyze(model_path, data_path, config)\n\nprint(\"Generated files:\")\nfor file_path in results['outputs']:\n    print(f\"  - {file_path}\")\n</code></pre>"},{"location":"user-guide/applications/secondary-loop/#batch-analysis","title":"Batch Analysis","text":"<pre><code>\"\"\"\nRun secondary loop analysis on multiple buildings\n\"\"\"\nfrom pathlib import Path\nfrom hhw_brick import apps\n\napp = apps.load_app(\"secondary_loop_temp_diff\")\nconfig = apps.get_default_config(\"secondary_loop_temp_diff\")\n\nmodel_dir = Path(\"brick_models\")\ndata_dir = Path(\"timeseries_data\")\n\nfor model_file in model_dir.glob(\"*.ttl\"):\n    building_id = model_file.stem.split('_')[1]\n\n    # Qualify\n    qualified, details = app.qualify(str(model_file))\n\n    if not qualified:\n        continue\n\n    # Find data file\n    data_file = data_dir / f\"{building_id}_data.csv\"\n\n    if not data_file.exists():\n        continue\n\n    # Run analysis\n    try:\n        config['output']['output_dir'] = f\"./results/building_{building_id}\"\n        results = app.analyze(str(model_file), str(data_file), config)\n\n        print(f\"Building {building_id}:\")\n        print(f\"  Mean temp diff: {results['summary']['mean_temp_diff']:.2f}\u00b0C\")\n    except Exception as e:\n        print(f\"Building {building_id}: Failed - {e}\")\n</code></pre>"},{"location":"user-guide/applications/secondary-loop/#troubleshooting","title":"Troubleshooting","text":""},{"location":"user-guide/applications/secondary-loop/#issue-building-not-qualified","title":"Issue: Building not qualified","text":"<p>Check: 1. Building has secondary loop (URI contains \"secondary\") 2. Loop has both supply and return temperature sensors 3. Sensors use recognized Brick classes</p> <pre><code># Debug\nfrom rdflib import Graph\n\ng = Graph()\ng.parse(\"building_105.ttl\", format=\"turtle\")\n\n# Check for secondary loops\nquery = \"\"\"\nSELECT ?loop WHERE {\n    ?loop a/rdfs:subClassOf* brick:Hot_Water_Loop .\n    FILTER(CONTAINS(LCASE(STR(?loop)), \"secondary\"))\n}\n\"\"\"\n\nfor row in g.query(query):\n    print(f\"Found loop: {row.loop}\")\n</code></pre>"},{"location":"user-guide/applications/secondary-loop/#issue-column-mapping-failed","title":"Issue: Column mapping failed","text":"<p>Solution: Check CSV column names match sensors:</p> <pre><code>import pandas as pd\n\ndf = pd.read_csv(\"building_105_data.csv\")\nprint(\"Available columns:\")\nprint(df.columns.tolist())\n</code></pre>"},{"location":"user-guide/applications/secondary-loop/#issue-no-data-in-time-range","title":"Issue: No data in time range","text":"<p>Check: Time range configuration:</p> <pre><code>config['time_range']['start_time'] = \"2024-01-01 00:00:00\"\nconfig['time_range']['end_time'] = \"2024-12-31 23:59:59\"\n</code></pre>"},{"location":"user-guide/applications/secondary-loop/#best-practices","title":"Best Practices","text":""},{"location":"user-guide/applications/secondary-loop/#1-always-qualify-first","title":"1. Always Qualify First","text":"<pre><code># Good \u2713\nqualified, details = app.qualify(model_path)\nif qualified:\n    results = app.analyze(model_path, data_path, config)\n</code></pre>"},{"location":"user-guide/applications/secondary-loop/#2-check-data-quality","title":"2. Check Data Quality","text":"<pre><code># Verify data before analysis\ndf = pd.read_csv(data_path)\nprint(f\"Data points: {len(df)}\")\nprint(f\"Date range: {df['datetime'].min()} to {df['datetime'].max()}\")\n</code></pre>"},{"location":"user-guide/applications/secondary-loop/#3-save-configuration","title":"3. Save Configuration","text":"<pre><code># Save config for reproducibility\nwith open('analysis_config.yaml', 'w') as f:\n    yaml.dump(config, f)\n</code></pre>"},{"location":"user-guide/applications/secondary-loop/#next-steps","title":"Next Steps","text":"<ul> <li>Primary Loop App - Analyze primary loop temperature difference</li> <li>Running Apps Guide - Complete application workflow</li> <li>Examples - More code samples</li> </ul> <p>Continue to: Primary Loop Temperature Difference \u2192</p>"},{"location":"user-guide/conversion/","title":"CSV to Brick Conversion","text":"<p>Complete guide to converting heating hot water system data from CSV format to Brick ontology models.</p>"},{"location":"user-guide/conversion/#overview","title":"Overview","text":"<p>The conversion module transforms your building equipment data into standardized Brick ontology format. This enables:</p> <ul> <li>Interoperability - Use the same data with different tools</li> <li>Portability - Move analytics between buildings</li> <li>Standardization - Common vocabulary for all buildings</li> </ul>"},{"location":"user-guide/conversion/#conversion-process","title":"Conversion Process","text":"<pre><code>graph TD\n    A[CSV Files] --&gt;|Read| B[Parse Data]\n    B --&gt;|Identify| C[System Type]\n    C --&gt;|Map| D[Brick Classes]\n    D --&gt;|Create| E[Equipment Entities]\n    E --&gt;|Add| F[Points/Sensors]\n    F --&gt;|Link| G[Relationships]\n    G --&gt;|Generate| H[RDF Graph]\n    H --&gt;|Serialize| I[TTL File]\n\n    style A fill:#e1f5ff\n    style I fill:#c8e6c9</code></pre>"},{"location":"user-guide/conversion/#what-gets-converted","title":"What Gets Converted","text":"Source Destination Building metadata <code>rec:Building</code> entity System type Equipment classes (Boiler, HX, etc.) Sensor availability Point entities and <code>hasPoint</code> relationships System topology <code>feeds</code> relationships between equipment"},{"location":"user-guide/conversion/#conversion-methods","title":"Conversion Methods","text":""},{"location":"user-guide/conversion/#1-single-building-conversion","title":"1. Single Building Conversion","text":"<p>Convert one building at a time with full control:</p> <pre><code>from hhw_brick import CSVToBrickConverter\n\nconverter = CSVToBrickConverter()\nresult = converter.convert_to_brick(\n    metadata_csv=\"metadata.csv\",\n    vars_csv=\"vars_available_by_building.csv\",\n    building_tag=\"105\",\n    output_path=\"building_105.ttl\"\n)\n</code></pre> <p>Best for: - Testing and development - Single building focus - Custom output paths</p> <p>Learn more \u2192</p>"},{"location":"user-guide/conversion/#2-batch-conversion","title":"2. Batch Conversion","text":"<p>Convert multiple buildings at once:</p> <pre><code>from hhw_brick import BatchConverter\n\nbatch = BatchConverter()\nresults = batch.convert_all_buildings(\n    metadata_csv=\"metadata.csv\",\n    vars_csv=\"vars_available_by_building.csv\",\n    output_dir=\"brick_models/\",\n    show_progress=True\n)\n</code></pre> <p>Best for: - Portfolio-wide conversion - Production workflows - Large datasets</p> <p>Learn more \u2192</p>"},{"location":"user-guide/conversion/#3-system-type-filtering","title":"3. System Type Filtering","text":"<p>Convert only specific system types:</p> <pre><code># Convert only condensing systems\nresult = converter.convert_to_brick(\n    metadata_csv=\"metadata.csv\",\n    vars_csv=\"vars_available_by_building.csv\",\n    system_type=\"Condensing\",\n    output_path=\"condensing_systems.ttl\"\n)\n</code></pre> <p>Learn more \u2192</p>"},{"location":"user-guide/conversion/#module-components","title":"Module Components","text":""},{"location":"user-guide/conversion/#csvtobrickconverter","title":"CSVToBrickConverter","text":"<p>Main conversion class for single buildings.</p> <p>Key Methods:</p> <pre><code>converter = CSVToBrickConverter()\n\n# Primary conversion method\nresult = converter.convert_to_brick(\n    metadata_csv: str,\n    vars_csv: str,\n    system_type: Optional[str] = None,\n    building_tag: Optional[str] = None,\n    sensor_mapping: Optional[str] = None,\n    output_path: str = \"output.ttl\"\n) -&gt; Graph\n</code></pre> <p>Parameters: - <code>metadata_csv</code> - Building information file - <code>vars_csv</code> - Sensor availability file - <code>system_type</code> - Filter by system (optional) - <code>building_tag</code> - Specific building ID (optional) - <code>sensor_mapping</code> - Custom mapping file (optional) - <code>output_path</code> - Where to save the model</p> <p>Returns: RDFLib Graph object</p> <p>API Reference \u2192</p>"},{"location":"user-guide/conversion/#batchconverter","title":"BatchConverter","text":"<p>Batch processing for multiple buildings.</p> <p>Key Methods:</p> <pre><code>batch = BatchConverter()\n\n# Convert all buildings\nresults = batch.convert_all_buildings(\n    metadata_csv: str,\n    vars_csv: str,\n    output_dir: str,\n    system_type: Optional[str] = None,\n    building_tags: Optional[List[str]] = None,\n    show_progress: bool = True\n) -&gt; Dict[str, Any]\n</code></pre> <p>Returns: Statistics dictionary with: - <code>total</code> - Total buildings processed - <code>successful</code> - Successfully converted - <code>failed</code> - Failed conversions - <code>by_system</code> - Breakdown by system type - <code>total_triples</code> - Total RDF statements created</p> <p>API Reference \u2192</p>"},{"location":"user-guide/conversion/#common-workflows","title":"Common Workflows","text":""},{"location":"user-guide/conversion/#workflow-1-single-building-development","title":"Workflow 1: Single Building Development","text":"<pre><code>\"\"\"\nDevelopment workflow for a single building\n\"\"\"\nfrom hhw_brick import CSVToBrickConverter, BrickModelValidator\n\n# Convert\nconverter = CSVToBrickConverter()\nmodel = converter.convert_to_brick(\n    metadata_csv=\"metadata.csv\",\n    vars_csv=\"vars.csv\",\n    building_tag=\"105\",\n    output_path=\"building_105.ttl\"\n)\n\nprint(f\"Created {len(model)} triples\")\n\n# Validate\nvalidator = BrickModelValidator()\nis_valid, report = validator.validate_model(\"building_105.ttl\")\n\nif is_valid:\n    print(\"\u2713 Model is valid\")\nelse:\n    print(\"\u26a0 Warnings:\", report)\n</code></pre>"},{"location":"user-guide/conversion/#workflow-2-batch-production","title":"Workflow 2: Batch Production","text":"<pre><code>\"\"\"\nProduction workflow for multiple buildings\n\"\"\"\nfrom hhw_brick import BatchConverter\nfrom pathlib import Path\n\n# Set up output directory\noutput_dir = Path(\"brick_models\")\noutput_dir.mkdir(exist_ok=True)\n\n# Batch convert\nbatch = BatchConverter()\nresults = batch.convert_all_buildings(\n    metadata_csv=\"metadata.csv\",\n    vars_csv=\"vars.csv\",\n    output_dir=str(output_dir),\n    show_progress=True\n)\n\n# Report results\nprint(f\"\\nConversion Summary:\")\nprint(f\"  Total: {results['total']}\")\nprint(f\"  Successful: {results['successful']}\")\nprint(f\"  Failed: {results['failed']}\")\nprint(f\"  Total RDF triples: {results['total_triples']:,}\")\n\n# Breakdown by system\nprint(f\"\\nBy System Type:\")\nfor system, count in results['by_system'].items():\n    print(f\"  {system}: {count}\")\n</code></pre>"},{"location":"user-guide/conversion/#workflow-3-filtered-conversion","title":"Workflow 3: Filtered Conversion","text":"<pre><code>\"\"\"\nConvert only specific buildings or system types\n\"\"\"\n\n# Option 1: Specific buildings\ntarget_buildings = [\"105\", \"106\", \"107\"]\nbatch = BatchConverter()\nresults = batch.convert_all_buildings(\n    metadata_csv=\"metadata.csv\",\n    vars_csv=\"vars.csv\",\n    output_dir=\"selected_buildings/\",\n    building_tags=target_buildings\n)\n\n# Option 2: Specific system type\nresults = batch.convert_all_buildings(\n    metadata_csv=\"metadata.csv\",\n    vars_csv=\"vars.csv\",\n    output_dir=\"condensing_only/\",\n    system_type=\"Condensing\"\n)\n</code></pre>"},{"location":"user-guide/conversion/#output-files","title":"Output Files","text":""},{"location":"user-guide/conversion/#file-naming-convention","title":"File Naming Convention","text":"<p>Single building: <pre><code>building_{tag}_{system}_{variant}.ttl\n</code></pre></p> <p>Example: <code>building_105_non-condensing_h.ttl</code></p> <p>Batch conversion: <pre><code>building_{tag}_{system_abbrev}_{variant}.ttl\n</code></pre></p> <p>All files go to the specified <code>output_dir</code>.</p>"},{"location":"user-guide/conversion/#file-contents","title":"File Contents","text":"<p>Each TTL file contains:</p> <pre><code># Ontology declaration\n@prefix brick: &lt;https://brickschema.org/schema/Brick#&gt; .\n@prefix hhws: &lt;https://hhws.example.org#&gt; .\n@prefix rec: &lt;https://w3id.org/rec#&gt; .\n\n&lt;ontology_uri&gt; a owl:Ontology ;\n    owl:imports &lt;https://brickschema.org/schema/1.3/Brick&gt; .\n\n# Building entity\n:Building_105 a rec:Building ;\n    brick:hasLocation :Building_105_location .\n\n# Equipment entities\n:Boiler_Primary a brick:Boiler ;\n    brick:feeds :Heat_Exchanger .\n\n# Points/sensors\n:HW_Supply_Temp a brick:Hot_Water_Supply_Temperature_Sensor .\n\n# Relationships\n:Boiler_Primary brick:hasPoint :HW_Supply_Temp .\n</code></pre>"},{"location":"user-guide/conversion/#advanced-features","title":"Advanced Features","text":""},{"location":"user-guide/conversion/#custom-sensor-mapping","title":"Custom Sensor Mapping","text":"<p>Provide your own sensor mapping:</p> <pre><code>result = converter.convert_to_brick(\n    metadata_csv=\"metadata.csv\",\n    vars_csv=\"vars.csv\",\n    sensor_mapping=\"my_custom_mapping.yaml\",\n    output_path=\"output.ttl\"\n)\n</code></pre> <p>Learn more \u2192</p>"},{"location":"user-guide/conversion/#accessing-warnings","title":"Accessing Warnings","text":"<p>Check conversion warnings:</p> <pre><code>converter = CSVToBrickConverter()\nresult = converter.convert_to_brick(...)\n\n# Check for warnings\nif converter.validation_warnings:\n    print(\"Conversion warnings:\")\n    for warning in converter.validation_warnings:\n        print(f\"  - {warning}\")\n</code></pre>"},{"location":"user-guide/conversion/#working-with-graph-objects","title":"Working with Graph Objects","text":"<p>Use the returned Graph object directly:</p> <pre><code># Get the graph without saving\nresult_graph = converter.convert_to_brick(\n    metadata_csv=\"metadata.csv\",\n    vars_csv=\"vars.csv\",\n    building_tag=\"105\",\n    output_path=\"temp.ttl\"\n)\n\n# Query it\nquery = \"\"\"\nSELECT ?equip WHERE {\n    ?equip a brick:Boiler .\n}\n\"\"\"\n\nfor row in result_graph.query(query):\n    print(f\"Found boiler: {row.equip}\")\n\n# Serialize in different formats\nresult_graph.serialize(\"output.xml\", format=\"xml\")\nresult_graph.serialize(\"output.json\", format=\"json-ld\")\n</code></pre>"},{"location":"user-guide/conversion/#performance-considerations","title":"Performance Considerations","text":""},{"location":"user-guide/conversion/#large-datasets","title":"Large Datasets","text":"<p>For hundreds of buildings:</p> <pre><code># Use batch converter with progress bar\nbatch = BatchConverter()\nresults = batch.convert_all_buildings(\n    metadata_csv=\"large_dataset.csv\",\n    vars_csv=\"large_vars.csv\",\n    output_dir=\"models/\",\n    show_progress=True  # Shows progress bar\n)\n</code></pre>"},{"location":"user-guide/conversion/#memory-usage","title":"Memory Usage","text":"<p>Each building's graph is created and cleared independently, so memory usage stays constant regardless of dataset size.</p>"},{"location":"user-guide/conversion/#error-handling","title":"Error Handling","text":""},{"location":"user-guide/conversion/#common-errors","title":"Common Errors","text":"<p>FileNotFoundError: <pre><code>try:\n    result = converter.convert_to_brick(\n        metadata_csv=\"missing.csv\",\n        vars_csv=\"vars.csv\"\n    )\nexcept FileNotFoundError as e:\n    print(f\"File not found: {e}\")\n</code></pre></p> <p>ValueError (no data): <pre><code>try:\n    result = converter.convert_to_brick(\n        metadata_csv=\"metadata.csv\",\n        vars_csv=\"vars.csv\",\n        building_tag=\"999\"  # Doesn't exist\n    )\nexcept ValueError as e:\n    print(f\"No data for building: {e}\")\n</code></pre></p>"},{"location":"user-guide/conversion/#robust-conversion-script","title":"Robust Conversion Script","text":"<pre><code>\"\"\"\nProduction conversion script with error handling\n\"\"\"\nfrom hhw_brick import BatchConverter\nimport logging\n\n# Set up logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(levelname)s - %(message)s'\n)\n\ndef convert_with_error_handling():\n    batch = BatchConverter()\n\n    try:\n        results = batch.convert_all_buildings(\n            metadata_csv=\"metadata.csv\",\n            vars_csv=\"vars.csv\",\n            output_dir=\"brick_models/\",\n            show_progress=True\n        )\n\n        # Log results\n        logging.info(f\"Converted {results['successful']} buildings\")\n\n        if results['failed'] &gt; 0:\n            logging.warning(f\"Failed: {results['failed']}\")\n            for building in results.get('failed_buildings', []):\n                logging.error(f\"  - Building {building}\")\n\n        return results\n\n    except FileNotFoundError as e:\n        logging.error(f\"Input file not found: {e}\")\n        return None\n    except Exception as e:\n        logging.error(f\"Unexpected error: {e}\")\n        return None\n\nif __name__ == \"__main__\":\n    convert_with_error_handling()\n</code></pre>"},{"location":"user-guide/conversion/#next-steps","title":"Next Steps","text":""},{"location":"user-guide/conversion/#deep-dive-into-conversion","title":"Deep Dive into Conversion","text":"<ul> <li>Single Building - Detailed single building guide</li> <li>Batch Conversion - Multi-building workflows</li> <li>System Types - Understanding HVAC systems</li> <li>Sensor Mapping - Customize sensor mapping</li> </ul>"},{"location":"user-guide/conversion/#related-topics","title":"Related Topics","text":"<ul> <li>Validation - Validate converted models</li> <li>Examples - Working code samples</li> <li>API Reference - Complete API docs</li> </ul> <p>Continue to: Single Building Conversion \u2192</p>"},{"location":"user-guide/conversion/batch-conversion/","title":"Batch Conversion","text":"<p>Efficiently convert multiple buildings from CSV to Brick format in a single operation.</p>"},{"location":"user-guide/conversion/batch-conversion/#overview","title":"Overview","text":"<p>Batch conversion is designed for processing multiple buildings at once. It's ideal for:</p> <ul> <li>Portfolio-wide conversion - Convert all buildings in a dataset</li> <li>Production workflows - Automated, repeatable processes  </li> <li>Large-scale operations - Hundreds of buildings</li> <li>Progress tracking - Visual progress bars</li> </ul>"},{"location":"user-guide/conversion/batch-conversion/#basic-usage","title":"Basic Usage","text":""},{"location":"user-guide/conversion/batch-conversion/#minimal-example","title":"Minimal Example","text":"<p>Convert all buildings in your CSV files:</p> <pre><code>from hhw_brick import BatchConverter\n\nbatch = BatchConverter()\nresults = batch.convert_all_buildings(\n    metadata_csv=\"metadata.csv\",\n    vars_csv=\"vars_available_by_building.csv\",\n    output_dir=\"brick_models/\"\n)\n\nprint(f\"Converted {results['successful']} buildings\")\nprint(f\"Failed: {results['failed']}\")\n</code></pre> <p>Output: <pre><code>Converted 150 buildings\nFailed: 0\n</code></pre></p>"},{"location":"user-guide/conversion/batch-conversion/#with-progress-bar","title":"With Progress Bar","text":"<p>Show progress during conversion:</p> <pre><code>batch = BatchConverter()\nresults = batch.convert_all_buildings(\n    metadata_csv=\"metadata.csv\",\n    vars_csv=\"vars_available_by_building.csv\",\n    output_dir=\"brick_models/\",\n    show_progress=True  # Enable progress bar\n)\n</code></pre> <p>Output: <pre><code>Converting buildings: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 150/150 [01:23&lt;00:00,  1.80it/s]\n</code></pre></p>"},{"location":"user-guide/conversion/batch-conversion/#parameters","title":"Parameters","text":""},{"location":"user-guide/conversion/batch-conversion/#required-parameters","title":"Required Parameters","text":""},{"location":"user-guide/conversion/batch-conversion/#metadata_csv","title":"metadata_csv","text":"<p>Path to building metadata file:</p> <pre><code>metadata_csv=\"path/to/metadata.csv\"\n</code></pre>"},{"location":"user-guide/conversion/batch-conversion/#vars_csv","title":"vars_csv","text":"<p>Path to sensor availability file:</p> <pre><code>vars_csv=\"path/to/vars_available_by_building.csv\"\n</code></pre>"},{"location":"user-guide/conversion/batch-conversion/#output_dir","title":"output_dir","text":"<p>Directory where TTL files will be saved:</p> <pre><code>output_dir=\"brick_models/\"\n</code></pre> <p>The directory will be created if it doesn't exist.</p>"},{"location":"user-guide/conversion/batch-conversion/#optional-parameters","title":"Optional Parameters","text":""},{"location":"user-guide/conversion/batch-conversion/#system_type","title":"system_type","text":"<p>Filter by HVAC system type:</p> <pre><code>system_type=\"Condensing\"  # Only condensing systems\n</code></pre> <ul> <li>Type: String</li> <li>Default: <code>None</code> (convert all systems)</li> <li>Options: <code>\"Boiler\"</code>, <code>\"Non-condensing\"</code>, <code>\"Condensing\"</code>, <code>\"District HW\"</code>, <code>\"District Steam\"</code></li> </ul> <p>Example: <pre><code># Convert only district hot water systems\nresults = batch.convert_all_buildings(\n    metadata_csv=\"metadata.csv\",\n    vars_csv=\"vars.csv\",\n    output_dir=\"district_hw_models/\",\n    system_type=\"District HW\"\n)\n</code></pre></p>"},{"location":"user-guide/conversion/batch-conversion/#building_tags","title":"building_tags","text":"<p>List of specific buildings to convert:</p> <pre><code>building_tags=[\"105\", \"106\", \"107\"]\n</code></pre> <ul> <li>Type: List of strings</li> <li>Default: <code>None</code> (convert all buildings)</li> </ul> <p>Example: <pre><code># Convert only selected buildings\ntarget_buildings = [\"105\", \"106\", \"107\", \"108\", \"109\"]\n\nresults = batch.convert_all_buildings(\n    metadata_csv=\"metadata.csv\",\n    vars_csv=\"vars.csv\",\n    output_dir=\"selected_buildings/\",\n    building_tags=target_buildings\n)\n</code></pre></p>"},{"location":"user-guide/conversion/batch-conversion/#show_progress","title":"show_progress","text":"<p>Show progress bar during conversion:</p> <pre><code>show_progress=True  # Default: True\n</code></pre> <ul> <li>Type: Boolean</li> <li>Default: <code>True</code></li> <li>Uses <code>tqdm</code> for progress visualization</li> </ul>"},{"location":"user-guide/conversion/batch-conversion/#return-value","title":"Return Value","text":"<p>The <code>convert_all_buildings()</code> method returns a dictionary with statistics:</p> <pre><code>results = batch.convert_all_buildings(...)\n\n# Results structure\n{\n    'total': 150,              # Total buildings processed\n    'successful': 148,         # Successfully converted\n    'failed': 2,               # Failed conversions\n    'by_system': {             # Breakdown by system type\n        'Condensing': 85,\n        'Non-condensing': 45,\n        'District HW': 18\n    },\n    'total_triples': 156789,   # Total RDF statements created\n    'failed_buildings': [      # List of failed building IDs\n        '127', '304'\n    ],\n    'successful_files': [      # List of created files\n        'brick_models/building_105_non-condensing_h.ttl',\n        'brick_models/building_106_condensing_n.ttl',\n        # ...\n    ]\n}\n</code></pre>"},{"location":"user-guide/conversion/batch-conversion/#processing-results","title":"Processing Results","text":"<pre><code>results = batch.convert_all_buildings(...)\n\nprint(\"Conversion Summary:\")\nprint(f\"  Total: {results['total']}\")\nprint(f\"  Successful: {results['successful']}\")\nprint(f\"  Failed: {results['failed']}\")\nprint(f\"  Success Rate: {results['successful']/results['total']*100:.1f}%\")\n\nprint(\"\\nBy System Type:\")\nfor system, count in results['by_system'].items():\n    print(f\"  {system}: {count}\")\n\nif results['failed'] &gt; 0:\n    print(\"\\nFailed Buildings:\")\n    for building_id in results['failed_buildings']:\n        print(f\"  - Building {building_id}\")\n</code></pre>"},{"location":"user-guide/conversion/batch-conversion/#output-files","title":"Output Files","text":""},{"location":"user-guide/conversion/batch-conversion/#file-naming","title":"File Naming","text":"<p>Files are automatically named using the pattern:</p> <pre><code>building_{tag}_{system_abbreviation}_{variant}.ttl\n</code></pre> <p>Examples: - <code>building_105_non-condensing_h.ttl</code> - <code>building_106_condensing_n.ttl</code> - <code>building_107_district_hw_aa.ttl</code></p>"},{"location":"user-guide/conversion/batch-conversion/#output-directory-structure","title":"Output Directory Structure","text":"<pre><code>brick_models/\n\u251c\u2500\u2500 building_105_non-condensing_h.ttl\n\u251c\u2500\u2500 building_106_condensing_n.ttl\n\u251c\u2500\u2500 building_107_condensing_an.ttl\n\u251c\u2500\u2500 building_108_district_hw_aa.ttl\n\u2514\u2500\u2500 ...\n</code></pre>"},{"location":"user-guide/conversion/batch-conversion/#common-workflows","title":"Common Workflows","text":""},{"location":"user-guide/conversion/batch-conversion/#workflow-1-convert-all-buildings","title":"Workflow 1: Convert All Buildings","text":"<pre><code>\"\"\"\nSimple batch conversion of all buildings\n\"\"\"\nfrom hhw_brick import BatchConverter\nfrom pathlib import Path\n\n# Create output directory\noutput_dir = Path(\"brick_models\")\noutput_dir.mkdir(exist_ok=True)\n\n# Convert\nbatch = BatchConverter()\nresults = batch.convert_all_buildings(\n    metadata_csv=\"metadata.csv\",\n    vars_csv=\"vars_available_by_building.csv\",\n    output_dir=str(output_dir),\n    show_progress=True\n)\n\n# Report\nprint(f\"\\n{'='*60}\")\nprint(\"Conversion Complete!\")\nprint(f\"{'='*60}\")\nprint(f\"Total Buildings: {results['total']}\")\nprint(f\"Successful: {results['successful']}\")\nprint(f\"Failed: {results['failed']}\")\nprint(f\"Total RDF Triples: {results['total_triples']:,}\")\n\nif results['failed'] &gt; 0:\n    print(f\"\\n\u26a0 Failed buildings: {results['failed_buildings']}\")\n</code></pre>"},{"location":"user-guide/conversion/batch-conversion/#workflow-2-filter-by-system-type","title":"Workflow 2: Filter by System Type","text":"<pre><code>\"\"\"\nConvert buildings of specific system types\n\"\"\"\nfrom hhw_brick import BatchConverter\n\n# Convert condensing systems only\nbatch = BatchConverter()\ncondensing_results = batch.convert_all_buildings(\n    metadata_csv=\"metadata.csv\",\n    vars_csv=\"vars.csv\",\n    output_dir=\"condensing_systems/\",\n    system_type=\"Condensing\",\n    show_progress=True\n)\n\nprint(f\"Converted {condensing_results['successful']} condensing systems\")\n\n# Convert district systems separately\ndistrict_results = batch.convert_all_buildings(\n    metadata_csv=\"metadata.csv\",\n    vars_csv=\"vars.csv\",\n    output_dir=\"district_systems/\",\n    system_type=\"District HW\",\n    show_progress=True\n)\n\nprint(f\"Converted {district_results['successful']} district systems\")\n</code></pre>"},{"location":"user-guide/conversion/batch-conversion/#workflow-3-convert-by-organization","title":"Workflow 3: Convert by Organization","text":"<pre><code>\"\"\"\nBatch convert buildings grouped by organization\n\"\"\"\nimport pandas as pd\nfrom hhw_brick import BatchConverter\n\n# Load metadata\nmetadata = pd.read_csv(\"metadata.csv\")\n\n# Get unique organizations\norganizations = metadata['org'].unique()\n\nbatch = BatchConverter()\n\nfor org in organizations:\n    print(f\"\\nConverting buildings for: {org}\")\n\n    # Get building IDs for this org\n    org_buildings = metadata[metadata['org'] == org]['tag'].astype(str).tolist()\n\n    # Create org-specific output directory\n    output_dir = f\"brick_models/{org.replace(' ', '_')}\"\n\n    # Convert\n    results = batch.convert_all_buildings(\n        metadata_csv=\"metadata.csv\",\n        vars_csv=\"vars.csv\",\n        output_dir=output_dir,\n        building_tags=org_buildings,\n        show_progress=True\n    )\n\n    print(f\"  Converted: {results['successful']}/{results['total']}\")\n</code></pre>"},{"location":"user-guide/conversion/batch-conversion/#workflow-4-production-with-logging","title":"Workflow 4: Production with Logging","text":"<pre><code>\"\"\"\nProduction batch conversion with comprehensive logging\n\"\"\"\nfrom hhw_brick import BatchConverter\nimport logging\nfrom datetime import datetime\nfrom pathlib import Path\n\n# Set up logging\nlog_file = f\"conversion_{datetime.now().strftime('%Y%m%d_%H%M%S')}.log\"\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(levelname)s - %(message)s',\n    handlers=[\n        logging.FileHandler(log_file),\n        logging.StreamHandler()\n    ]\n)\n\ndef production_conversion():\n    \"\"\"Production batch conversion with error handling.\"\"\"\n\n    logging.info(\"Starting batch conversion\")\n\n    # Set up paths\n    output_dir = Path(\"brick_models_production\")\n    output_dir.mkdir(exist_ok=True)\n\n    try:\n        # Convert\n        batch = BatchConverter()\n        results = batch.convert_all_buildings(\n            metadata_csv=\"metadata.csv\",\n            vars_csv=\"vars.csv\",\n            output_dir=str(output_dir),\n            show_progress=True\n        )\n\n        # Log results\n        logging.info(f\"Conversion complete: {results['successful']}/{results['total']}\")\n        logging.info(f\"Total triples created: {results['total_triples']:,}\")\n\n        # Log by system type\n        logging.info(\"Breakdown by system:\")\n        for system, count in results['by_system'].items():\n            logging.info(f\"  {system}: {count}\")\n\n        # Log failures\n        if results['failed'] &gt; 0:\n            logging.warning(f\"{results['failed']} buildings failed:\")\n            for building_id in results['failed_buildings']:\n                logging.warning(f\"  - Building {building_id}\")\n\n        # Save results summary\n        summary_file = output_dir / \"conversion_summary.txt\"\n        with open(summary_file, 'w') as f:\n            f.write(f\"Conversion Date: {datetime.now()}\\n\")\n            f.write(f\"Total: {results['total']}\\n\")\n            f.write(f\"Successful: {results['successful']}\\n\")\n            f.write(f\"Failed: {results['failed']}\\n\")\n            f.write(f\"Total Triples: {results['total_triples']:,}\\n\")\n\n        logging.info(f\"Summary saved to {summary_file}\")\n        return results\n\n    except FileNotFoundError as e:\n        logging.error(f\"Input file not found: {e}\")\n        return None\n    except Exception as e:\n        logging.error(f\"Conversion failed: {e}\", exc_info=True)\n        return None\n\nif __name__ == \"__main__\":\n    results = production_conversion()\n</code></pre>"},{"location":"user-guide/conversion/batch-conversion/#advanced-usage","title":"Advanced Usage","text":""},{"location":"user-guide/conversion/batch-conversion/#parallel-processing-custom-implementation","title":"Parallel Processing (Custom Implementation)","text":"<p>For very large datasets, you can implement parallel processing:</p> <pre><code>\"\"\"\nCustom parallel batch conversion\n\"\"\"\nfrom hhw_brick import CSVToBrickConverter\nimport pandas as pd\nfrom multiprocessing import Pool\nfrom pathlib import Path\n\ndef convert_single_building(args):\n    \"\"\"Convert a single building (for use with multiprocessing).\"\"\"\n    building_tag, metadata_csv, vars_csv, output_dir = args\n\n    try:\n        converter = CSVToBrickConverter()\n        result = converter.convert_to_brick(\n            metadata_csv=metadata_csv,\n            vars_csv=vars_csv,\n            building_tag=building_tag,\n            output_path=f\"{output_dir}/building_{building_tag}.ttl\"\n        )\n        return building_tag, 'success', len(result)\n    except Exception as e:\n        return building_tag, 'failed', str(e)\n\ndef parallel_batch_conversion(metadata_csv, vars_csv, output_dir, num_workers=4):\n    \"\"\"Batch convert using multiple processes.\"\"\"\n\n    # Get building IDs\n    metadata = pd.read_csv(metadata_csv)\n    building_ids = metadata['tag'].astype(str).tolist()\n\n    # Create output directory\n    Path(output_dir).mkdir(exist_ok=True)\n\n    # Prepare arguments\n    args = [\n        (bid, metadata_csv, vars_csv, output_dir)\n        for bid in building_ids\n    ]\n\n    # Process in parallel\n    with Pool(num_workers) as pool:\n        results = pool.map(convert_single_building, args)\n\n    # Summarize\n    successful = sum(1 for _, status, _ in results if status == 'success')\n    failed = sum(1 for _, status, _ in results if status == 'failed')\n\n    print(f\"Parallel conversion complete:\")\n    print(f\"  Workers: {num_workers}\")\n    print(f\"  Successful: {successful}\")\n    print(f\"  Failed: {failed}\")\n\n    return results\n\n# Use it\nresults = parallel_batch_conversion(\n    \"metadata.csv\",\n    \"vars.csv\",\n    \"brick_models/\",\n    num_workers=8\n)\n</code></pre>"},{"location":"user-guide/conversion/batch-conversion/#incremental-conversion","title":"Incremental Conversion","text":"<p>Convert only new buildings:</p> <pre><code>\"\"\"\nIncremental conversion - skip already converted buildings\n\"\"\"\nfrom hhw_brick import BatchConverter\nimport pandas as pd\nfrom pathlib import Path\n\ndef incremental_conversion(metadata_csv, vars_csv, output_dir):\n    \"\"\"Convert only buildings not already in output directory.\"\"\"\n\n    # Get all buildings\n    metadata = pd.read_csv(metadata_csv)\n    all_buildings = set(metadata['tag'].astype(str))\n\n    # Get already converted buildings\n    output_path = Path(output_dir)\n    if output_path.exists():\n        existing_files = list(output_path.glob(\"building_*.ttl\"))\n        converted = set()\n        for file in existing_files:\n            # Extract building ID from filename\n            parts = file.stem.split('_')\n            if len(parts) &gt; 1:\n                converted.add(parts[1])  # building_105_... -&gt; 105\n    else:\n        converted = set()\n        output_path.mkdir(exist_ok=True)\n\n    # Find new buildings\n    new_buildings = all_buildings - converted\n\n    print(f\"Total buildings: {len(all_buildings)}\")\n    print(f\"Already converted: {len(converted)}\")\n    print(f\"New buildings: {len(new_buildings)}\")\n\n    if not new_buildings:\n        print(\"No new buildings to convert\")\n        return\n\n    # Convert new buildings\n    batch = BatchConverter()\n    results = batch.convert_all_buildings(\n        metadata_csv=metadata_csv,\n        vars_csv=vars_csv,\n        output_dir=output_dir,\n        building_tags=list(new_buildings),\n        show_progress=True\n    )\n\n    print(f\"\\nConverted {results['successful']} new buildings\")\n    return results\n\n# Use it\nresults = incremental_conversion(\n    \"metadata.csv\",\n    \"vars.csv\",\n    \"brick_models/\"\n)\n</code></pre>"},{"location":"user-guide/conversion/batch-conversion/#performance","title":"Performance","text":""},{"location":"user-guide/conversion/batch-conversion/#benchmarks","title":"Benchmarks","text":"<p>Typical performance on a standard laptop:</p> Buildings Time Rate 10 ~6 seconds 1.7 builds/sec 50 ~28 seconds 1.8 builds/sec 100 ~55 seconds 1.8 builds/sec 500 ~4.5 minutes 1.9 builds/sec"},{"location":"user-guide/conversion/batch-conversion/#optimization-tips","title":"Optimization Tips","text":"<ol> <li>Use SSD storage - Faster file I/O</li> <li>Disable progress bar for scripts - Slight speedup</li> <li>Consider parallel processing - For very large datasets (&gt;1000 buildings)</li> <li>Close other applications - More memory available</li> </ol>"},{"location":"user-guide/conversion/batch-conversion/#troubleshooting","title":"Troubleshooting","text":""},{"location":"user-guide/conversion/batch-conversion/#issue-no-such-file-or-directory","title":"Issue: \"No such file or directory\"","text":"<p>Cause: Output directory path is invalid</p> <p>Solution: <pre><code>from pathlib import Path\n\n# Create directory first\noutput_dir = Path(\"brick_models\")\noutput_dir.mkdir(parents=True, exist_ok=True)\n\n# Then convert\nresults = batch.convert_all_buildings(\n    metadata_csv=\"metadata.csv\",\n    vars_csv=\"vars.csv\",\n    output_dir=str(output_dir)\n)\n</code></pre></p>"},{"location":"user-guide/conversion/batch-conversion/#issue-some-buildings-failed","title":"Issue: Some buildings failed","text":"<p>Cause: Data issues in specific buildings</p> <p>Solution: <pre><code>results = batch.convert_all_buildings(...)\n\nif results['failed'] &gt; 0:\n    print(f\"Failed buildings: {results['failed_buildings']}\")\n\n    # Try converting failed buildings individually for debugging\n    from hhw_brick import CSVToBrickConverter\n    converter = CSVToBrickConverter()\n\n    for building_id in results['failed_buildings']:\n        try:\n            converter.convert_to_brick(\n                metadata_csv=\"metadata.csv\",\n                vars_csv=\"vars.csv\",\n                building_tag=building_id,\n                output_path=f\"debug_building_{building_id}.ttl\"\n            )\n        except Exception as e:\n            print(f\"Building {building_id} error: {e}\")\n</code></pre></p>"},{"location":"user-guide/conversion/batch-conversion/#issue-progress-bar-not-showing","title":"Issue: Progress bar not showing","text":"<p>Cause: <code>tqdm</code> not installed</p> <p>Solution: <pre><code>pip install tqdm\n</code></pre></p> <p>Or disable progress bar: <pre><code>results = batch.convert_all_buildings(\n    ...,\n    show_progress=False\n)\n</code></pre></p>"},{"location":"user-guide/conversion/batch-conversion/#best-practices","title":"Best Practices","text":""},{"location":"user-guide/conversion/batch-conversion/#1-test-first","title":"1. Test First","text":"<p>Test on a small subset before full conversion:</p> <pre><code># Test with 10 buildings\ntest_buildings = [\"105\", \"106\", \"107\", \"108\", \"109\"]\n\nresults = batch.convert_all_buildings(\n    metadata_csv=\"metadata.csv\",\n    vars_csv=\"vars.csv\",\n    output_dir=\"test_output/\",\n    building_tags=test_buildings\n)\n\n# If successful, run full conversion\nif results['failed'] == 0:\n    results = batch.convert_all_buildings(\n        metadata_csv=\"metadata.csv\",\n        vars_csv=\"vars.csv\",\n        output_dir=\"production_output/\"\n    )\n</code></pre>"},{"location":"user-guide/conversion/batch-conversion/#2-separate-by-system-type","title":"2. Separate by System Type","text":"<p>Organize outputs by system type:</p> <pre><code>system_types = [\"Condensing\", \"Non-condensing\", \"District HW\"]\n\nfor system in system_types:\n    results = batch.convert_all_buildings(\n        metadata_csv=\"metadata.csv\",\n        vars_csv=\"vars.csv\",\n        output_dir=f\"brick_models/{system.lower().replace(' ', '_')}/\",\n        system_type=system\n    )\n</code></pre>"},{"location":"user-guide/conversion/batch-conversion/#3-keep-conversion-logs","title":"3. Keep Conversion Logs","text":"<p>Save detailed logs for auditing:</p> <pre><code>import json\nfrom datetime import datetime\n\nresults = batch.convert_all_buildings(...)\n\n# Save results\nlog_data = {\n    'timestamp': datetime.now().isoformat(),\n    'results': results,\n    'metadata_file': 'metadata.csv',\n    'vars_file': 'vars.csv'\n}\n\nwith open('conversion_log.json', 'w') as f:\n    json.dump(log_data, f, indent=2)\n</code></pre>"},{"location":"user-guide/conversion/batch-conversion/#next-steps","title":"Next Steps","text":"<ul> <li>System Types - Learn about different HVAC systems</li> <li>Sensor Mapping - Customize sensor mappings</li> <li>Validation - Validate converted models</li> <li>Examples - More code examples</li> </ul> <p>Continue to: System Types \u2192</p>"},{"location":"user-guide/conversion/sensor-mapping/","title":"Sensor Mapping","text":"<p>Customize how CSV sensor columns map to Brick ontology classes.</p>"},{"location":"user-guide/conversion/sensor-mapping/#overview","title":"Overview","text":"<p>The sensor mapping file (<code>sensor_to_brick_mapping.yaml</code>) defines how CSV column names translate to Brick point classes. This allows you to:</p> <ul> <li>Customize mappings for your specific data</li> <li>Add new sensor types not in the default mapping</li> <li>Modify Brick classes for existing sensors</li> <li>Document sensor meanings with descriptions</li> </ul>"},{"location":"user-guide/conversion/sensor-mapping/#default-mapping-file","title":"Default Mapping File","text":"<p>The package includes a default mapping at: <pre><code>hhw_brick/conversion/sensor_to_brick_mapping.yaml\n</code></pre></p> <p>This is used automatically unless you provide a custom file.</p>"},{"location":"user-guide/conversion/sensor-mapping/#mapping-file-format","title":"Mapping File Format","text":""},{"location":"user-guide/conversion/sensor-mapping/#yaml-structure","title":"YAML Structure","text":"<p>Each sensor mapping has four fields:</p> <pre><code>sensor_name:\n  brick_class: \"brick:ClassName\"\n  description: \"Human-readable description\"\n  unit: \"UNIT_TYPE\"\n  equipment: \"equipment_type\"\n</code></pre>"},{"location":"user-guide/conversion/sensor-mapping/#example-entry","title":"Example Entry","text":"<pre><code>hw_supply_temp:\n  brick_class: \"brick:Hot_Water_Supply_Temperature_Sensor\"\n  description: \"Hot water supply temperature\"\n  unit: \"DEG_C\"\n  equipment: \"primary_loop\"\n</code></pre>"},{"location":"user-guide/conversion/sensor-mapping/#fields-explained","title":"Fields Explained","text":"Field Required Description Example <code>brick_class</code> Yes Full Brick class name <code>brick:Hot_Water_Supply_Temperature_Sensor</code> <code>description</code> Yes Sensor description <code>\"Primary loop supply temperature\"</code> <code>unit</code> No Unit of measurement <code>DEG_C</code>, <code>L_PER_MIN</code>, <code>KW</code> <code>equipment</code> No Associated equipment <code>boiler</code>, <code>heat_exchanger</code>, <code>pump</code>"},{"location":"user-guide/conversion/sensor-mapping/#default-mappings","title":"Default Mappings","text":""},{"location":"user-guide/conversion/sensor-mapping/#temperature-sensors","title":"Temperature Sensors","text":"<pre><code># Primary Loop\nhw_supply_temp:\n  brick_class: \"brick:Hot_Water_Supply_Temperature_Sensor\"\n  description: \"Primary hot water supply temperature\"\n  unit: \"DEG_C\"\n  equipment: \"primary_loop\"\n\nhw_return_temp:\n  brick_class: \"brick:Hot_Water_Return_Temperature_Sensor\"\n  description: \"Primary hot water return temperature\"\n  unit: \"DEG_C\"\n  equipment: \"primary_loop\"\n\n# Secondary Loop\nsecondary_supply_temp:\n  brick_class: \"brick:Hot_Water_Supply_Temperature_Sensor\"\n  description: \"Secondary loop supply temperature\"\n  unit: \"DEG_C\"\n  equipment: \"secondary_loop\"\n\nsecondary_return_temp:\n  brick_class: \"brick:Hot_Water_Return_Temperature_Sensor\"\n  description: \"Secondary loop return temperature\"\n  unit: \"DEG_C\"\n  equipment: \"secondary_loop\"\n\n# Outdoor\noutdoor_temp:\n  brick_class: \"brick:Outside_Air_Temperature_Sensor\"\n  description: \"Outdoor air temperature\"\n  unit: \"DEG_C\"\n  equipment: \"building\"\n</code></pre>"},{"location":"user-guide/conversion/sensor-mapping/#flow-sensors","title":"Flow Sensors","text":"<pre><code>hw_flow:\n  brick_class: \"brick:Water_Flow_Sensor\"\n  description: \"Primary hot water flow rate\"\n  unit: \"L_PER_MIN\"\n  equipment: \"primary_loop\"\n\nsecondary_flow:\n  brick_class: \"brick:Water_Flow_Sensor\"\n  description: \"Secondary loop flow rate\"\n  unit: \"L_PER_MIN\"\n  equipment: \"secondary_loop\"\n</code></pre>"},{"location":"user-guide/conversion/sensor-mapping/#numbered-sensors-boilers","title":"Numbered Sensors (Boilers)","text":"<pre><code>sup1:\n  brick_class: \"brick:Leaving_Hot_Water_Temperature_Sensor\"\n  description: \"Supply water temperature leaving boiler 1\"\n  unit: \"DEG_C\"\n  equipment: \"boiler\"\n\nret1:\n  brick_class: \"brick:Entering_Hot_Water_Temperature_Sensor\"\n  description: \"Return water temperature entering boiler 1\"\n  unit: \"DEG_C\"\n  equipment: \"boiler\"\n\nfire1:\n  brick_class: \"brick:Firing_Rate_Sensor\"\n  description: \"Boiler 1 firing rate\"\n  unit: \"PERCENT\"\n  equipment: \"boiler\"\n</code></pre>"},{"location":"user-guide/conversion/sensor-mapping/#pump-sensors","title":"Pump Sensors","text":"<pre><code>pmp1_pwr:\n  brick_class: \"brick:Power_Sensor\"\n  description: \"Pump 1 power consumption\"\n  unit: \"KW\"\n  equipment: \"pump\"\n\npmp1_spd:\n  brick_class: \"brick:Speed_Sensor\"\n  description: \"Pump 1 speed\"\n  unit: \"PERCENT\"\n  equipment: \"pump\"\n\npmp1_vfd:\n  brick_class: \"brick:VFD_Enable_Command\"\n  description: \"Pump 1 VFD enable status\"\n  unit: \"BINARY\"\n  equipment: \"pump\"\n</code></pre>"},{"location":"user-guide/conversion/sensor-mapping/#valves","title":"Valves","text":"<pre><code>hw_valve:\n  brick_class: \"brick:Heating_Valve\"\n  description: \"Hot water control valve position\"\n  unit: \"PERCENT\"\n  equipment: \"valve\"\n</code></pre>"},{"location":"user-guide/conversion/sensor-mapping/#creating-custom-mappings","title":"Creating Custom Mappings","text":""},{"location":"user-guide/conversion/sensor-mapping/#step-1-copy-default-file","title":"Step 1: Copy Default File","text":"<p>Start with the default as a template:</p> <pre><code>cp hhw_brick/conversion/sensor_to_brick_mapping.yaml custom_mapping.yaml\n</code></pre>"},{"location":"user-guide/conversion/sensor-mapping/#step-2-edit-mappings","title":"Step 2: Edit Mappings","text":"<p>Open <code>custom_mapping.yaml</code> and modify:</p> <pre><code># Add your custom sensors\nchilled_water_supply:\n  brick_class: \"brick:Chilled_Water_Supply_Temperature_Sensor\"\n  description: \"Chilled water supply temperature\"\n  unit: \"DEG_C\"\n  equipment: \"chiller\"\n\nchilled_water_return:\n  brick_class: \"brick:Chilled_Water_Return_Temperature_Sensor\"\n  description: \"Chilled water return temperature\"\n  unit: \"DEG_C\"\n  equipment: \"chiller\"\n\n# Modify existing mappings\noutdoor_temp:\n  brick_class: \"brick:Outside_Air_Temperature_Sensor\"\n  description: \"Custom outdoor sensor at roof level\"  # Changed\n  unit: \"DEG_F\"  # Changed to Fahrenheit\n  equipment: \"building\"\n</code></pre>"},{"location":"user-guide/conversion/sensor-mapping/#step-3-use-custom-mapping","title":"Step 3: Use Custom Mapping","text":"<pre><code>from hhw_brick import CSVToBrickConverter\n\nconverter = CSVToBrickConverter()\nresult = converter.convert_to_brick(\n    metadata_csv=\"metadata.csv\",\n    vars_csv=\"vars.csv\",\n    sensor_mapping=\"custom_mapping.yaml\",  # Your custom file\n    output_path=\"output.ttl\"\n)\n</code></pre>"},{"location":"user-guide/conversion/sensor-mapping/#common-customizations","title":"Common Customizations","text":""},{"location":"user-guide/conversion/sensor-mapping/#add-building-specific-sensors","title":"Add Building-Specific Sensors","text":"<p>Your building has unique sensors:</p> <pre><code># custom_mapping.yaml\n\n# Add solar collector sensors\nsolar_panel_temp:\n  brick_class: \"brick:Solar_Panel_Temperature_Sensor\"\n  description: \"Solar thermal panel temperature\"\n  unit: \"DEG_C\"\n  equipment: \"solar_collector\"\n\nsolar_flow:\n  brick_class: \"brick:Water_Flow_Sensor\"\n  description: \"Solar collector flow rate\"\n  unit: \"L_PER_MIN\"\n  equipment: \"solar_collector\"\n\n# Add thermal storage sensors\nstorage_tank_top:\n  brick_class: \"brick:Temperature_Sensor\"\n  description: \"Thermal storage tank top temperature\"\n  unit: \"DEG_C\"\n  equipment: \"thermal_storage\"\n\nstorage_tank_bottom:\n  brick_class: \"brick:Temperature_Sensor\"\n  description: \"Thermal storage tank bottom temperature\"\n  unit: \"DEG_C\"\n  equipment: \"thermal_storage\"\n</code></pre>"},{"location":"user-guide/conversion/sensor-mapping/#change-units","title":"Change Units","text":"<p>Convert between measurement systems:</p> <pre><code># Use Fahrenheit instead of Celsius\nhw_supply_temp:\n  brick_class: \"brick:Hot_Water_Supply_Temperature_Sensor\"\n  description: \"Hot water supply temperature\"\n  unit: \"DEG_F\"  # Changed from DEG_C\n  equipment: \"primary_loop\"\n\n# Use gallons per minute instead of liters\nhw_flow:\n  brick_class: \"brick:Water_Flow_Sensor\"\n  description: \"Primary hot water flow rate\"\n  unit: \"GAL_PER_MIN\"  # Changed from L_PER_MIN\n  equipment: \"primary_loop\"\n</code></pre>"},{"location":"user-guide/conversion/sensor-mapping/#use-more-specific-classes","title":"Use More Specific Classes","text":"<p>Brick has many specialized classes:</p> <pre><code># Instead of generic Temperature_Sensor\n# Use specific class:\nsupply_temp:\n  brick_class: \"brick:Leaving_Hot_Water_Temperature_Sensor\"  # Specific\n  # vs brick:Temperature_Sensor (generic)\n  description: \"Hot water leaving temperature\"\n  unit: \"DEG_C\"\n  equipment: \"boiler\"\n\n# Instead of generic Sensor\n# Use specific measurement type:\nenergy_meter:\n  brick_class: \"brick:Thermal_Energy_Sensor\"  # Specific\n  # vs brick:Sensor (generic)\n  description: \"Thermal energy meter\"\n  unit: \"KWH\"\n  equipment: \"primary_loop\"\n</code></pre>"},{"location":"user-guide/conversion/sensor-mapping/#brick-class-reference","title":"Brick Class Reference","text":""},{"location":"user-guide/conversion/sensor-mapping/#common-brick-classes","title":"Common Brick Classes","text":""},{"location":"user-guide/conversion/sensor-mapping/#temperature","title":"Temperature","text":"<ul> <li><code>brick:Temperature_Sensor</code> - Generic</li> <li><code>brick:Hot_Water_Supply_Temperature_Sensor</code> - HW supply</li> <li><code>brick:Hot_Water_Return_Temperature_Sensor</code> - HW return</li> <li><code>brick:Leaving_Hot_Water_Temperature_Sensor</code> - Equipment leaving</li> <li><code>brick:Entering_Hot_Water_Temperature_Sensor</code> - Equipment entering</li> <li><code>brick:Outside_Air_Temperature_Sensor</code> - Outdoor</li> <li><code>brick:Chilled_Water_Supply_Temperature_Sensor</code> - CHW supply</li> <li><code>brick:Chilled_Water_Return_Temperature_Sensor</code> - CHW return</li> </ul>"},{"location":"user-guide/conversion/sensor-mapping/#flow","title":"Flow","text":"<ul> <li><code>brick:Water_Flow_Sensor</code> - Water flow rate</li> <li><code>brick:Air_Flow_Sensor</code> - Air flow rate</li> <li><code>brick:Steam_Flow_Sensor</code> - Steam flow</li> </ul>"},{"location":"user-guide/conversion/sensor-mapping/#pressure","title":"Pressure","text":"<ul> <li><code>brick:Water_Pressure_Sensor</code> - Water pressure</li> <li><code>brick:Steam_Pressure_Sensor</code> - Steam pressure</li> <li><code>brick:Differential_Pressure_Sensor</code> - Pressure difference</li> </ul>"},{"location":"user-guide/conversion/sensor-mapping/#powerenergy","title":"Power/Energy","text":"<ul> <li><code>brick:Power_Sensor</code> - Electrical power</li> <li><code>brick:Energy_Sensor</code> - Energy consumption</li> <li><code>brick:Thermal_Power_Sensor</code> - Thermal power</li> <li><code>brick:Thermal_Energy_Sensor</code> - Thermal energy</li> </ul>"},{"location":"user-guide/conversion/sensor-mapping/#control","title":"Control","text":"<ul> <li><code>brick:Valve_Command</code> - Valve position</li> <li><code>brick:Heating_Valve</code> - Heating valve</li> <li><code>brick:VFD_Enable_Command</code> - VFD status</li> <li><code>brick:Speed_Setpoint</code> - Speed setpoint</li> </ul>"},{"location":"user-guide/conversion/sensor-mapping/#status","title":"Status","text":"<ul> <li><code>brick:Run_Status</code> - Equipment running</li> <li><code>brick:Enable_Status</code> - Equipment enabled</li> <li><code>brick:Alarm_Status</code> - Alarm condition</li> </ul>"},{"location":"user-guide/conversion/sensor-mapping/#finding-brick-classes","title":"Finding Brick Classes","text":"<p>Browse online: Brick Schema Explorer</p> <p>Search in Python: <pre><code>from brickschema import Graph\n\ng = Graph(load_brick=True)\n\n# Find all sensor types\nquery = \"\"\"\nPREFIX brick: &lt;https://brickschema.org/schema/Brick#&gt;\nSELECT ?sensor WHERE {\n    ?sensor rdfs:subClassOf* brick:Sensor .\n}\n\"\"\"\n\nfor row in g.query(query):\n    print(row.sensor)\n</code></pre></p>"},{"location":"user-guide/conversion/sensor-mapping/#validation","title":"Validation","text":""},{"location":"user-guide/conversion/sensor-mapping/#check-your-mapping","title":"Check Your Mapping","text":"<p>Validate mapping file structure:</p> <pre><code>import yaml\n\n# Load mapping\nwith open('custom_mapping.yaml', 'r') as f:\n    mapping = yaml.safe_load(f)\n\n# Check required fields\nfor sensor, config in mapping.items():\n    if 'brick_class' not in config:\n        print(f\"\u274c {sensor}: missing brick_class\")\n    if 'description' not in config:\n        print(f\"\u26a0\ufe0f  {sensor}: missing description (optional)\")\n\n    # Check brick_class format\n    if not config['brick_class'].startswith('brick:'):\n        print(f\"\u26a0\ufe0f  {sensor}: brick_class should start with 'brick:'\")\n</code></pre>"},{"location":"user-guide/conversion/sensor-mapping/#test-custom-mapping","title":"Test Custom Mapping","text":"<p>Test with a small dataset:</p> <pre><code>from hhw_brick import CSVToBrickConverter\n\nconverter = CSVToBrickConverter()\n\ntry:\n    result = converter.convert_to_brick(\n        metadata_csv=\"test_metadata.csv\",\n        vars_csv=\"test_vars.csv\",\n        building_tag=\"105\",\n        sensor_mapping=\"custom_mapping.yaml\",\n        output_path=\"test_output.ttl\"\n    )\n    print(f\"\u2713 Custom mapping works! Created {len(result)} triples\")\nexcept Exception as e:\n    print(f\"\u274c Error with custom mapping: {e}\")\n</code></pre>"},{"location":"user-guide/conversion/sensor-mapping/#complete-custom-mapping-example","title":"Complete Custom Mapping Example","text":""},{"location":"user-guide/conversion/sensor-mapping/#building-with-geothermal-system","title":"Building with Geothermal System","text":"<pre><code># geothermal_mapping.yaml\n\n# Geothermal loop sensors\ngeo_source_supply:\n  brick_class: \"brick:Leaving_Water_Temperature_Sensor\"\n  description: \"Geothermal source loop supply temperature\"\n  unit: \"DEG_C\"\n  equipment: \"geothermal_loop\"\n\ngeo_source_return:\n  brick_class: \"brick:Entering_Water_Temperature_Sensor\"\n  description: \"Geothermal source loop return temperature\"\n  unit: \"DEG_C\"\n  equipment: \"geothermal_loop\"\n\ngeo_flow:\n  brick_class: \"brick:Water_Flow_Sensor\"\n  description: \"Geothermal loop flow rate\"\n  unit: \"L_PER_MIN\"\n  equipment: \"geothermal_loop\"\n\n# Heat pump sensors\nhp_leaving_temp:\n  brick_class: \"brick:Leaving_Hot_Water_Temperature_Sensor\"\n  description: \"Heat pump leaving water temperature\"\n  unit: \"DEG_C\"\n  equipment: \"heat_pump\"\n\nhp_entering_temp:\n  brick_class: \"brick:Entering_Hot_Water_Temperature_Sensor\"\n  description: \"Heat pump entering water temperature\"\n  unit: \"DEG_C\"\n  equipment: \"heat_pump\"\n\nhp_power:\n  brick_class: \"brick:Power_Sensor\"\n  description: \"Heat pump electrical power\"\n  unit: \"KW\"\n  equipment: \"heat_pump\"\n\nhp_cop:\n  brick_class: \"brick:Sensor\"\n  description: \"Heat pump coefficient of performance\"\n  unit: \"DIMENSIONLESS\"\n  equipment: \"heat_pump\"\n\n# Building loop (same as standard)\nhw_supply_temp:\n  brick_class: \"brick:Hot_Water_Supply_Temperature_Sensor\"\n  description: \"Building hot water supply\"\n  unit: \"DEG_C\"\n  equipment: \"building_loop\"\n\nhw_return_temp:\n  brick_class: \"brick:Hot_Water_Return_Temperature_Sensor\"\n  description: \"Building hot water return\"\n  unit: \"DEG_C\"\n  equipment: \"building_loop\"\n</code></pre>"},{"location":"user-guide/conversion/sensor-mapping/#usage","title":"Usage","text":"<pre><code>from hhw_brick import CSVToBrickConverter\n\nconverter = CSVToBrickConverter()\nresult = converter.convert_to_brick(\n    metadata_csv=\"geothermal_buildings.csv\",\n    vars_csv=\"geothermal_sensors.csv\",\n    building_tag=\"205\",\n    sensor_mapping=\"geothermal_mapping.yaml\",\n    output_path=\"geothermal_building_205.ttl\"\n)\n</code></pre>"},{"location":"user-guide/conversion/sensor-mapping/#troubleshooting","title":"Troubleshooting","text":""},{"location":"user-guide/conversion/sensor-mapping/#issue-unknown-sensor-type","title":"Issue: \"Unknown sensor type\"","text":"<p>Cause: Sensor in CSV not in mapping file</p> <p>Solution: Add it to your custom mapping: <pre><code>new_sensor:\n  brick_class: \"brick:Sensor\"\n  description: \"New sensor type\"\n  unit: \"UNIT\"\n  equipment: \"equipment_type\"\n</code></pre></p>"},{"location":"user-guide/conversion/sensor-mapping/#issue-invalid-brick-class","title":"Issue: \"Invalid Brick class\"","text":"<p>Cause: Brick class doesn't exist</p> <p>Solution: Check class name at Brick Explorer</p> <pre><code># Wrong:\ntemp_sensor:\n  brick_class: \"brick:TemperatureSensor\"  # No such class\n\n# Right:\ntemp_sensor:\n  brick_class: \"brick:Temperature_Sensor\"  # Underscores\n</code></pre>"},{"location":"user-guide/conversion/sensor-mapping/#issue-mapping-not-being-used","title":"Issue: Mapping not being used","text":"<p>Cause: File path incorrect</p> <p>Solution: <pre><code>import os\n\n# Check file exists\nmapping_file = \"custom_mapping.yaml\"\nif not os.path.exists(mapping_file):\n    print(f\"\u274c File not found: {mapping_file}\")\nelse:\n    print(f\"\u2713 File exists: {os.path.abspath(mapping_file)}\")\n\n# Use absolute path\nresult = converter.convert_to_brick(\n    metadata_csv=\"metadata.csv\",\n    vars_csv=\"vars.csv\",\n    sensor_mapping=os.path.abspath(\"custom_mapping.yaml\"),\n    output_path=\"output.ttl\"\n)\n</code></pre></p>"},{"location":"user-guide/conversion/sensor-mapping/#best-practices","title":"Best Practices","text":""},{"location":"user-guide/conversion/sensor-mapping/#1-start-with-default","title":"1. Start with Default","text":"<p>Don't create from scratch: <pre><code># Copy default as starting point\ncp hhw_brick/conversion/sensor_to_brick_mapping.yaml my_mapping.yaml\n\n# Edit only what you need to change\n</code></pre></p>"},{"location":"user-guide/conversion/sensor-mapping/#2-use-specific-classes","title":"2. Use Specific Classes","text":"<p>Prefer specific Brick classes over generic: <pre><code># \u2713 Good - Specific\nsupply_temp:\n  brick_class: \"brick:Leaving_Hot_Water_Temperature_Sensor\"\n\n# \u2717 Avoid - Too generic\nsupply_temp:\n  brick_class: \"brick:Sensor\"\n</code></pre></p>"},{"location":"user-guide/conversion/sensor-mapping/#3-document-well","title":"3. Document Well","text":"<p>Write clear descriptions: <pre><code># \u2713 Good - Clear description\npmp1_vfd:\n  brick_class: \"brick:VFD_Enable_Command\"\n  description: \"Primary pump 1 variable frequency drive enable status\"\n  unit: \"BINARY\"\n  equipment: \"pump\"\n\n# \u2717 Avoid - Vague\npmp1_vfd:\n  brick_class: \"brick:VFD_Enable_Command\"\n  description: \"VFD\"  # Too brief\n  unit: \"BINARY\"\n  equipment: \"pump\"\n</code></pre></p>"},{"location":"user-guide/conversion/sensor-mapping/#4-version-control","title":"4. Version Control","text":"<p>Keep mapping files in version control: <pre><code>git add custom_mapping.yaml\ngit commit -m \"Add geothermal sensor mappings\"\n</code></pre></p>"},{"location":"user-guide/conversion/sensor-mapping/#5-test-thoroughly","title":"5. Test Thoroughly","text":"<p>Test with sample data before production use.</p>"},{"location":"user-guide/conversion/sensor-mapping/#next-steps","title":"Next Steps","text":"<ul> <li>Validation - Validate converted models</li> <li>Applications - Run analytics</li> <li>Examples - More examples</li> </ul> <p>Conversion documentation complete! \ud83c\udf89</p> <p>Continue to Validation Guide \u2192</p>"},{"location":"user-guide/conversion/single-building/","title":"Single Building Conversion","text":"<p>Detailed guide to converting individual buildings from CSV to Brick format.</p>"},{"location":"user-guide/conversion/single-building/#overview","title":"Overview","text":"<p>Single building conversion gives you precise control over the conversion process. It's ideal for:</p> <ul> <li>Development and testing - Work with one building at a time</li> <li>Custom workflows - Integrate into your own scripts</li> <li>Detailed inspection - Examine the output carefully</li> <li>Targeted conversion - Convert specific buildings</li> </ul>"},{"location":"user-guide/conversion/single-building/#basic-usage","title":"Basic Usage","text":""},{"location":"user-guide/conversion/single-building/#minimal-example","title":"Minimal Example","text":"<p>The simplest possible conversion:</p> <pre><code>from hhw_brick import CSVToBrickConverter\n\nconverter = CSVToBrickConverter()\nresult = converter.convert_to_brick(\n    metadata_csv=\"metadata.csv\",\n    vars_csv=\"vars_available_by_building.csv\",\n    building_tag=\"105\",\n    output_path=\"building_105.ttl\"\n)\n\nprint(f\"\u2713 Created {len(result)} RDF triples\")\n</code></pre> <p>This will: 1. Read building #105 from the CSV files 2. Auto-detect the system type 3. Create appropriate Brick entities 4. Save to <code>building_105.ttl</code></p>"},{"location":"user-guide/conversion/single-building/#complete-example","title":"Complete Example","text":"<p>With all parameters:</p> <pre><code>from hhw_brick import CSVToBrickConverter\n\nconverter = CSVToBrickConverter()\n\nresult = converter.convert_to_brick(\n    metadata_csv=\"metadata.csv\",\n    vars_csv=\"vars_available_by_building.csv\",\n    building_tag=\"105\",\n    system_type=\"Non-condensing\",  # Optional: specify type\n    sensor_mapping=\"custom_mapping.yaml\",  # Optional: custom mapping\n    output_path=\"output/building_105_non-condensing.ttl\"\n)\n\n# Check for warnings\nif converter.validation_warnings:\n    print(\"Warnings during conversion:\")\n    for warning in converter.validation_warnings:\n        print(f\"  \u26a0 {warning}\")\n\nprint(f\"\u2713 Conversion complete: {len(result)} triples\")\n</code></pre>"},{"location":"user-guide/conversion/single-building/#parameters-explained","title":"Parameters Explained","text":""},{"location":"user-guide/conversion/single-building/#required-parameters","title":"Required Parameters","text":""},{"location":"user-guide/conversion/single-building/#metadata_csv","title":"metadata_csv","text":"<p>Path to the building metadata file.</p> <pre><code>metadata_csv=\"path/to/metadata.csv\"\n</code></pre> <p>Format: <pre><code>tag,system,org\n105,Non-condensing,Organization A\n106,Condensing,Organization B\n</code></pre></p>"},{"location":"user-guide/conversion/single-building/#vars_csv","title":"vars_csv","text":"<p>Path to the sensor availability file.</p> <pre><code>vars_csv=\"path/to/vars_available_by_building.csv\"\n</code></pre> <p>Format: <pre><code>tag,hw_supply_temp,hw_return_temp,hw_flow\n105,1,1,1\n106,1,1,0\n</code></pre></p>"},{"location":"user-guide/conversion/single-building/#optional-parameters","title":"Optional Parameters","text":""},{"location":"user-guide/conversion/single-building/#building_tag","title":"building_tag","text":"<p>Specific building ID to convert.</p> <pre><code>building_tag=\"105\"  # Convert only building 105\n</code></pre> <ul> <li>Type: String or Integer</li> <li>Default: <code>None</code> (converts all matching buildings)</li> <li>When to use: Convert a single specific building</li> </ul> <p>Example: <pre><code># Convert building 105 only\nresult = converter.convert_to_brick(\n    metadata_csv=\"metadata.csv\",\n    vars_csv=\"vars.csv\",\n    building_tag=\"105\",  # Specific building\n    output_path=\"building_105.ttl\"\n)\n</code></pre></p>"},{"location":"user-guide/conversion/single-building/#system_type","title":"system_type","text":"<p>Filter by HVAC system type.</p> <pre><code>system_type=\"Condensing\"  # Only condensing systems\n</code></pre> <ul> <li>Type: String</li> <li>Default: <code>None</code> (auto-detect from metadata)</li> <li>Options: <code>\"Boiler\"</code>, <code>\"Non-condensing\"</code>, <code>\"Condensing\"</code>, <code>\"District HW\"</code>, <code>\"District Steam\"</code></li> <li>Case insensitive</li> </ul> <p>When to use: - Converting multiple buildings of the same type - Filtering a large dataset - Validation (ensure building matches expected type)</p> <p>Example: <pre><code># Convert all condensing systems\nresult = converter.convert_to_brick(\n    metadata_csv=\"metadata.csv\",\n    vars_csv=\"vars.csv\",\n    system_type=\"Condensing\",\n    output_path=\"all_condensing.ttl\"\n)\n</code></pre></p>"},{"location":"user-guide/conversion/single-building/#sensor_mapping","title":"sensor_mapping","text":"<p>Custom sensor mapping file.</p> <pre><code>sensor_mapping=\"my_custom_mapping.yaml\"\n</code></pre> <ul> <li>Type: String (file path)</li> <li>Default: Uses built-in mapping</li> <li>Format: YAML file</li> </ul> <p>See Sensor Mapping for details.</p>"},{"location":"user-guide/conversion/single-building/#output_path","title":"output_path","text":"<p>Where to save the generated Brick model.</p> <pre><code>output_path=\"output/building_105.ttl\"\n</code></pre> <ul> <li>Type: String (file path)</li> <li>Default: <code>\"output.ttl\"</code></li> <li>Format: Creates TTL (Turtle) format file</li> </ul>"},{"location":"user-guide/conversion/single-building/#return-value","title":"Return Value","text":"<p>The <code>convert_to_brick()</code> method returns an RDFLib Graph object.</p> <pre><code>result = converter.convert_to_brick(...)\n\n# Result is an rdflib.Graph\nprint(type(result))  # &lt;class 'rdflib.graph.Graph'&gt;\nprint(len(result))   # Number of RDF triples\n\n# Query the graph\nfor s, p, o in result:\n    print(f\"{s} {p} {o}\")\n</code></pre>"},{"location":"user-guide/conversion/single-building/#working-with-the-graph","title":"Working with the Graph","text":"<pre><code>from rdflib import Namespace\n\nresult = converter.convert_to_brick(\n    metadata_csv=\"metadata.csv\",\n    vars_csv=\"vars.csv\",\n    building_tag=\"105\",\n    output_path=\"building_105.ttl\"\n)\n\n# Define namespaces\nBRICK = Namespace(\"https://brickschema.org/schema/Brick#\")\n\n# Query for equipment\nquery = \"\"\"\nPREFIX brick: &lt;https://brickschema.org/schema/Brick#&gt;\n\nSELECT ?equip ?type WHERE {\n    ?equip a ?type .\n    FILTER(STRSTARTS(STR(?type), STR(brick:)))\n}\n\"\"\"\n\nprint(\"Equipment in model:\")\nfor row in result.query(query):\n    equip_name = str(row.equip).split('#')[-1]\n    type_name = str(row.type).split('#')[-1]\n    print(f\"  - {equip_name}: {type_name}\")\n\n# Serialize in different formats\nresult.serialize(\"output.xml\", format=\"xml\")\nresult.serialize(\"output.json\", format=\"json-ld\")\nresult.serialize(\"output.nt\", format=\"nt\")  # N-Triples\n</code></pre>"},{"location":"user-guide/conversion/single-building/#step-by-step-workflow","title":"Step-by-Step Workflow","text":""},{"location":"user-guide/conversion/single-building/#step-1-prepare-data","title":"Step 1: Prepare Data","text":"<p>Ensure your CSV files are ready:</p> <pre><code>import pandas as pd\n\n# Check metadata\nmetadata = pd.read_csv(\"metadata.csv\")\nprint(\"Buildings in metadata:\")\nprint(metadata[['tag', 'system', 'org']])\n\n# Check vars\nvars_df = pd.read_csv(\"vars_available_by_building.csv\")\nprint(\"\\nSensors available:\")\nprint(vars_df.head())\n</code></pre>"},{"location":"user-guide/conversion/single-building/#step-2-initialize-converter","title":"Step 2: Initialize Converter","text":"<pre><code>from hhw_brick import CSVToBrickConverter\n\nconverter = CSVToBrickConverter()\n</code></pre> <p>The converter initializes with: - Default namespaces (Brick, REC, etc.) - Empty RDF graph - Built-in sensor mapping</p>"},{"location":"user-guide/conversion/single-building/#step-3-convert","title":"Step 3: Convert","text":"<pre><code>result = converter.convert_to_brick(\n    metadata_csv=\"metadata.csv\",\n    vars_csv=\"vars_available_by_building.csv\",\n    building_tag=\"105\",\n    output_path=\"building_105.ttl\"\n)\n</code></pre> <p>During conversion: 1. \u2713 Reads CSV files 2. \u2713 Finds building #105 3. \u2713 Identifies system type 4. \u2713 Creates building entity 5. \u2713 Creates equipment entities 6. \u2713 Creates sensor/point entities 7. \u2713 Adds relationships 8. \u2713 Writes to file</p>"},{"location":"user-guide/conversion/single-building/#step-4-validate-output","title":"Step 4: Validate Output","text":"<pre><code>from hhw_brick import BrickModelValidator\n\nvalidator = BrickModelValidator()\nis_valid, report = validator.validate_model(\"building_105.ttl\")\n\nif is_valid:\n    print(\"\u2713 Model is valid!\")\nelse:\n    print(\"Validation report:\")\n    print(report)\n</code></pre>"},{"location":"user-guide/conversion/single-building/#step-5-inspect-results","title":"Step 5: Inspect Results","text":"<pre><code>from rdflib import Graph\n\n# Load the model\ng = Graph()\ng.parse(\"building_105.ttl\", format=\"turtle\")\n\n# Count entities\nprint(f\"Total triples: {len(g)}\")\n\n# List all equipment\nquery = \"\"\"\nPREFIX brick: &lt;https://brickschema.org/schema/Brick#&gt;\n\nSELECT DISTINCT ?type WHERE {\n    ?equip a ?type .\n    FILTER(STRSTARTS(STR(?type), STR(brick:)))\n}\n\"\"\"\n\nprint(\"\\nEquipment types:\")\nfor row in g.query(query):\n    print(f\"  - {str(row.type).split('#')[-1]}\")\n</code></pre>"},{"location":"user-guide/conversion/single-building/#common-patterns","title":"Common Patterns","text":""},{"location":"user-guide/conversion/single-building/#pattern-1-convert-multiple-buildings-sequentially","title":"Pattern 1: Convert Multiple Buildings Sequentially","text":"<pre><code>\"\"\"\nConvert multiple specific buildings one by one\n\"\"\"\nfrom hhw_brick import CSVToBrickConverter\n\nconverter = CSVToBrickConverter()\nbuilding_ids = [\"105\", \"106\", \"107\", \"108\"]\n\nfor building_id in building_ids:\n    print(f\"Converting building {building_id}...\")\n\n    try:\n        result = converter.convert_to_brick(\n            metadata_csv=\"metadata.csv\",\n            vars_csv=\"vars.csv\",\n            building_tag=building_id,\n            output_path=f\"output/building_{building_id}.ttl\"\n        )\n\n        print(f\"  \u2713 Success: {len(result)} triples\")\n\n    except Exception as e:\n        print(f\"  \u2717 Failed: {e}\")\n\n    # Clear graph for next building\n    converter.graph = converter.graph.__class__()\n</code></pre>"},{"location":"user-guide/conversion/single-building/#pattern-2-conditional-conversion","title":"Pattern 2: Conditional Conversion","text":"<pre><code>\"\"\"\nConvert only if building meets criteria\n\"\"\"\nimport pandas as pd\nfrom hhw_brick import CSVToBrickConverter\n\nmetadata = pd.read_csv(\"metadata.csv\")\nconverter = CSVToBrickConverter()\n\nfor _, building in metadata.iterrows():\n    building_id = str(int(building['tag']))\n    system = building['system']\n\n    # Only convert condensing systems\n    if 'condensing' in system.lower():\n        print(f\"Converting {building_id} ({system})...\")\n\n        result = converter.convert_to_brick(\n            metadata_csv=\"metadata.csv\",\n            vars_csv=\"vars.csv\",\n            building_tag=building_id,\n            output_path=f\"condensing/building_{building_id}.ttl\"\n        )\n\n        print(f\"  \u2713 {len(result)} triples\")\n</code></pre>"},{"location":"user-guide/conversion/single-building/#pattern-3-conversion-with-validation","title":"Pattern 3: Conversion with Validation","text":"<pre><code>\"\"\"\nConvert and validate in one workflow\n\"\"\"\nfrom hhw_brick import CSVToBrickConverter, BrickModelValidator\n\ndef convert_and_validate(building_id):\n    \"\"\"Convert a building and validate the result.\"\"\"\n\n    # Convert\n    converter = CSVToBrickConverter()\n    output_file = f\"building_{building_id}.ttl\"\n\n    result = converter.convert_to_brick(\n        metadata_csv=\"metadata.csv\",\n        vars_csv=\"vars.csv\",\n        building_tag=building_id,\n        output_path=output_file\n    )\n\n    print(f\"Converted: {len(result)} triples\")\n\n    # Validate\n    validator = BrickModelValidator()\n    is_valid, report = validator.validate_model(output_file)\n\n    if is_valid:\n        print(\"\u2713 Validation passed\")\n        return True, output_file\n    else:\n        print(\"\u26a0 Validation warnings:\")\n        for warning in report.get('warnings', []):\n            print(f\"  - {warning}\")\n        return False, output_file\n\n# Use it\nsuccess, file = convert_and_validate(\"105\")\n</code></pre>"},{"location":"user-guide/conversion/single-building/#advanced-usage","title":"Advanced Usage","text":""},{"location":"user-guide/conversion/single-building/#custom-output-processing","title":"Custom Output Processing","text":"<pre><code>\"\"\"\nProcess the graph before saving\n\"\"\"\nfrom hhw_brick import CSVToBrickConverter\nfrom rdflib import Namespace, Literal\n\nconverter = CSVToBrickConverter()\nresult = converter.convert_to_brick(\n    metadata_csv=\"metadata.csv\",\n    vars_csv=\"vars.csv\",\n    building_tag=\"105\",\n    output_path=\"temp.ttl\"\n)\n\n# Add custom metadata\nHHWS = Namespace(\"https://hhws.example.org#\")\nbuilding_uri = HHWS.Building_105\n\nresult.add((\n    building_uri,\n    HHWS.conversionDate,\n    Literal(\"2025-10-30\")\n))\n\nresult.add((\n    building_uri,\n    HHWS.conversionTool,\n    Literal(\"HHW Brick Application v0.2.0\")\n))\n\n# Save with custom metadata\nresult.serialize(\"building_105_annotated.ttl\", format=\"turtle\")\n</code></pre>"},{"location":"user-guide/conversion/single-building/#merging-multiple-buildings","title":"Merging Multiple Buildings","text":"<pre><code>\"\"\"\nCombine multiple buildings into one graph\n\"\"\"\nfrom hhw_brick import CSVToBrickConverter\nfrom rdflib import Graph\n\nconverter = CSVToBrickConverter()\ncombined = Graph()\n\n# Bind namespaces\nfor prefix, namespace in converter.graph.namespace_manager.namespaces():\n    combined.bind(prefix, namespace)\n\n# Convert and merge multiple buildings\nfor building_id in [\"105\", \"106\", \"107\"]:\n    result = converter.convert_to_brick(\n        metadata_csv=\"metadata.csv\",\n        vars_csv=\"vars.csv\",\n        building_tag=building_id,\n        output_path=f\"temp_{building_id}.ttl\"\n    )\n\n    # Add to combined graph\n    combined += result\n\n    print(f\"Added building {building_id}: {len(result)} triples\")\n\n# Save combined graph\ncombined.serialize(\"campus_model.ttl\", format=\"turtle\")\nprint(f\"\\nCombined model: {len(combined)} total triples\")\n</code></pre>"},{"location":"user-guide/conversion/single-building/#troubleshooting","title":"Troubleshooting","text":""},{"location":"user-guide/conversion/single-building/#issue-no-data-found-for-building-tag","title":"Issue: \"No data found for building tag\"","text":"<p>Cause: Building ID doesn't exist in CSV files</p> <p>Solution: <pre><code>import pandas as pd\n\n# Check which buildings exist\nmetadata = pd.read_csv(\"metadata.csv\")\nprint(\"Available building IDs:\")\nprint(metadata['tag'].tolist())\n\n# Then use a valid ID\nresult = converter.convert_to_brick(\n    metadata_csv=\"metadata.csv\",\n    vars_csv=\"vars.csv\",\n    building_tag=\"105\",  # Must be in the list above\n    output_path=\"output.ttl\"\n)\n</code></pre></p>"},{"location":"user-guide/conversion/single-building/#issue-conversion-warnings","title":"Issue: Conversion warnings","text":"<p>Cause: Some data issues (usually minor)</p> <p>Solution: <pre><code>converter = CSVToBrickConverter()\nresult = converter.convert_to_brick(...)\n\n# Check warnings\nif converter.validation_warnings:\n    print(\"Conversion completed with warnings:\")\n    for w in converter.validation_warnings:\n        print(f\"  {w}\")\n    print(\"\\nThese are usually safe to ignore.\")\n</code></pre></p>"},{"location":"user-guide/conversion/single-building/#issue-empty-output-file","title":"Issue: Empty output file","text":"<p>Cause: No matching data or wrong filters</p> <p>Solution: <pre><code># Don't use system_type filter unless needed\nresult = converter.convert_to_brick(\n    metadata_csv=\"metadata.csv\",\n    vars_csv=\"vars.csv\",\n    building_tag=\"105\",\n    # system_type=\"Condensing\",  # Remove this if not needed\n    output_path=\"output.ttl\"\n)\n</code></pre></p>"},{"location":"user-guide/conversion/single-building/#performance-tips","title":"Performance Tips","text":""},{"location":"user-guide/conversion/single-building/#memory-management","title":"Memory Management","text":"<p>Clear the graph between conversions:</p> <pre><code>converter = CSVToBrickConverter()\n\nfor building_id in range(105, 200):\n    result = converter.convert_to_brick(...)\n\n    # Clear for next iteration\n    converter.graph = converter.graph.__class__()\n</code></pre>"},{"location":"user-guide/conversion/single-building/#batch-vs-sequential","title":"Batch vs Sequential","text":"<p>For many buildings, use BatchConverter instead:</p> <pre><code># Instead of this:\nfor building_id in all_buildings:\n    converter.convert_to_brick(building_tag=building_id, ...)\n\n# Use this:\nfrom hhw_brick import BatchConverter\nbatch = BatchConverter()\nbatch.convert_all_buildings(...)\n</code></pre> <p>See Batch Conversion for details.</p>"},{"location":"user-guide/conversion/single-building/#next-steps","title":"Next Steps","text":"<ul> <li>Batch Conversion - Convert multiple buildings efficiently</li> <li>System Types - Understand different HVAC systems</li> <li>Sensor Mapping - Customize sensor mappings</li> <li>Examples - More code examples</li> </ul> <p>Continue to: Batch Conversion \u2192</p>"},{"location":"user-guide/conversion/system-types/","title":"System Types","text":"<p>Understanding the different HVAC system types supported by HHW Brick Application.</p>"},{"location":"user-guide/conversion/system-types/#overview","title":"Overview","text":"<p>HHW Brick Application supports five main system types for heating hot water systems. Each system type has different equipment configurations and Brick class mappings.</p>"},{"location":"user-guide/conversion/system-types/#supported-system-types","title":"Supported System Types","text":"System Type Description Common Use Equipment Created Boiler Generic boiler system Legacy/generic buildings Boiler, pumps Non-condensing Non-condensing boiler with heat exchanger Older buildings Boiler, HX, primary/secondary loops Condensing High-efficiency condensing boiler Modern buildings Condensing boiler, HX, loops District HW District hot water connection Campus settings District connection, HX, building loop District Steam District steam connection Dense urban areas Steam connection, HX, building loop"},{"location":"user-guide/conversion/system-types/#system-type-details","title":"System Type Details","text":""},{"location":"user-guide/conversion/system-types/#1-boiler-systems","title":"1. Boiler Systems","text":"<p>Generic boiler system without specific efficiency classification.</p>"},{"location":"user-guide/conversion/system-types/#equipment-hierarchy","title":"Equipment Hierarchy","text":"<pre><code>graph TD\n    B[Boiler] --&gt;|has point| SP[Supply Temp]\n    B --&gt;|has point| RP[Return Temp]\n    B --&gt;|has point| F[Flow]\n    B --&gt;|feeds| P[Pump]\n\n    style B fill:#ff9800\n    style P fill:#2196f3</code></pre>"},{"location":"user-guide/conversion/system-types/#created-equipment","title":"Created Equipment","text":"<ul> <li>Boiler (<code>brick:Boiler</code>)</li> <li>Supply temperature sensor</li> <li>Return temperature sensor</li> <li> <p>Flow sensor (if available)</p> </li> <li> <p>Pumps (<code>brick:Water_Pump</code>)</p> </li> <li>Primary pumps</li> <li>Variable frequency drives (if available)</li> </ul>"},{"location":"user-guide/conversion/system-types/#csv-example","title":"CSV Example","text":"<pre><code># metadata.csv\ntag,system,org\n105,Boiler,Organization A\n\n# vars_available_by_building.csv\ntag,hw_supply_temp,hw_return_temp,hw_flow\n105,1,1,1\n</code></pre>"},{"location":"user-guide/conversion/system-types/#2-non-condensing-systems","title":"2. Non-condensing Systems","text":"<p>Non-condensing boiler with heat exchanger separating primary and secondary loops.</p>"},{"location":"user-guide/conversion/system-types/#equipment-hierarchy_1","title":"Equipment Hierarchy","text":"<pre><code>graph LR\n    B[Boiler&lt;br/&gt;Primary] --&gt;|feeds| HX[Heat&lt;br/&gt;Exchanger]\n    HX --&gt;|feeds| SL[Secondary&lt;br/&gt;Loop]\n    B --&gt;|has| PP[Primary&lt;br/&gt;Pump]\n    SL --&gt;|has| SP[Secondary&lt;br/&gt;Pump]\n\n    style B fill:#ff9800\n    style HX fill:#2196f3\n    style SL fill:#4caf50</code></pre>"},{"location":"user-guide/conversion/system-types/#created-equipment_1","title":"Created Equipment","text":"<p>Primary Side: - Boiler (<code>brick:Boiler</code>)   - HW supply temperature   - HW return temperature   - Flow rate   - Firing rate (if available)</p> <ul> <li>Primary Pumps (<code>brick:Water_Pump</code>)</li> <li>Pump power</li> <li>Pump speed</li> <li>VFD status</li> </ul> <p>Heat Transfer: - Heat Exchanger (<code>brick:Heat_Exchanger</code>)   - Primary/secondary interface</p> <p>Secondary Side: - Secondary Loop Equipment   - Supply/return temperatures   - Flow rate   - Pumps with VFDs</p>"},{"location":"user-guide/conversion/system-types/#csv-example_1","title":"CSV Example","text":"<pre><code># metadata.csv\ntag,system,org,b_number\n105,Non-condensing,Org A,2\n\n# vars_available_by_building.csv\ntag,hw_supply_temp,hw_return_temp,hw_flow,secondary_supply_temp,secondary_return_temp,secondary_flow,sup1,ret1,sup2,ret2\n105,1,1,1,1,1,1,1,1,1,1\n</code></pre>"},{"location":"user-guide/conversion/system-types/#multiple-boilers","title":"Multiple Boilers","text":"<p>The system can model multiple boilers:</p> <pre><code># Building with 3 boilers\n# metadata.csv: b_number=3\n# Creates: Boiler_Primary_1, Boiler_Primary_2, Boiler_Primary_3\n</code></pre>"},{"location":"user-guide/conversion/system-types/#3-condensing-systems","title":"3. Condensing Systems","text":"<p>High-efficiency condensing boiler systems with same topology as non-condensing.</p>"},{"location":"user-guide/conversion/system-types/#key-differences","title":"Key Differences","text":"Feature Non-condensing Condensing Boiler Type <code>brick:Boiler</code> <code>brick:Condensing_Boiler</code> Efficiency ~80-85% ~90-98% Exhaust Temp High (&gt;140\u00b0C) Low (&lt;60\u00b0C) Return Temp &gt;60\u00b0C Can be &lt;60\u00b0C"},{"location":"user-guide/conversion/system-types/#equipment-hierarchy_2","title":"Equipment Hierarchy","text":"<p>Same as non-condensing, but uses <code>brick:Condensing_Boiler</code> class.</p>"},{"location":"user-guide/conversion/system-types/#csv-example_2","title":"CSV Example","text":"<pre><code># metadata.csv\ntag,system,org\n106,Condensing,Org A\n\n# vars_available_by_building.csv (same format as non-condensing)\ntag,hw_supply_temp,hw_return_temp,hw_flow\n106,1,1,1\n</code></pre>"},{"location":"user-guide/conversion/system-types/#4-district-hot-water-district-hw","title":"4. District Hot Water (District HW)","text":"<p>Building connected to a campus-wide hot water distribution system.</p>"},{"location":"user-guide/conversion/system-types/#equipment-hierarchy_3","title":"Equipment Hierarchy","text":"<pre><code>graph LR\n    DS[District&lt;br/&gt;Supply] --&gt;|feeds| HX[Heat&lt;br/&gt;Exchanger]\n    HX --&gt;|feeds| BL[Building&lt;br/&gt;Loop]\n    DS --&gt;|has| DM[District&lt;br/&gt;Meter]\n    BL --&gt;|has| BP[Building&lt;br/&gt;Pump]\n\n    style DS fill:#9c27b0\n    style HX fill:#2196f3\n    style BL fill:#4caf50</code></pre>"},{"location":"user-guide/conversion/system-types/#created-equipment_2","title":"Created Equipment","text":"<p>District Side: - District Connection (<code>brick:District_Hot_Water_System</code>)   - Supply temperature   - Return temperature   - Flow meter   - Energy meter</p> <p>Building Side: - Heat Exchanger (<code>brick:Heat_Exchanger</code>) - Building Loop   - Secondary supply/return temperatures   - Building circulation pumps   - Control valves</p>"},{"location":"user-guide/conversion/system-types/#csv-example_3","title":"CSV Example","text":"<pre><code># metadata.csv\ntag,system,org\n108,District HW,Org B\n\n# vars_available_by_building.csv\ntag,hw_supply_temp,hw_return_temp,hw_flow,secondary_supply_temp,secondary_return_temp\n108,1,1,1,1,1\n</code></pre>"},{"location":"user-guide/conversion/system-types/#no-boilers","title":"No Boilers","text":"<p>District systems do not create boiler entities, even if boiler-related data exists:</p> <pre><code># If b_number &gt; 0 in District HW system:\n# \u26a0 Warning logged: \"District system but found boiler data\"\n# \u2713 No boilers created (correct behavior)\n</code></pre>"},{"location":"user-guide/conversion/system-types/#5-district-steam","title":"5. District Steam","text":"<p>Building connected to campus steam distribution.</p>"},{"location":"user-guide/conversion/system-types/#equipment-hierarchy_4","title":"Equipment Hierarchy","text":"<pre><code>graph LR\n    DST[District&lt;br/&gt;Steam] --&gt;|feeds| SC[Steam&lt;br/&gt;Condenser/HX]\n    SC --&gt;|feeds| BL[Building&lt;br/&gt;HW Loop]\n    SC --&gt;|returns| CR[Condensate&lt;br/&gt;Return]\n\n    style DST fill:#9c27b0\n    style SC fill:#ff5722\n    style BL fill:#4caf50</code></pre>"},{"location":"user-guide/conversion/system-types/#created-equipment_3","title":"Created Equipment","text":"<p>Steam Side: - District Steam Connection (<code>brick:District_Steam_System</code>)   - Steam pressure   - Steam temperature   - Condensate return temperature</p> <p>Conversion: - Steam-to-Water Heat Exchanger   - Steam condensing   - Hot water generation</p> <p>Building Side: - Hot Water Loop   - Supply/return temperatures   - Pumps and controls</p>"},{"location":"user-guide/conversion/system-types/#csv-example_4","title":"CSV Example","text":"<pre><code># metadata.csv\ntag,system,org\n109,District Steam,Org B\n\n# vars_available_by_building.csv\ntag,steam_pressure,condensate_temp,hw_supply_temp,hw_return_temp\n109,1,1,1,1\n</code></pre>"},{"location":"user-guide/conversion/system-types/#system-type-selection","title":"System Type Selection","text":""},{"location":"user-guide/conversion/system-types/#auto-detection","title":"Auto-Detection","text":"<p>If you don't specify <code>system_type</code>, it's auto-detected from metadata:</p> <pre><code>converter = CSVToBrickConverter()\nresult = converter.convert_to_brick(\n    metadata_csv=\"metadata.csv\",\n    vars_csv=\"vars.csv\",\n    building_tag=\"105\"\n    # system_type not specified - auto-detected\n)\n</code></pre>"},{"location":"user-guide/conversion/system-types/#manual-specification","title":"Manual Specification","text":"<p>You can override the metadata:</p> <pre><code>result = converter.convert_to_brick(\n    metadata_csv=\"metadata.csv\",\n    vars_csv=\"vars.csv\",\n    building_tag=\"105\",\n    system_type=\"Condensing\"  # Force this type\n)\n</code></pre>"},{"location":"user-guide/conversion/system-types/#filtering","title":"Filtering","text":"<p>Convert only specific system types:</p> <pre><code># Convert only condensing systems\nresult = converter.convert_to_brick(\n    metadata_csv=\"metadata.csv\",\n    vars_csv=\"vars.csv\",\n    system_type=\"Condensing\"  # Filter\n)\n</code></pre>"},{"location":"user-guide/conversion/system-types/#equipment-numbering","title":"Equipment Numbering","text":""},{"location":"user-guide/conversion/system-types/#boiler-numbering","title":"Boiler Numbering","text":"<p>Boilers are numbered based on <code>b_number</code> in metadata and sensor patterns:</p> <pre><code># metadata.csv: b_number=3\n# Creates:\n#   Boiler_Primary_1\n#   Boiler_Primary_2\n#   Boiler_Primary_3\n</code></pre>"},{"location":"user-guide/conversion/system-types/#sensor-based-detection","title":"Sensor-Based Detection","text":"<p>If <code>b_number</code> is missing, the converter infers from sensors:</p> <pre><code># vars_available_by_building.csv\ntag,sup1,ret1,fire1,sup2,ret2,fire2,sup3,ret3,fire3\n105,1,1,1,1,1,1,1,1,1\n# Detects 3 boilers from sup1-3, ret1-3, fire1-3\n</code></pre>"},{"location":"user-guide/conversion/system-types/#pump-numbering","title":"Pump Numbering","text":"<p>Similar logic for pumps:</p> <pre><code># vars_available_by_building.csv\ntag,pmp1_pwr,pmp1_spd,pmp2_pwr,pmp2_spd\n105,1,1,1,1\n# Detects 2 pumps\n</code></pre>"},{"location":"user-guide/conversion/system-types/#point-mappings-by-system","title":"Point Mappings by System","text":""},{"location":"user-guide/conversion/system-types/#common-points-all-systems","title":"Common Points (All Systems)","text":"CSV Column Brick Class <code>hw_supply_temp</code> <code>Hot_Water_Supply_Temperature_Sensor</code> <code>hw_return_temp</code> <code>Hot_Water_Return_Temperature_Sensor</code> <code>hw_flow</code> <code>Water_Flow_Sensor</code> <code>outdoor_temp</code> <code>Outside_Air_Temperature_Sensor</code>"},{"location":"user-guide/conversion/system-types/#boiler-specific-points","title":"Boiler-Specific Points","text":"CSV Column Brick Class Systems <code>fire1</code>, <code>fire2</code>, ... <code>Firing_Rate_Sensor</code> Boiler, Non-condensing, Condensing <code>sup1</code>, <code>sup2</code>, ... <code>Hot_Water_Supply_Temperature_Sensor</code> Boiler, Non-condensing, Condensing <code>ret1</code>, <code>ret2</code>, ... <code>Hot_Water_Return_Temperature_Sensor</code> Boiler, Non-condensing, Condensing"},{"location":"user-guide/conversion/system-types/#secondary-loop-points","title":"Secondary Loop Points","text":"CSV Column Brick Class Systems <code>secondary_supply_temp</code> <code>Hot_Water_Supply_Temperature_Sensor</code> Non-condensing, Condensing, District <code>secondary_return_temp</code> <code>Hot_Water_Return_Temperature_Sensor</code> Non-condensing, Condensing, District <code>secondary_flow</code> <code>Water_Flow_Sensor</code> Non-condensing, Condensing, District"},{"location":"user-guide/conversion/system-types/#district-specific-points","title":"District-Specific Points","text":"CSV Column Brick Class Systems <code>steam_pressure</code> <code>Steam_Pressure_Sensor</code> District Steam <code>condensate_temp</code> <code>Condensate_Temperature_Sensor</code> District Steam"},{"location":"user-guide/conversion/system-types/#validation-and-warnings","title":"Validation and Warnings","text":""},{"location":"user-guide/conversion/system-types/#system-type-mismatch","title":"System Type Mismatch","text":"<pre><code># Building marked as \"District HW\" but has boiler data\n# \u26a0 Warning: \"District system but found boiler data\"\n# \u2713 Boilers not created (correct)\n</code></pre>"},{"location":"user-guide/conversion/system-types/#missing-equipment-count","title":"Missing Equipment Count","text":"<pre><code># Boiler system but b_number=0\n# \u26a0 Warning: \"Boiler system but b_number=0\"\n# \u2713 Falls back to sensor detection\n</code></pre>"},{"location":"user-guide/conversion/system-types/#inconsistent-data","title":"Inconsistent Data","text":"<pre><code># b_number=2 but sensors show 3 boilers\n# \u26a0 Warning: \"b_number=2 but sensors show 3, using max\"\n# \u2713 Creates 3 boilers\n</code></pre>"},{"location":"user-guide/conversion/system-types/#choosing-the-right-system-type","title":"Choosing the Right System Type","text":""},{"location":"user-guide/conversion/system-types/#when-to-use-each-type","title":"When to Use Each Type","text":"<p>Boiler: - Generic/legacy systems - Simple heating setups - When specific efficiency unknown</p> <p>Non-condensing: - Older buildings (pre-2000) - Systems with return temp &gt;60\u00b0C - Standard efficiency boilers</p> <p>Condensing: - Modern buildings (post-2000) - High-efficiency systems - Return temp can be &lt;60\u00b0C</p> <p>District HW: - Campus settings - Centralized hot water - No on-site boilers</p> <p>District Steam: - Dense urban areas - Legacy campus systems - Steam-to-hot-water conversion</p>"},{"location":"user-guide/conversion/system-types/#examples-by-system-type","title":"Examples by System Type","text":""},{"location":"user-guide/conversion/system-types/#convert-all-non-condensing","title":"Convert All Non-condensing","text":"<pre><code>from hhw_brick import BatchConverter\n\nbatch = BatchConverter()\nresults = batch.convert_all_buildings(\n    metadata_csv=\"metadata.csv\",\n    vars_csv=\"vars.csv\",\n    output_dir=\"non_condensing_models/\",\n    system_type=\"Non-condensing\"\n)\n</code></pre>"},{"location":"user-guide/conversion/system-types/#convert-district-systems","title":"Convert District Systems","text":"<pre><code># District HW\nresults_hw = batch.convert_all_buildings(\n    metadata_csv=\"metadata.csv\",\n    vars_csv=\"vars.csv\",\n    output_dir=\"district_hw/\",\n    system_type=\"District HW\"\n)\n\n# District Steam\nresults_steam = batch.convert_all_buildings(\n    metadata_csv=\"metadata.csv\",\n    vars_csv=\"vars.csv\",\n    output_dir=\"district_steam/\",\n    system_type=\"District Steam\"\n)\n</code></pre>"},{"location":"user-guide/conversion/system-types/#separate-by-type","title":"Separate by Type","text":"<pre><code>system_types = [\n    \"Non-condensing\",\n    \"Condensing\",\n    \"District HW\"\n]\n\nfor system in system_types:\n    results = batch.convert_all_buildings(\n        metadata_csv=\"metadata.csv\",\n        vars_csv=\"vars.csv\",\n        output_dir=f\"models/{system.lower().replace(' ', '_')}/\",\n        system_type=system,\n        show_progress=True\n    )\n\n    print(f\"{system}: {results['successful']} buildings\")\n</code></pre>"},{"location":"user-guide/conversion/system-types/#next-steps","title":"Next Steps","text":"<ul> <li>Sensor Mapping - Customize sensor mappings</li> <li>Validation - Validate system models</li> <li>Examples - Working examples</li> </ul> <p>Continue to: Sensor Mapping \u2192</p>"},{"location":"user-guide/validation/","title":"Model Validation","text":"<p>Ensure your Brick models are correct, complete, and follow schema rules.</p>"},{"location":"user-guide/validation/#overview","title":"Overview","text":"<p>After converting CSV data to Brick models, validation ensures:</p> <ul> <li>Ontology correctness - Models follow Brick Schema 1.4 rules (SHACL validation)</li> <li>Data completeness - All expected sensors and equipment exist</li> <li>Structural integrity - System topology matches expected patterns</li> </ul>"},{"location":"user-guide/validation/#why-validate","title":"Why Validate?","text":""},{"location":"user-guide/validation/#quality-assurance","title":"Quality Assurance","text":"<p>Catch errors early before running analytics:</p> <pre><code># Convert\nconverter = CSVToBrickConverter()\ngraph = converter.convert_to_brick(...)\n\n# Validate immediately\nvalidator = BrickModelValidator()\nresult = validator.validate_ontology(\"building_105.ttl\")\n\nif not result['valid']:\n    print(\"Fix these issues before proceeding:\")\n    for violation in result['violations']:\n        print(f\"  - {violation}\")\n</code></pre>"},{"location":"user-guide/validation/#production-readiness","title":"Production Readiness","text":"<p>Ensure models are ready for analytics applications:</p> <pre><code># Only use validated models in production\nif result['valid']:\n    app = apps.load_app(\"secondary_loop_temp_diff\")\n    results = app.analyze(\n        brick_model=\"building_105.ttl\",\n        timeseries_data=\"data.csv\"\n    )\n</code></pre>"},{"location":"user-guide/validation/#build-confidence","title":"Build Confidence","text":"<p>Validation provides confidence that your semantic models accurately represent your buildings.</p>"},{"location":"user-guide/validation/#four-validation-levels","title":"Four Validation Levels","text":"<p>HHW Brick provides comprehensive multi-level validation:</p>"},{"location":"user-guide/validation/#1-ontology-validation-shacl","title":"1. \ud83d\udd0d Ontology Validation (SHACL)","text":"<p>What it checks: Compliance with Brick Schema 1.4 rules</p> <pre><code>from hhw_brick import BrickModelValidator\n\nvalidator = BrickModelValidator(use_local_brick=True)\nresult = validator.validate_ontology(\"building_105.ttl\")\n\nif result['valid']:\n    print(\"\u2713 Model follows Brick Schema\")\nelse:\n    print(f\"\u2717 Found {len(result['violations'])} violations\")\n    for v in result['violations']:\n        print(f\"  - {v}\")\n</code></pre> <p>Validates: - \u2713 Valid Brick classes used (e.g., <code>brick:Boiler</code>, <code>brick:Temperature_Sensor</code>) - \u2713 Correct relationship types (e.g., <code>brick:hasPart</code>, <code>brick:feeds</code>) - \u2713 Proper namespaces and URIs - \u2713 RDF/OWL syntax correctness</p> <p>Learn more about ontology validation \u2192</p>"},{"location":"user-guide/validation/#2-point-count-validation","title":"2. \ud83d\udcca Point Count Validation","text":"<p>What it checks: All sensors from CSV were converted correctly</p> <pre><code>from hhw_brick import GroundTruthCalculator, BrickModelValidator\n\n# Step 1: Generate ground truth from CSV\ncalculator = GroundTruthCalculator()\nground_truth = calculator.calculate(\n    metadata_csv=\"metadata.csv\",\n    vars_csv=\"vars_available_by_building.csv\",\n    output_csv=\"ground_truth.csv\"\n)\n\n# Step 2: Validate point counts\nvalidator = BrickModelValidator(ground_truth_csv_path=\"ground_truth.csv\")\nresult = validator.validate_point_count(\"building_105.ttl\")\n\nprint(f\"Expected: {result['expected_points']} points\")\nprint(f\"Actual: {result['actual_points']} points\")\nprint(f\"Match: {result['match']} ({'\u2713' if result['match'] else '\u2717'})\")\nprint(f\"Accuracy: {result['accuracy_percentage']:.1f}%\")\n</code></pre> <p>Validates: - \u2713 Sensor count matches expected (from CSV) - \u2713 Handles <code>owl:sameAs</code> deduplication (shared sensors) - \u2713 Independent ground truth (calculated from source CSV, not Brick model)</p> <p>Learn more about point count validation \u2192</p>"},{"location":"user-guide/validation/#3-equipment-count-validation","title":"3. \u2699\ufe0f Equipment Count Validation","text":"<p>What it checks: Boilers, pumps, and weather stations</p> <pre><code>result = validator.validate_equipment_count(\"building_105.ttl\")\n\nprint(\"Equipment Counts:\")\nprint(f\"  Boilers: {result['boilers']['actual']}/{result['boilers']['expected']}\")\nprint(f\"  Pumps: {result['pumps']['actual']}/{result['pumps']['expected']}\")\nprint(f\"  Weather: {result['weather_stations']['actual']}/{result['weather_stations']['expected']}\")\n\nif result['all_match']:\n    print(\"\u2713 All equipment counts correct\")\n</code></pre> <p>Validates: - \u2713 Boiler count (with subclass support for condensing/non-condensing) - \u2713 Pump count (per loop) - \u2713 Weather station presence - \u2713 Supports equipment inheritance (e.g., <code>Condensing_Boiler</code> \u2192 <code>Boiler</code>)</p> <p>Learn more about equipment validation \u2192</p>"},{"location":"user-guide/validation/#4-structural-pattern-validation","title":"4. \ud83c\udfd7\ufe0f Structural Pattern Validation","text":"<p>What it checks: System topology and component relationships</p> <pre><code>from hhw_brick import SubgraphPatternValidator\n\nvalidator = SubgraphPatternValidator()\nresult = validator.validate_building_pattern(\"building_105.ttl\")\n\nif result['pattern_1']:\n    print(\"\u2713 Pattern 1: Boiler System\")\n    print(f\"  Boilers: {result['pattern_1']['boiler_count']}\")\n    print(f\"  Primary pumps: {result['pattern_1']['primary_pump_count']}\")\n    print(f\"  Secondary pumps: {result['pattern_1']['secondary_pump_count']}\")\nelif result['pattern_2']:\n    print(\"\u2713 Pattern 2: District System\")\n    print(f\"  Secondary pumps: {result['pattern_2']['secondary_pump_count']}\")\n</code></pre> <p>Validates: - \u2713 Pattern 1: Boiler system (primary loop + secondary loop + boilers) - \u2713 Pattern 2: District system (secondary loop only, no boilers) - \u2713 Correct loop structure using SPARQL queries - \u2713 Equipment placement in appropriate loops</p> <p>Learn more about pattern validation \u2192</p>"},{"location":"user-guide/validation/#validation-workflow","title":"Validation Workflow","text":"<pre><code>graph TD\n    A[CSV Files] --&gt; B[Convert to Brick]\n    B --&gt; C[Brick Model .ttl]\n    C --&gt; D[1. Ontology Validation]\n    D --&gt; E{Valid?}\n    E --&gt;|No| F[Fix Conversion Logic]\n    E --&gt;|Yes| G[2. Point Count Validation]\n    G --&gt; H{Match?}\n    H --&gt;|No| I[Check CSV &amp; Converter]\n    H --&gt;|Yes| J[3. Equipment Count Validation]\n    J --&gt; K{Match?}\n    K --&gt;|No| L[Check Equipment Logic]\n    K --&gt;|Yes| M[4. Pattern Validation]\n    M --&gt; N{Pattern Found?}\n    N --&gt;|No| O[Check System Structure]\n    N --&gt;|Yes| P[\u2713 Validated Model]\n    P --&gt; Q[Ready for Analytics]\n    F --&gt; B\n    I --&gt; B\n    L --&gt; B\n    O --&gt; B</code></pre>"},{"location":"user-guide/validation/#recommended-validation-order","title":"Recommended Validation Order","text":"<ol> <li>Ontology First - Catch schema violations early</li> <li>Point Counts - Verify completeness</li> <li>Equipment Counts - Check specific components</li> <li>Patterns Last - Validate overall structure</li> </ol>"},{"location":"user-guide/validation/#batch-validation-parallel-processing","title":"Batch Validation (Parallel Processing)","text":"<p>Validate multiple buildings efficiently using parallel workers:</p>"},{"location":"user-guide/validation/#batch-ontology-validation","title":"Batch Ontology Validation","text":"<pre><code>validator = BrickModelValidator(use_local_brick=True)\n\nresults = validator.batch_validate_ontology(\n    test_data_dir=\"output/\",\n    max_workers=4  # Parallel processing\n)\n\nprint(f\"Total: {results['total_files']}\")\nprint(f\"Passed: {results['passed_files']}\")\nprint(f\"Failed: {results['failed_files']}\")\nprint(f\"Accuracy: {results['overall_accuracy']:.1f}%\")\n</code></pre>"},{"location":"user-guide/validation/#batch-point-count-validation","title":"Batch Point Count Validation","text":"<pre><code>results = validator.batch_validate_point_count(\n    test_data_dir=\"output/\",\n    max_workers=4\n)\n\nfor detail in results['details']:\n    building = detail['filename']\n    match = detail['match']\n    print(f\"{building}: {'\u2713' if match else '\u2717'}\")\n</code></pre>"},{"location":"user-guide/validation/#batch-pattern-validation","title":"Batch Pattern Validation","text":"<pre><code>validator = SubgraphPatternValidator()\n\nresults = validator.batch_validate_patterns(\n    test_data_dir=\"output/\",\n    max_workers=4\n)\n\nprint(f\"Boiler Systems (Pattern 1): {results['pattern_1_count']}\")\nprint(f\"District Systems (Pattern 2): {results['pattern_2_count']}\")\nprint(f\"Success Rate: {results['success_rate']:.1f}%\")\n</code></pre> <p>Benefits of Batch Validation: - \u26a1 Faster (parallel processing) - \ud83d\udcca Summary statistics - \ud83c\udfaf Identify problematic buildings - \ud83d\udcc8 Track overall quality</p>"},{"location":"user-guide/validation/#ground-truth-the-key-concept","title":"Ground Truth: The Key Concept","text":"<p>What is Ground Truth?</p> <p>Ground truth values (expected counts) are calculated independently from the input CSV data, not from the generated Brick model. This ensures unbiased validation.</p>"},{"location":"user-guide/validation/#why-independent-ground-truth","title":"Why Independent Ground Truth?","text":"<p>Without Independent Ground Truth (circular validation): <pre><code>CSV \u2192 Converter \u2192 Brick Model\n                      \u2193\n                  Count Points \u2190 Compare with itself \u2717\n</code></pre></p> <p>With Independent Ground Truth (proper validation): <pre><code>CSV \u2192 Converter \u2192 Brick Model\n  \u2193                   \u2193\nCount Expected \u2192 Compare with Actual \u2713\n  (Ground Truth)\n</code></pre></p>"},{"location":"user-guide/validation/#how-ground-truth-is-calculated","title":"How Ground Truth is Calculated","text":"<pre><code>calculator = GroundTruthCalculator()\n\n# Reads metadata.csv and vars_available_by_building.csv\n# Counts sensors and equipment directly from source data\nground_truth = calculator.calculate(\n    metadata_csv=\"metadata.csv\",\n    vars_csv=\"vars_available_by_building.csv\",\n    output_csv=\"ground_truth.csv\"\n)\n\n# ground_truth.csv contains expected counts for each building\n# Independent of the conversion process\n</code></pre>"},{"location":"user-guide/validation/#quick-start-example","title":"Quick Start Example","text":"<p>Complete validation workflow:</p> <pre><code>from hhw_brick import (\n    CSVToBrickConverter,\n    BrickModelValidator,\n    GroundTruthCalculator,\n    SubgraphPatternValidator\n)\n\n# 1. Convert\nconverter = CSVToBrickConverter()\ngraph = converter.convert_to_brick(\n    metadata_csv=\"metadata.csv\",\n    vars_csv=\"vars_available_by_building.csv\",\n    building_tag=\"105\",\n    output_path=\"building_105.ttl\"\n)\nprint(f\"Converted: {len(graph)} triples\")\n\n# 2. Generate ground truth\ncalculator = GroundTruthCalculator()\ncalculator.calculate(\n    metadata_csv=\"metadata.csv\",\n    vars_csv=\"vars_available_by_building.csv\",\n    output_csv=\"ground_truth.csv\"\n)\n\n# 3. Validate ontology\nvalidator = BrickModelValidator(\n    use_local_brick=True,\n    ground_truth_csv_path=\"ground_truth.csv\"\n)\n\nontology_result = validator.validate_ontology(\"building_105.ttl\")\nprint(f\"Ontology valid: {ontology_result['valid']}\")\n\n# 4. Validate point counts\npoint_result = validator.validate_point_count(\"building_105.ttl\")\nprint(f\"Point count match: {point_result['match']}\")\n\n# 5. Validate equipment\nequip_result = validator.validate_equipment_count(\"building_105.ttl\")\nprint(f\"Equipment match: {equip_result['all_match']}\")\n\n# 6. Validate pattern\npattern_validator = SubgraphPatternValidator()\npattern_result = pattern_validator.validate_building_pattern(\"building_105.ttl\")\nprint(f\"Pattern found: {pattern_result['pattern_1'] is not None or pattern_result['pattern_2'] is not None}\")\n</code></pre>"},{"location":"user-guide/validation/#troubleshooting-validation-issues","title":"Troubleshooting Validation Issues","text":""},{"location":"user-guide/validation/#ontology-validation-failures","title":"Ontology Validation Failures","text":"<p>Issue: SHACL violations</p> <p>Solutions: - Check class names (e.g., use <code>brick:Boiler</code>, not <code>Boiler</code>) - Verify relationships (e.g., <code>brick:hasPart</code>, not <code>hasPart</code>) - Ensure URIs are properly formatted - Use <code>use_local_brick=True</code> for stable validation</p>"},{"location":"user-guide/validation/#point-count-mismatches","title":"Point Count Mismatches","text":"<p>Issue: Expected \u2260 Actual point counts</p> <p>Solutions: - Check CSV data for missing/extra sensors - Verify <code>owl:sameAs</code> is used for shared sensors - Review converter sensor mapping logic - Inspect ground_truth.csv for accuracy</p>"},{"location":"user-guide/validation/#equipment-count-mismatches","title":"Equipment Count Mismatches","text":"<p>Issue: Boiler/pump counts don't match</p> <p>Solutions: - Use <code>include_subclasses=True</code> for equipment inheritance - Check metadata.csv for correct <code>b_number</code> and <code>p_number</code> - Verify equipment placement in correct loops</p>"},{"location":"user-guide/validation/#pattern-validation-failures","title":"Pattern Validation Failures","text":"<p>Issue: No pattern matched</p> <p>Solutions: - Verify loop labels contain \"primary\" or \"secondary\" - Check <code>brick:feeds</code> relationship between loops - Ensure boilers are in primary loop (Pattern 1) - Validate equipment placement</p>"},{"location":"user-guide/validation/#best-practices","title":"Best Practices","text":"<p>Validation Best Practices</p> <ol> <li>Validate immediately after conversion - Catch errors early</li> <li>Use batch validation - Faster with <code>max_workers</code></li> <li>Save validation reports - Track quality over time</li> <li>Fix root causes - Don't just fix individual models</li> <li>Automate validation - Include in CI/CD pipeline</li> </ol>"},{"location":"user-guide/validation/#automation-example","title":"Automation Example","text":"<pre><code>def validate_pipeline(metadata_csv, vars_csv, output_dir):\n    \"\"\"Complete conversion and validation pipeline\"\"\"\n\n    # Convert\n    batch = BatchConverter()\n    conv_results = batch.convert_all_buildings(\n        metadata_csv=metadata_csv,\n        vars_csv=vars_csv,\n        output_dir=output_dir\n    )\n\n    # Generate ground truth\n    calculator = GroundTruthCalculator()\n    calculator.calculate(\n        metadata_csv=metadata_csv,\n        vars_csv=vars_csv,\n        output_csv=f\"{output_dir}/ground_truth.csv\"\n    )\n\n    # Validate all\n    validator = BrickModelValidator(\n        use_local_brick=True,\n        ground_truth_csv_path=f\"{output_dir}/ground_truth.csv\"\n    )\n\n    val_results = {\n        'ontology': validator.batch_validate_ontology(output_dir),\n        'points': validator.batch_validate_point_count(output_dir),\n        'equipment': validator.batch_validate_equipment_count(output_dir)\n    }\n\n    # Report\n    print(f\"\\n{'='*60}\")\n    print(\"Validation Report\")\n    print(f\"{'='*60}\")\n    print(f\"Converted: {conv_results['successful']}/{conv_results['total']} buildings\")\n    print(f\"Ontology: {val_results['ontology']['passed_files']}/{val_results['ontology']['total_files']} passed\")\n    print(f\"Points: {val_results['points']['passed_files']}/{val_results['points']['total_files']} matched\")\n    print(f\"Equipment: {val_results['equipment']['passed_files']}/{val_results['equipment']['total_files']} matched\")\n\n    return val_results\n</code></pre>"},{"location":"user-guide/validation/#next-steps","title":"Next Steps","text":"<ul> <li>Ontology Validation Guide - SHACL validation details</li> <li>Ground Truth Validation - Point and equipment count validation</li> <li>Subgraph Pattern Validation - Structural pattern validation</li> <li>Examples - Complete working examples</li> </ul>"},{"location":"user-guide/validation/#need-help","title":"Need Help?","text":"<ul> <li>Check the FAQ for common issues</li> <li>Review examples for working code</li> <li>Report issues on GitHub</li> </ul> <p>Verify system topology patterns.</p> <pre><code>from hhw_brick.validation import SubgraphPatternValidator\n\nvalidator = SubgraphPatternValidator()\nresult = validator.validate(\"building_105.ttl\")\n\nif result['all_patterns_found']:\n    print(\"\u2713 All expected patterns found\")\nelse:\n    print(f\"\u2717 Missing: {result['missing_patterns']}\")\n</code></pre> <p>Checks: - \u2713 Boiler \u2192 Heat Exchanger connection - \u2713 Equipment \u2192 Points relationships - \u2713 Primary \u2192 Secondary loop flow</p> <p>Learn more \u2192</p>"},{"location":"user-guide/validation/#quick-start","title":"Quick Start","text":""},{"location":"user-guide/validation/#validate-a-single-model","title":"Validate a Single Model","text":"<p>Complete validation workflow:</p> <pre><code>from hhw_brick import BrickModelValidator, GroundTruthCalculator\n\n# Step 1: Generate ground truth\ncalculator = GroundTruthCalculator()\ncalculator.calculate(\n    metadata_csv=\"metadata.csv\",\n    vars_csv=\"vars.csv\",\n    output_csv=\"ground_truth.csv\"\n)\n\n# Step 2: Create validator\nvalidator = BrickModelValidator(\n    ground_truth_csv_path=\"ground_truth.csv\",\n    use_local_brick=True\n)\n\n# Step 3: Validate ontology\nontology_result = validator.validate_ontology(\"building_105.ttl\")\nprint(f\"Ontology valid: {ontology_result['valid']}\")\n\n# Step 4: Validate point counts\npoint_result = validator.validate_point_count(\"building_105.ttl\")\nprint(f\"Point accuracy: {point_result['accuracy_percentage']:.1f}%\")\n\n# Step 5: Validate equipment counts\nequipment_result = validator.validate_equipment_count(\"building_105.ttl\")\nprint(f\"Equipment match: {equipment_result['overall_success']}\")\n</code></pre>"},{"location":"user-guide/validation/#batch-validate-multiple-models","title":"Batch Validate Multiple Models","text":"<p>Validate all models in a directory:</p> <pre><code>from hhw_brick import BrickModelValidator\n\nvalidator = BrickModelValidator(\n    ground_truth_csv_path=\"ground_truth.csv\",\n    use_local_brick=True\n)\n\n# Batch ontology validation (parallel processing)\nresults = validator.batch_validate_ontology(\n    test_data_dir=\"brick_models/\",\n    max_workers=8  # Parallel workers\n)\n\nprint(f\"Validated {results['total_files']} models\")\nprint(f\"Valid: {results['passed_files']}\")\nprint(f\"Invalid: {results['failed_files']}\")\nprint(f\"Accuracy: {results['overall_accuracy']:.1f}%\")\n\n# Batch point count validation\npoint_results = validator.batch_validate_point_count(\n    test_data_dir=\"brick_models/\"\n)\n\nprint(f\"Point count accuracy: {point_results['overall_accuracy']:.1f}%\")\n</code></pre>"},{"location":"user-guide/validation/#validation-workflow_1","title":"Validation Workflow","text":""},{"location":"user-guide/validation/#complete-production-workflow","title":"Complete Production Workflow","text":"<pre><code>graph TD\n    A[CSV Files] --&gt;|Convert| B[Brick Models]\n    A --&gt;|Calculate| C[Ground Truth]\n    B --&gt;|Validate Ontology| D{Valid?}\n    D --&gt;|No| E[Fix Conversion]\n    E --&gt; A\n    D --&gt;|Yes| F[Validate Counts]\n    C --&gt;|Compare| F\n    F --&gt;|Check| G{Match?}\n    G --&gt;|No| H[Review Data]\n    H --&gt; A\n    G --&gt;|Yes| I[\u2713 Validated Models]\n    I --&gt;|Use in| J[Analytics Apps]\n\n    style A fill:#e1f5ff\n    style I fill:#c8e6c9\n    style E fill:#ffcdd2\n    style H fill:#ffcdd2</code></pre>"},{"location":"user-guide/validation/#step-by-step-example","title":"Step-by-Step Example","text":"<p>Based on <code>examples/02_ontology_validation.py</code> and <code>examples/03_point_count_validation.py</code>:</p> <pre><code>\"\"\"\nComplete validation workflow\nBased on HHW Brick Application examples\n\"\"\"\n\nfrom pathlib import Path\nfrom hhw_brick import (\n    CSVToBrickConverter,\n    BatchConverter,\n    BrickModelValidator,\n    GroundTruthCalculator\n)\n\ndef complete_workflow():\n    # Paths\n    metadata_csv = \"metadata.csv\"\n    vars_csv = \"vars_available_by_building.csv\"\n    output_dir = Path(\"brick_models\")\n    ground_truth_csv = \"ground_truth.csv\"\n\n    # ===== Step 1: Convert CSV to Brick =====\n    print(\"Step 1: Converting CSV to Brick...\")\n    batch = BatchConverter()\n    conversion_results = batch.convert_all_buildings(\n        metadata_csv=metadata_csv,\n        vars_csv=vars_csv,\n        output_dir=str(output_dir),\n        show_progress=True\n    )\n    print(f\"\u2713 Converted {conversion_results['successful']} buildings\")\n\n    # ===== Step 2: Generate Ground Truth =====\n    print(\"\\nStep 2: Generating ground truth...\")\n    calculator = GroundTruthCalculator()\n    ground_truth_df = calculator.calculate(\n        metadata_csv=metadata_csv,\n        vars_csv=vars_csv,\n        output_csv=ground_truth_csv\n    )\n    print(f\"\u2713 Ground truth generated for {len(ground_truth_df)} buildings\")\n\n    # ===== Step 3: Validate Ontology (Batch) =====\n    print(\"\\nStep 3: Validating ontology...\")\n    validator = BrickModelValidator(\n        ground_truth_csv_path=ground_truth_csv,\n        use_local_brick=True\n    )\n\n    ontology_results = validator.batch_validate_ontology(\n        test_data_dir=str(output_dir),\n        max_workers=8\n    )\n\n    print(f\"\u2713 Ontology validation:\")\n    print(f\"  - Valid: {ontology_results['passed_files']}/{ontology_results['total_files']}\")\n    print(f\"  - Accuracy: {ontology_results['overall_accuracy']:.1f}%\")\n\n    # ===== Step 4: Validate Point Counts (Batch) =====\n    print(\"\\nStep 4: Validating point counts...\")\n    point_results = validator.batch_validate_point_count(\n        test_data_dir=str(output_dir)\n    )\n\n    print(f\"\u2713 Point count validation:\")\n    print(f\"  - Matched: {point_results['passed_files']}/{point_results['total_files']}\")\n    print(f\"  - Accuracy: {point_results['overall_accuracy']:.1f}%\")\n\n    # ===== Step 5: Validate Equipment Counts (Batch) =====\n    print(\"\\nStep 5: Validating equipment counts...\")\n    equipment_results = validator.batch_validate_equipment_count(\n        test_data_dir=str(output_dir)\n    )\n\n    print(f\"\u2713 Equipment count validation:\")\n    print(f\"  - Matched: {equipment_results['passed_files']}/{equipment_results['total_files']}\")\n    print(f\"  - Accuracy: {equipment_results['overall_accuracy']:.1f}%\")\n\n    # ===== Summary =====\n    print(\"\\n\" + \"=\"*60)\n    print(\"Validation Summary\")\n    print(\"=\"*60)\n    print(f\"Total models: {conversion_results['successful']}\")\n    print(f\"Ontology valid: {ontology_results['passed_files']}\")\n    print(f\"Point counts match: {point_results['passed_files']}\")\n    print(f\"Equipment counts match: {equipment_results['passed_files']}\")\n\n    # Overall success\n    all_valid = (\n        ontology_results['passed_files'] == conversion_results['successful'] and\n        point_results['passed_files'] == conversion_results['successful'] and\n        equipment_results['passed_files'] == conversion_results['successful']\n    )\n\n    if all_valid:\n        print(\"\\n\u2713 All models validated successfully!\")\n        print(\"  Models are ready for analytics applications.\")\n    else:\n        print(\"\\n\u26a0 Some models have validation issues\")\n        print(\"  Review failed models before using in production.\")\n\n    return {\n        'conversion': conversion_results,\n        'ontology': ontology_results,\n        'points': point_results,\n        'equipment': equipment_results\n    }\n\nif __name__ == \"__main__\":\n    results = complete_workflow()\n</code></pre>"},{"location":"user-guide/validation/#common-validation-patterns","title":"Common Validation Patterns","text":""},{"location":"user-guide/validation/#pattern-1-validate-after-conversion","title":"Pattern 1: Validate After Conversion","text":"<p>Always validate after converting:</p> <pre><code># Convert\nresult = converter.convert_to_brick(\n    metadata_csv=\"metadata.csv\",\n    vars_csv=\"vars.csv\",\n    building_tag=\"105\",\n    output_path=\"building_105.ttl\"\n)\n\n# Validate immediately\nvalidator = BrickModelValidator(use_local_brick=True)\nvalidation = validator.validate_ontology(\"building_105.ttl\")\n\nif validation['valid']:\n    print(\"\u2713 Conversion successful and valid\")\nelse:\n    print(\"\u2717 Model has errors - review conversion\")\n</code></pre>"},{"location":"user-guide/validation/#pattern-2-pre-production-check","title":"Pattern 2: Pre-Production Check","text":"<p>Before deploying to analytics:</p> <pre><code>def is_model_ready(model_path, ground_truth_path):\n    \"\"\"Check if model is ready for production use.\"\"\"\n\n    validator = BrickModelValidator(\n        ground_truth_csv_path=ground_truth_path,\n        use_local_brick=True\n    )\n\n    # Check ontology\n    ont_result = validator.validate_ontology(model_path)\n    if not ont_result['valid']:\n        return False, \"Ontology validation failed\"\n\n    # Check point counts\n    point_result = validator.validate_point_count(model_path)\n    if not point_result['success']:\n        return False, \"Point count mismatch\"\n\n    # Check equipment counts\n    equip_result = validator.validate_equipment_count(model_path)\n    if not equip_result['overall_success']:\n        return False, \"Equipment count mismatch\"\n\n    return True, \"Model ready\"\n\n# Use it\nready, message = is_model_ready(\"building_105.ttl\", \"ground_truth.csv\")\nif ready:\n    # Run analytics\n    app.analyze(model, data, config)\n</code></pre>"},{"location":"user-guide/validation/#pattern-3-continuous-validation","title":"Pattern 3: Continuous Validation","text":"<p>Validate on data updates:</p> <pre><code>import os\nfrom datetime import datetime\n\ndef validate_if_changed(model_path, ground_truth_path, cache_file=\".validation_cache\"):\n    \"\"\"Only validate if model changed since last check.\"\"\"\n\n    # Get model modification time\n    mod_time = os.path.getmtime(model_path)\n\n    # Check cache\n    if os.path.exists(cache_file):\n        with open(cache_file, 'r') as f:\n            last_validated = float(f.read().strip())\n\n        if mod_time &lt;= last_validated:\n            print(\"Model unchanged, using cached validation result\")\n            return True\n\n    # Validate\n    validator = BrickModelValidator(\n        ground_truth_csv_path=ground_truth_path\n    )\n\n    result = validator.validate_ontology(model_path)\n\n    # Update cache\n    if result['valid']:\n        with open(cache_file, 'w') as f:\n            f.write(str(datetime.now().timestamp()))\n\n    return result['valid']\n</code></pre>"},{"location":"user-guide/validation/#validation-results","title":"Validation Results","text":""},{"location":"user-guide/validation/#understanding-results","title":"Understanding Results","text":"<p>All validation methods return dictionaries with results:</p> <pre><code># Ontology validation\n{\n    'valid': True,\n    'violations': [],\n    'ttl_file_path': 'building_105.ttl'\n}\n\n# Point count validation\n{\n    'success': True,\n    'match': True,\n    'expected_point_count': 23,\n    'actual_point_count': 23,\n    'accuracy_percentage': 100.0\n}\n\n# Equipment count validation\n{\n    'overall_success': True,\n    'boiler': {'expected': 2, 'actual': 2, 'match': True},\n    'pump': {'expected': 3, 'actual': 3, 'match': True},\n    'weather_station': {'expected': 1, 'actual': 1, 'match': True}\n}\n</code></pre>"},{"location":"user-guide/validation/#troubleshooting","title":"Troubleshooting","text":""},{"location":"user-guide/validation/#issue-brickschema-not-available","title":"Issue: \"brickschema not available\"","text":"<p>Solution: <pre><code>pip install brickschema\n</code></pre></p>"},{"location":"user-guide/validation/#issue-ground-truth-file-not-found","title":"Issue: \"Ground truth file not found\"","text":"<p>Solution: Generate it first: <pre><code>calculator = GroundTruthCalculator()\ncalculator.calculate(\n    metadata_csv=\"metadata.csv\",\n    vars_csv=\"vars.csv\",\n    output_csv=\"ground_truth.csv\"\n)\n</code></pre></p>"},{"location":"user-guide/validation/#issue-point-count-mismatch","title":"Issue: Point count mismatch","text":"<p>Possible causes: 1. Sensor mapping incorrect 2. Missing sensors in vars.csv 3. Conversion issues</p> <p>Solution: Review conversion warnings: <pre><code>converter = CSVToBrickConverter()\nresult = converter.convert_to_brick(...)\n\nif converter.validation_warnings:\n    for warning in converter.validation_warnings:\n        print(warning)\n</code></pre></p>"},{"location":"user-guide/validation/#performance","title":"Performance","text":""},{"location":"user-guide/validation/#batch-validation-speed","title":"Batch Validation Speed","text":"<p>Parallel processing significantly improves performance:</p> <pre><code># Serial (slow for many files)\nfor file in ttl_files:\n    validator.validate_ontology(file)\n\n# Parallel (much faster)\nresults = validator.batch_validate_ontology(\n    test_data_dir=\"brick_models/\",\n    max_workers=8  # Use 8 parallel workers\n)\n</code></pre> <p>Typical performance: - 10 models: ~5 seconds (parallel) vs ~30 seconds (serial) - 100 models: ~45 seconds (parallel) vs ~5 minutes (serial)</p>"},{"location":"user-guide/validation/#next-steps_1","title":"Next Steps","text":"<p>Learn about each validation type in detail:</p> <ul> <li>Ontology Validation - Check Brick schema compliance</li> <li>Ground Truth Validation - Verify counts and completeness</li> <li>Subgraph Patterns - Validate system topology</li> </ul> <p>Or explore related topics:</p> <ul> <li>Conversion Guide - How to generate models</li> <li>Applications Guide - Use validated models</li> <li>Examples - Working code samples</li> </ul> <p>Continue to: Ontology Validation \u2192</p>"},{"location":"user-guide/validation/ground-truth/","title":"Ground Truth Validation","text":"<p>Validate Brick models against expected counts calculated from source CSV data.</p>"},{"location":"user-guide/validation/ground-truth/#overview","title":"Overview","text":"<p>Ground truth validation compares your Brick model against expected values derived from the original CSV data:</p> <ul> <li>Point counts - Number of sensors/points</li> <li>Boiler counts - Number of boilers</li> <li>Pump counts - Number of pumps  </li> <li>Weather stations - Presence of weather data</li> </ul> <p>This ensures your conversion was complete and accurate.</p>"},{"location":"user-guide/validation/ground-truth/#why-ground-truth-validation","title":"Why Ground Truth Validation?","text":""},{"location":"user-guide/validation/ground-truth/#verify-completeness","title":"Verify Completeness","text":"<p>Ensure no data was lost during conversion:</p> <pre><code># Expected: 23 points (from CSV)\n# Actual: 18 points (in Brick model)\n# \u2717 5 points missing - conversion issue!\n</code></pre>"},{"location":"user-guide/validation/ground-truth/#catch-conversion-errors","title":"Catch Conversion Errors","text":"<p>Find problems early:</p> <pre><code># Expected: 2 boilers\n# Actual: 1 boiler\n# \u2717 Check b_number or sensor detection logic\n</code></pre>"},{"location":"user-guide/validation/ground-truth/#production-quality","title":"Production Quality","text":"<p>Only use complete models:</p> <pre><code>if point_validation['match']:\n    # Model is complete, safe to use\n    app.analyze(model, data, config)\n</code></pre>"},{"location":"user-guide/validation/ground-truth/#ground-truth-calculator","title":"Ground Truth Calculator","text":""},{"location":"user-guide/validation/ground-truth/#generate-ground-truth","title":"Generate Ground Truth","text":"<p>From <code>examples/03_point_count_validation.py</code>:</p> <pre><code>from hhw_brick.validation import GroundTruthCalculator\n\n# Create calculator\ncalculator = GroundTruthCalculator()\n\n# Calculate expected counts from CSV\nground_truth_df = calculator.calculate(\n    metadata_csv=\"metadata.csv\",\n    vars_csv=\"vars_available_by_building.csv\",\n    output_csv=\"ground_truth.csv\"\n)\n\nprint(f\"Generated ground truth for {len(ground_truth_df)} buildings\")\n</code></pre>"},{"location":"user-guide/validation/ground-truth/#ground-truth-format","title":"Ground Truth Format","text":"<p>The generated <code>ground_truth.csv</code> contains:</p> <pre><code>tag,system,point_count,boiler_count,pump_count,weather_station_count\n105,Non-condensing,23,2,3,1\n106,Condensing,18,1,2,0\n107,District HW,15,0,2,1\n</code></pre> <p>Columns: - <code>tag</code> - Building ID - <code>system</code> - System type - <code>point_count</code> - Expected total points - <code>boiler_count</code> - Expected boilers - <code>pump_count</code> - Expected pumps - <code>weather_station_count</code> - Expected weather stations (0 or 1)</p>"},{"location":"user-guide/validation/ground-truth/#how-counts-are-calculated","title":"How Counts Are Calculated","text":""},{"location":"user-guide/validation/ground-truth/#point-count","title":"Point Count","text":"<p>Counts all sensors marked as available (value=1) in <code>vars_available_by_building.csv</code>:</p> <pre><code># vars.csv\ntag,hw_supply_temp,hw_return_temp,hw_flow,outdoor_temp\n105,1,1,1,1  # 4 sensors available\n\n# ground_truth.csv\ntag,point_count\n105,4  # Calculated from available sensors\n</code></pre>"},{"location":"user-guide/validation/ground-truth/#boiler-count","title":"Boiler Count","text":"<p>From <code>b_number</code> in metadata.csv or inferred from sensor patterns:</p> <pre><code># metadata.csv\ntag,b_number\n105,2  # Explicitly set\n\n# OR inferred from sensors\n# vars.csv: sup1, ret1, fire1, sup2, ret2, fire2\n# Infers: 2 boilers\n\n# ground_truth.csv\ntag,boiler_count\n105,2\n</code></pre>"},{"location":"user-guide/validation/ground-truth/#pump-count","title":"Pump Count","text":"<p>Inferred from pump sensor patterns (<code>pmp1_*</code>, <code>pmp2_*</code>, etc.):</p> <pre><code># vars.csv\ntag,pmp1_pwr,pmp1_spd,pmp2_pwr,pmp2_spd,pmp3_pwr\n105,1,1,1,1,1  # Pump 1, 2, 3 detected\n\n# ground_truth.csv\ntag,pump_count\n105,3\n</code></pre>"},{"location":"user-guide/validation/ground-truth/#weather-station","title":"Weather Station","text":"<p>From <code>oper</code> column or outdoor sensors:</p> <pre><code># Has outdoor_temp sensor or oper != 0\n# weather_station_count = 1\n</code></pre>"},{"location":"user-guide/validation/ground-truth/#point-count-validation","title":"Point Count Validation","text":""},{"location":"user-guide/validation/ground-truth/#validate-single-building","title":"Validate Single Building","text":"<p>From <code>examples/03_point_count_validation.py</code>:</p> <pre><code>from hhw_brick import BrickModelValidator\n\n# Create validator with ground truth\nvalidator = BrickModelValidator(\n    ground_truth_csv_path=\"ground_truth.csv\"\n)\n\n# Validate point count\nresult = validator.validate_point_count(\"building_105.ttl\")\n\n# Check result\nif result['success'] and result['match']:\n    print(\"\u2713 Point count matches!\")\nelse:\n    print(f\"\u2717 Point count mismatch\")\n    print(f\"  Expected: {result['expected_point_count']}\")\n    print(f\"  Actual: {result['actual_point_count']}\")\n    print(f\"  Accuracy: {result['accuracy_percentage']:.1f}%\")\n</code></pre>"},{"location":"user-guide/validation/ground-truth/#validate_point_count","title":"validate_point_count()","text":"<p>Signature: <pre><code>def validate_point_count(ttl_file_path: str) -&gt; Dict\n</code></pre></p> <p>Returns: <pre><code>{\n    'success': bool,                # Overall success\n    'match': bool,                  # Counts match exactly\n    'expected_point_count': int,    # From ground truth\n    'actual_point_count': int,      # From Brick model\n    'accuracy_percentage': float,   # Match percentage\n    'ttl_file_path': str,          # Model file path\n    'building_tag': str             # Extracted building ID\n}\n</code></pre></p> <p>Example: <pre><code>result = validator.validate_point_count(\"building_105.ttl\")\n\nprint(f\"Expected: {result['expected_point_count']}\")\nprint(f\"Actual: {result['actual_point_count']}\")\nprint(f\"Match: {result['match']}\")\nprint(f\"Accuracy: {result['accuracy_percentage']:.1f}%\")\n</code></pre></p>"},{"location":"user-guide/validation/ground-truth/#equipment-count-validation","title":"Equipment Count Validation","text":""},{"location":"user-guide/validation/ground-truth/#validate-equipment-counts","title":"Validate Equipment Counts","text":"<p>From <code>examples/04_equipment_count_validation.py</code>:</p> <pre><code>from hhw_brick import BrickModelValidator\n\nvalidator = BrickModelValidator(\n    ground_truth_csv_path=\"ground_truth.csv\",\n    use_local_brick=True\n)\n\n# Validate equipment counts\nresult = validator.validate_equipment_count(\"building_105.ttl\")\n\n# Check overall result\nif result['overall_success']:\n    print(\"\u2713 All equipment counts match!\")\nelse:\n    print(\"\u2717 Equipment count mismatch detected\")\n\n# Check individual equipment\nprint(f\"Boilers: {result['boiler']['actual']}/{result['boiler']['expected']}\")\nprint(f\"Pumps: {result['pump']['actual']}/{result['pump']['expected']}\")\nprint(f\"Weather: {result['weather_station']['actual']}/{result['weather_station']['expected']}\")\n</code></pre>"},{"location":"user-guide/validation/ground-truth/#validate_equipment_count","title":"validate_equipment_count()","text":"<p>Signature: <pre><code>def validate_equipment_count(ttl_file_path: str) -&gt; Dict\n</code></pre></p> <p>Returns: <pre><code>{\n    'overall_success': bool,        # All equipment matches\n    'boiler': {\n        'expected': int,\n        'actual': int,\n        'match': bool\n    },\n    'pump': {\n        'expected': int,\n        'actual': int,\n        'match': bool\n    },\n    'weather_station': {\n        'expected': int,\n        'actual': int,\n        'match': bool\n    },\n    'ttl_file_path': str,\n    'building_tag': str\n}\n</code></pre></p> <p>Example: <pre><code>result = validator.validate_equipment_count(\"building_105.ttl\")\n\nfor equip_type in ['boiler', 'pump', 'weather_station']:\n    equip = result[equip_type]\n    status = \"\u2713\" if equip['match'] else \"\u2717\"\n    print(f\"{status} {equip_type}: {equip['actual']}/{equip['expected']}\")\n</code></pre></p>"},{"location":"user-guide/validation/ground-truth/#batch-validation","title":"Batch Validation","text":""},{"location":"user-guide/validation/ground-truth/#batch-point-count-validation","title":"Batch Point Count Validation","text":"<p>Validate multiple models:</p> <pre><code>from hhw_brick import BrickModelValidator\n\nvalidator = BrickModelValidator(\n    ground_truth_csv_path=\"ground_truth.csv\"\n)\n\n# Batch validate point counts\nresults = validator.batch_validate_point_count(\n    test_data_dir=\"brick_models/\"\n)\n\nprint(f\"Total files: {results['total_files']}\")\nprint(f\"Matched: {results['passed_files']}\")\nprint(f\"Mismatched: {results['failed_files']}\")\nprint(f\"Accuracy: {results['overall_accuracy']:.1f}%\")\n</code></pre>"},{"location":"user-guide/validation/ground-truth/#batch-equipment-count-validation","title":"Batch Equipment Count Validation","text":"<pre><code># Batch validate equipment counts\nresults = validator.batch_validate_equipment_count(\n    test_data_dir=\"brick_models/\"\n)\n\nprint(f\"Total files: {results['total_files']}\")\nprint(f\"All matched: {results['passed_files']}\")\nprint(f\"Accuracy: {results['overall_accuracy']:.1f}%\")\n</code></pre>"},{"location":"user-guide/validation/ground-truth/#batch_validate_point_count","title":"batch_validate_point_count()","text":"<p>Signature: <pre><code>def batch_validate_point_count(test_data_dir: str) -&gt; Dict\n</code></pre></p> <p>Returns: <pre><code>{\n    'total_files': int,\n    'passed_files': int,            # Exact matches\n    'failed_files': int,            # Mismatches\n    'overall_accuracy': float,      # Average accuracy %\n    'individual_results': [...]     # List of individual results\n}\n</code></pre></p>"},{"location":"user-guide/validation/ground-truth/#complete-validation-workflow","title":"Complete Validation Workflow","text":"<p>From examples:</p> <pre><code>\"\"\"\nComplete ground truth validation workflow\nBased on examples/03 and 04\n\"\"\"\n\nfrom pathlib import Path\nfrom hhw_brick import BatchConverter, BrickModelValidator\nfrom hhw_brick.validation import GroundTruthCalculator\n\ndef complete_ground_truth_workflow():\n    # Paths\n    metadata_csv = \"metadata.csv\"\n    vars_csv = \"vars_available_by_building.csv\"\n    output_dir = Path(\"brick_models\")\n    ground_truth_csv = \"ground_truth.csv\"\n\n    # ===== Step 1: Convert CSV to Brick =====\n    print(\"Step 1: Converting CSV to Brick...\")\n    batch = BatchConverter()\n    conversion_results = batch.convert_all_buildings(\n        metadata_csv=metadata_csv,\n        vars_csv=vars_csv,\n        output_dir=str(output_dir),\n        show_progress=True\n    )\n    print(f\"\u2713 Converted {conversion_results['successful']} buildings\")\n\n    # ===== Step 2: Generate Ground Truth =====\n    print(\"\\nStep 2: Generating ground truth...\")\n    calculator = GroundTruthCalculator()\n    ground_truth_df = calculator.calculate(\n        metadata_csv=metadata_csv,\n        vars_csv=vars_csv,\n        output_csv=ground_truth_csv\n    )\n    print(f\"\u2713 Ground truth for {len(ground_truth_df)} buildings\")\n\n    # Show sample\n    print(\"\\n  Sample (first 3 buildings):\")\n    for _, row in ground_truth_df.head(3).iterrows():\n        print(f\"    Building {row['tag']}: \"\n              f\"{int(row['point_count'])} points, \"\n              f\"{int(row['boiler_count'])} boilers, \"\n              f\"{int(row['pump_count'])} pumps\")\n\n    # ===== Step 3: Create Validator =====\n    validator = BrickModelValidator(\n        ground_truth_csv_path=ground_truth_csv,\n        use_local_brick=True\n    )\n\n    # ===== Step 4: Validate Point Counts =====\n    print(\"\\nStep 3: Validating point counts...\")\n    point_results = validator.batch_validate_point_count(\n        test_data_dir=str(output_dir)\n    )\n\n    print(f\"\u2713 Point count validation:\")\n    print(f\"  - Matched: {point_results['passed_files']}/{point_results['total_files']}\")\n    print(f\"  - Accuracy: {point_results['overall_accuracy']:.1f}%\")\n\n    # ===== Step 5: Validate Equipment Counts =====\n    print(\"\\nStep 4: Validating equipment counts...\")\n    equipment_results = validator.batch_validate_equipment_count(\n        test_data_dir=str(output_dir)\n    )\n\n    print(f\"\u2713 Equipment count validation:\")\n    print(f\"  - Matched: {equipment_results['passed_files']}/{equipment_results['total_files']}\")\n    print(f\"  - Accuracy: {equipment_results['overall_accuracy']:.1f}%\")\n\n    # ===== Step 6: Detailed Report for Failures =====\n    if point_results['failed_files'] &gt; 0:\n        print(\"\\nPoint count mismatches:\")\n        for result in point_results['individual_results']:\n            if not result['match']:\n                file_name = Path(result['ttl_file_path']).name\n                print(f\"  \u2717 {file_name}\")\n                print(f\"      Expected: {result['expected_point_count']}\")\n                print(f\"      Actual: {result['actual_point_count']}\")\n                print(f\"      Accuracy: {result['accuracy_percentage']:.1f}%\")\n\n    # ===== Summary =====\n    print(\"\\n\" + \"=\"*60)\n    print(\"Ground Truth Validation Summary\")\n    print(\"=\"*60)\n    print(f\"Total buildings: {conversion_results['successful']}\")\n    print(f\"Point counts matched: {point_results['passed_files']}\")\n    print(f\"Equipment counts matched: {equipment_results['passed_files']}\")\n\n    all_valid = (\n        point_results['passed_files'] == conversion_results['successful'] and\n        equipment_results['passed_files'] == conversion_results['successful']\n    )\n\n    if all_valid:\n        print(\"\\n\u2713 All models complete and accurate!\")\n        print(\"  Ready for production use.\")\n    else:\n        print(\"\\n\u26a0 Some models have count mismatches\")\n        print(\"  Review conversion or source data.\")\n\n    return {\n        'conversion': conversion_results,\n        'ground_truth': ground_truth_df,\n        'points': point_results,\n        'equipment': equipment_results\n    }\n\nif __name__ == \"__main__\":\n    results = complete_ground_truth_workflow()\n</code></pre>"},{"location":"user-guide/validation/ground-truth/#understanding-results","title":"Understanding Results","text":""},{"location":"user-guide/validation/ground-truth/#point-count-match","title":"Point Count Match","text":"<pre><code># Perfect match\n{\n    'success': True,\n    'match': True,\n    'expected_point_count': 23,\n    'actual_point_count': 23,\n    'accuracy_percentage': 100.0\n}\n\n# Partial match\n{\n    'success': True,\n    'match': False,\n    'expected_point_count': 23,\n    'actual_point_count': 20,\n    'accuracy_percentage': 86.96  # 20/23 * 100\n}\n</code></pre>"},{"location":"user-guide/validation/ground-truth/#equipment-count-results","title":"Equipment Count Results","text":"<pre><code># All match\n{\n    'overall_success': True,\n    'boiler': {'expected': 2, 'actual': 2, 'match': True},\n    'pump': {'expected': 3, 'actual': 3, 'match': True},\n    'weather_station': {'expected': 1, 'actual': 1, 'match': True}\n}\n\n# Mismatch detected\n{\n    'overall_success': False,\n    'boiler': {'expected': 2, 'actual': 1, 'match': False},  # Missing 1\n    'pump': {'expected': 3, 'actual': 3, 'match': True},\n    'weather_station': {'expected': 1, 'actual': 1, 'match': True}\n}\n</code></pre>"},{"location":"user-guide/validation/ground-truth/#common-patterns","title":"Common Patterns","text":""},{"location":"user-guide/validation/ground-truth/#pattern-1-validate-during-conversion","title":"Pattern 1: Validate During Conversion","text":"<pre><code>from hhw_brick import CSVToBrickConverter, BrickModelValidator\nfrom hhw_brick.validation import GroundTruthCalculator\n\n# Generate ground truth once\ncalculator = GroundTruthCalculator()\ncalculator.calculate(\"metadata.csv\", \"vars.csv\", \"ground_truth.csv\")\n\n# Create validator\nvalidator = BrickModelValidator(ground_truth_csv_path=\"ground_truth.csv\")\n\n# Convert and validate each building\nconverter = CSVToBrickConverter()\nfor building_id in [\"105\", \"106\", \"107\"]:\n    # Convert\n    converter.convert_to_brick(\n        metadata_csv=\"metadata.csv\",\n        vars_csv=\"vars.csv\",\n        building_tag=building_id,\n        output_path=f\"building_{building_id}.ttl\"\n    )\n\n    # Validate immediately\n    result = validator.validate_point_count(f\"building_{building_id}.ttl\")\n\n    if result['match']:\n        print(f\"\u2713 Building {building_id}: Complete\")\n    else:\n        print(f\"\u2717 Building {building_id}: {result['accuracy_percentage']:.1f}% complete\")\n</code></pre>"},{"location":"user-guide/validation/ground-truth/#pattern-2-only-use-complete-models","title":"Pattern 2: Only Use Complete Models","text":"<pre><code>def get_complete_models(model_dir, ground_truth_path):\n    \"\"\"Return list of models with 100% point count match.\"\"\"\n\n    validator = BrickModelValidator(\n        ground_truth_csv_path=ground_truth_path\n    )\n\n    results = validator.batch_validate_point_count(test_data_dir=model_dir)\n\n    complete_models = []\n    for result in results['individual_results']:\n        if result['match']:  # 100% match\n            complete_models.append(result['ttl_file_path'])\n\n    return complete_models\n\n# Use only complete models\ncomplete = get_complete_models(\"brick_models/\", \"ground_truth.csv\")\nprint(f\"Found {len(complete)} complete models\")\n\nfor model_path in complete:\n    # Safe to use in analytics\n    app.analyze(model_path, data, config)\n</code></pre>"},{"location":"user-guide/validation/ground-truth/#pattern-3-threshold-based-acceptance","title":"Pattern 3: Threshold-Based Acceptance","text":"<p>Accept models above a certain accuracy threshold:</p> <pre><code>def get_acceptable_models(model_dir, ground_truth_path, threshold=95.0):\n    \"\"\"Return models with accuracy &gt;= threshold.\"\"\"\n\n    validator = BrickModelValidator(\n        ground_truth_csv_path=ground_truth_path\n    )\n\n    results = validator.batch_validate_point_count(test_data_dir=model_dir)\n\n    acceptable = []\n    for result in results['individual_results']:\n        if result['accuracy_percentage'] &gt;= threshold:\n            acceptable.append({\n                'path': result['ttl_file_path'],\n                'accuracy': result['accuracy_percentage']\n            })\n\n    return acceptable\n\n# Use models with 95%+ accuracy\nacceptable = get_acceptable_models(\"brick_models/\", \"ground_truth.csv\", 95.0)\nprint(f\"Found {len(acceptable)} acceptable models (\u226595% accurate)\")\n</code></pre>"},{"location":"user-guide/validation/ground-truth/#troubleshooting","title":"Troubleshooting","text":""},{"location":"user-guide/validation/ground-truth/#issue-ground-truth-file-not-found","title":"Issue: \"Ground truth file not found\"","text":"<p>Solution: Generate it first: <pre><code>calculator = GroundTruthCalculator()\ncalculator.calculate(\n    metadata_csv=\"metadata.csv\",\n    vars_csv=\"vars.csv\",\n    output_csv=\"ground_truth.csv\"\n)\n</code></pre></p>"},{"location":"user-guide/validation/ground-truth/#issue-point-count-always-0","title":"Issue: Point count always 0","text":"<p>Cause: Building tag not found in ground truth</p> <p>Solution: Check building ID format: <pre><code>import pandas as pd\n\n# Check ground truth\ngt = pd.read_csv(\"ground_truth.csv\")\nprint(\"Buildings in ground truth:\")\nprint(gt['tag'].tolist())\n\n# Ensure building ID matches\n# File: building_105.ttl -&gt; tag should be \"105\" in ground_truth.csv\n</code></pre></p>"},{"location":"user-guide/validation/ground-truth/#issue-all-equipment-counts-mismatch","title":"Issue: All equipment counts mismatch","text":"<p>Cause: Ground truth calculation issue</p> <p>Solution: Regenerate ground truth: <pre><code># Delete old file\nimport os\nif os.exists(\"ground_truth.csv\"):\n    os.remove(\"ground_truth.csv\")\n\n# Regenerate\ncalculator = GroundTruthCalculator()\ncalculator.calculate(\n    metadata_csv=\"metadata.csv\",\n    vars_csv=\"vars.csv\",\n    output_csv=\"ground_truth.csv\"\n)\n</code></pre></p>"},{"location":"user-guide/validation/ground-truth/#issue-point-count-slightly-off","title":"Issue: Point count slightly off","text":"<p>Possible causes: 1. Sensor mapping differences 2. Optional sensors not counted 3. Generated points (e.g., virtual points)</p> <p>Investigation: <pre><code># Check what's in the model\nfrom rdflib import Graph\n\ng = Graph()\ng.parse(\"building_105.ttl\", format=\"turtle\")\n\n# Count points manually\nquery = \"\"\"\nPREFIX brick: &lt;https://brickschema.org/schema/Brick#&gt;\nSELECT (COUNT(?point) as ?count) WHERE {\n    ?point a ?type .\n    ?type rdfs:subClassOf* brick:Point .\n}\n\"\"\"\n\nfor row in g.query(query):\n    print(f\"Actual points in model: {row.count}\")\n</code></pre></p>"},{"location":"user-guide/validation/ground-truth/#best-practices","title":"Best Practices","text":""},{"location":"user-guide/validation/ground-truth/#1-generate-ground-truth-first","title":"1. Generate Ground Truth First","text":"<pre><code># Good \u2713\ncalculator.calculate(\"metadata.csv\", \"vars.csv\", \"ground_truth.csv\")\nvalidator = BrickModelValidator(ground_truth_csv_path=\"ground_truth.csv\")\n\n# Bad \u2717\n# Try to validate without ground truth\n</code></pre>"},{"location":"user-guide/validation/ground-truth/#2-regenerate-after-data-changes","title":"2. Regenerate After Data Changes","text":"<pre><code># If CSV data changes, regenerate ground truth\ncalculator.calculate(\"updated_metadata.csv\", \"updated_vars.csv\", \"ground_truth.csv\")\n</code></pre>"},{"location":"user-guide/validation/ground-truth/#3-check-both-points-and-equipment","title":"3. Check Both Points and Equipment","text":"<pre><code># Good \u2713\npoint_result = validator.validate_point_count(model)\nequip_result = validator.validate_equipment_count(model)\n\n# Bad \u2717\n# Only check one type\n</code></pre>"},{"location":"user-guide/validation/ground-truth/#4-handle-partial-matches","title":"4. Handle Partial Matches","text":"<pre><code># Good \u2713\nif result['accuracy_percentage'] &gt;= 95.0:\n    # Use model with warning\n    logging.warning(f\"Model {model} is {result['accuracy_percentage']:.1f}% complete\")\n    use_model(model)\n\n# Bad \u2717\nif result['match']:  # Only accept 100% matches\n    use_model(model)\n# Might reject many usable models\n</code></pre>"},{"location":"user-guide/validation/ground-truth/#next-steps","title":"Next Steps","text":"<ul> <li>Subgraph Patterns - Validate system topology</li> <li>Applications - Use validated models</li> <li>Examples - Working code</li> </ul> <p>Continue to: Subgraph Patterns \u2192</p>"},{"location":"user-guide/validation/ontology/","title":"Ontology Validation","text":"<p>Verify that Brick models follow the Brick Schema 1.4 rules and RDF/OWL standards using SHACL validation.</p>"},{"location":"user-guide/validation/ontology/#overview","title":"Overview","text":"<p>Ontology validation ensures your Brick model:</p> <ul> <li>\u2713 Uses valid Brick classes (e.g., <code>brick:Boiler</code>, <code>brick:Temperature_Sensor</code>)</li> <li>\u2713 Has correct relationships (e.g., <code>brick:hasPart</code>, <code>brick:feeds</code>, <code>brick:isPointOf</code>)</li> <li>\u2713 Follows RDF/OWL syntax rules</li> <li>\u2713 Uses proper namespaces and URIs</li> <li>\u2713 Conforms to SHACL constraints defined in Brick Schema 1.4</li> </ul>"},{"location":"user-guide/validation/ontology/#why-ontology-validation","title":"Why Ontology Validation?","text":""},{"location":"user-guide/validation/ontology/#1-ensure-interoperability","title":"1. Ensure Interoperability","text":"<p>Valid models work seamlessly with all Brick-compatible tools:</p> <pre><code># If model is valid, it works with:\n# \u2713 Other Brick applications\n# \u2713 SPARQL query engines\n# \u2713 Visualization tools (e.g., Brick Viewer)\n# \u2713 Analytics frameworks\n# \u2713 Integration platforms\n</code></pre>"},{"location":"user-guide/validation/ontology/#2-catch-errors-early","title":"2. Catch Errors Early","text":"<p>Find schema violations before using models in production:</p> <pre><code># Invalid models might cause:\n# \u2717 Analytics application failures\n# \u2717 SPARQL query errors\n# \u2717 Integration problems\n# \u2717 Incorrect inference results\n\n# Always validate first:\nvalidator = BrickModelValidator(use_local_brick=True)\nresult = validator.validate_ontology(\"building_105.ttl\")\n\nif result['valid']:\n    # Safe to use in production\n    app.analyze(\"building_105.ttl\", data, config)\nelse:\n    print(\"Fix violations before proceeding\")\n</code></pre>"},{"location":"user-guide/validation/ontology/#3-quality-assurance","title":"3. Quality Assurance","text":"<p>Ontology validation is the first level of quality assurance in the validation pipeline.</p>"},{"location":"user-guide/validation/ontology/#what-is-shacl","title":"What is SHACL?","text":"<p>SHACL (Shapes Constraint Language) is a W3C standard for validating RDF graphs.</p>"},{"location":"user-guide/validation/ontology/#how-shacl-works","title":"How SHACL Works","text":"<pre><code>Brick Model (RDF)  +  SHACL Shapes  \u2192  Validation Report\n    (Your data)      (Schema rules)     (Conformance check)\n</code></pre> <p>Example SHACL Shape (from Brick Schema): <pre><code># A Temperature_Sensor must have a unit\nbrick:TemperatureSensorShape\n    a sh:NodeShape ;\n    sh:targetClass brick:Temperature_Sensor ;\n    sh:property [\n        sh:path brick:hasUnit ;\n        sh:minCount 1 ;\n        sh:message \"Temperature sensor must have a unit\" ;\n    ] .\n</code></pre></p>"},{"location":"user-guide/validation/ontology/#shacl-in-hhw-brick","title":"SHACL in HHW Brick","text":"<p>HHW Brick uses Brick Schema 1.4's official SHACL shapes to validate models:</p> <ul> <li>\u2713 Class constraints</li> <li>\u2713 Property constraints</li> <li>\u2713 Relationship constraints</li> <li>\u2713 Data type constraints</li> </ul>"},{"location":"user-guide/validation/ontology/#basic-usage","title":"Basic Usage","text":""},{"location":"user-guide/validation/ontology/#validate-single-model","title":"Validate Single Model","text":"<p>Complete example from <code>examples/02_ontology_validation.py</code>:</p> <pre><code>from hhw_brick import BrickModelValidator\n\n# Create validator with local Brick schema\nvalidator = BrickModelValidator(use_local_brick=True)\n\n# Validate a model\nresult = validator.validate_ontology(\"building_105.ttl\")\n\n# Check result\nif result['valid']:\n    print(\"\u2713 Model is valid!\")\n    print(f\"  Conforms to Brick Schema 1.4\")\nelse:\n    print(f\"\u2717 Model has {len(result['violations'])} violations:\")\n    for i, violation in enumerate(result['violations'], 1):\n        print(f\"  {i}. {violation}\")\n</code></pre>"},{"location":"user-guide/validation/ontology/#result-structure","title":"Result Structure","text":"<pre><code>{\n    'valid': True,              # or False\n    'conforms': True,           # SHACL conformance\n    'violations': [],           # List of violation messages\n    'validation_report': {...}  # Detailed SHACL report (if violations exist)\n}\n</code></pre>"},{"location":"user-guide/validation/ontology/#expected-output","title":"Expected Output","text":"<p>\u2713 Valid model: <pre><code>\u2713 Model is valid!\n  Conforms to Brick Schema 1.4\n</code></pre></p> <p>\u2717 Invalid model: <pre><code>\u2717 Model has 3 violations:\n  1. Value does not have class brick:Equipment\n  2. Less than 1 values on building105:boiler1-&gt;brick:hasPoint\n  3. Invalid namespace: http://wrong.namespace.org#sensor1\n</code></pre></p>"},{"location":"user-guide/validation/ontology/#batch-validation-with-parallel-processing","title":"Batch Validation with Parallel Processing","text":"<p>Validate multiple buildings efficiently:</p>"},{"location":"user-guide/validation/ontology/#basic-batch-validation","title":"Basic Batch Validation","text":"<pre><code>from hhw_brick import BrickModelValidator\n\nvalidator = BrickModelValidator(use_local_brick=True)\n\n# Validate all TTL files in directory\nresults = validator.batch_validate_ontology(\n    test_data_dir=\"output/\",\n    max_workers=4  # Parallel workers (default: CPU count - 1)\n)\n\n# Display summary\nprint(f\"\\n{'='*60}\")\nprint(\"Batch Validation Results\")\nprint(f\"{'='*60}\")\nprint(f\"Total models: {results['total_files']}\")\nprint(f\"Valid: {results['passed_files']} \u2713\")\nprint(f\"Invalid: {results['failed_files']} \u2717\")\nprint(f\"Overall accuracy: {results['overall_accuracy']:.1f}%\")\n</code></pre>"},{"location":"user-guide/validation/ontology/#detailed-results","title":"Detailed Results","text":"<pre><code># Access individual results\nfor detail in results['details']:\n    filename = detail['filename']\n    valid = detail['valid']\n    status = '\u2713' if valid else '\u2717'\n\n    print(f\"{status} {filename}\")\n\n    if not valid and 'violations' in detail:\n        for violation in detail['violations']:\n            print(f\"    - {violation}\")\n</code></pre>"},{"location":"user-guide/validation/ontology/#results-structure","title":"Results Structure","text":"<pre><code>{\n    'total_files': 10,\n    'passed_files': 9,\n    'failed_files': 1,\n    'overall_accuracy': 90.0,\n    'details': [\n        {\n            'filename': 'building_105.ttl',\n            'valid': True,\n            'conforms': True,\n            'violations': []\n        },\n        {\n            'filename': 'building_110.ttl',\n            'valid': False,\n            'conforms': False,\n            'violations': ['Invalid class: brick:WrongBoiler']\n        },\n        # ... more results\n    ]\n}\n</code></pre>"},{"location":"user-guide/validation/ontology/#performance-with-parallel-processing","title":"Performance with Parallel Processing","text":"<pre><code># Single-threaded (slow for many files)\nresults = validator.batch_validate_ontology(\n    test_data_dir=\"output/\",\n    max_workers=1  # Sequential\n)\n# 10 files \u00d7 10s each = 100 seconds\n\n# Multi-threaded (faster)\nresults = validator.batch_validate_ontology(\n    test_data_dir=\"output/\",\n    max_workers=4  # 4 parallel workers\n)\n# 10 files / 4 workers \u00d7 10s = ~25 seconds\n</code></pre> <p>Choosing max_workers</p> <ul> <li>Default: <code>cpu_count() - 1</code> (leaves one core free)</li> <li>Small datasets: <code>max_workers=2</code> or <code>3</code></li> <li>Large datasets: <code>max_workers=8</code> or more</li> <li>Don't exceed available CPU cores</li> </ul>"},{"location":"user-guide/validation/ontology/#local-vs-nightly-brick-schema","title":"Local vs Nightly Brick Schema","text":""},{"location":"user-guide/validation/ontology/#use-local-brick-recommended","title":"Use Local Brick (Recommended)","text":"<pre><code>validator = BrickModelValidator(use_local_brick=True)\n</code></pre> <p>Advantages: - \u2713 Works offline - \u2713 Faster (no network download) - \u2713 Stable (specific Brick version) - \u2713 Reproducible results</p> <p>When to use: - Production environments - CI/CD pipelines - Offline validation - Consistent testing</p>"},{"location":"user-guide/validation/ontology/#use-nightly-brick-latest","title":"Use Nightly Brick (Latest)","text":"<pre><code>validator = BrickModelValidator(load_brick_nightly=True)\n</code></pre> <p>Advantages: - \u2713 Latest Brick Schema features - \u2713 Newest SHACL shapes - \u2713 Cutting-edge updates</p> <p>Disadvantages: - \u2717 Requires internet connection - \u2717 Slower (downloads from GitHub) - \u2717 Results may change over time</p> <p>When to use: - Development/testing - Exploring new Brick features - Checking compatibility with latest schema</p> <p>Don't mix in production</p> <p>Choose one approach and stick with it for consistency. Use <code>use_local_brick=True</code> for production to ensure reproducible validation results.</p>"},{"location":"user-guide/validation/ontology/#common-violations-and-fixes","title":"Common Violations and Fixes","text":""},{"location":"user-guide/validation/ontology/#1-invalid-brick-class","title":"1. Invalid Brick Class","text":"<p>Violation: <pre><code>Value does not have class brick:Equipment\n</code></pre></p> <p>Cause: Using non-existent or misspelled Brick class</p> <p>Fix: <pre><code># \u2717 Wrong\ng.add((building_ns.boiler1, RDF.type, BRICK.InvalidBoiler))\n\n# \u2713 Correct\ng.add((building_ns.boiler1, RDF.type, BRICK.Boiler))\n</code></pre></p>"},{"location":"user-guide/validation/ontology/#2-missing-required-relationship","title":"2. Missing Required Relationship","text":"<p>Violation: <pre><code>Less than 1 values on building105:boiler1-&gt;brick:hasPoint\n</code></pre></p> <p>Cause: Equipment missing required sensors/points</p> <p>Fix: <pre><code># \u2717 Missing hasPoint relationship\ng.add((building_ns.boiler1, RDF.type, BRICK.Boiler))\n\n# \u2713 Add required sensor\ng.add((building_ns.boiler1, RDF.type, BRICK.Boiler))\ng.add((building_ns.boiler1, BRICK.hasPoint, building_ns.boiler1_temp))\ng.add((building_ns.boiler1_temp, RDF.type, BRICK.Temperature_Sensor))\n</code></pre></p>"},{"location":"user-guide/validation/ontology/#3-invalid-namespace","title":"3. Invalid Namespace","text":"<p>Violation: <pre><code>Invalid namespace: http://example.org#sensor1\n</code></pre></p> <p>Cause: Using non-standard namespace without proper declaration</p> <p>Fix: <pre><code># \u2717 Wrong - undefined namespace\nsensor_uri = URIRef(\"http://example.org#sensor1\")\n\n# \u2713 Correct - use building-specific namespace\nfrom rdflib import Namespace\nBUILDING = Namespace(\"https://buildings.example.org#\")\nsensor_uri = BUILDING.building105_sensor1\n</code></pre></p>"},{"location":"user-guide/validation/ontology/#4-incorrect-relationship-direction","title":"4. Incorrect Relationship Direction","text":"<p>Violation: <pre><code>Unexpected relationship direction\n</code></pre></p> <p>Cause: Using inverse relationships incorrectly</p> <p>Fix: <pre><code># \u2717 Wrong direction\ng.add((sensor, BRICK.isPointOf, equipment))\n\n# \u2713 Correct direction\ng.add((equipment, BRICK.hasPoint, sensor))\n# OR use inverse\ng.add((sensor, BRICK.isPointOf, equipment))\n</code></pre></p>"},{"location":"user-guide/validation/ontology/#5-missing-type-declaration","title":"5. Missing Type Declaration","text":"<p>Violation: <pre><code>Node has no rdf:type\n</code></pre></p> <p>Cause: Entity missing <code>rdf:type</code> declaration</p> <p>Fix: <pre><code># \u2717 Missing type\ng.add((building_ns.loop1, BRICK.hasPart, building_ns.pump1))\n\n# \u2713 Add types\ng.add((building_ns.loop1, RDF.type, BRICK.Hot_Water_Loop))\ng.add((building_ns.pump1, RDF.type, BRICK.Pump))\ng.add((building_ns.loop1, BRICK.hasPart, building_ns.pump1))\n</code></pre></p>"},{"location":"user-guide/validation/ontology/#advanced-usage","title":"Advanced Usage","text":""},{"location":"user-guide/validation/ontology/#custom-validation-with-additional-shapes","title":"Custom Validation with Additional Shapes","text":"<pre><code>from hhw_brick import BrickModelValidator\n\n# Validate with custom SHACL shapes\nvalidator = BrickModelValidator(use_local_brick=True)\n\n# Load additional shapes\ncustom_shapes = \"\"\"\n@prefix sh: &lt;http://www.w3.org/ns/shacl#&gt; .\n@prefix brick: &lt;https://brickschema.org/schema/Brick#&gt; .\n\n# Custom shape: All boilers must have a manufacturer\nbrick:CustomBoilerShape\n    a sh:NodeShape ;\n    sh:targetClass brick:Boiler ;\n    sh:property [\n        sh:path brick:hasManufacturer ;\n        sh:minCount 1 ;\n        sh:message \"Boiler must have a manufacturer\" ;\n    ] .\n\"\"\"\n\n# Note: HHW Brick currently validates against standard Brick shapes\n# Custom shapes require extending the validator\n</code></pre>"},{"location":"user-guide/validation/ontology/#programmatic-access-to-violations","title":"Programmatic Access to Violations","text":"<pre><code>result = validator.validate_ontology(\"building_105.ttl\")\n\nif not result['valid']:\n    violations = result['violations']\n\n    # Categorize violations\n    class_violations = [v for v in violations if 'class' in v.lower()]\n    property_violations = [v for v in violations if 'property' in v.lower()]\n\n    print(f\"Class violations: {len(class_violations)}\")\n    print(f\"Property violations: {len(property_violations)}\")\n\n    # Log for debugging\n    with open('validation_report.txt', 'w') as f:\n        for v in violations:\n            f.write(f\"{v}\\n\")\n</code></pre>"},{"location":"user-guide/validation/ontology/#integration-with-conversion-pipeline","title":"Integration with Conversion Pipeline","text":"<p>Validate immediately after conversion:</p> <pre><code>from hhw_brick import CSVToBrickConverter, BrickModelValidator\n\n# Convert\nconverter = CSVToBrickConverter()\ngraph = converter.convert_to_brick(\n    metadata_csv=\"metadata.csv\",\n    vars_csv=\"vars_available_by_building.csv\",\n    building_tag=\"105\",\n    output_path=\"building_105.ttl\"\n)\n\n# Validate immediately\nvalidator = BrickModelValidator(use_local_brick=True)\nresult = validator.validate_ontology(\"building_105.ttl\")\n\nif result['valid']:\n    print(f\"\u2713 Conversion successful: {len(graph)} triples\")\n    print(\"\u2713 Model validated\")\nelse:\n    print(\"\u2717 Conversion produced invalid model\")\n    print(\"Violations:\")\n    for v in result['violations']:\n        print(f\"  - {v}\")\n    # Fix converter logic\n</code></pre>"},{"location":"user-guide/validation/ontology/#troubleshooting","title":"Troubleshooting","text":""},{"location":"user-guide/validation/ontology/#validation-takes-too-long","title":"Validation Takes Too Long","text":"<p>Problem: Validation is slow for large models</p> <p>Solutions: 1. Use batch validation with parallel processing 2. Reduce <code>max_workers</code> if memory is limited 3. Validate incrementally during development</p> <pre><code># Fast batch validation\nresults = validator.batch_validate_ontology(\n    test_data_dir=\"output/\",\n    max_workers=8  # Adjust based on CPU\n)\n</code></pre>"},{"location":"user-guide/validation/ontology/#no-data-to-validate-error","title":"\"No data to validate\" Error","text":"<p>Problem: Validator can't read the TTL file</p> <p>Solutions: 1. Check file path is correct 2. Verify TTL file is valid RDF syntax 3. Ensure file has <code>.ttl</code> extension</p> <pre><code>from pathlib import Path\n\nttl_file = Path(\"building_105.ttl\")\nif not ttl_file.exists():\n    print(f\"File not found: {ttl_file}\")\nelif not ttl_file.suffix == '.ttl':\n    print(f\"Wrong extension: {ttl_file.suffix}\")\n</code></pre>"},{"location":"user-guide/validation/ontology/#inconsistent-validation-results","title":"Inconsistent Validation Results","text":"<p>Problem: Results differ between runs</p> <p>Solution: Use <code>use_local_brick=True</code> for consistent results</p> <pre><code># \u2717 Inconsistent (downloads latest schema each time)\nvalidator = BrickModelValidator(load_brick_nightly=True)\n\n# \u2713 Consistent (uses fixed local schema)\nvalidator = BrickModelValidator(use_local_brick=True)\n</code></pre>"},{"location":"user-guide/validation/ontology/#violations-but-model-looks-correct","title":"Violations but Model Looks Correct","text":"<p>Problem: SHACL reports violations but model seems valid</p> <p>Solutions: 1. Check Brick Schema version compatibility 2. Verify namespace URIs are exact 3. Review SHACL shape definitions 4. Check relationship directions</p> <pre><code># Debug: Inspect model manually\nfrom rdflib import Graph\n\ng = Graph()\ng.parse(\"building_105.ttl\", format=\"turtle\")\n\n# Check all types used\ntypes = set()\nfor s, p, o in g.triples((None, RDF.type, None)):\n    types.add(str(o))\n\nprint(\"Classes used:\")\nfor t in sorted(types):\n    print(f\"  - {t}\")\n</code></pre>"},{"location":"user-guide/validation/ontology/#best-practices","title":"Best Practices","text":"<p>Ontology Validation Best Practices</p> <ol> <li>Validate early and often - After each conversion</li> <li>Use local Brick - For consistent results (<code>use_local_brick=True</code>)</li> <li>Batch validate - Faster with <code>max_workers</code></li> <li>Log violations - Save reports for debugging</li> <li>Fix root causes - Update converter, not individual models</li> <li>Automate - Include in CI/CD pipeline</li> </ol>"},{"location":"user-guide/validation/ontology/#example-cicd-integration","title":"Example CI/CD Integration","text":"<pre><code>def ci_validation_check(output_dir):\n    \"\"\"CI/CD validation check - fails build if invalid models\"\"\"\n    validator = BrickModelValidator(use_local_brick=True)\n\n    results = validator.batch_validate_ontology(\n        test_data_dir=output_dir,\n        max_workers=4\n    )\n\n    if results['overall_accuracy'] &lt; 100.0:\n        print(f\"\u2717 Validation failed: {results['failed_files']} invalid models\")\n        for detail in results['details']:\n            if not detail['valid']:\n                print(f\"\\n{detail['filename']}:\")\n                for v in detail.get('violations', []):\n                    print(f\"  - {v}\")\n        return False  # Fail CI build\n    else:\n        print(f\"\u2713 All {results['total_files']} models valid\")\n        return True  # Pass CI build\n\n# In CI pipeline\nif not ci_validation_check(\"output/\"):\n    exit(1)  # Fail build\n</code></pre>"},{"location":"user-guide/validation/ontology/#next-steps","title":"Next Steps","text":"<ul> <li>Ground Truth Validation - Validate point and equipment counts</li> <li>Subgraph Pattern Validation - Validate system structure</li> <li>Examples - Working validation examples</li> <li>Back to Validation Overview</li> </ul>"},{"location":"user-guide/validation/ontology/#references","title":"References","text":"<ul> <li>Brick Schema Documentation</li> <li>SHACL W3C Specification</li> <li>RDF 1.1 Primer</li> <li>brickschema Python Package</li> </ul>"},{"location":"user-guide/validation/ontology/#validation-methods","title":"Validation Methods","text":""},{"location":"user-guide/validation/ontology/#validate_ontology","title":"validate_ontology()","text":"<p>Main ontology validation method.</p> <p>Signature: <pre><code>def validate_ontology(ttl_file_path: str) -&gt; Dict\n</code></pre></p> <p>Parameters: - <code>ttl_file_path</code> (str): Path to TTL file to validate</p> <p>Returns: <pre><code>{\n    'valid': bool,              # True if valid\n    'violations': list,         # List of violation messages\n    'ttl_file_path': str,       # Path to validated file\n    'success': bool,            # Same as 'valid'\n    'is_valid': bool,           # Same as 'valid'\n    'validation_report': str    # Text report\n}\n</code></pre></p> <p>Example: <pre><code>result = validator.validate_ontology(\"building_105.ttl\")\n\nprint(f\"Valid: {result['valid']}\")\nprint(f\"File: {result['ttl_file_path']}\")\n\nif not result['valid']:\n    print(\"Violations:\")\n    for v in result['violations']:\n        print(f\"  - {v}\")\n</code></pre></p>"},{"location":"user-guide/validation/ontology/#batch-validation","title":"Batch Validation","text":""},{"location":"user-guide/validation/ontology/#validate-multiple-models-parallel","title":"Validate Multiple Models (Parallel)","text":"<p>From <code>examples/02_ontology_validation.py</code>:</p> <pre><code>from hhw_brick import BrickModelValidator\n\nvalidator = BrickModelValidator(use_local_brick=True)\n\n# Batch validate with parallel processing\nresults = validator.batch_validate_ontology(\n    test_data_dir=\"brick_models/\",\n    max_workers=8  # Number of parallel workers\n)\n\n# Results\nprint(f\"Total files: {results['total_files']}\")\nprint(f\"Valid: {results['passed_files']}\")\nprint(f\"Invalid: {results['failed_files']}\")\nprint(f\"Accuracy: {results['overall_accuracy']:.1f}%\")\n</code></pre>"},{"location":"user-guide/validation/ontology/#batch_validate_ontology","title":"batch_validate_ontology()","text":"<p>Signature: <pre><code>def batch_validate_ontology(\n    test_data_dir: str,\n    max_workers: int = None\n) -&gt; Dict\n</code></pre></p> <p>Parameters: - <code>test_data_dir</code> (str): Directory containing TTL files - <code>max_workers</code> (int, optional): Number of parallel workers (default: CPU count - 1)</p> <p>Returns: <pre><code>{\n    'total_files': int,           # Total TTL files found\n    'passed_files': int,          # Valid models\n    'failed_files': int,          # Invalid models\n    'overall_accuracy': float,    # Percentage valid\n    'individual_results': [...]   # List of individual results\n}\n</code></pre></p> <p>Example: <pre><code># Auto-detect worker count\nresults = validator.batch_validate_ontology(\n    test_data_dir=\"brick_models/\"\n)\n\n# Custom worker count for better performance\nresults = validator.batch_validate_ontology(\n    test_data_dir=\"brick_models/\",\n    max_workers=16  # Use 16 workers\n)\n\n# Show detailed results\nfor result in results['individual_results']:\n    file_name = result['ttl_file_path'].split('/')[-1]\n    status = \"\u2713\" if result['valid'] else \"\u2717\"\n    print(f\"{status} {file_name}\")\n</code></pre></p>"},{"location":"user-guide/validation/ontology/#local-vs-remote-brick-schema","title":"Local vs Remote Brick Schema","text":""},{"location":"user-guide/validation/ontology/#using-local-brick-schema-recommended","title":"Using Local Brick Schema (Recommended)","text":"<p>Faster and works offline:</p> <pre><code>validator = BrickModelValidator(use_local_brick=True)\nresult = validator.validate_ontology(\"building_105.ttl\")\n</code></pre> <p>Advantages: - \u2713 Faster validation - \u2713 Works offline - \u2713 Consistent results - \u2713 No network dependency</p> <p>Uses: <code>hhw_brick/validation/Brick_Self.ttl</code></p>"},{"location":"user-guide/validation/ontology/#using-remote-brick-schema","title":"Using Remote Brick Schema","text":"<p>Latest Brick schema from GitHub:</p> <pre><code>validator = BrickModelValidator(use_local_brick=False)\nresult = validator.validate_ontology(\"building_105.ttl\")\n</code></pre> <p>Advantages: - \u2713 Always latest Brick version - \u2713 Latest class definitions</p> <p>Disadvantages: - \u2717 Requires internet - \u2717 Slower validation - \u2717 May change over time</p>"},{"location":"user-guide/validation/ontology/#common-validation-patterns","title":"Common Validation Patterns","text":""},{"location":"user-guide/validation/ontology/#pattern-1-validate-after-conversion","title":"Pattern 1: Validate After Conversion","text":"<pre><code>from hhw_brick import CSVToBrickConverter, BrickModelValidator\n\n# Convert\nconverter = CSVToBrickConverter()\nresult = converter.convert_to_brick(\n    metadata_csv=\"metadata.csv\",\n    vars_csv=\"vars.csv\",\n    building_tag=\"105\",\n    output_path=\"building_105.ttl\"\n)\n\n# Validate immediately\nvalidator = BrickModelValidator(use_local_brick=True)\nvalidation = validator.validate_ontology(\"building_105.ttl\")\n\nif validation['valid']:\n    print(\"\u2713 Conversion successful and valid\")\nelse:\n    print(\"\u2717 Conversion produced invalid model\")\n    print(\"Review these issues:\")\n    for v in validation['violations']:\n        print(f\"  - {v}\")\n</code></pre>"},{"location":"user-guide/validation/ontology/#pattern-2-production-batch-validation","title":"Pattern 2: Production Batch Validation","text":"<pre><code>\"\"\"\nProduction validation workflow\n\"\"\"\nfrom pathlib import Path\nfrom hhw_brick import BatchConverter, BrickModelValidator\n\ndef production_validation():\n    \"\"\"Convert and validate all buildings.\"\"\"\n\n    # Step 1: Batch convert\n    print(\"Converting buildings...\")\n    batch = BatchConverter()\n    conversion_results = batch.convert_all_buildings(\n        metadata_csv=\"metadata.csv\",\n        vars_csv=\"vars.csv\",\n        output_dir=\"brick_models/\",\n        show_progress=True\n    )\n\n    print(f\"Converted {conversion_results['successful']} buildings\")\n\n    # Step 2: Batch validate\n    print(\"\\nValidating models...\")\n    validator = BrickModelValidator(use_local_brick=True)\n    validation_results = validator.batch_validate_ontology(\n        test_data_dir=\"brick_models/\",\n        max_workers=8\n    )\n\n    # Step 3: Report\n    print(f\"\\nValidation Results:\")\n    print(f\"  Total: {validation_results['total_files']}\")\n    print(f\"  Valid: {validation_results['passed_files']}\")\n    print(f\"  Invalid: {validation_results['failed_files']}\")\n    print(f\"  Accuracy: {validation_results['overall_accuracy']:.1f}%\")\n\n    # Step 4: Handle failures\n    if validation_results['failed_files'] &gt; 0:\n        print(\"\\nFailed models:\")\n        for result in validation_results['individual_results']:\n            if not result['valid']:\n                print(f\"  \u2717 {Path(result['ttl_file_path']).name}\")\n                for v in result.get('violations', [])[:3]:  # First 3\n                    print(f\"      - {v}\")\n\n    return validation_results\n\nif __name__ == \"__main__\":\n    results = production_validation()\n</code></pre>"},{"location":"user-guide/validation/ontology/#pattern-3-selective-validation","title":"Pattern 3: Selective Validation","text":"<p>Only validate new or changed models:</p> <pre><code>import os\nfrom pathlib import Path\n\ndef validate_new_models(model_dir, cache_file=\".validation_cache\"):\n    \"\"\"Validate only new/changed models.\"\"\"\n\n    # Load validation cache\n    validated = set()\n    if os.path.exists(cache_file):\n        with open(cache_file, 'r') as f:\n            validated = set(line.strip() for line in f)\n\n    # Find new models\n    all_models = set(str(p) for p in Path(model_dir).glob(\"*.ttl\"))\n    new_models = all_models - validated\n\n    if not new_models:\n        print(\"No new models to validate\")\n        return\n\n    print(f\"Validating {len(new_models)} new models...\")\n\n    validator = BrickModelValidator(use_local_brick=True)\n\n    # Validate new models\n    newly_validated = []\n    for model_path in new_models:\n        result = validator.validate_ontology(model_path)\n\n        if result['valid']:\n            newly_validated.append(model_path)\n            print(f\"\u2713 {Path(model_path).name}\")\n        else:\n            print(f\"\u2717 {Path(model_path).name}\")\n\n    # Update cache\n    with open(cache_file, 'a') as f:\n        for model in newly_validated:\n            f.write(f\"{model}\\n\")\n\n    print(f\"\\nValidated {len(newly_validated)}/{len(new_models)} new models\")\n\n# Use it\nvalidate_new_models(\"brick_models/\")\n</code></pre>"},{"location":"user-guide/validation/ontology/#what-gets-validated","title":"What Gets Validated","text":""},{"location":"user-guide/validation/ontology/#brick-class-names","title":"Brick Class Names","text":"<p>Checks if classes exist in Brick schema:</p> <pre><code># Valid \u2713\nbrick:Boiler\nbrick:Hot_Water_Supply_Temperature_Sensor\nbrick:Heat_Exchanger\n\n# Invalid \u2717\nbrick:InvalidBoiler  # No such class\nbrick:TemperatureSensor  # Wrong name (should be Temperature_Sensor)\nmyprefix:CustomClass  # Not in Brick namespace\n</code></pre>"},{"location":"user-guide/validation/ontology/#relationship-types","title":"Relationship Types","text":"<p>Checks if relationships are valid:</p> <pre><code># Valid \u2713\nbrick:hasPoint\nbrick:feeds\nbrick:isPartOf\n\n# Invalid \u2717\nbrick:hasInvalidRelation  # No such relation\ncustom:feeds  # Wrong namespace\n</code></pre>"},{"location":"user-guide/validation/ontology/#rdf-syntax","title":"RDF Syntax","text":"<p>Checks RDF/Turtle syntax:</p> <pre><code># Valid \u2713\n:Boiler_01 a brick:Boiler .\n:Boiler_01 brick:hasPoint :Temp_Sensor .\n\n# Invalid \u2717\n:Boiler_01 a brick:Boiler  # Missing period\n:Boiler_01 brick:hasPoint  # Incomplete triple\n</code></pre>"},{"location":"user-guide/validation/ontology/#namespace-declarations","title":"Namespace Declarations","text":"<p>Checks proper namespace usage:</p> <pre><code># Valid \u2713\n@prefix brick: &lt;https://brickschema.org/schema/Brick#&gt; .\n@prefix hhws: &lt;https://hhws.example.org#&gt; .\n\n# Invalid \u2717\n@prefix brick: &lt;http://wrong.url.org#&gt; .  # Wrong URL\n# Missing namespace declarations\n</code></pre>"},{"location":"user-guide/validation/ontology/#understanding-validation-results","title":"Understanding Validation Results","text":""},{"location":"user-guide/validation/ontology/#valid-result","title":"Valid Result","text":"<pre><code>{\n    'valid': True,\n    'violations': [],\n    'ttl_file_path': 'building_105.ttl',\n    'success': True,\n    'is_valid': True,\n    'validation_report': 'Model is valid'\n}\n</code></pre>"},{"location":"user-guide/validation/ontology/#invalid-result","title":"Invalid Result","text":"<pre><code>{\n    'valid': False,\n    'violations': [\n        'sh:Violation on brick:hasPoint',\n        'Invalid class: brick:WrongClass',\n        'Missing required property'\n    ],\n    'ttl_file_path': 'building_105.ttl',\n    'success': False,\n    'is_valid': False,\n    'validation_report': 'Model has 3 violations'\n}\n</code></pre>"},{"location":"user-guide/validation/ontology/#performance","title":"Performance","text":""},{"location":"user-guide/validation/ontology/#single-model","title":"Single Model","text":"<p>Typical validation time: - Local Brick: 0.5-2 seconds per model - Remote Brick: 3-5 seconds per model (first time)</p>"},{"location":"user-guide/validation/ontology/#batch-validation_1","title":"Batch Validation","text":"<p>Parallel processing dramatically improves speed:</p> <pre><code># Serial (slow)\nfor file in ttl_files:\n    validator.validate_ontology(file)  # ~2 sec each\n# 100 files = ~200 seconds\n\n# Parallel (fast)\nresults = validator.batch_validate_ontology(\n    test_data_dir=\"models/\",\n    max_workers=8\n)\n# 100 files = ~30 seconds (8x speedup)\n</code></pre> <p>Performance table:</p> Models Serial Parallel (8 workers) Speedup 10 ~20s ~5s 4x 50 ~100s ~15s 6.7x 100 ~200s ~30s 6.7x 500 ~1000s ~150s 6.7x"},{"location":"user-guide/validation/ontology/#optimization-tips","title":"Optimization Tips","text":"<ol> <li>Use local Brick for faster validation</li> <li>Increase workers for more parallelism (up to CPU count)</li> <li>Validate in batches rather than one-by-one</li> <li>Cache results for unchanged models</li> </ol>"},{"location":"user-guide/validation/ontology/#troubleshooting_1","title":"Troubleshooting","text":""},{"location":"user-guide/validation/ontology/#issue-brickschema-not-available","title":"Issue: \"brickschema not available\"","text":"<p>Cause: Missing dependency</p> <p>Solution: <pre><code>pip install brickschema\n</code></pre></p>"},{"location":"user-guide/validation/ontology/#issue-local-brick-file-not-found","title":"Issue: \"Local Brick file not found\"","text":"<p>Cause: Package not properly installed</p> <p>Solution: <pre><code># Reinstall package\npip install --force-reinstall hhw-brick\n</code></pre></p> <p>Or use remote Brick: <pre><code>validator = BrickModelValidator(use_local_brick=False)\n</code></pre></p>"},{"location":"user-guide/validation/ontology/#issue-all-models-failing-validation","title":"Issue: All models failing validation","text":"<p>Possible causes: 1. Conversion issues 2. Wrong Brick version 3. Corrupted TTL files</p> <p>Solution: <pre><code># Check single model manually\nfrom rdflib import Graph\n\ng = Graph()\ntry:\n    g.parse(\"building_105.ttl\", format=\"turtle\")\n    print(f\"\u2713 File parses correctly: {len(g)} triples\")\nexcept Exception as e:\n    print(f\"\u2717 Parse error: {e}\")\n</code></pre></p>"},{"location":"user-guide/validation/ontology/#issue-validation-too-slow","title":"Issue: Validation too slow","text":"<p>Solution 1: Use local Brick <pre><code>validator = BrickModelValidator(use_local_brick=True)\n</code></pre></p> <p>Solution 2: Increase workers <pre><code>results = validator.batch_validate_ontology(\n    test_data_dir=\"models/\",\n    max_workers=16  # More workers\n)\n</code></pre></p> <p>Solution 3: Validate only changed files <pre><code># See \"Pattern 3: Selective Validation\" above\n</code></pre></p>"},{"location":"user-guide/validation/ontology/#best-practices_1","title":"Best Practices","text":""},{"location":"user-guide/validation/ontology/#1-always-validate-after-conversion","title":"1. Always Validate After Conversion","text":"<pre><code># Good \u2713\nresult = converter.convert_to_brick(...)\nvalidation = validator.validate_ontology(output_file)\n\n# Bad \u2717\nresult = converter.convert_to_brick(...)\n# Skip validation - might have invalid models\n</code></pre>"},{"location":"user-guide/validation/ontology/#2-use-local-brick-for-production","title":"2. Use Local Brick for Production","text":"<pre><code># Production \u2713\nvalidator = BrickModelValidator(use_local_brick=True)\n\n# Development (occasional use)\nvalidator = BrickModelValidator(use_local_brick=False)\n</code></pre>"},{"location":"user-guide/validation/ontology/#3-handle-validation-failures","title":"3. Handle Validation Failures","text":"<pre><code># Good \u2713\nresult = validator.validate_ontology(\"model.ttl\")\nif not result['valid']:\n    log_error(result['violations'])\n    notify_admin()\n    skip_model()\n\n# Bad \u2717\nresult = validator.validate_ontology(\"model.ttl\")\n# Ignore failures - use invalid model anyway\n</code></pre>"},{"location":"user-guide/validation/ontology/#4-log-validation-results","title":"4. Log Validation Results","text":"<pre><code>import logging\n\nlogging.basicConfig(level=logging.INFO)\n\nresult = validator.validate_ontology(\"model.ttl\")\nif result['valid']:\n    logging.info(f\"\u2713 Valid: {result['ttl_file_path']}\")\nelse:\n    logging.error(f\"\u2717 Invalid: {result['ttl_file_path']}\")\n    for v in result['violations']:\n        logging.error(f\"  - {v}\")\n</code></pre>"},{"location":"user-guide/validation/ontology/#next-steps_1","title":"Next Steps","text":"<ul> <li>Ground Truth Validation - Validate counts and completeness</li> <li>Subgraph Patterns - Validate system topology</li> <li>Examples - Working code samples</li> </ul> <p>Continue to: Ground Truth Validation \u2192</p>"},{"location":"user-guide/validation/subgraph-patterns/","title":"Subgraph Pattern Validation","text":"<p>Validate system topology and architectural patterns in Brick models.</p>"},{"location":"user-guide/validation/subgraph-patterns/#overview","title":"Overview","text":"<p>Subgraph pattern validation checks if your Brick model follows expected system architecture patterns:</p> <ul> <li>Pattern 1 (Boiler System): Has boilers, primary loop, heat exchanger, secondary loop</li> <li>Pattern 2 (District System): Has district connection, secondary loop, no boilers</li> </ul> <p>This ensures system topology is correct.</p>"},{"location":"user-guide/validation/subgraph-patterns/#why-validate-patterns","title":"Why Validate Patterns?","text":""},{"location":"user-guide/validation/subgraph-patterns/#verify-system-architecture","title":"Verify System Architecture","text":"<p>Ensure model represents the actual system:</p> <pre><code># Pattern 2: District System\n# Expected: District connection \u2192 HX \u2192 Secondary loop\n# Should NOT have: Boilers, primary loop\n\nresult = validator.check_pattern_2_district_system(\"building_108.ttl\")\nif result['matched']:\n    print(\"\u2713 District system architecture correct\")\n</code></pre>"},{"location":"user-guide/validation/subgraph-patterns/#catch-modeling-errors","title":"Catch Modeling Errors","text":"<p>Find structural issues:</p> <pre><code># District system but has boilers? Error!\nif result['has_boiler']:\n    print(\"\u2717 District system should not have boilers\")\n</code></pre>"},{"location":"user-guide/validation/subgraph-patterns/#prepare-for-analytics","title":"Prepare for Analytics","text":"<p>Some analytics require specific patterns:</p> <pre><code># This app requires boiler system (Pattern 1)\nif not has_boilers(model):\n    print(\"Skip: Model doesn't match required pattern\")\n</code></pre>"},{"location":"user-guide/validation/subgraph-patterns/#subgraphpatternvalidator","title":"SubgraphPatternValidator","text":""},{"location":"user-guide/validation/subgraph-patterns/#basic-usage","title":"Basic Usage","text":"<p>From <code>examples/05_subgraph_pattern_matching.py</code>:</p> <pre><code>from hhw_brick.validation import SubgraphPatternValidator\n\n# Create validator\nvalidator = SubgraphPatternValidator()\n\n# Check if model matches Pattern 2 (District System)\nresult = validator.check_pattern_2_district_system(\"building_108.ttl\")\n\nif result['matched']:\n    print(\"\u2713 This is a District System\")\n    print(f\"  - Has building: {result['details']['has_building']}\")\n    print(f\"  - Has HW system: {result['details']['has_hot_water_system']}\")\n    print(f\"  - Has secondary loop: {result['details']['has_secondary_loop']}\")\n    print(f\"  - No boilers: {not result['details']['has_boiler']}\")\nelse:\n    print(\"\u2717 Not a District System\")\n</code></pre>"},{"location":"user-guide/validation/subgraph-patterns/#pattern-definitions","title":"Pattern Definitions","text":""},{"location":"user-guide/validation/subgraph-patterns/#pattern-1-boiler-system","title":"Pattern 1: Boiler System","text":"<p>Architecture: <pre><code>graph LR\n    B[Boiler] --&gt;|feeds| HX[Heat Exchanger]\n    HX --&gt;|feeds| SL[Secondary Loop]\n    B --&gt;|has| PP[Primary Pump]\n    SL --&gt;|has| SP[Secondary Pump]\n\n    style B fill:#ff9800\n    style HX fill:#2196f3\n    style SL fill:#4caf50</code></pre></p> <p>Components: - \u2713 One or more boilers - \u2713 Primary loop - \u2713 Heat exchanger - \u2713 Secondary loop - \u2713 Primary and secondary pumps</p> <p>System Types: Non-condensing, Condensing, Boiler</p>"},{"location":"user-guide/validation/subgraph-patterns/#pattern-2-district-system","title":"Pattern 2: District System","text":"<p>Architecture: <pre><code>graph LR\n    DS[District&lt;br/&gt;Supply] --&gt;|feeds| HX[Heat&lt;br/&gt;Exchanger]\n    HX --&gt;|feeds| BL[Building&lt;br/&gt;Loop]\n    DS --&gt;|has| DM[District&lt;br/&gt;Meter]\n    BL --&gt;|has| BP[Building&lt;br/&gt;Pump]\n\n    style DS fill:#9c27b0\n    style HX fill:#2196f3\n    style BL fill:#4caf50</code></pre></p> <p>Components: - \u2713 District hot water/steam connection - \u2713 Heat exchanger - \u2713 Secondary loop (building side) - \u2713 Building pumps - \u2717 NO boilers - \u2717 NO primary loop</p> <p>System Types: District HW, District Steam</p>"},{"location":"user-guide/validation/subgraph-patterns/#validation-methods","title":"Validation Methods","text":""},{"location":"user-guide/validation/subgraph-patterns/#check_pattern_2_district_system","title":"check_pattern_2_district_system()","text":"<p>Check if model matches District System pattern.</p> <p>Signature: <pre><code>def check_pattern_2_district_system(ttl_file_path: str) -&gt; Dict\n</code></pre></p> <p>Returns: <pre><code>{\n    'matched': bool,                    # True if matches Pattern 2\n    'details': {\n        'has_building': bool,           # Building entity exists\n        'has_hot_water_system': bool,   # HW system exists\n        'has_secondary_loop': bool,     # Secondary loop exists\n        'has_pump': bool,               # Pumps exist\n        'has_weather_station': bool,    # Weather station exists\n        'has_boiler': bool,             # Should be False for Pattern 2\n        'has_primary_loop': bool,       # Should be False for Pattern 2\n        'pump_count': int               # Number of pumps\n    },\n    'ttl_file_path': str,\n    'error': str or None                # Error message if failed\n}\n</code></pre></p> <p>Example: <pre><code>result = validator.check_pattern_2_district_system(\"building_108.ttl\")\n\nprint(f\"Matched Pattern 2: {result['matched']}\")\n\ndetails = result['details']\nprint(f\"\\nComponents:\")\nprint(f\"  Building: {details['has_building']}\")\nprint(f\"  HW System: {details['has_hot_water_system']}\")\nprint(f\"  Secondary Loop: {details['has_secondary_loop']}\")\nprint(f\"  Pump Count: {details['pump_count']}\")\n\n# Verify no boiler components\nprint(f\"\\nNo Boiler Components (should be False):\")\nprint(f\"  Has Boiler: {details['has_boiler']}\")\nprint(f\"  Has Primary Loop: {details['has_primary_loop']}\")\n</code></pre></p>"},{"location":"user-guide/validation/subgraph-patterns/#batch-pattern-validation","title":"Batch Pattern Validation","text":"<p>From <code>examples/05_subgraph_pattern_matching.py</code>:</p> <pre><code>from hhw_brick.validation import SubgraphPatternValidator\n\nvalidator = SubgraphPatternValidator()\n\n# Batch validate all buildings\nbatch_results = validator.batch_validate_all_buildings(\n    ttl_directory=\"brick_models/\",\n    max_workers=4  # Parallel workers\n)\n\n# Summary\ntotal = len(batch_results)\npattern_2 = sum(1 for r in batch_results if r.get('matched'))\npattern_1 = total - pattern_2\n\nprint(f\"Total buildings: {total}\")\nprint(f\"Pattern 1 (Boiler Systems): {pattern_1}\")\nprint(f\"Pattern 2 (District Systems): {pattern_2}\")\n</code></pre>"},{"location":"user-guide/validation/subgraph-patterns/#batch_validate_all_buildings","title":"batch_validate_all_buildings()","text":"<p>Signature: <pre><code>def batch_validate_all_buildings(\n    ttl_directory: str,\n    max_workers: int = None\n) -&gt; List[Dict]\n</code></pre></p> <p>Parameters: - <code>ttl_directory</code> (str): Directory containing TTL files - <code>max_workers</code> (int, optional): Number of parallel workers</p> <p>Returns: <pre><code>[\n    {\n        'matched': bool,\n        'details': {...},\n        'ttl_file_path': str,\n        'error': str or None\n    },\n    # ... one dict per file\n]\n</code></pre></p> <p>Example: <pre><code>results = validator.batch_validate_all_buildings(\n    ttl_directory=\"brick_models/\",\n    max_workers=8\n)\n\n# Group by pattern\npattern_1_models = []\npattern_2_models = []\n\nfor result in results:\n    file_name = Path(result['ttl_file_path']).name\n\n    if result['matched']:\n        pattern_2_models.append(file_name)\n    else:\n        pattern_1_models.append(file_name)\n\nprint(f\"Pattern 1 (Boiler): {len(pattern_1_models)} models\")\nprint(f\"Pattern 2 (District): {len(pattern_2_models)} models\")\n</code></pre></p>"},{"location":"user-guide/validation/subgraph-patterns/#complete-validation-example","title":"Complete Validation Example","text":"<p>Based on <code>examples/05_subgraph_pattern_matching.py</code>:</p> <pre><code>\"\"\"\nComplete subgraph pattern validation\n\"\"\"\n\nfrom pathlib import Path\nfrom hhw_brick.validation import SubgraphPatternValidator\n\ndef validate_system_patterns():\n    # Create validator\n    validator = SubgraphPatternValidator()\n\n    # ===== Single Building Validation =====\n    print(\"Single Building Pattern Validation\")\n    print(\"=\"*60)\n\n    building_file = \"building_108_district_hw_aa.ttl\"\n\n    # Check Pattern 2\n    result = validator.check_pattern_2_district_system(building_file)\n\n    if result['matched']:\n        print(f\"\u2713 {building_file} matches Pattern 2 (District System)\")\n\n        details = result['details']\n        print(\"\\nSystem Components:\")\n        print(f\"  \u2713 Building: {details['has_building']}\")\n        print(f\"  \u2713 HW System: {details['has_hot_water_system']}\")\n        print(f\"  \u2713 Secondary Loop: {details['has_secondary_loop']}\")\n        print(f\"  \u2713 Pumps: {details['pump_count']}\")\n        print(f\"  \u2713 Weather Station: {details['has_weather_station']}\")\n\n        print(\"\\nNo Boiler Components (correct for District):\")\n        print(f\"  \u2713 No Boiler: {not details['has_boiler']}\")\n        print(f\"  \u2713 No Primary Loop: {not details['has_primary_loop']}\")\n    else:\n        print(f\"\u2717 {building_file} does NOT match Pattern 2\")\n        print(f\"  This is likely a Pattern 1 (Boiler System)\")\n\n    # ===== Batch Validation =====\n    print(\"\\n\" + \"=\"*60)\n    print(\"Batch Pattern Validation\")\n    print(\"=\"*60)\n\n    batch_results = validator.batch_validate_all_buildings(\n        ttl_directory=\"brick_models/\",\n        max_workers=8\n    )\n\n    # Analyze results\n    total = len(batch_results)\n    pattern_2_count = 0\n    pattern_1_count = 0\n    errors = 0\n\n    pattern_2_files = []\n    pattern_1_files = []\n\n    for result in batch_results:\n        file_name = Path(result['ttl_file_path']).name\n\n        if result.get('error'):\n            errors += 1\n        elif result['matched']:\n            pattern_2_count += 1\n            pattern_2_files.append(file_name)\n        else:\n            pattern_1_count += 1\n            pattern_1_files.append(file_name)\n\n    # Summary\n    print(f\"\\nPattern Validation Summary:\")\n    print(f\"  Total files: {total}\")\n    print(f\"  Pattern 1 (Boiler Systems): {pattern_1_count}\")\n    print(f\"  Pattern 2 (District Systems): {pattern_2_count}\")\n    print(f\"  Errors: {errors}\")\n\n    # Show samples\n    if pattern_1_files:\n        print(f\"\\nPattern 1 (Boiler) sample:\")\n        for file in pattern_1_files[:3]:\n            print(f\"  - {file}\")\n\n    if pattern_2_files:\n        print(f\"\\nPattern 2 (District) sample:\")\n        for file in pattern_2_files[:3]:\n            print(f\"  - {file}\")\n\n    return batch_results\n\nif __name__ == \"__main__\":\n    results = validate_system_patterns()\n</code></pre>"},{"location":"user-guide/validation/subgraph-patterns/#common-use-cases","title":"Common Use Cases","text":""},{"location":"user-guide/validation/subgraph-patterns/#use-case-1-separate-by-pattern","title":"Use Case 1: Separate by Pattern","text":"<p>Group models by their pattern:</p> <pre><code>def separate_by_pattern(model_dir):\n    \"\"\"Separate models into Pattern 1 and Pattern 2 directories.\"\"\"\n\n    from pathlib import Path\n    import shutil\n\n    validator = SubgraphPatternValidator()\n\n    # Create output directories\n    pattern_1_dir = Path(\"pattern_1_boiler\")\n    pattern_2_dir = Path(\"pattern_2_district\")\n    pattern_1_dir.mkdir(exist_ok=True)\n    pattern_2_dir.mkdir(exist_ok=True)\n\n    # Validate all\n    results = validator.batch_validate_all_buildings(\n        ttl_directory=model_dir,\n        max_workers=8\n    )\n\n    # Copy to appropriate directories\n    for result in results:\n        src = Path(result['ttl_file_path'])\n\n        if result['matched']:\n            dst = pattern_2_dir / src.name\n        else:\n            dst = pattern_1_dir / src.name\n\n        shutil.copy(src, dst)\n\n    print(f\"Pattern 1 (Boiler): {len(list(pattern_1_dir.glob('*.ttl')))} files\")\n    print(f\"Pattern 2 (District): {len(list(pattern_2_dir.glob('*.ttl')))} files\")\n\n# Use it\nseparate_by_pattern(\"brick_models/\")\n</code></pre>"},{"location":"user-guide/validation/subgraph-patterns/#use-case-2-validate-before-analytics","title":"Use Case 2: Validate Before Analytics","text":"<p>Only run certain analytics on matching patterns:</p> <pre><code>def run_pattern_specific_analytics(model_path, data, config):\n    \"\"\"Run analytics based on system pattern.\"\"\"\n\n    validator = SubgraphPatternValidator()\n    result = validator.check_pattern_2_district_system(model_path)\n\n    if result['matched']:\n        # Pattern 2: District System\n        print(\"Running district system analytics...\")\n        app = apps.load_app(\"district_efficiency\")\n    else:\n        # Pattern 1: Boiler System\n        print(\"Running boiler system analytics...\")\n        app = apps.load_app(\"boiler_efficiency\")\n\n    # Run appropriate analytics\n    qualified, details = app.qualify(model_path)\n    if qualified:\n        results = app.analyze(model_path, data, config)\n        return results\n    else:\n        print(\"Building doesn't qualify for this analysis\")\n        return None\n</code></pre>"},{"location":"user-guide/validation/subgraph-patterns/#use-case-3-validation-report","title":"Use Case 3: Validation Report","text":"<p>Generate detailed pattern validation report:</p> <pre><code>def generate_pattern_report(model_dir, output_file=\"pattern_report.csv\"):\n    \"\"\"Generate CSV report of pattern validation.\"\"\"\n\n    import pandas as pd\n\n    validator = SubgraphPatternValidator()\n    results = validator.batch_validate_all_buildings(\n        ttl_directory=model_dir,\n        max_workers=8\n    )\n\n    # Create report data\n    report_data = []\n    for result in results:\n        file_name = Path(result['ttl_file_path']).name\n        building_id = file_name.split('_')[1]  # Extract from filename\n\n        details = result.get('details', {})\n\n        report_data.append({\n            'building_id': building_id,\n            'file_name': file_name,\n            'pattern': 'Pattern 2 (District)' if result['matched'] else 'Pattern 1 (Boiler)',\n            'has_building': details.get('has_building', False),\n            'has_hw_system': details.get('has_hot_water_system', False),\n            'has_secondary_loop': details.get('has_secondary_loop', False),\n            'has_boiler': details.get('has_boiler', False),\n            'pump_count': details.get('pump_count', 0),\n            'has_weather_station': details.get('has_weather_station', False)\n        })\n\n    # Create DataFrame and save\n    df = pd.DataFrame(report_data)\n    df.to_csv(output_file, index=False)\n\n    print(f\"Pattern report saved to: {output_file}\")\n    print(f\"Total buildings: {len(df)}\")\n    print(df['pattern'].value_counts())\n\n    return df\n\n# Use it\nreport = generate_pattern_report(\"brick_models/\")\n</code></pre>"},{"location":"user-guide/validation/subgraph-patterns/#understanding-results","title":"Understanding Results","text":""},{"location":"user-guide/validation/subgraph-patterns/#pattern-2-match-district-system","title":"Pattern 2 Match (District System)","text":"<pre><code>{\n    'matched': True,\n    'details': {\n        'has_building': True,\n        'has_hot_water_system': True,\n        'has_secondary_loop': True,\n        'has_pump': True,\n        'has_weather_station': True,\n        'has_boiler': False,          # Correct: No boiler\n        'has_primary_loop': False,    # Correct: No primary loop\n        'pump_count': 2\n    },\n    'ttl_file_path': 'building_108.ttl',\n    'error': None\n}\n</code></pre>"},{"location":"user-guide/validation/subgraph-patterns/#pattern-1-not-pattern-2","title":"Pattern 1 (Not Pattern 2)","text":"<pre><code>{\n    'matched': False,  # Not Pattern 2\n    'details': {\n        'has_building': True,\n        'has_hot_water_system': True,\n        'has_secondary_loop': True,\n        'has_pump': True,\n        'has_weather_station': True,\n        'has_boiler': True,           # Has boiler -&gt; Pattern 1\n        'has_primary_loop': True,     # Has primary loop -&gt; Pattern 1\n        'pump_count': 4\n    },\n    'ttl_file_path': 'building_105.ttl',\n    'error': None\n}\n</code></pre>"},{"location":"user-guide/validation/subgraph-patterns/#troubleshooting","title":"Troubleshooting","text":""},{"location":"user-guide/validation/subgraph-patterns/#issue-all-models-show-matchedfalse","title":"Issue: All models show matched=False","text":"<p>Cause: Models are Pattern 1 (Boiler systems)</p> <p>Solution: This is correct if you have boiler systems. Pattern 2 is specifically for district systems.</p>"},{"location":"user-guide/validation/subgraph-patterns/#issue-pattern-validation-fails","title":"Issue: Pattern validation fails","text":"<p>Cause: Model parsing error</p> <p>Solution: <pre><code>result = validator.check_pattern_2_district_system(\"model.ttl\")\n\nif result.get('error'):\n    print(f\"Validation error: {result['error']}\")\n    # Check if file is valid\n    from rdflib import Graph\n    g = Graph()\n    g.parse(\"model.ttl\", format=\"turtle\")\n</code></pre></p>"},{"location":"user-guide/validation/subgraph-patterns/#issue-district-system-not-matching-pattern-2","title":"Issue: District system not matching Pattern 2","text":"<p>Possible causes: 1. Model has boiler entities (shouldn't) 2. Missing secondary loop components 3. Conversion issue</p> <p>Investigation: <pre><code>result = validator.check_pattern_2_district_system(\"district_model.ttl\")\n\ndetails = result['details']\nprint(f\"Has boiler (should be False): {details['has_boiler']}\")\nprint(f\"Has primary loop (should be False): {details['has_primary_loop']}\")\nprint(f\"Has secondary loop (should be True): {details['has_secondary_loop']}\")\n</code></pre></p>"},{"location":"user-guide/validation/subgraph-patterns/#best-practices","title":"Best Practices","text":""},{"location":"user-guide/validation/subgraph-patterns/#1-use-pattern-validation-for-filtering","title":"1. Use Pattern Validation for Filtering","text":"<pre><code># Separate district systems for specific analytics\nvalidator = SubgraphPatternValidator()\nresults = validator.batch_validate_all_buildings(\"brick_models/\")\n\ndistrict_models = [\n    r['ttl_file_path'] for r in results if r['matched']\n]\n\nfor model in district_models:\n    # Run district-specific analytics\n    run_district_analysis(model)\n</code></pre>"},{"location":"user-guide/validation/subgraph-patterns/#2-combine-with-other-validation","title":"2. Combine with Other Validation","text":"<pre><code># Complete validation pipeline\nontology_valid = validator.validate_ontology(model)['valid']\npattern_matched = pattern_validator.check_pattern_2_district_system(model)['matched']\ncounts_match = validator.validate_point_count(model)['match']\n\nif ontology_valid and counts_match:\n    # Model is valid, check pattern for analytics selection\n    if pattern_matched:\n        run_district_analytics(model)\n    else:\n        run_boiler_analytics(model)\n</code></pre>"},{"location":"user-guide/validation/subgraph-patterns/#3-document-pattern-in-metadata","title":"3. Document Pattern in Metadata","text":"<pre><code># Add pattern info to model metadata\nresults = validator.batch_validate_all_buildings(\"brick_models/\")\n\nfor result in results:\n    pattern = \"District\" if result['matched'] else \"Boiler\"\n    file_path = result['ttl_file_path']\n\n    # Store in database or metadata file\n    save_metadata(file_path, pattern=pattern)\n</code></pre>"},{"location":"user-guide/validation/subgraph-patterns/#next-steps","title":"Next Steps","text":"<ul> <li>Applications - Use validated models in analytics</li> <li>Examples - More pattern examples</li> <li>API Reference - Complete API</li> </ul> <p>Validation documentation complete! \ud83c\udf89</p> <p>Continue to Applications Guide \u2192</p>"}]}