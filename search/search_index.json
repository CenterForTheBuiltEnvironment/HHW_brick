{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"HHW Brick: Heating Hot Water System Brick Schema Toolkit <p> A Python package for converting heating hot water system data to Brick Schema models with comprehensive validation and portable analytics </p> <p> </p> <p> Get Started Installation </p>"},{"location":"#overview","title":"Overview","text":"<p>HHW Brick provides tools for converting building heating hot water system data to Brick Schema models and running portable analytics applications.</p> <p>Core Capabilities:</p> <ul> <li>CSV-to-Brick Converter: Automated conversion from tabular BMS data to Brick Schema 1.4 RDF models</li> <li>Multi-Level Validators: Ontology, point count, equipment count, and structural pattern validation  </li> <li>Portable Analytics: Building-agnostic applications that use SPARQL to auto-discover required sensors</li> </ul> <p>Key Benefits:</p> <ul> <li>Interoperability: Standardized semantic models work across different BMS platforms</li> <li>Portability: Write analytics once, run on any qualified building without recoding</li> <li>Quality Assurance: Comprehensive validation ensures model correctness</li> </ul> <p>The package supports five heating hot water system types (condensing boilers, non-condensing boilers, generic boilers, district hot water, district steam) and has been tested on 216 real buildings.</p>"},{"location":"#installation","title":"Installation","text":"<pre><code># For users (when published to PyPI)\npip install hhw-brick\n\n# For development (current method)\ngit clone https://github.com/CenterForTheBuiltEnvironment/HHW_brick.git\ncd HHW_brick\npip install -e .\n</code></pre> <p>Requirements: Python 3.8 or higher</p> <p>\ud83d\udcd8 Detailed Installation Guide \u2192</p>"},{"location":"#quick-start-example","title":"Quick Start Example","text":"<p>Convert, validate, and analyze a building in under 5 minutes:</p> <p>Sample Data: For input data format examples, see https://doi.org/10.5061/dryad.t4b8gtj8n or use test data in <code>tests/fixtures/</code></p>"},{"location":"#step-1-convert-csv-to-brick-model","title":"Step 1: Convert CSV to Brick Model","text":"<p>Transform your CSV data into a standardized Brick Schema RDF model with automatic system type detection and sensor mapping.</p> <pre><code>from pathlib import Path\nfrom hhw_brick import CSVToBrickConverter\n\n# Setup paths\nfixtures = Path(\"tests/fixtures\")\nmetadata_csv = fixtures / \"metadata.csv\"\nvars_csv = fixtures / \"vars_available_by_building.csv\"\n\n# Convert CSV to Brick model\nconverter = CSVToBrickConverter()\ngraph = converter.convert_to_brick(\n    metadata_csv=str(metadata_csv),\n    vars_csv=str(vars_csv),\n    building_tag=\"105\",\n    output_path=\"building_105.ttl\"\n)\nprint(f\"\u2713 Converted: {len(graph)} RDF triples\")\n</code></pre>"},{"location":"#step-2-validate-the-model","title":"Step 2: Validate the Model","text":"<p>Ensure your Brick model is correct through multi-level validation: ontology compliance (SHACL), point counts, and equipment counts.</p> <pre><code>from hhw_brick import BrickModelValidator\nfrom hhw_brick.validation import GroundTruthCalculator\n\n# 2a. Ontology validation (Brick Schema compliance)\nvalidator = BrickModelValidator(use_local_brick=True)\nresult = validator.validate_ontology(\"building_105.ttl\")\nprint(f\"\u2713 Ontology valid: {result['valid']}\")\n\n# 2b. Generate ground truth from CSV\ncalculator = GroundTruthCalculator()\ncalculator.calculate(\n    metadata_csv=str(metadata_csv),\n    vars_csv=str(vars_csv),\n    output_csv=\"ground_truth.csv\"\n)\n\n# 2c. Validate point counts\nvalidator = BrickModelValidator(ground_truth_csv_path=\"ground_truth.csv\")\npoint_result = validator.validate_point_count(\"building_105.ttl\")\nprint(f\"\u2713 Point count match: {point_result['match']}\")\n\n# 2d. Validate equipment counts\nequip_result = validator.validate_equipment_count(\"building_105.ttl\")\nprint(f\"\u2713 Equipment match: {equip_result.get('overall_success', False)}\")\n</code></pre>"},{"location":"#step-3-run-analytics-application","title":"Step 3: Run Analytics Application","text":"<p>Deploy portable analytics that automatically discover required sensors using SPARQL queries. Save configuration templates for easy customization.</p> <pre><code>from hhw_brick import apps\nimport yaml\n\n# Load application\napp = apps.load_app(\"secondary_loop_temp_diff\")\n\n# Check if building qualifies\nqualified = app.qualify(\"building_105.ttl\")\nif qualified:\n    # Get and save default config template\n    config = apps.get_default_config(\"secondary_loop_temp_diff\")\n\n    # Save config template for easy editing\n    with open(\"app_config.yaml\", \"w\") as f:\n        yaml.dump(config, f, default_flow_style=False, sort_keys=False)\n    print(\"\u2713 Config template saved: app_config.yaml\")\n\n    # Customize config (or edit the YAML file directly)\n    config[\"output\"][\"output_dir\"] = \"results/\"\n    config[\"output\"][\"generate_plots\"] = True\n\n    # Run analysis\n    results = app.analyze(\n        \"building_105.ttl\",\n        \"tests/fixtures/TimeSeriesData/105hhw_system_data.csv\",\n        config\n    )\n    print(f\"\u2713 Analysis complete! Results in: results/\")\n</code></pre> <p>That's it! From CSV to insights in 3 simple steps.</p> <p>\ud83d\udcd6 Full Tutorial \u2192</p>"},{"location":"#key-features","title":"Key Features","text":"\ud83d\udd04 Automated Conversion <p>Convert CSV data to Brick Schema 1.4 models with automatic system type detection and sensor mapping.</p> \ud83c\udfed 5 System Types <p>Support for condensing boilers, non-condensing boilers, generic boilers, district hot water, and district steam.</p> \u2705 Multi-Level Validation <p>Ontology (SHACL) + point counts + equipment counts + structural patterns ensure model quality.</p> \ud83d\udcca Portable Analytics <p>Applications use SPARQL to auto-discover sensors, working across any qualified building.</p> \u26a1 Batch Processing <p>Convert and validate 100+ buildings in parallel with progress tracking and error handling.</p> \ud83c\udfaf Ground Truth Validation <p>Independent validation using expected counts calculated directly from source CSV data.</p>"},{"location":"#documentation","title":"Documentation","text":"\ud83d\ude80 Getting Started <p>Installation guide, 5-minute quick start tutorial, understanding Brick Schema, and CSV data format requirements.</p> Read Guide \u2192 \ud83d\udd04 Conversion Guide <p>Single building conversion, batch processing, system type configuration, and sensor mapping customization.</p> Read Guide \u2192 \u2705 Validation Guide <p>Ontology validation, ground truth comparison, structural pattern matching, and batch validation workflows.</p> Read Guide \u2192 \ud83d\udcca Applications Guide <p>Application management, temperature difference analysis, running applications, and qualification checks.</p> Read Guide \u2192"},{"location":"#resources","title":"ResourcesReady to Get Started?","text":"\ud83d\udcd6 Documentation <p> Getting Started User Guide FAQ </p> \ud83d\udce6 Package Info <p> PyPI Package Changelog MIT License </p> \ud83d\udd27 Source Code <p> GitHub Repository View Examples Report Issues </p> <p> Transform your heating hot water system data into standardized Brick models </p> <p>      Get Started Now \u2192    </p> <p>Developed by Mingchen Li</p> <p>Making building heating hot water system data standardized and analyzable</p>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#changelog_1","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p>"},{"location":"changelog/#010-2025-11-02","title":"0.1.0 - 2025-11-02","text":""},{"location":"changelog/#initial-release","title":"\ud83c\udf89 Initial Release","text":"<p>First official release of HHW Brick, migrated from <code>hhws_brick_application</code>.</p>"},{"location":"changelog/#breaking-changes","title":"\ud83d\udd34 BREAKING CHANGES","text":""},{"location":"changelog/#package-rename","title":"Package Rename","text":"<ul> <li>Old: <code>hhws_brick_application</code></li> <li>New: <code>hhw_brick</code> (PyPI: <code>hhw-brick</code>)</li> </ul> <p>Migration: <pre><code># Before\nfrom hhws_brick_application.conversion import CSVToBrickConverter\n\n# After\nfrom hhw_brick import CSVToBrickConverter\n</code></pre></p>"},{"location":"changelog/#api-changes","title":"API Changes","text":"<ul> <li>Applications interface: <code>ApplicationManager</code> \u2192 <code>apps</code></li> <li>New CLI command: <code>hhw-brick</code></li> </ul>"},{"location":"changelog/#added","title":"\u2728 Added","text":""},{"location":"changelog/#core-features","title":"Core Features","text":"<ul> <li>CSV to Brick Conversion: Support for 5 hot water system types</li> <li>Validation Framework: 4-level validation (ontology, point count, equipment count, pattern)</li> <li>Ground Truth Calculator: Generate expected counts from CSV</li> <li>Batch Processing: Parallel conversion with multiprocessing</li> <li>Analytics Applications: Plugin-based apps framework with 2 built-in apps</li> <li>CLI Tool: <code>hhw-brick</code> command with convert, validate, deploy subcommands</li> <li>Utilities: SPARQL query helpers, data loading, file operations</li> </ul>"},{"location":"changelog/#testing","title":"Testing","text":"<ul> <li>110 test cases (95% pass rate)</li> <li>Test coverage: 40-45% overall</li> <li>pytest framework with fixtures</li> </ul>"},{"location":"changelog/#documentation","title":"Documentation","text":"<ul> <li>README with quick start</li> <li>MkDocs structure</li> <li>8 example scripts</li> <li>Contributing guide</li> </ul>"},{"location":"changelog/#changed","title":"\ud83d\udd04 Changed","text":"<ul> <li>Package structure reorganized</li> <li>All documentation translated to English</li> <li>Improved error messages and type hints</li> <li>Simplified public API</li> </ul>"},{"location":"changelog/#fixed","title":"\ud83d\udc1b Fixed","text":"<ul> <li>Package import paths (7 test files)</li> <li>Test API mismatches (60+ tests)</li> <li>UTF-8 BOM encoding in pyproject.toml</li> <li>Missing module exports</li> </ul>"},{"location":"changelog/#statistics","title":"\ud83d\udcca Statistics","text":"<ul> <li>Code: ~3,000+ lines</li> <li>Tests: 110 (53 passed, 3 skipped)</li> <li>Coverage: 40-45%</li> <li>Supported Systems: 5 hot water types</li> <li>Tested Buildings: 216 real buildings</li> </ul>"},{"location":"changelog/#upgrade-from-hhws_brick_application","title":"\ud83d\ude80 Upgrade from hhws_brick_application","text":"<pre><code># 1. Uninstall old package\npip uninstall hhws_brick_application\n\n# 2. Install new package\npip install hhw-brick\n\n# 3. Update imports\n# Replace hhws_brick_application with hhw_brick in all files\n\n# 4. Update application usage\nfrom hhw_brick import apps  # instead of ApplicationManager\n</code></pre>"},{"location":"changelog/#acknowledgments","title":"\ud83d\ude4f Acknowledgments","text":"<ul> <li>Original package: hhws_brick_application</li> <li>Author: Mingchen Li</li> <li>Built with: Brick Schema 1.4, RDF/OWL, SPARQL</li> </ul>"},{"location":"license/","title":"License","text":"<p>MIT License</p> <p>Copyright \u00a9 2025 Center for the Built Environment</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"api-reference/","title":"API Reference","text":"<p>Complete API documentation for HHW Brick Application.</p>"},{"location":"api-reference/#overview","title":"Overview","text":"<p>This section provides detailed documentation for all public APIs in the package.</p>"},{"location":"api-reference/#modules","title":"Modules","text":""},{"location":"api-reference/#conversion","title":"Conversion","text":"<p>Transform CSV data to Brick ontology models.</p> <ul> <li>CSVToBrickConverter - Main converter class</li> <li>BatchConverter - Batch processing</li> </ul>"},{"location":"api-reference/#validation","title":"Validation","text":"<p>Validate Brick models against schemas and ground truth.</p> <ul> <li>BrickModelValidator - Main validator</li> <li>SubgraphPatternValidator - Pattern matching</li> <li>GroundTruthCalculator - Ground truth comparison</li> </ul>"},{"location":"api-reference/#applications","title":"Applications","text":"<p>Analytics application framework.</p> <ul> <li>AppsManager - Application management</li> <li>BaseApp - Base application interface</li> </ul>"},{"location":"api-reference/#cli","title":"CLI","text":"<p>Command-line interface.</p> <ul> <li>Main CLI - Command-line entry points</li> </ul>"},{"location":"api-reference/#utils","title":"Utils","text":"<p>Utility functions and helpers.</p> <ul> <li>BrickQuery - Query Brick models</li> <li>ConfigLoader - Load configurations</li> </ul>"},{"location":"api-reference/#quick-reference","title":"Quick Reference","text":""},{"location":"api-reference/#import-statements","title":"Import Statements","text":"<pre><code># Main classes\nfrom hhw_brick import (\n    CSVToBrickConverter,\n    BatchConverter,\n    BrickModelValidator,\n    GroundTruthCalculator,\n    apps\n)\n\n# Utilities\nfrom hhw_brick.utils import (\n    BrickQuery,\n    ConfigLoader\n)\n\n# Validation\nfrom hhw_brick.validation import (\n    SubgraphPatternValidator\n)\n</code></pre>"},{"location":"api-reference/#common-methods","title":"Common Methods","text":""},{"location":"api-reference/#conversion_1","title":"Conversion","text":"<pre><code>converter = CSVToBrickConverter()\n\n# Convert single file\nconverter.convert_csv_to_brick(input_file, output_file)\n\n# Batch convert\nbatch = BatchConverter()\nbatch.convert_batch(input_dir, output_dir)\n</code></pre>"},{"location":"api-reference/#validation_1","title":"Validation","text":"<pre><code>validator = BrickModelValidator()\n\n# Validate model\nis_valid, report = validator.validate_model(model_path)\n\n# Check ontology\nis_valid, errors = validator.validate_ontology(model_path)\n</code></pre>"},{"location":"api-reference/#applications_1","title":"Applications","text":"<pre><code># List apps\navailable = apps.list_apps()\n\n# Load app\napp = apps.load_app(\"app_name\")\n\n# Qualify building\nqualified, details = app.qualify(brick_model)\n\n# Run analysis\nresults = app.analyze(brick_model, data, config)\n</code></pre>"},{"location":"api-reference/#type-hints","title":"Type Hints","text":"<p>All public APIs include type hints for better IDE support:</p> <pre><code>from typing import Dict, Tuple, Optional\nfrom rdflib import Graph\nimport pandas as pd\n\ndef qualify(brick_model: Graph) -&gt; Tuple[bool, Dict]:\n    ...\n\ndef analyze(\n    brick_model: Graph,\n    timeseries_data: pd.DataFrame,\n    config: Optional[Dict] = None\n) -&gt; Dict:\n    ...\n</code></pre>"},{"location":"api-reference/#return-values","title":"Return Values","text":""},{"location":"api-reference/#successfailure-pattern","title":"Success/Failure Pattern","text":"<p>Most methods return success status with details:</p> <pre><code># Pattern 1: Boolean + Details\nis_valid, report = validator.validate_model(path)\n# is_valid: bool\n# report: Dict[str, Any]\n\n# Pattern 2: Result Dictionary\nresult = {\n    \"success\": True,\n    \"data\": {...},\n    \"errors\": []\n}\n</code></pre>"},{"location":"api-reference/#error-handling","title":"Error Handling","text":"<p>APIs raise specific exceptions:</p> <pre><code>from hhw_brick.exceptions import (\n    ValidationError,\n    ConversionError,\n    ConfigurationError\n)\n</code></pre>"},{"location":"api-reference/#next-steps","title":"Next Steps","text":"<ul> <li>Browse module documentation in the sidebar</li> <li>Check Examples for practical usage</li> <li>Read User Guide for workflows</li> </ul> <p>Need details? Select a module from the navigation \u2192</p>"},{"location":"developer-guide/","title":"Developer Guide","text":"<p>Welcome to the HHW Brick Application Developer Guide! This guide is for developers who want to extend the package or contribute to its development.</p>"},{"location":"developer-guide/#overview","title":"Overview","text":"<p>This guide covers:</p>"},{"location":"developer-guide/#package-architecture","title":"Package Architecture","text":"<p>Understand the internal structure and design of the package.</p> <ul> <li>Core Modules - Overview of all modules</li> <li>Application Framework - How the app system works</li> <li>Design Patterns - Architectural decisions</li> </ul>"},{"location":"developer-guide/#developing-applications","title":"Developing Applications","text":"<p>Learn how to create your own analytics applications.</p> <ul> <li>Getting Started - Your first application</li> <li>Application Structure - Required components</li> <li>Qualify Function - Check building eligibility</li> <li>Analyze Function - Implement analysis logic</li> <li>Configuration - Handle app settings</li> <li>Testing - Test your application</li> <li>Best Practices - Tips and guidelines</li> </ul>"},{"location":"developer-guide/#contributing","title":"Contributing","text":"<p>Contribute to the HHW Brick Application project.</p> <ul> <li>Development Setup - Set up your environment</li> <li>Code Style - Coding standards</li> <li>Testing Guide - Write and run tests</li> <li>Documentation - Update docs</li> <li>Pull Requests - Submit changes</li> </ul>"},{"location":"developer-guide/#quick-start-for-developers","title":"Quick Start for Developers","text":""},{"location":"developer-guide/#create-your-first-application","title":"Create Your First Application","text":"<pre><code># my_app/__init__.py\n\"\"\"\nCustom Analytics Application\n\"\"\"\nfrom typing import Dict, Tuple\nimport pandas as pd\nfrom rdflib import Graph\n\n__all__ = ['qualify', 'analyze', 'load_config']\n\ndef qualify(brick_model: Graph) -&gt; Tuple[bool, Dict]:\n    \"\"\"Check if building has required sensors\"\"\"\n    # Implementation here\n    return True, {\"status\": \"qualified\"}\n\ndef analyze(brick_model: Graph,\n           timeseries_data: pd.DataFrame,\n           config: Dict) -&gt; Dict:\n    \"\"\"Run analysis on the building\"\"\"\n    # Implementation here\n    return {\"results\": \"analysis complete\"}\n\ndef load_config(config_path: str = None) -&gt; Dict:\n    \"\"\"Load application configuration\"\"\"\n    return {\"default\": \"config\"}\n</code></pre> <p>Learn more about developing apps \u2192</p>"},{"location":"developer-guide/#application-development-workflow","title":"Application Development Workflow","text":"<pre><code>graph TD\n    A[Define App Idea] --&gt; B[Create App Structure]\n    B --&gt; C[Implement qualify]\n    C --&gt; D[Implement analyze]\n    D --&gt; E[Add Configuration]\n    E --&gt; F[Write Tests]\n    F --&gt; G[Document App]\n    G --&gt; H{Tests Pass?}\n    H --&gt;|Yes| I[Deploy App]\n    H --&gt;|No| F\n\n    style A fill:#e1f5ff\n    style I fill:#c8e6c9</code></pre>"},{"location":"developer-guide/#package-structure","title":"Package Structure","text":"<pre><code>hhw_brick/\n\u251c\u2500\u2500 conversion/              # CSV to Brick conversion\n\u2502   \u251c\u2500\u2500 csv_to_brick.py\n\u2502   \u2514\u2500\u2500 batch_converter.py\n\u251c\u2500\u2500 validation/              # Model validation\n\u2502   \u251c\u2500\u2500 validator.py\n\u2502   \u2514\u2500\u2500 subgraph_matcher.py\n\u251c\u2500\u2500 applications/            # Analytics applications\n\u2502   \u251c\u2500\u2500 apps_manager.py     # Application framework\n\u2502   \u251c\u2500\u2500 secondary_loop_temp_diff/\n\u2502   \u2514\u2500\u2500 primary_loop_temp_diff/\n\u251c\u2500\u2500 cli/                     # Command-line interface\n\u2502   \u2514\u2500\u2500 main.py\n\u2514\u2500\u2500 utils/                   # Utility functions\n    \u251c\u2500\u2500 brick_query.py\n    \u2514\u2500\u2500 config_loader.py\n</code></pre> <p>Explore architecture \u2192</p>"},{"location":"developer-guide/#development-tools","title":"Development Tools","text":""},{"location":"developer-guide/#required-tools","title":"Required Tools","text":"<ul> <li>Python 3.8+</li> <li>Git - Version control</li> <li>pytest - Testing framework</li> <li>black - Code formatting</li> <li>mypy - Type checking</li> </ul>"},{"location":"developer-guide/#recommended-tools","title":"Recommended Tools","text":"<ul> <li>VS Code or PyCharm - IDE</li> <li>pytest-cov - Coverage reporting</li> <li>pre-commit - Git hooks</li> </ul> <p>Setup guide \u2192</p>"},{"location":"developer-guide/#api-design-principles","title":"API Design Principles","text":""},{"location":"developer-guide/#consistency","title":"Consistency","text":"<p>All applications follow the same interface:</p> <pre><code>__all__ = ['qualify', 'analyze', 'load_config']\n\ndef qualify(brick_model: Graph) -&gt; Tuple[bool, Dict]:\n    \"\"\"Standard signature for all apps\"\"\"\n    pass\n\ndef analyze(brick_model: Graph,\n           timeseries_data: pd.DataFrame,\n           config: Dict) -&gt; Dict:\n    \"\"\"Standard signature for all apps\"\"\"\n    pass\n</code></pre>"},{"location":"developer-guide/#modularity","title":"Modularity","text":"<p>Each component is self-contained and can be used independently:</p> <pre><code># Use conversion alone\nfrom hhw_brick import CSVToBrickConverter\n\n# Use validation alone\nfrom hhw_brick import BrickModelValidator\n\n# Use apps alone\nfrom hhw_brick import apps\n</code></pre>"},{"location":"developer-guide/#extensibility","title":"Extensibility","text":"<p>The application framework allows easy addition of new analytics:</p> <pre><code># Your custom app is automatically discovered\nfrom hhw_brick import apps\n\n# Just place it in applications/ directory\napps.list_apps()  # Will include your app\n</code></pre>"},{"location":"developer-guide/#quick-navigation","title":"Quick Navigation","text":"<ul> <li> <p>:material-architecture: Architecture</p> <p>Understand the package design</p> </li> <li> <p> Build Apps</p> <p>Create analytics applications</p> </li> <li> <p> Contribute</p> <p>Join the development</p> </li> <li> <p> API Reference</p> <p>Detailed API docs</p> </li> </ul>"},{"location":"developer-guide/#resources","title":"Resources","text":"<ul> <li>Source Code: GitHub Repository</li> <li>Issue Tracker: GitHub Issues</li> <li>PyPI Package: hhw-brick</li> </ul> <p>Ready to build? Start with Package Architecture or jump to Developing Applications \u2192</p>"},{"location":"developer-guide/#getting-started","title":"Getting Started","text":"<p>Welcome to HHW Brick Application! This guide will help you get up and running quickly.</p>"},{"location":"developer-guide/#what-youll-learn","title":"What You'll Learn","text":"<p>In this section, you'll learn:</p> <ul> <li>How to install the package</li> <li>How to perform your first conversion</li> <li>Understanding core concepts of the package</li> </ul>"},{"location":"developer-guide/#prerequisites","title":"Prerequisites","text":"<p>Before you begin, make sure you have:</p> <ul> <li>Python 3.8 or higher installed</li> <li>Basic knowledge of Python programming</li> <li>Familiarity with CSV files (optional but helpful)</li> <li>Understanding of building systems (optional but helpful)</li> </ul>"},{"location":"developer-guide/#installation-overview","title":"Installation Overview","text":"<p>The easiest way to install HHW Brick Application is using pip:</p> <pre><code>pip install hhw-brick\n</code></pre> <p>For detailed installation instructions, including development setup, see the Installation Guide.</p>"},{"location":"developer-guide/#quick-example","title":"Quick Example","text":"<p>Here's a simple example to get you started:</p> <pre><code>from hhw_brick import CSVToBrickConverter\n\n# Create a converter\nconverter = CSVToBrickConverter()\n\n# Convert CSV to Brick\nconverter.convert_csv_to_brick(\n    input_file=\"your_building.csv\",\n    output_file=\"your_building.ttl\"\n)\n</code></pre>"},{"location":"developer-guide/#next-steps","title":"Next Steps","text":"<p>Ready to dive in? Choose your path:</p> <ul> <li> <p> Install the Package</p> <p>Get HHW Brick Application installed on your system</p> </li> <li> <p> Quick Start Guide</p> <p>Follow a step-by-step tutorial</p> </li> <li> <p> Learn Core Concepts</p> <p>Understand the fundamentals</p> </li> <li> <p> Explore User Guide</p> <p>Dive deeper into features</p> </li> </ul>"},{"location":"developer-guide/#need-help","title":"Need Help?","text":"<ul> <li>Check the FAQ for common questions</li> <li>Browse Examples for code samples</li> <li>Visit our GitHub repository for issues and discussions</li> </ul> <p>Let's get started! Head over to the Installation Guide \u2192</p>"},{"location":"examples/","title":"Examples","text":"<p>Practical code examples for using HHW Brick Application.</p>"},{"location":"examples/#overview","title":"Overview","text":"<p>This section contains working code examples demonstrating how to use the HHW Brick Application package. All examples use test data from <code>tests/fixtures/</code> to ensure they work out of the box.</p>"},{"location":"examples/#available-examples","title":"Available Examples","text":""},{"location":"examples/#getting-started","title":"Getting Started","text":"<ul> <li>Installation and Setup - Quick Start Guide</li> <li>First Conversion - Convert your first building to Brick format</li> </ul>"},{"location":"examples/#conversion-examples","title":"Conversion Examples","text":"<ul> <li>Single Building Conversion - Convert one building at a time</li> <li>Batch Conversion - Convert multiple buildings at once</li> <li>Custom Sensor Mapping - Customize sensor mappings</li> </ul>"},{"location":"examples/#validation-examples","title":"Validation Examples","text":"<ul> <li>Ontology Validation - Validate Brick schema compliance</li> <li>Ground Truth Validation - Check point and equipment counts</li> <li>Pattern Validation - Verify system topology</li> </ul>"},{"location":"examples/#application-examples","title":"Application Examples","text":"<ul> <li>Apps Manager - Discover and manage apps</li> <li>Secondary Loop Analysis - Temperature difference analysis</li> <li>Running Apps - Complete application workflow</li> </ul>"},{"location":"examples/#example-code-repository","title":"Example Code Repository","text":"<p>The package includes complete example scripts in the <code>examples/</code> directory:</p> <pre><code>examples/\n\u251c\u2500\u2500 01_convert_csv_to_brick.py\n\u251c\u2500\u2500 02_ontology_validation.py\n\u251c\u2500\u2500 03_point_count_validation.py\n\u251c\u2500\u2500 04_equipment_count_validation.py\n\u251c\u2500\u2500 05_subgraph_pattern_matching.py\n\u251c\u2500\u2500 06_application_management.py\n\u251c\u2500\u2500 07_run_application.py\n\u251c\u2500\u2500 08_batch_run_application.py\n\u2514\u2500\u2500 README.md\n</code></pre>"},{"location":"examples/#running-examples","title":"Running Examples","text":"<p>All examples can be run directly from the package installation:</p> <pre><code>cd path/to/hhw-brick\npython examples/01_convert_csv_to_brick.py\n</code></pre>"},{"location":"examples/#common-workflows","title":"Common Workflows","text":""},{"location":"examples/#complete-end-to-end-workflow","title":"Complete End-to-End Workflow","text":"<pre><code>\"\"\"\nComplete workflow: Convert \u2192 Validate \u2192 Analyze\n\"\"\"\nfrom hhw_brick import (\n    CSVToBrickConverter,\n    BrickModelValidator,\n    apps\n)\n\n# Step 1: Convert\nconverter = CSVToBrickConverter()\nconverter.convert_to_brick(\n    metadata_csv=\"metadata.csv\",\n    vars_csv=\"vars.csv\",\n    building_tag=\"105\",\n    output_path=\"building_105.ttl\"\n)\n\n# Step 2: Validate\nvalidator = BrickModelValidator(use_local_brick=True)\nis_valid = validator.validate_ontology(\"building_105.ttl\")['valid']\n\nif is_valid:\n    # Step 3: Analyze\n    app = apps.load_app(\"secondary_loop_temp_diff\")\n    qualified, details = app.qualify(\"building_105.ttl\")\n\n    if qualified:\n        config = apps.get_default_config(\"secondary_loop_temp_diff\")\n        results = app.analyze(\n            \"building_105.ttl\",\n            \"105_data.csv\",\n            config\n        )\n        print(f\"Analysis complete: {results['summary']}\")\n</code></pre>"},{"location":"examples/#interactive-tutorials","title":"Interactive Tutorials","text":"<p>For step-by-step learning, see:</p> <ul> <li>Quick Start Tutorial</li> <li>Conversion Guide</li> <li>Validation Guide</li> <li>Applications Guide</li> </ul>"},{"location":"examples/#need-help","title":"Need Help?","text":"<ul> <li>Check the FAQ for common questions</li> <li>Browse the User Guide for detailed documentation</li> <li>Visit the GitHub repository for issues and discussions</li> </ul>"},{"location":"getting-started/","title":"Getting Started","text":"<p>Welcome to HHW Brick! This comprehensive guide will take you from installation to running your first portable analytics application on heating hot water system data.</p>"},{"location":"getting-started/#what-youll-learn","title":"What You'll Learn","text":"<p>In this Getting Started section, you'll master:</p> <ol> <li>Installation - Set up the hhw_brick package on your system</li> <li>Understanding Brick Schema - Learn the semantic ontology powering interoperability</li> <li>CSV Data Format - Prepare your data files with proper structure</li> <li>Quick Start - Complete workflow: Convert \u2192 Validate \u2192 Analyze in 10 minutes</li> </ol> <p>By the end of this guide, you'll be able to:</p> <ul> <li>\u2705 Convert CSV building data to standardized Brick Schema models</li> <li>\u2705 Validate models for correctness and completeness</li> <li>\u2705 Run analytics applications without writing building-specific code</li> <li>\u2705 Process multiple buildings in parallel with batch operations</li> </ul>"},{"location":"getting-started/#what-is-hhw-brick","title":"What is HHW Brick?","text":"<p>HHW Brick (<code>hhw_brick</code>) is a Python toolkit for converting, validating, and analyzing heating hot water system data using the Brick Schema semantic standard.</p>"},{"location":"getting-started/#the-problem-data-chaos","title":"The Problem: Data Chaos","text":"<pre><code>graph TB\n    subgraph \"Building A\"\n        A1[HW_Supply_Temp]\n        A2[HW_Return_Temp]\n        A3[HW_Flow_Rate]\n    end\n\n    subgraph \"Building B\"\n        B1[SupplyTempHotWater]\n        B2[ReturnTemp_HW]\n        B3[FlowRateHW]\n    end\n\n    subgraph \"Building C\"\n        C1[HWST_01]\n        C2[HWRT_01]\n        C3[HWF_01]\n    end\n\n    style A1 fill:#ffcdd2\n    style A2 fill:#ffcdd2\n    style A3 fill:#ffcdd2\n    style B1 fill:#ffcdd2\n    style B2 fill:#ffcdd2\n    style B3 fill:#ffcdd2\n    style C1 fill:#ffcdd2\n    style C2 fill:#ffcdd2\n    style C3 fill:#ffcdd2</code></pre> <p>Different names for the same sensors \u2192 Impossible to write reusable analytics!</p>"},{"location":"getting-started/#our-solution-semantic-standardization","title":"Our Solution: Semantic Standardization","text":"<pre><code>graph TB\n    subgraph \"Building A\"\n        A1[HW_Supply_Temp]\n        A2[HW_Return_Temp]\n    end\n\n    subgraph \"Building B\"\n        B1[SupplyTempHotWater]\n        B2[ReturnTemp_HW]\n    end\n\n    subgraph \"Building C\"\n        C1[HWST_01]\n        C2[HWRT_01]\n    end\n\n    A1 --&gt;|Convert| S1[brick:Hot_Water_Supply_Temperature_Sensor]\n    B1 --&gt;|Convert| S1\n    C1 --&gt;|Convert| S1\n\n    A2 --&gt;|Convert| S2[brick:Hot_Water_Return_Temperature_Sensor]\n    B2 --&gt;|Convert| S2\n    C2 --&gt;|Convert| S2\n\n    S1 --&gt; App[Portable Analytics]\n    S2 --&gt; App\n\n    style S1 fill:#c8e6c9\n    style S2 fill:#c8e6c9\n    style App fill:#90caf9</code></pre> <p>Same semantic meaning \u2192 Write analytics once, run everywhere!</p>"},{"location":"getting-started/#core-capabilities","title":"Core Capabilities","text":"<p>HHW Brick (<code>hhw_brick</code>) is a Python package that provides three integrated capabilities:</p>"},{"location":"getting-started/#conversion","title":"\ud83d\udd04 Conversion","text":"<p>Transform heating hot water system equipment data from CSV format into standardized Brick Schema 1.4 RDF models.</p> <ul> <li>5 System Types Supported: Condensing boilers, non-condensing boilers, generic boilers, district hot water, district steam</li> <li>Automatic Detection: System type identification and sensor mapping</li> <li>Batch Processing: Convert hundreds of buildings in parallel</li> <li>Flexible Input: Works with varying CSV structures and sensor availability</li> <li>Test Data: We provide test data in <code>tests/fixtures/</code> to get you started</li> </ul>"},{"location":"getting-started/#validation","title":"\u2705 Validation","text":"<p>Ensure your Brick models are correct through comprehensive multi-level validation.</p> <ul> <li>Ontology Validation: SHACL-based compliance with Brick Schema 1.4</li> <li>Point Count Validation: Verify all sensors were converted correctly</li> <li>Equipment Count Validation: Validate boilers, pumps, and weather stations</li> <li>Structural Validation: Pattern matching for system topology</li> <li>Ground Truth Comparison: Independent validation against source CSV data</li> </ul>"},{"location":"getting-started/#portable-analytics","title":"\ud83d\udcca Portable Analytics","text":"<p>Run analytics applications that work across any qualified building without recoding.</p> <ul> <li>Auto-Discovery: SPARQL queries find required sensors automatically</li> <li>Building-Agnostic: No hardcoded point names or building IDs</li> <li>Qualification Checks: Automatically verify buildings have required equipment</li> <li>Pre-Built Apps: Temperature difference analysis for primary/secondary loops</li> <li>Extensible Framework: Build your own portable applications</li> </ul>"},{"location":"getting-started/#prerequisites","title":"Prerequisites","text":"<p>Before you begin, ensure you have:</p> <ul> <li>Python 3.8 or higher installed on your system</li> <li>Basic Python knowledge - understanding of variables, functions, and imports</li> <li>Git installed for cloning the repository</li> <li>CSV data files with building equipment metadata and sensor availability</li> <li>We provide test data in <code>tests/fixtures/</code> to get you started</li> <li>Or download sample data from https://doi.org/10.5061/dryad.t4b8gtj8n</li> </ul> <p>Optional but Recommended:</p> <ul> <li>Virtual environment tool (venv or conda)</li> <li>Text editor or IDE (VS Code, PyCharm, etc.)</li> <li>Basic understanding of RDF/semantic web (helpful but not required)</li> </ul>"},{"location":"getting-started/#three-step-workflow","title":"Three-Step Workflow","text":"<p>HHW Brick follows a simple three-step workflow:</p> <pre><code>graph LR\n    A[CSV Files] --&gt;|1. Convert| B[Brick Model]\n    B --&gt;|2. Validate| C[Validated Model]\n    C --&gt;|3. Analyze| D[Insights]\n\n    style A fill:#e3f2fd\n    style B fill:#fff9c4\n    style C fill:#c8e6c9\n    style D fill:#f8bbd0</code></pre> <ol> <li>Convert - Transform CSV to Brick Schema</li> <li>Validate - Ensure model correctness</li> <li>Analyze - Deploy portable analytics</li> </ol>"},{"location":"getting-started/#package-architecture","title":"Package Architecture","text":"<pre><code>graph LR\n    subgraph Input\n        CSV[CSV Files]\n        TS[Timeseries Data]\n    end\n\n    subgraph \"HHW Brick Package\"\n        direction TB\n        CONV[\ud83d\udd04 Conversion Module]\n        VAL[\u2705 Validation Module]\n        APP[\ud83d\udcca Analytics Module]\n\n        CONV --&gt;|TTL Models| VAL\n        VAL --&gt;|Validated Models| APP\n    end\n\n    subgraph Output\n        TTL[Brick Models&lt;br/&gt;.ttl files]\n        REP[Validation Reports]\n        RES[Analysis Results]\n    end\n\n    CSV --&gt; CONV\n    CONV --&gt; TTL\n    VAL --&gt; REP\n    TS --&gt; APP\n    APP --&gt; RES\n\n    style CONV fill:#fff9c4\n    style VAL fill:#c8e6c9\n    style APP fill:#bbdefb\n    style TTL fill:#e1f5fe\n    style REP fill:#f0f4c3\n    style RES fill:#ffe0b2</code></pre>"},{"location":"getting-started/#package-components","title":"Package Components","text":"<p>The package consists of three main modules:</p>"},{"location":"getting-started/#1-conversion-module","title":"1. \ud83d\udd04 Conversion Module","text":"<p>Transform CSV data to Brick Schema models.</p> <p>Key Classes: <code>CSVToBrickConverter</code>, <code>BatchConverter</code></p> <p>Supported System Types:</p> <pre><code>graph LR\n    subgraph \"5 Supported System Types\"\n        C[\ud83d\udd25 Condensing&lt;br/&gt;Boiler]\n        NC[\ud83d\udd25 Non-Condensing&lt;br/&gt;Boiler]\n        G[\ud83d\udd25 Generic&lt;br/&gt;Boiler]\n        DH[\ud83c\udfe2 District&lt;br/&gt;Hot Water]\n        DS[\ud83d\udca8 District&lt;br/&gt;Steam]\n    end\n\n    style C fill:#ffccbc\n    style NC fill:#ffccbc\n    style G fill:#ffccbc\n    style DH fill:#b3e5fc\n    style DS fill:#b2dfdb</code></pre> <p>Capabilities:</p> <ul> <li>\u26a1 Single building conversion</li> <li>\ud83d\ude80 Batch conversion with parallel processing</li> <li>\ud83e\udd16 Automatic system type detection</li> <li>\ud83d\udccb Flexible CSV input handling</li> </ul> <p>\ud83d\udc49 Learn more in Quick Start</p>"},{"location":"getting-started/#2-validation-module","title":"2. \u2705 Validation Module","text":"<p>Ensure your Brick models are correct and complete.</p> <p>Key Classes: <code>BrickModelValidator</code>, <code>GroundTruthCalculator</code></p> <p>Multi-Level Validation Process:</p> <pre><code>graph TD\n    M[Brick Model] --&gt; V1[\ud83d\udccb Ontology Validation]\n    M --&gt; V2[\ud83d\udd22 Point Count Validation]\n    M --&gt; V3[\u2699\ufe0f Equipment Count Validation]\n    M --&gt; V4[\ud83d\udd0d Structural Validation]\n\n    V1 --&gt; R1{SHACL&lt;br/&gt;Conformance?}\n    V2 --&gt; R2{Counts&lt;br/&gt;Match?}\n    V3 --&gt; R3{Equipment&lt;br/&gt;Present?}\n    V4 --&gt; R4{Pattern&lt;br/&gt;Match?}\n\n    R1 --&gt;|\u2713| PASS[\u2705 Valid Model]\n    R2 --&gt;|\u2713| PASS\n    R3 --&gt;|\u2713| PASS\n    R4 --&gt;|\u2713| PASS\n\n    R1 --&gt;|\u2717| FAIL[\u26a0\ufe0f Issues Found]\n    R2 --&gt;|\u2717| FAIL\n    R3 --&gt;|\u2717| FAIL\n    R4 --&gt;|\u2717| FAIL\n\n    style M fill:#e3f2fd\n    style V1 fill:#fff9c4\n    style V2 fill:#fff9c4\n    style V3 fill:#fff9c4\n    style V4 fill:#fff9c4\n    style PASS fill:#c8e6c9\n    style FAIL fill:#ffcdd2</code></pre> <p>Validation Layers:</p> <ul> <li>\ud83d\udccb Ontology: SHACL-based Brick Schema 1.4 compliance</li> <li>\ud83d\udd22 Point Count: All sensors converted correctly</li> <li>\u2699\ufe0f Equipment Count: Boilers, pumps, weather stations validated</li> <li>\ud83d\udd0d Structural: System topology pattern matching</li> </ul> <p>\ud83d\udc49 Learn more in Validation Guide</p>"},{"location":"getting-started/#3-portable-analytics-module","title":"3. \ud83d\udcca Portable Analytics Module","text":"<p>Run analytics applications that work across any qualified building.</p> <p>Key Interface: <code>apps</code> manager</p> <p>Traditional vs. Portable Analytics:</p> <pre><code>graph TB\n    subgraph \"\u274c Traditional Approach\"\n        T1[Building A] --&gt;|Custom Code A| TA[Analytics A]\n        T2[Building B] --&gt;|Custom Code B| TB[Analytics B]\n        T3[Building C] --&gt;|Custom Code C| TC[Analytics C]\n    end\n\n    subgraph \"\u2705 Portable Approach\"\n        P1[Building A&lt;br/&gt;Brick Model] --&gt;|Same Code| PA[Portable&lt;br/&gt;Analytics]\n        P2[Building B&lt;br/&gt;Brick Model] --&gt;|Same Code| PA\n        P3[Building C&lt;br/&gt;Brick Model] --&gt;|Same Code| PA\n    end\n\n    style T1 fill:#ffcdd2\n    style T2 fill:#ffcdd2\n    style T3 fill:#ffcdd2\n    style TA fill:#ffcdd2\n    style TB fill:#ffcdd2\n    style TC fill:#ffcdd2\n\n    style P1 fill:#c8e6c9\n    style P2 fill:#c8e6c9\n    style P3 fill:#c8e6c9\n    style PA fill:#90caf9</code></pre> <p>How It Works:</p> <pre><code>graph LR\n    APP[Analytics App] --&gt;|1. SPARQL Query| BM[Brick Model]\n    BM --&gt;|2. Auto-Discover| SENS[Required&lt;br/&gt;Sensors]\n    SENS --&gt;|3. Qualify| CHECK{Has All&lt;br/&gt;Sensors?}\n    CHECK --&gt;|\u2713 Yes| RUN[4. Run Analysis]\n    CHECK --&gt;|\u2717 No| SKIP[Skip Building]\n\n    style APP fill:#90caf9\n    style BM fill:#fff9c4\n    style SENS fill:#ffe0b2\n    style RUN fill:#c8e6c9\n    style SKIP fill:#ffcdd2</code></pre> <p>Why Portable?</p> <ul> <li>\u2705 No hardcoded point names - SPARQL auto-discovers sensors</li> <li>\u2705 Building-agnostic - Same code on any qualified building</li> <li>\u2705 Auto-qualification - Checks requirements automatically</li> <li>\u2705 One-click deployment - No recoding needed</li> </ul> <p>Available Applications:</p> <ul> <li>\ud83c\udf21\ufe0f <code>secondary_loop_temp_diff</code> - Secondary loop \u0394T analysis</li> <li>\ud83d\udd25 <code>primary_loop_temp_diff</code> - Primary loop \u0394T analysis</li> </ul> <p>\ud83d\udc49 Learn more in Applications Guide</p>"},{"location":"getting-started/#next-steps","title":"Next Steps","text":"<p>Ready to get started? Follow this path:</p> <ol> <li>\ud83d\udce5 Install the Package - Set up hhw_brick on your system</li> <li>\ud83d\udcda Understanding Brick - Learn what Brick Schema is and why it matters</li> <li>\ud83d\udccb CSV Format Guide - Understand the required data structure</li> <li>\u26a1 Quick Start Guide - Complete workflow: Convert \u2192 Validate \u2192 Analyze</li> </ol>"},{"location":"getting-started/#need-help","title":"Need Help?","text":"<ul> <li>Check the FAQ for common questions</li> <li>See User Guide for detailed documentation</li> </ul> <p>Let's begin! Head over to Installation \u2192</p>"},{"location":"getting-started/csv-format/","title":"CSV Data Format","text":"<p>Understanding the CSV file format for converting to Brick models.</p>"},{"location":"getting-started/csv-format/#two-required-files","title":"Two Required Files","text":"<ol> <li>metadata.csv - Building information</li> <li>vars_available_by_building.csv - Sensor availability</li> </ol>"},{"location":"getting-started/csv-format/#metadatacsv","title":"metadata.csv","text":""},{"location":"getting-started/csv-format/#minimum-required","title":"Minimum Required","text":"<pre><code>tag,system,org\n105,Non-condensing,Organization A\n106,Condensing,Organization B\n107,District HW,Organization C\n</code></pre>"},{"location":"getting-started/csv-format/#real-world-example-with-optional-columns","title":"Real-World Example (with optional columns)","text":"<pre><code>tag,org,area,bldg_type,year,system,b_number,design_supply,design_return\n29,Z,13000,Other/EventSpace,1960,District HW,NA,NA,NA\n53,X,7700,Other/Museum,2020,Condensing,2,71.1,54.4\n105,H,46000,Office,1980,Non-condensing,3,87.8,NA\n127,M,26000,Other,2020,Condensing,2,60,37.8\n</code></pre>"},{"location":"getting-started/csv-format/#column-descriptions","title":"Column Descriptions","text":"<p>Required:</p> <ul> <li><code>tag</code> - Building ID (integer, unique)</li> <li><code>system</code> - System type (see below)</li> <li><code>org</code> - Organization name</li> </ul> <p>Optional but useful:</p> <ul> <li><code>area</code> - Building area (sq ft)</li> <li><code>bldg_type</code> - Building type (Office, Lab, etc.)</li> <li><code>year</code> - Year built</li> <li><code>b_number</code> - Number of boilers</li> <li><code>design_supply</code> - Design supply temperature (\u00b0C)</li> <li><code>design_return</code> - Design return temperature (\u00b0C)</li> </ul>"},{"location":"getting-started/csv-format/#system-types","title":"System Types","text":"<p>Must be one of these 5 types (case-insensitive):</p> System Type Description <code>Boiler</code> Generic boiler system <code>Non-condensing</code> Standard efficiency boiler <code>Condensing</code> High efficiency boiler <code>District HW</code> Campus hot water <code>District Steam</code> District steam"},{"location":"getting-started/csv-format/#vars_available_by_buildingcsv","title":"vars_available_by_building.csv","text":""},{"location":"getting-started/csv-format/#purpose","title":"Purpose","text":"<p>Shows which sensors each building has. - <code>1</code> = sensor exists - <code>0</code> or empty = no sensor</p>"},{"location":"getting-started/csv-format/#minimum-example","title":"Minimum Example","text":"<pre><code>tag,ret,sup,hw,flow,t_out\n105,1,1,1,1,1\n106,1,1,1,0,0\n107,1,1,0,0,1\n</code></pre>"},{"location":"getting-started/csv-format/#real-world-example-many-sensors","title":"Real-World Example (many sensors)","text":"<pre><code>tag,ret,sup,sup1,ret1,fire1,sup2,ret2,fire2,hw,flow,pmp1_pwr,pmp2_pwr,t_out,enab\n29,1,1,,,,,,,1,1,,,1,\n53,1,1,1,,,,,,1,1,,,1,1\n105,1,1,1,1,1,1,1,1,1,1,1,1,1,1\n</code></pre>"},{"location":"getting-started/csv-format/#common-sensor-columns","title":"Common Sensor Columns","text":"<p>Temperature:</p> <pre><code>sup, ret          # Primary supply/return\nsup1-4, ret1-4    # Individual boiler temps\n</code></pre> <p>Pumps:</p> <pre><code>pmp1_pwr, pmp1_spd, pmp1_vfd    # Pump 1\npmp2_pwr, pmp2_spd, pmp2_vfd    # Pump 2\n</code></pre> <p>Other:</p> <pre><code>hw          # Hot water sensor\nflow        # Flow rate\ndp          # Differential pressure\nfire1-4     # Boiler firing rates\nt_out       # Outdoor temperature\nenab        # Enable signal\n</code></pre> <p>You can have 5 columns or 50 columns - the converter automatically handles all available sensors!</p>"},{"location":"getting-started/csv-format/#quick-validation","title":"Quick Validation","text":"<pre><code>import pandas as pd\n\n# Load files\nmeta = pd.read_csv(\"metadata.csv\")\nvars_df = pd.read_csv(\"vars_available_by_building.csv\")\n\n# Check basics\nprint(\"Buildings in metadata:\", len(meta))\nprint(\"Buildings in vars:\", len(vars_df))\nprint(\"Tags match:\", set(meta['tag']) == set(vars_df['tag']))\nprint(\"Sensor types:\", len(vars_df.columns) - 1)\n</code></pre>"},{"location":"getting-started/csv-format/#common-issues-solutions","title":"Common Issues &amp; Solutions","text":""},{"location":"getting-started/csv-format/#issue-missing-required-column","title":"\u274c Issue: Missing required column","text":"<pre><code>tag,system\n105,Non-condensing\n# Missing 'org' column!\n</code></pre> <p>\u2705 Fix: Add the <code>org</code> column <pre><code>tag,system,org\n105,Non-condensing,Organization A\n</code></pre></p>"},{"location":"getting-started/csv-format/#issue-invalid-system-type","title":"\u274c Issue: Invalid system type","text":"<pre><code>tag,system,org\n105,InvalidType,Org A\n</code></pre> <p>\u2705 Fix: Use one of the 5 supported types <pre><code>tag,system,org\n105,Non-condensing,Org A\n</code></pre></p>"},{"location":"getting-started/csv-format/#issue-tags-dont-match","title":"\u274c Issue: Tags don't match","text":"<pre><code># metadata.csv: has building 105\n# vars.csv: has building 106\n</code></pre> <p>\u2705 Fix: Ensure tags match exactly in both files</p>"},{"location":"getting-started/csv-format/#next-steps","title":"Next Steps","text":"<p>Ready to convert? See:</p> <ul> <li>Quick Start - Convert your first building</li> <li>Conversion Guide - Detailed guide</li> <li>Sensor Mapping - Customize mappings</li> </ul>"},{"location":"getting-started/installation/","title":"Installation","text":"<p>Get hhw_brick installed and ready to use.</p>"},{"location":"getting-started/installation/#requirements","title":"Requirements","text":""},{"location":"getting-started/installation/#python-version","title":"Python Version","text":"<ul> <li>Python 3.8 or higher is required</li> <li>Python 3.10 is recommended for best performance</li> </ul> <p>Check your Python version:</p> <pre><code>python --version\n</code></pre>"},{"location":"getting-started/installation/#operating-systems","title":"Operating Systems","text":"<p>HHW Brick works on:</p> <ul> <li>\u2705 Windows 10/11</li> <li>\u2705 macOS 10.15+</li> <li>\u2705 Linux (Ubuntu 20.04+, Debian, CentOS, etc.)</li> </ul>"},{"location":"getting-started/installation/#installation-methods","title":"Installation Methods","text":""},{"location":"getting-started/installation/#method-1-install-from-source-recommended","title":"Method 1: Install from Source (Recommended)","text":"<p>Currently, the package is not yet published to PyPI. Install from source:</p> <pre><code># Clone the repository\ngit clone https://github.com/CenterForTheBuiltEnvironment/HHW_brick.git\ncd HHW_brick\n\n# Install in editable mode\npip install -e .\n</code></pre> <p>The <code>-e</code> flag installs in editable mode, so changes to the source code are immediately reflected.</p>"},{"location":"getting-started/installation/#method-2-install-from-pypi-coming-soon","title":"Method 2: Install from PyPI (Coming Soon)","text":"<p>Once published to PyPI, you'll be able to install with:</p> <pre><code>pip install hhw-brick\n</code></pre> <p>This installs the latest stable version.</p>"},{"location":"getting-started/installation/#verify-installation","title":"Verify Installation","text":"<p>Check that the package is installed correctly:</p> <pre><code>import hhw_brick\nprint(hhw_brick.__version__)\n</code></pre> <p>Expected output: <pre><code>0.1.0\n</code></pre></p> <p>Test the main components:</p> <pre><code>from hhw_brick import CSVToBrickConverter, BatchConverter, apps\n\nprint(\"\u2713 Conversion module loaded\")\nprint(f\"\u2713 Available apps: {len(apps.list_apps())} applications\")\n</code></pre>"},{"location":"getting-started/installation/#dependencies","title":"Dependencies","text":"<p>HHW Brick automatically installs these dependencies:</p>"},{"location":"getting-started/installation/#core-dependencies","title":"Core Dependencies","text":"Package Version Purpose rdflib \u22656.2.0, &lt;7.0.0 RDF graph processing pandas \u22651.3.0, &lt;3.0.0 Data manipulation pyyaml \u22655.4.0, &lt;7.0.0 Configuration files brickschema \u22650.6.0, &lt;0.7.0 Brick ontology support"},{"location":"getting-started/installation/#analytics-utilities","title":"Analytics &amp; Utilities","text":"Package Version Purpose tqdm \u22654.0.0 Progress bars jsonschema \u22654.0.0 JSON validation requests \u22652.28.0 HTTP requests matplotlib \u22653.5.0 Visualization seaborn \u22650.11.0 Statistical visualization <p>All dependencies are automatically installed when you run <code>pip install -e .</code></p>"},{"location":"getting-started/installation/#virtual-environment-recommended","title":"Virtual Environment (Recommended)","text":"<p>It's recommended to use a virtual environment to avoid dependency conflicts:</p>"},{"location":"getting-started/installation/#using-venv","title":"Using venv","text":"<pre><code># Create virtual environment\npython -m venv venv\n\n# Activate (Windows)\nvenv\\Scripts\\activate\n\n# Activate (Linux/Mac)\nsource venv/bin/activate\n\n# Clone and install package\ngit clone https://github.com/CenterForTheBuiltEnvironment/HHW_brick.git\ncd HHW_brick\npip install -e .\n</code></pre>"},{"location":"getting-started/installation/#using-conda","title":"Using conda","text":"<pre><code># Create environment\nconda create -n hhw_brick python=3.10\n\n# Activate\nconda activate hhw_brick\n\n# Clone and install package\ngit clone https://github.com/CenterForTheBuiltEnvironment/HHW_brick.git\ncd HHW_brick\npip install -e .\n</code></pre>"},{"location":"getting-started/installation/#troubleshooting","title":"Troubleshooting","text":""},{"location":"getting-started/installation/#issue-pip-command-not-found","title":"Issue: \"pip: command not found\"","text":"<p>Solution: Install pip or use <code>python -m pip</code> instead:</p> <pre><code>python -m pip install -e .\n</code></pre>"},{"location":"getting-started/installation/#issue-permission-denied","title":"Issue: \"Permission denied\"","text":"<p>Solution: Use a virtual environment (recommended) or add <code>--user</code> flag:</p> <pre><code>pip install --user -e .\n</code></pre>"},{"location":"getting-started/installation/#issue-git-not-installed","title":"Issue: Git not installed","text":"<p>Solution: Install Git first: - Windows: Download from git-scm.com - Mac: <code>brew install git</code> or install Xcode Command Line Tools - Linux: <code>sudo apt-get install git</code> (Ubuntu/Debian)</p>"},{"location":"getting-started/installation/#issue-dependency-conflicts","title":"Issue: Dependency conflicts","text":"<p>Solution: Install in a clean virtual environment:</p> <pre><code>python -m venv fresh_env\nfresh_env\\Scripts\\activate  # Windows\nsource fresh_env/bin/activate  # Linux/Mac\ncd HHW_brick\npip install -e .\n</code></pre>"},{"location":"getting-started/installation/#issue-import-errors-after-installation","title":"Issue: Import errors after installation","text":"<p>Solution: Verify the installation:</p> <pre><code>pip list | grep hhw-brick\n# Should show: hhw-brick  0.1.0  /path/to/HHW_brick\n</code></pre>"},{"location":"getting-started/installation/#development-installation","title":"Development Installation","text":"<p>For contributors and developers who want to modify the code:</p> <pre><code># Clone repository\ngit clone https://github.com/CenterForTheBuiltEnvironment/HHW_brick.git\ncd HHW_brick\n\n# Install development dependencies\npip install -r requirements-dev.txt\n\n# Install in editable mode\npip install -e .\n\n# Run tests to verify\npytest\n</code></pre> <p>Development dependencies include: - pytest - Testing framework - pytest-cov - Code coverage - black - Code formatter - flake8 - Linter - mkdocs - Documentation</p> <p>See Contributing Guide for more details on contributing to the project.</p>"},{"location":"getting-started/installation/#uninstallation","title":"Uninstallation","text":"<p>To remove the package:</p> <pre><code>pip uninstall hhw-brick\n</code></pre>"},{"location":"getting-started/installation/#next-steps","title":"Next Steps","text":"<p>Now that you have the package installed:</p> <ol> <li>Understanding Brick - Learn about Brick Schema ontology</li> <li>CSV Format - Prepare your data files</li> <li>Quick Start - Convert your first building (complete workflow)</li> </ol> <p>Installation complete! Continue to Understanding Brick \u2192</p>"},{"location":"getting-started/quick-start/","title":"Quick Start: Complete Workflow","text":"<p>This guide walks you through the complete HHW Brick workflow in 10 minutes:</p> <p>Convert CSV data \u2192 Validate Brick model \u2192 Analyze with portable analytics</p>"},{"location":"getting-started/quick-start/#what-youll-build","title":"What You'll Build","text":"<p>By the end of this guide, you'll have:</p> <ul> <li>\u2705 Converted a building from CSV to Brick Schema format</li> <li>\u2705 Validated the model for correctness and completeness</li> <li>\u2705 Run a portable analytics application on the building</li> <li>\u2705 Understood the complete workflow</li> </ul>"},{"location":"getting-started/quick-start/#step-1-install-the-package","title":"Step 1: Install the Package","text":"<p>If you haven't already, clone the repository and install in editable mode:</p> <pre><code># Clone the repository\ngit clone https://github.com/CenterForTheBuiltEnvironment/HHW_brick.git\ncd HHW_brick\n\n# Install in editable mode\npip install -e .\n</code></pre> <p>Note: Once published to PyPI, you'll be able to install with <code>pip install hhw-brick</code>.</p>"},{"location":"getting-started/quick-start/#step-2-prepare-your-data","title":"Step 2: Prepare Your Data","text":"<p>You need two types of CSV files for the complete workflow:</p>"},{"location":"getting-started/quick-start/#a-building-metadata-for-conversion","title":"A. Building Metadata (for conversion)","text":"<ol> <li>metadata.csv - Building information (system type, organization, etc.)</li> <li>vars_available_by_building.csv - Sensor/point availability for each building</li> </ol>"},{"location":"getting-started/quick-start/#b-timeseries-data-for-analytics","title":"B. Timeseries Data (for analytics)","text":"<ol> <li>[building]_timeseries.csv - Time-indexed sensor readings (used in Step 6)</li> </ol> <p>For this tutorial, we'll use the included test data for metadata (Steps 3-5).</p>"},{"location":"getting-started/quick-start/#download-test-data","title":"Download Test Data","text":"<p>The package includes test data in the repository:</p> <p>Download from GitHub \u2192</p> <p>You can find: - <code>metadata.csv</code> - Building metadata - <code>vars_available_by_building.csv</code> - Sensor availability data - <code>TimeSeriesData/*.csv</code> - Example timeseries data (for Step 6 analytics)</p> <p>Or if you've cloned the repository, they're located at:</p> <pre><code>tests/fixtures/metadata.csv\ntests/fixtures/vars_available_by_building.csv\ntests/fixtures/TimeSeriesData/building_105_timeseries.csv  (example)\n</code></pre> <p>Or create a simple example:</p> <pre><code>import pandas as pd\n\n# Create metadata.csv\nmetadata = pd.DataFrame({\n    'tag': [105],\n    'system': ['Non-condensing'],\n    'org': ['Organization A']\n})\nmetadata.to_csv('metadata.csv', index=False)\n\n# Create vars_available_by_building.csv  \nvars_data = pd.DataFrame({\n    'tag': [105],\n    'hw_supply_temp': [1],\n    'hw_return_temp': [1],\n    'hw_flow': [1]\n})\nvars_data.to_csv('vars_available_by_building.csv', index=False)\n</code></pre>"},{"location":"getting-started/quick-start/#step-3-convert-your-first-building","title":"Step 3: Convert Your First Building","text":"<p>Create a Python script (<code>my_first_conversion.py</code>):</p> <pre><code>from hhw_brick import CSVToBrickConverter\n\n# Create the converter\nconverter = CSVToBrickConverter()\n\n# Convert building #105\nresult = converter.convert_to_brick(\n    metadata_csv=\"metadata.csv\",\n    vars_csv=\"vars_available_by_building.csv\",\n    building_tag=\"105\",  # Building ID to convert\n    output_path=\"building_105.ttl\"\n)\n\nprint(f\"\u2713 Conversion complete!\")\nprint(f\"\u2713 Created {len(result)} RDF triples\")\nprint(f\"\u2713 Output: building_105.ttl\")\n</code></pre> <p>Run it:</p> <pre><code>python my_first_conversion.py\n</code></pre> <p>Expected output:</p> <pre><code>\u2713 Conversion complete!\n\u2713 Created 156 RDF triples\n\u2713 Output: building_105.ttl\n</code></pre>"},{"location":"getting-started/quick-start/#step-4-inspect-the-output","title":"Step 4: Inspect the Output","text":"<p>Your <code>building_105.ttl</code> file now contains a Brick model. Let's peek inside:</p> <pre><code>from rdflib import Graph\n\n# Load the Brick model\ng = Graph()\ng.parse(\"building_105.ttl\", format=\"turtle\")\n\n# Count elements\nprint(f\"Total statements: {len(g)}\")\n\n# Query for equipment\nquery = \"\"\"\nSELECT ?equip ?type WHERE {\n    ?equip a ?type .\n    FILTER(STRSTARTS(STR(?type), \"https://brickschema.org/schema/Brick#\"))\n}\n\"\"\"\nfor row in g.query(query):\n    print(f\"  - {row.equip.split('#')[-1]}: {row.type.split('#')[-1]}\")\n</code></pre>"},{"location":"getting-started/quick-start/#step-5-validate-the-model","title":"Step 5: Validate the Model","text":"<p>Ensure your model is correct and complete:</p> <pre><code>from hhw_brick import BrickModelValidator\n\n# Create validator\nvalidator = BrickModelValidator()\n\n# Validate the model\nis_valid, report = validator.validate_ontology(\"building_105.ttl\")\n\nif is_valid:\n    print(\"\u2713 Model passed ontology validation!\")\n    print(f\"  - {report['conformance']} conformance\")\n    print(f\"  - {report['violations']} violations\")\nelse:\n    print(\"\u26a0 Validation found issues:\")\n    for issue in report.get('violations', []):\n        print(f\"  - {issue}\")\n</code></pre> <p>Expected output:</p> <pre><code>\u2713 Model passed ontology validation!\n  - True conformance\n  - 0 violations\n</code></pre>"},{"location":"getting-started/quick-start/#step-6-run-portable-analytics","title":"Step 6: Run Portable Analytics","text":"<p>Now for the key advantage of Brick Schema - run analytics that work across any building!</p>"},{"location":"getting-started/quick-start/#discover-available-applications","title":"Discover Available Applications","text":"<pre><code>from hhw_brick import apps\n\n# List all available applications\navailable = apps.list_apps()\nprint(\"Available applications:\")\nfor app_info in available:\n    print(f\"  - {app_info['name']}: {app_info['description']}\")\n</code></pre> <p>Expected output:</p> <pre><code>Available applications:\n  - secondary_loop_temp_diff: Analyzes temperature difference in secondary loop\n  - primary_loop_temp_diff: Analyzes temperature difference in primary loop\n</code></pre>"},{"location":"getting-started/quick-start/#check-if-building-qualifies","title":"Check if Building Qualifies","text":"<pre><code># Load an application\napp = apps.load_app(\"secondary_loop_temp_diff\")\n\n# Check if building has required equipment\nqualified, details = app.qualify(\"building_105.ttl\")\n\nif qualified:\n    print(\"\u2713 Building qualifies for this analysis!\")\n    print(f\"  Required sensors: {details['required_sensors']}\")\n    print(f\"  Found sensors: {details['found_sensors']}\")\nelse:\n    print(\"\u2717 Building does not qualify\")\n    print(f\"  Missing: {details['missing']}\")\n</code></pre>"},{"location":"getting-started/quick-start/#prepare-timeseries-data","title":"Prepare Timeseries Data","text":"<p>To run analytics, you need timeseries data in CSV format with timestamps and sensor readings:</p> <p>Example timeseries CSV format:</p> <pre><code>timestamp,hw_supply_temp,hw_return_temp,hw_flow\n2023-01-01 00:00:00,180.5,160.2,350.0\n2023-01-01 00:15:00,181.0,160.8,352.5\n2023-01-01 00:30:00,180.8,160.5,351.2\n...\n</code></pre> <p>Requirements:</p> <ul> <li>First column: <code>timestamp</code> (datetime format)</li> <li>Remaining columns: Sensor names matching your CSV variable names</li> <li>Values: Numeric readings (\u00b0F, GPM, etc.)</li> </ul> <p>Download example timeseries data:</p> <p>Example Timeseries Data \u2192</p> <p>Or create a simple example:</p> <pre><code>import pandas as pd\nimport numpy as np\n\n# Create sample timeseries data\ndates = pd.date_range('2023-01-01', periods=1000, freq='15min')\ndf = pd.DataFrame({\n    'timestamp': dates,\n    'hw_supply_temp': np.random.normal(180, 5, 1000),\n    'hw_return_temp': np.random.normal(160, 5, 1000),\n    'hw_flow': np.random.normal(350, 20, 1000)\n})\ndf.to_csv('building_105_timeseries.csv', index=False)\n</code></pre>"},{"location":"getting-started/quick-start/#run-analysis","title":"Run Analysis","text":"<p>With timeseries data ready, run the complete analysis:</p> <pre><code># Get default configuration\nconfig = apps.get_default_config(\"secondary_loop_temp_diff\")\n\n# Customize configuration if needed\nconfig[\"analysis_period\"] = \"2023-01-01 to 2023-12-31\"\nconfig[\"output_directory\"] = \"results/\"\n\n# Run the analysis\nresults = app.analyze(\n    brick_model=\"building_105.ttl\",\n    timeseries_csv=\"building_105_timeseries.csv\",\n    config=config\n)\n\nprint(\"\u2713 Analysis complete!\")\nprint(f\"  - Temperature difference mean: {results['mean_temp_diff']:.2f}\u00b0F\")\nprint(f\"  - Anomalies detected: {results['anomaly_count']}\")\nprint(f\"  - Report saved to: {results['output_path']}\")\n</code></pre> <p>Expected output:</p> <pre><code>\u2713 Analysis complete!\n  - Temperature difference mean: 20.35\u00b0F\n  - Anomalies detected: 12\n  - Report saved to: results/building_105_analysis.html\n</code></pre> <p>Note: For detailed timeseries format requirements and advanced analysis options, see Applications Guide.</p>"},{"location":"getting-started/quick-start/#what-just-happened","title":"What Just Happened?","text":"<p>You completed the complete HHW Brick workflow:</p> <pre><code>graph LR\n    A[CSV Files] --&gt;|1. Convert| B[Brick Model]\n    B --&gt;|2. Validate| C[Validated Model]\n    C --&gt;|3. Qualify| D[Check Requirements]\n    D --&gt;|4. Analyze| E[Insights]\n\n    style A fill:#e1f5ff\n    style B fill:#fff9c4\n    style C fill:#c8e6c9\n    style D fill:#ffe0b2\n    style E fill:#f8bbd0</code></pre>"},{"location":"getting-started/quick-start/#step-by-step-breakdown","title":"Step-by-Step Breakdown","text":"<p>1. Conversion (CSV \u2192 Brick) - Read CSV files containing equipment metadata and sensor availability - Identified system type (e.g., \"Non-condensing boiler\") - Mapped CSV columns to Brick Schema classes and relationships - Generated RDF triples in Turtle format</p> <p>2. Validation (Quality Check) - Verified model conforms to Brick Schema 1.4 ontology - Checked point counts match source CSV data - Validated equipment relationships and structure</p> <p>3. Analytics (Portable Application) - Used SPARQL to auto-discover required sensors in the model - Checked if building has necessary equipment for analysis - Ready to run analytics without hardcoded point names</p> <p>Key Insight: You created a standardized, validated, analysis-ready building model!</p>"},{"location":"getting-started/quick-start/#why-this-matters","title":"Why This Matters","text":"<p>Traditional building analytics require manual recoding for each building:</p> <pre><code># \u274c Traditional approach - hardcoded point names\nsupply_temp = data[\"HW_Supply_Temp\"]  # Only works for this building!\nreturn_temp = data[\"HWReturnTemp\"]    # Different name in next building\n</code></pre> <p>With HHW Brick, analytics are portable:</p> <pre><code># \u2705 Brick approach - semantic queries\nquery = \"\"\"\nSELECT ?sensor WHERE {\n    ?sensor a brick:Hot_Water_Supply_Temperature_Sensor .\n}\n\"\"\"\n# Works on ANY building with Brick model!\n</code></pre> <p>Result: Write analytics once, deploy across hundreds of buildings.</p>"},{"location":"getting-started/quick-start/#next-steps","title":"Next Steps","text":"<p>Congratulations! You've completed the full workflow. Now dive deeper:</p>"},{"location":"getting-started/quick-start/#deepen-your-understanding","title":"\ud83d\udcda Deepen Your Understanding","text":"<ul> <li>Understanding Brick Schema - Learn the ontology concepts</li> <li>CSV Data Format - Master the input data structure</li> </ul>"},{"location":"getting-started/quick-start/#master-the-tools","title":"\ud83d\udd27 Master the Tools","text":"<ul> <li>Conversion Guide - Advanced conversion techniques</li> <li>Single building conversion with custom options</li> <li>Batch conversion for multiple buildings</li> <li> <p>Supported system types and configurations</p> </li> <li> <p>Validation Guide - Ensure model quality</p> </li> <li>Ontology conformance validation</li> <li>Point count validation</li> <li> <p>Equipment structure validation</p> </li> <li> <p>Applications Guide - Build portable analytics</p> </li> <li>Creating custom analytics apps</li> <li>Timeseries data format requirements</li> <li>Configuration and deployment</li> </ul>"},{"location":"getting-started/quick-start/#see-more-examples","title":"\ud83d\udca1 See More Examples","text":"<ul> <li>Example Scripts - Copy-paste ready code</li> <li><code>01_convert_csv_to_brick.py</code> - Basic conversion</li> <li><code>02_ontology_validation.py</code> - Validation examples</li> <li><code>06_application_management.py</code> - App discovery and loading</li> <li><code>07_run_application.py</code> - Running analytics</li> </ul>"},{"location":"getting-started/quick-start/#common-next-tasks","title":"Common Next Tasks","text":""},{"location":"getting-started/quick-start/#convert-multiple-buildings","title":"Convert Multiple Buildings","text":"<pre><code>from hhw_brick import BatchConverter\n\nbatch = BatchConverter()\nresults = batch.convert_all_buildings(\n    metadata_csv=\"metadata.csv\",\n    vars_csv=\"vars_available_by_building.csv\",\n    output_dir=\"brick_models/\",\n    show_progress=True\n)\n\nprint(f\"Converted {results['successful']} buildings\")\n</code></pre>"},{"location":"getting-started/quick-start/#filter-by-system-type","title":"Filter by System Type","text":"<pre><code># Convert only condensing systems\nresult = converter.convert_to_brick(\n    metadata_csv=\"metadata.csv\",\n    vars_csv=\"vars_available_by_building.csv\",\n    system_type=\"Condensing\",  # Filter\n    output_path=\"condensing_buildings.ttl\"\n)\n</code></pre>"},{"location":"getting-started/quick-start/#run-an-analytics-application","title":"Run an Analytics Application","text":"<pre><code>from hhw_brick import apps\n\n# Load temperature difference analysis app\napp = apps.load_app(\"secondary_loop_temp_diff\")\n\n# Check if building qualifies\nqualified, details = app.qualify(\"building_105.ttl\")\n\nif qualified:\n    # Run analysis (need timeseries data)\n    results = app.analyze(model, timeseries_data, config)\n</code></pre>"},{"location":"getting-started/quick-start/#troubleshooting","title":"Troubleshooting","text":""},{"location":"getting-started/quick-start/#error-filenotfounderror","title":"Error: \"FileNotFoundError\"","text":"<p>Make sure your CSV files exist:</p> <pre><code>import os\nprint(os.path.exists(\"metadata.csv\"))  # Should be True\n</code></pre>"},{"location":"getting-started/quick-start/#error-no-data-found-for-building-tag","title":"Error: \"No data found for building tag\"","text":"<p>Check that the building ID exists in your CSV:</p> <pre><code>import pandas as pd\ndf = pd.read_csv(\"metadata.csv\")\nprint(df['tag'].unique())  # List all building IDs\n</code></pre>"},{"location":"getting-started/quick-start/#warning-could-not-convert-value-to-float","title":"Warning: \"Could not convert value to float\"","text":"<p>Some sensor values might be missing (NA). This is normal and the converter handles it automatically.</p>"},{"location":"getting-started/quick-start/#complete-example-script","title":"Complete Example Script","text":"<p>Here's a complete end-to-end script you can copy and run:</p> <pre><code>\"\"\"\nHHW Brick - Complete Workflow Example\n\nThis script demonstrates the complete workflow:\n1. Convert CSV to Brick model\n2. Validate the model\n3. Check analytics qualification\n\"\"\"\n\nfrom hhw_brick import CSVToBrickConverter, BrickModelValidator, apps\nfrom pathlib import Path\n\ndef main():\n    print(\"=\" * 60)\n    print(\"HHW Brick - Complete Workflow\")\n    print(\"=\" * 60)\n\n    # Configuration\n    metadata_csv = \"metadata.csv\"\n    vars_csv = \"vars_available_by_building.csv\"\n    building_tag = \"105\"\n    output_file = f\"building_{building_tag}.ttl\"\n\n    # Step 1: Convert CSV to Brick\n    print(\"\\n[Step 1/3] Converting CSV to Brick Schema...\")\n    converter = CSVToBrickConverter()\n    graph = converter.convert_to_brick(\n        metadata_csv=metadata_csv,\n        vars_csv=vars_csv,\n        building_tag=building_tag,\n        output_path=output_file\n    )\n    print(f\"\u2713 Created {len(graph)} RDF triples\")\n    print(f\"\u2713 Saved to: {output_file}\")\n\n    # Step 2: Validate the model\n    print(\"\\n[Step 2/3] Validating Brick model...\")\n    validator = BrickModelValidator()\n    is_valid, report = validator.validate_ontology(output_file)\n\n    if is_valid:\n        print(\"\u2713 Model passed ontology validation!\")\n    else:\n        print(\"\u26a0 Validation issues found:\")\n        for issue in report.get('violations', [])[:3]:\n            print(f\"  - {issue}\")\n\n    # Step 3: Check analytics qualification\n    print(\"\\n[Step 3/3] Checking analytics qualification...\")\n\n    # Discover available apps\n    available_apps = apps.list_apps()\n    print(f\"Found {len(available_apps)} analytics applications\")\n\n    # Test qualification for each app\n    for app_info in available_apps:\n        app_name = app_info['name']\n        try:\n            app = apps.load_app(app_name)\n            qualified, details = app.qualify(output_file)\n\n            if qualified:\n                print(f\"  \u2713 {app_name}: QUALIFIED\")\n            else:\n                print(f\"  \u2717 {app_name}: Not qualified\")\n                if 'missing' in details:\n                    print(f\"    Missing: {', '.join(details['missing'][:3])}\")\n        except Exception as e:\n            print(f\"  ! {app_name}: Error - {e}\")\n\n    # Summary\n    print(\"\\n\" + \"=\" * 60)\n    print(\"Summary\")\n    print(\"=\" * 60)\n    print(f\"Input:  {metadata_csv}, {vars_csv}\")\n    print(f\"Output: {output_file} ({Path(output_file).stat().st_size / 1024:.1f} KB)\")\n    print(f\"Status: {'Valid' if is_valid else 'Has warnings'}\")\n    print(\"\\n\u2713 Complete workflow finished!\")\n    print(\"\\nNext: View the TTL file or run analytics with timeseries data\")\n\nif __name__ == \"__main__\":\n    main()\n</code></pre> <p>Run it:</p> <pre><code>python complete_workflow.py\n</code></pre> <p>Expected output:</p> <pre><code>============================================================\nHHW Brick - Complete Workflow\n============================================================\n\n[Step 1/3] Converting CSV to Brick Schema...\n\u2713 Created 156 RDF triples\n\u2713 Saved to: building_105.ttl\n\n[Step 2/3] Validating Brick model...\n\u2713 Model passed ontology validation!\n\n[Step 3/3] Checking analytics qualification...\nFound 2 analytics applications\n  \u2713 secondary_loop_temp_diff: QUALIFIED\n  \u2713 primary_loop_temp_diff: QUALIFIED\n\n============================================================\nSummary\n============================================================\nInput:  metadata.csv, vars_available_by_building.csv\nOutput: building_105.ttl (12.3 KB)\nStatus: Valid\n\n\u2713 Complete workflow finished!\n\nNext: View the TTL file or run analytics with timeseries data\n</code></pre> <p>\ud83c\udf89 Congratulations! You've completed the HHW Brick quick start and experienced the full workflow.</p> <p>What's Next?</p> <ul> <li>\ud83d\udcd6 Understanding Brick Schema - Learn the concepts</li> <li>\ud83d\udccb CSV Data Format - Master the input format  </li> <li>\ud83d\udd27 User Guide - Advanced features</li> <li>\ud83d\udcbb Example Scripts - More code samples</li> </ul>"},{"location":"getting-started/understanding-brick/","title":"Understanding Brick Schema","text":"<p>Learn what Brick Schema is, why it matters, and how it enables portable building analytics.</p>"},{"location":"getting-started/understanding-brick/#what-is-brick-schema","title":"What is Brick Schema?","text":"<p>Brick Schema is an open-source, standardized semantic vocabulary (ontology) for describing buildings, their equipment, and sensor systems. Think of it as a universal language that allows different building systems, analytics tools, and applications to understand each other.</p> <p>\ud83d\udd17 Official Website: https://brickschema.org/ \ud83d\udcda Documentation: https://docs.brickschema.org/ \ud83d\udcbb GitHub: https://github.com/BrickSchema/Brick</p>"},{"location":"getting-started/understanding-brick/#the-problem-building-data-chaos","title":"The Problem: Building Data Chaos","text":""},{"location":"getting-started/understanding-brick/#real-world-example","title":"Real-World Example","text":"<p>Imagine you want to analyze hot water supply temperature across 100 buildings. Each building uses different naming conventions:</p> <pre><code>graph TB\n    subgraph \"Building A - University Campus\"\n        A1[\"HW_Supply_Temp\"]\n        A2[\"HW_Return_Temp\"]\n        A3[\"HW_Flow_Rate\"]\n    end\n\n    subgraph \"Building B - Office Complex\"\n        B1[\"SupplyTempHotWater\"]\n        B2[\"ReturnTemp_HW\"]\n        B3[\"FlowRateHW_GPM\"]\n    end\n\n    subgraph \"Building C - Hospital\"\n        C1[\"HWST_01\"]\n        C2[\"HWRT_01\"]\n        C3[\"HWF_01_GPM\"]\n    end\n\n    subgraph \"Building D - Lab Facility\"\n        D1[\"Hot_Water_Supply_Temperature\"]\n        D2[\"Hot_Water_Return_Temperature\"]\n        D3[\"HW_Flow\"]\n    end\n\n    style A1 fill:#ffcdd2\n    style A2 fill:#ffcdd2\n    style A3 fill:#ffcdd2\n    style B1 fill:#ffcdd2\n    style B2 fill:#ffcdd2\n    style B3 fill:#ffcdd2\n    style C1 fill:#ffcdd2\n    style C2 fill:#ffcdd2\n    style C3 fill:#ffcdd2\n    style D1 fill:#ffcdd2\n    style D2 fill:#ffcdd2\n    style D3 fill:#ffcdd2</code></pre> <p>The Problem: - \ud83d\udd34 Same sensors, different names - Makes automation impossible - \ud83d\udd34 Manual recoding required - Analytics must be rewritten for each building - \ud83d\udd34 No semantic meaning - Software can't understand \"what is what\" - \ud83d\udd34 Scalability nightmare - 100 buildings = 100 custom implementations</p>"},{"location":"getting-started/understanding-brick/#the-solution-semantic-standardization-with-brick","title":"The Solution: Semantic Standardization with Brick","text":"<p>Brick Schema provides standardized class names with semantic meaning:</p> <pre><code>graph TB\n    subgraph \"Any Building - After Brick Conversion\"\n        direction TB\n        B[\ud83c\udfe2 Building]\n\n        E1[\u2699\ufe0f Boiler]\n        E2[\u2699\ufe0f Heat Exchanger]\n        E3[\u2699\ufe0f Pump]\n\n        P1[\ud83c\udf21\ufe0f brick:Hot_Water_Supply_Temperature_Sensor]\n        P2[\ud83c\udf21\ufe0f brick:Hot_Water_Return_Temperature_Sensor]\n        P3[\ud83d\udca7 brick:Water_Flow_Sensor]\n\n        B --&gt;|hasEquipment| E1\n        B --&gt;|hasEquipment| E2\n        B --&gt;|hasEquipment| E3\n\n        E1 --&gt;|hasPoint| P1\n        E1 --&gt;|hasPoint| P2\n        E2 --&gt;|hasPoint| P3\n    end\n\n    style B fill:#90caf9\n    style E1 fill:#fff9c4\n    style E2 fill:#fff9c4\n    style E3 fill:#fff9c4\n    style P1 fill:#c8e6c9\n    style P2 fill:#c8e6c9\n    style P3 fill:#c8e6c9</code></pre> <p>The Benefits: - \u2705 Same semantic classes - <code>brick:Hot_Water_Supply_Temperature_Sensor</code> everywhere - \u2705 Portable analytics - Write code once, run on any building - \u2705 Automatic discovery - Software knows what each sensor represents - \u2705 Scales effortlessly - 1 building or 1000 buildings, same code</p>"},{"location":"getting-started/understanding-brick/#how-brick-works-core-concepts","title":"How Brick Works: Core Concepts","text":""},{"location":"getting-started/understanding-brick/#1-classes-what-things-are","title":"1. Classes (What Things Are)","text":"<p>Brick defines standardized classes for building components:</p> <pre><code>graph TD\n    E[Equipment] --&gt; B[Boiler]\n    E --&gt; P[Pump]\n    E --&gt; HX[Heat_Exchanger]\n    E --&gt; V[Valve]\n\n    PT[Point] --&gt; TS[Temperature_Sensor]\n    PT --&gt; FS[Flow_Sensor]\n    PT --&gt; PS[Pressure_Sensor]\n    PT --&gt; CMD[Command]\n\n    TS --&gt; HWST[Hot_Water_Supply_Temperature_Sensor]\n    TS --&gt; HWRT[Hot_Water_Return_Temperature_Sensor]\n    FS --&gt; WFS[Water_Flow_Sensor]\n\n    style E fill:#ff9800\n    style PT fill:#2196f3\n    style HWST fill:#4caf50\n    style HWRT fill:#4caf50\n    style WFS fill:#4caf50</code></pre> <p>Example in RDF (Turtle format):</p> <pre><code>@prefix brick: &lt;https://brickschema.org/schema/Brick#&gt; .\n\n# Equipment instances\n:Boiler_01 a brick:Boiler .\n:Pump_Primary_01 a brick:Water_Pump .\n:HX_01 a brick:Heat_Exchanger .\n\n# Sensor instances\n:HW_Supply_Temp a brick:Hot_Water_Supply_Temperature_Sensor .\n:HW_Return_Temp a brick:Hot_Water_Return_Temperature_Sensor .\n:HW_Flow a brick:Water_Flow_Sensor .\n</code></pre>"},{"location":"getting-started/understanding-brick/#2-relationships-how-things-connect","title":"2. Relationships (How Things Connect)","text":"<p>Brick defines relationships between entities:</p> <pre><code>graph LR\n    B[Boiler] --&gt;|hasPoint| ST[Supply Temp Sensor]\n    B --&gt;|hasPoint| RT[Return Temp Sensor]\n    B --&gt;|feeds| HX[Heat Exchanger]\n    HX --&gt;|hasPoint| FST[Secondary Supply Temp]\n    HX --&gt;|feeds| SL[Secondary Loop]\n\n    P[Pump] --&gt;|isPartOf| B\n\n    style B fill:#ff9800\n    style HX fill:#2196f3\n    style SL fill:#4caf50\n    style ST fill:#fff9c4\n    style RT fill:#fff9c4\n    style FST fill:#fff9c4\n    style P fill:#e1bee7</code></pre> <p>Common Relationships:</p> Relationship Description Example <code>brick:hasPoint</code> Equipment has a sensor/actuator <code>Boiler hasPoint SupplyTempSensor</code> <code>brick:feeds</code> Flow direction (water, air, etc.) <code>Boiler feeds HeatExchanger</code> <code>brick:isPartOf</code> Component hierarchy <code>Pump isPartOf BoilerSystem</code> <code>brick:hasPart</code> Reverse of <code>isPartOf</code> <code>BoilerSystem hasPart Pump</code> <code>brick:hasLocation</code> Physical location <code>Sensor hasLocation Room_101</code> <p>Example in RDF:</p> <pre><code># Relationships\n:Boiler_01 brick:hasPoint :HW_Supply_Temp,\n                          :HW_Return_Temp ;\n           brick:feeds :HX_01 .\n\n:HX_01 brick:hasPoint :Secondary_Supply_Temp ;\n       brick:feeds :Secondary_Loop .\n\n:Pump_Primary_01 brick:isPartOf :Boiler_01 .\n</code></pre>"},{"location":"getting-started/understanding-brick/#3-properties-attributes-metadata","title":"3. Properties (Attributes &amp; Metadata)","text":"<p>Additional information about entities:</p> <pre><code>:Building_105 a brick:Building ;\n    brick:buildingPrimaryFunction \"Office\" ;\n    brick:hasAddress \"123 Main St, Berkeley, CA\" ;\n    brick:grossArea \"50000\"^^xsd:float .\n\n:Boiler_01 a brick:Boiler ;\n    brick:hasManufacturer \"Cleaver-Brooks\" ;\n    brick:hasModelNumber \"CB-500\" ;\n    brick:hasTag \"boiler\", \"primary\", \"hw\" .\n</code></pre>"},{"location":"getting-started/understanding-brick/#real-world-brick-model-example","title":"Real-World Brick Model Example","text":"<p>Here's an actual example of a Brick Schema model from the official Brick documentation, showing how a complete building system is represented:</p> <p> Figure: Official Brick Schema example showing equipment, sensors, and their relationships in a real building model</p> <p>What you see in this example:</p> <ul> <li>\ud83c\udfe2 Building structure - Hierarchical organization of spaces and equipment</li> <li>\u2699\ufe0f Equipment instances - AHUs, VAVs, boilers, pumps with specific IDs</li> <li>\ud83c\udf21\ufe0f Point instances - Temperature sensors, setpoints, commands</li> <li>\ud83d\udd17 Relationships - <code>hasPoint</code>, <code>feeds</code>, <code>isPartOf</code> connections</li> <li>\ud83d\udcca Semantic meaning - Each component has a standardized Brick class</li> </ul> <p>This is exactly the type of model that HHW Brick automatically generates from your CSV data, but focused on heating hot water systems instead of HVAC.</p>"},{"location":"getting-started/understanding-brick/#why-brick-matters-for-building-analytics","title":"Why Brick Matters for Building Analytics","text":""},{"location":"getting-started/understanding-brick/#traditional-approach","title":"Traditional Approach \u274c","text":"<pre><code>graph TB\n    subgraph \"Traditional Analytics - Manual Recoding\"\n        B1[Building A] --&gt; C1[Custom Code A]\n        B2[Building B] --&gt; C2[Custom Code B]\n        B3[Building C] --&gt; C3[Custom Code C]\n\n        C1 --&gt; A1[Analysis Results A]\n        C2 --&gt; A2[Analysis Results B]\n        C3 --&gt; A3[Analysis Results C]\n    end\n\n    style B1 fill:#ffcdd2\n    style B2 fill:#ffcdd2\n    style B3 fill:#ffcdd2\n    style C1 fill:#ffcdd2\n    style C2 fill:#ffcdd2\n    style C3 fill:#ffcdd2\n    style A1 fill:#ffcdd2\n    style A2 fill:#ffcdd2\n    style A3 fill:#ffcdd2</code></pre> <p>Problems: - \ud83d\udd34 Each building needs custom code - \ud83d\udd34 Point names hardcoded in analytics - \ud83d\udd34 Doesn't scale beyond a few buildings - \ud83d\udd34 High maintenance cost</p> <p>Example Code:</p> <pre><code># \u274c Traditional approach - hardcoded point names\ndef analyze_building_A(data):\n    supply = data[\"HW_Supply_Temp\"]  # Only works for Building A!\n    return_temp = data[\"HW_Return_Temp\"]\n    delta_t = supply - return_temp\n    return delta_t\n\ndef analyze_building_B(data):\n    supply = data[\"SupplyTempHotWater\"]  # Different name in Building B!\n    return_temp = data[\"ReturnTemp_HW\"]\n    delta_t = supply - return_temp\n    return delta_t\n\n# Need to write custom code for EACH building! \ud83d\ude31\n</code></pre>"},{"location":"getting-started/understanding-brick/#brick-approach","title":"Brick Approach \u2705","text":"<pre><code>graph TB\n    subgraph \"Brick-Based Analytics - Portable Code\"\n        BM1[Building A&lt;br/&gt;Brick Model] --&gt; PC[Portable&lt;br/&gt;Analytics Code]\n        BM2[Building B&lt;br/&gt;Brick Model] --&gt; PC\n        BM3[Building C&lt;br/&gt;Brick Model] --&gt; PC\n\n        PC --&gt; R[Universal Results]\n    end\n\n    style BM1 fill:#c8e6c9\n    style BM2 fill:#c8e6c9\n    style BM3 fill:#c8e6c9\n    style PC fill:#90caf9\n    style R fill:#fff9c4</code></pre> <p>Advantages: - \u2705 Same code works on ANY Brick-compliant building - \u2705 SPARQL queries auto-discover sensors - \u2705 Scales to thousands of buildings - \u2705 Low maintenance - write once, deploy everywhere</p> <p>Example Code:</p> <pre><code># \u2705 Brick approach - semantic queries\ndef analyze_any_brick_building(brick_model):\n    # SPARQL query finds sensors automatically\n    query = \"\"\"\n    PREFIX brick: &lt;https://brickschema.org/schema/Brick#&gt;\n\n    SELECT ?supply ?return WHERE {\n        ?supply a brick:Hot_Water_Supply_Temperature_Sensor .\n        ?return a brick:Hot_Water_Return_Temperature_Sensor .\n    }\n    \"\"\"\n\n    results = brick_model.query(query)\n    # Get sensor URIs, then fetch data\n    # Same code works on Building A, B, C... Z!\n    return analysis_results\n\n# Write once, run on 100+ buildings! \ud83c\udf89\n</code></pre>"},{"location":"getting-started/understanding-brick/#how-hhw-brick-uses-brick-schema","title":"How HHW Brick Uses Brick Schema","text":""},{"location":"getting-started/understanding-brick/#the-conversion-process","title":"The Conversion Process","text":"<p>HHW Brick automatically converts your CSV data into standardized Brick models:</p> <pre><code>graph LR\n    subgraph \"Input - CSV Files\"\n        CSV1[metadata.csv&lt;br/&gt;Building info]\n        CSV2[vars_available_by_building.csv&lt;br/&gt;Sensor availability]\n    end\n\n    subgraph \"HHW Brick Converter\"\n        direction TB\n        P1[Parse CSV]\n        P2[Detect System Type]\n        P3[Map to Brick Classes]\n        P4[Create Relationships]\n        P5[Generate RDF]\n\n        P1 --&gt; P2 --&gt; P3 --&gt; P4 --&gt; P5\n    end\n\n    subgraph \"Output - Brick Model\"\n        TTL[building_105.ttl&lt;br/&gt;Standardized Brick Model]\n    end\n\n    CSV1 --&gt; P1\n    CSV2 --&gt; P1\n    P5 --&gt; TTL\n\n    style CSV1 fill:#e3f2fd\n    style CSV2 fill:#e3f2fd\n    style P1 fill:#fff9c4\n    style P2 fill:#fff9c4\n    style P3 fill:#fff9c4\n    style P4 fill:#fff9c4\n    style P5 fill:#fff9c4\n    style TTL fill:#c8e6c9</code></pre>"},{"location":"getting-started/understanding-brick/#example-non-condensing-boiler-system","title":"Example: Non-Condensing Boiler System","text":"<p>Input CSV:</p> <pre><code># metadata.csv\ntag,system,org,area,bldg_type\n105,Non-condensing,Organization A,50000,Office\n\n# vars_available_by_building.csv\ntag,hw_supply_temp,hw_return_temp,hw_flow,pmp1_pwr,t_out\n105,1,1,1,1,1\n</code></pre> <p>Generated Brick Model:</p> <pre><code>graph TD\n    subgraph \"Building 105 - Brick Model\"\n        B[\ud83c\udfe2 Building_105&lt;br/&gt;brick:Building]\n\n        subgraph \"Equipment\"\n            BOIL[\u2699\ufe0f Boiler_Primary&lt;br/&gt;brick:Boiler]\n            HX[\u2699\ufe0f Heat_Exchanger&lt;br/&gt;brick:Heat_Exchanger]\n            PMP[\u2699\ufe0f Pump_Primary&lt;br/&gt;brick:Water_Pump]\n        end\n\n        subgraph \"Points\"\n            ST[\ud83c\udf21\ufe0f HW_Supply_Temp&lt;br/&gt;brick:Hot_Water_Supply_&lt;br/&gt;Temperature_Sensor]\n            RT[\ud83c\udf21\ufe0f HW_Return_Temp&lt;br/&gt;brick:Hot_Water_Return_&lt;br/&gt;Temperature_Sensor]\n            FL[\ud83d\udca7 HW_Flow&lt;br/&gt;brick:Water_Flow_Sensor]\n            PP[\u26a1 Pump_Power&lt;br/&gt;brick:Power_Sensor]\n            TO[\ud83c\udf24\ufe0f Outdoor_Temp&lt;br/&gt;brick:Outside_Air_&lt;br/&gt;Temperature_Sensor]\n        end\n\n        B --&gt;|hasEquipment| BOIL\n        B --&gt;|hasEquipment| HX\n        B --&gt;|hasEquipment| PMP\n\n        BOIL --&gt;|hasPoint| ST\n        BOIL --&gt;|hasPoint| RT\n        BOIL --&gt;|feeds| HX\n\n        HX --&gt;|hasPoint| FL\n\n        PMP --&gt;|hasPoint| PP\n        PMP --&gt;|isPartOf| BOIL\n\n        B --&gt;|hasPoint| TO\n    end\n\n    style B fill:#90caf9\n    style BOIL fill:#ff9800\n    style HX fill:#ff9800\n    style PMP fill:#ff9800\n    style ST fill:#c8e6c9\n    style RT fill:#c8e6c9\n    style FL fill:#c8e6c9\n    style PP fill:#c8e6c9\n    style TO fill:#c8e6c9</code></pre> <p>RDF (Turtle) Output:</p> <pre><code>@prefix brick: &lt;https://brickschema.org/schema/Brick#&gt; .\n@prefix rec: &lt;https://w3id.org/rec#&gt; .\n@prefix : &lt;http://example.org/building_105#&gt; .\n\n# Building\n:Building_105 a rec:Building ;\n    brick:hasLocation :Location_105 .\n\n# Equipment\n:Boiler_Primary a brick:Boiler ;\n    brick:hasPoint :HW_Supply_Temp_Sensor,\n                   :HW_Return_Temp_Sensor ;\n    brick:feeds :Heat_Exchanger .\n\n:Heat_Exchanger a brick:Heat_Exchanger ;\n    brick:hasPoint :HW_Flow_Sensor .\n\n:Pump_Primary a brick:Water_Pump ;\n    brick:hasPoint :Pump_Power_Sensor ;\n    brick:isPartOf :Boiler_Primary .\n\n# Points (Sensors)\n:HW_Supply_Temp_Sensor a brick:Hot_Water_Supply_Temperature_Sensor .\n:HW_Return_Temp_Sensor a brick:Hot_Water_Return_Temperature_Sensor .\n:HW_Flow_Sensor a brick:Water_Flow_Sensor .\n:Pump_Power_Sensor a brick:Power_Sensor .\n:Outdoor_Temp_Sensor a brick:Outside_Air_Temperature_Sensor .\n</code></pre>"},{"location":"getting-started/understanding-brick/#supported-system-types","title":"Supported System Types","text":"<p>HHW Brick supports 5 heating system types, each generating appropriate Brick models:</p>"},{"location":"getting-started/understanding-brick/#1-non-condensing-boiler","title":"1. Non-Condensing Boiler","text":"<pre><code>graph LR\n    B[\ud83d\udd25 Non-Condensing&lt;br/&gt;Boiler] --&gt;|feeds| HX[\ud83d\udd04 Heat&lt;br/&gt;Exchanger]\n    HX --&gt;|feeds| SL[\ud83d\udca7 Secondary&lt;br/&gt;Loop]\n\n    P1[\u26a1 Primary&lt;br/&gt;Pump] --&gt;|isPartOf| B\n    P2[\u26a1 Secondary&lt;br/&gt;Pump] --&gt;|isPartOf| SL\n\n    style B fill:#ff9800\n    style HX fill:#2196f3\n    style SL fill:#4caf50\n    style P1 fill:#e1bee7\n    style P2 fill:#e1bee7</code></pre> <p>Brick Classes: - <code>brick:Boiler</code> (non-condensing type) - <code>brick:Heat_Exchanger</code> - <code>brick:Water_Pump</code> (primary &amp; secondary) - Various temperature and flow sensors</p>"},{"location":"getting-started/understanding-brick/#2-condensing-boiler","title":"2. Condensing Boiler","text":"<pre><code>graph LR\n    B[\ud83d\udd25 Condensing&lt;br/&gt;Boiler&lt;br/&gt;High Efficiency] --&gt;|feeds| HX[\ud83d\udd04 Heat&lt;br/&gt;Exchanger]\n    HX --&gt;|feeds| SL[\ud83d\udca7 Secondary&lt;br/&gt;Loop]\n\n    style B fill:#4caf50\n    style HX fill:#2196f3\n    style SL fill:#4caf50</code></pre> <p>Brick Classes: - <code>brick:Boiler</code> (condensing type) - Same downstream equipment as non-condensing</p>"},{"location":"getting-started/understanding-brick/#3-generic-boiler","title":"3. Generic Boiler","text":"<pre><code>graph LR\n    B[\ud83d\udd25 Generic&lt;br/&gt;Boiler] --&gt;|feeds| HX[\ud83d\udd04 Heat&lt;br/&gt;Exchanger]\n\n    style B fill:#9e9e9e\n    style HX fill:#2196f3</code></pre> <p>Brick Classes: - <code>brick:Boiler</code> (generic type) - Flexible configuration</p>"},{"location":"getting-started/understanding-brick/#4-district-hot-water","title":"4. District Hot Water","text":"<pre><code>graph LR\n    DS[\ud83c\udfe2 District&lt;br/&gt;Supply] --&gt;|feeds| HX[\ud83d\udd04 Heat&lt;br/&gt;Exchanger]\n    HX --&gt;|feeds| BL[\ud83d\udca7 Building&lt;br/&gt;Loop]\n\n    M[\ud83d\udcca Meter] --&gt;|measures| DS\n\n    style DS fill:#9c27b0\n    style HX fill:#2196f3\n    style BL fill:#4caf50\n    style M fill:#ff9800</code></pre> <p>Brick Classes: - <code>brick:Heat_Exchanger</code> (district connection) - <code>brick:Water_Pump</code> (building side) - District-specific sensors</p>"},{"location":"getting-started/understanding-brick/#5-district-steam","title":"5. District Steam","text":"<pre><code>graph LR\n    DS[\ud83d\udca8 District&lt;br/&gt;Steam] --&gt;|feeds| HX[\ud83d\udd04 Heat&lt;br/&gt;Exchanger]\n    HX --&gt;|feeds| BL[\ud83d\udca7 Building&lt;br/&gt;HW Loop]\n\n    CT[\ud83e\uddca Condensate&lt;br/&gt;Return] --&gt;|returns| DS\n\n    style DS fill:#f44336\n    style HX fill:#2196f3\n    style BL fill:#4caf50\n    style CT fill:#00bcd4</code></pre> <p>Brick Classes: - <code>brick:Steam_System</code> - <code>brick:Heat_Exchanger</code> - Steam-specific points</p>"},{"location":"getting-started/understanding-brick/#querying-brick-models-with-sparql","title":"Querying Brick Models with SPARQL","text":"<p>Once you have a Brick model, you can query it using SPARQL (the standard RDF query language):</p>"},{"location":"getting-started/understanding-brick/#example-1-find-all-equipment","title":"Example 1: Find All Equipment","text":"<pre><code>from rdflib import Graph\n\n# Load Brick model\ng = Graph()\ng.parse(\"building_105.ttl\", format=\"turtle\")\n\n# SPARQL query\nquery = \"\"\"\nPREFIX brick: &lt;https://brickschema.org/schema/Brick#&gt;\n\nSELECT ?equipment ?type WHERE {\n    ?equipment a ?type .\n    FILTER(STRSTARTS(STR(?type), STR(brick:)))\n}\n\"\"\"\n\n# Execute query\nfor row in g.query(query):\n    print(f\"Found: {row.equipment} is a {row.type}\")\n</code></pre> <p>Output: <pre><code>Found: Boiler_Primary is a brick:Boiler\nFound: Heat_Exchanger is a brick:Heat_Exchanger\nFound: Pump_Primary is a brick:Water_Pump\n</code></pre></p>"},{"location":"getting-started/understanding-brick/#example-2-find-temperature-sensors","title":"Example 2: Find Temperature Sensors","text":"<pre><code>query = \"\"\"\nPREFIX brick: &lt;https://brickschema.org/schema/Brick#&gt;\n\nSELECT ?sensor WHERE {\n    ?sensor a brick:Temperature_Sensor .\n}\n\"\"\"\n\nfor row in g.query(query):\n    print(f\"Temperature sensor: {row.sensor}\")\n</code></pre>"},{"location":"getting-started/understanding-brick/#example-3-find-equipment-and-their-points","title":"Example 3: Find Equipment and Their Points","text":"<pre><code>query = \"\"\"\nPREFIX brick: &lt;https://brickschema.org/schema/Brick#&gt;\n\nSELECT ?equipment ?point WHERE {\n    ?equipment brick:hasPoint ?point .\n}\n\"\"\"\n\nfor row in g.query(query):\n    print(f\"{row.equipment} has point: {row.point}\")\n</code></pre>"},{"location":"getting-started/understanding-brick/#example-4-portable-analytics-temperature-difference","title":"Example 4: Portable Analytics - Temperature Difference","text":"<p>This is the key advantage - same query works on ANY building!</p> <pre><code>def calculate_loop_temperature_diff(brick_model_path):\n    \"\"\"\n    Calculate hot water loop \u0394T.\n    Works on ANY building with Brick model!\n    \"\"\"\n    g = Graph()\n    g.parse(brick_model_path)\n\n    # Auto-discover sensors\n    query = \"\"\"\n    PREFIX brick: &lt;https://brickschema.org/schema/Brick#&gt;\n\n    SELECT ?supply ?return WHERE {\n        ?supply a brick:Hot_Water_Supply_Temperature_Sensor .\n        ?return a brick:Hot_Water_Return_Temperature_Sensor .\n    }\n    \"\"\"\n\n    results = list(g.query(query))\n\n    if results:\n        supply_sensor = results[0].supply\n        return_sensor = results[0].return\n\n        # Now fetch timeseries data for these sensors\n        # and calculate \u0394T\n        print(f\"\u2713 Found supply sensor: {supply_sensor}\")\n        print(f\"\u2713 Found return sensor: {return_sensor}\")\n        return supply_sensor, return_sensor\n    else:\n        print(\"\u2717 Building missing required sensors\")\n        return None, None\n\n# Same code works on building_105, building_106, ... building_999!\ncalculate_loop_temperature_diff(\"building_105.ttl\")\n</code></pre>"},{"location":"getting-started/understanding-brick/#brick-schema-versions","title":"Brick Schema Versions","text":""},{"location":"getting-started/understanding-brick/#brick-13-used-by-hhw-brick","title":"Brick 1.3 (Used by HHW Brick)","text":"<p>HHW Brick uses Brick Schema 1.3, which includes:</p> <ul> <li>\u2705 Comprehensive HVAC equipment classes</li> <li>\u2705 Hot water system support</li> <li>\u2705 Improved relationship definitions</li> <li>\u2705 Better sensor taxonomies</li> </ul> <p>Import Declaration:</p> <pre><code>@prefix brick: &lt;https://brickschema.org/schema/Brick#&gt; .\n\n&lt;http://example.org/building_105&gt; a owl:Ontology ;\n    owl:imports &lt;https://brickschema.org/schema/1.3/Brick&gt; .\n</code></pre>"},{"location":"getting-started/understanding-brick/#future-brick-14","title":"Future: Brick 1.4+","text":"<p>Brick Schema continues to evolve with new classes and relationships.</p>"},{"location":"getting-started/understanding-brick/#key-advantages-for-hvac-analytics","title":"Key Advantages for HVAC Analytics","text":""},{"location":"getting-started/understanding-brick/#1-write-once-deploy-everywhere","title":"1. \u2705 Write Once, Deploy Everywhere","text":"<pre><code># Same analytics code works on 100+ buildings\ndef analyze_all_buildings(brick_models):\n    for model_path in brick_models:\n        # Same SPARQL query finds sensors automatically\n        results = run_analysis(model_path)\n        save_results(results)\n</code></pre>"},{"location":"getting-started/understanding-brick/#2-automatic-qualification","title":"2. \u2705 Automatic Qualification","text":"<p>Check if a building has required sensors before running analytics:</p> <pre><code>def check_qualification(brick_model):\n    \"\"\"\n    Check if building qualifies for analysis.\n    \"\"\"\n    required_classes = [\n        \"brick:Hot_Water_Supply_Temperature_Sensor\",\n        \"brick:Hot_Water_Return_Temperature_Sensor\",\n        \"brick:Water_Flow_Sensor\"\n    ]\n\n    g = Graph()\n    g.parse(brick_model)\n\n    for sensor_class in required_classes:\n        query = f\"\"\"\n        PREFIX brick: &lt;https://brickschema.org/schema/Brick#&gt;\n        ASK {{ ?sensor a {sensor_class} . }}\n        \"\"\"\n\n        if not g.query(query):\n            return False, f\"Missing {sensor_class}\"\n\n    return True, \"Building qualified for analysis\"\n</code></pre>"},{"location":"getting-started/understanding-brick/#3-relationship-traversal","title":"3. \u2705 Relationship Traversal","text":"<p>Follow system connections automatically:</p> <pre><code># Find all equipment downstream of the boiler\nquery = \"\"\"\nPREFIX brick: &lt;https://brickschema.org/schema/Brick#&gt;\n\nSELECT ?downstream WHERE {\n    :Boiler_Primary brick:feeds+ ?downstream .\n}\n\"\"\"\n# The '+' means \"one or more steps\" - follows the chain!\n</code></pre>"},{"location":"getting-started/understanding-brick/#4-metadata-integration","title":"4. \u2705 Metadata Integration","text":"<p>Combine equipment data with building metadata:</p> <pre><code>query = \"\"\"\nPREFIX brick: &lt;https://brickschema.org/schema/Brick#&gt;\nPREFIX rec: &lt;https://w3id.org/rec#&gt;\n\nSELECT ?building ?area ?sensor WHERE {\n    ?building a rec:Building ;\n              brick:grossArea ?area ;\n              brick:hasPoint ?sensor .\n    ?sensor a brick:Temperature_Sensor .\n}\n\"\"\"\n</code></pre>"},{"location":"getting-started/understanding-brick/#real-world-impact","title":"Real-World Impact","text":""},{"location":"getting-started/understanding-brick/#case-study-analyzing-100-buildings","title":"Case Study: Analyzing 100 Buildings","text":"<p>Without Brick (Traditional Approach): - \ud83d\udd34 Write custom code for each building's unique point names - \ud83d\udd34 Manually map 100 different naming schemes - \ud83d\udd34 Estimated time: 2-3 weeks - \ud83d\udd34 Maintenance nightmare when buildings change</p> <p>With Brick (HHW Brick Approach): - \u2705 Write analytics code ONCE using SPARQL - \u2705 Automatically discovers sensors in each building - \u2705 Estimated time: 1 day (after conversion) - \u2705 Code works on future buildings automatically</p> <p>Time Saved: ~90% reduction in development time!</p>"},{"location":"getting-started/understanding-brick/#data-interoperability-example","title":"Data Interoperability Example","text":"<pre><code>graph TB\n    subgraph \"Brick Ecosystem\"\n        BM[Brick Models&lt;br/&gt;from HHW Brick]\n\n        BM --&gt; T1[Tool A:&lt;br/&gt;Energy Analysis]\n        BM --&gt; T2[Tool B:&lt;br/&gt;Fault Detection]\n        BM --&gt; T3[Tool C:&lt;br/&gt;Optimization]\n        BM --&gt; T4[Tool D:&lt;br/&gt;Visualization]\n\n        T1 --&gt; R[Integrated&lt;br/&gt;Results]\n        T2 --&gt; R\n        T3 --&gt; R\n        T4 --&gt; R\n    end\n\n    style BM fill:#90caf9\n    style T1 fill:#fff9c4\n    style T2 fill:#fff9c4\n    style T3 fill:#fff9c4\n    style T4 fill:#fff9c4\n    style R fill:#c8e6c9</code></pre> <p>Benefit: Different tools can share the same Brick model without custom integrations!</p>"},{"location":"getting-started/understanding-brick/#learning-resources","title":"Learning Resources","text":""},{"location":"getting-started/understanding-brick/#official-brick-schema-resources","title":"Official Brick Schema Resources","text":"<ul> <li>\ud83c\udf10 Brick Schema Website - Official homepage</li> <li>\ud83d\udcd6 Brick Documentation - Comprehensive guides</li> <li>\ud83d\udd0d Brick Class Explorer - Browse all classes interactively</li> <li>\ud83d\udcbb Brick GitHub Repository - Source code and issues</li> <li>\ud83d\udcc4 Brick Research Paper - Academic publications</li> </ul>"},{"location":"getting-started/understanding-brick/#hhw-brick-specific-guides","title":"HHW Brick Specific Guides","text":"<ul> <li>\ud83d\udccb CSV Data Format - How to prepare your data</li> <li>\u26a1 Quick Start - Complete workflow tutorial</li> <li>\ud83d\udd27 Conversion Guide - Advanced conversion options</li> <li>\ud83d\udcca Applications Guide - Building portable analytics</li> </ul>"},{"location":"getting-started/understanding-brick/#recommended-tools","title":"Recommended Tools","text":"<ul> <li>brickschema Python library - Official Python library for Brick</li> <li>Brick Studio - Visual Brick model editor</li> <li>RDFLib - Python RDF processing (used by HHW Brick)</li> <li>Apache Jena - Java-based RDF toolkit</li> <li>SPARQL Tutorial - Learn SPARQL query language</li> </ul>"},{"location":"getting-started/understanding-brick/#community-support","title":"Community &amp; Support","text":"<ul> <li>\ud83d\udcac Brick Schema Forum - Google Group for discussions</li> <li>\ud83d\udc1b HHW Brick Issues - Report bugs or request features</li> <li>\ud83d\udce7 Contact: For questions about HHW Brick, open a GitHub issue</li> </ul>"},{"location":"getting-started/understanding-brick/#common-questions","title":"Common Questions","text":""},{"location":"getting-started/understanding-brick/#q-do-i-need-to-know-rdfowl-to-use-hhw-brick","title":"Q: Do I need to know RDF/OWL to use HHW Brick?","text":"<p>A: No! HHW Brick handles all the Brick Schema complexity for you. You only need to: 1. Prepare CSV files with your building data 2. Run the converter 3. Use the generated Brick models for analytics</p> <p>The converter automatically creates valid Brick models.</p>"},{"location":"getting-started/understanding-brick/#q-can-i-edit-the-generated-brick-models","title":"Q: Can I edit the generated Brick models?","text":"<p>A: Yes! The output <code>.ttl</code> files are standard RDF Turtle format. You can: - Edit them manually with a text editor - Use tools like Brick Studio for visual editing - Modify them programmatically with RDFLib</p>"},{"location":"getting-started/understanding-brick/#q-what-if-my-building-doesnt-fit-the-5-supported-system-types","title":"Q: What if my building doesn't fit the 5 supported system types?","text":"<p>A: You can: 1. Use \"Generic Boiler\" as a starting point 2. Manually edit the generated Brick model to add custom equipment 3. Request a new system type as a feature</p>"},{"location":"getting-started/understanding-brick/#q-how-do-i-validate-my-brick-model","title":"Q: How do I validate my Brick model?","text":"<p>A: HHW Brick includes built-in validation:</p> <pre><code>from hhw_brick import BrickModelValidator\n\nvalidator = BrickModelValidator()\nis_valid, report = validator.validate_ontology(\"building_105.ttl\")\n</code></pre> <p>This checks SHACL compliance with Brick Schema 1.3.</p>"},{"location":"getting-started/understanding-brick/#q-can-i-use-brick-models-with-other-software","title":"Q: Can I use Brick models with other software?","text":"<p>A: Absolutely! That's the whole point of standardization. Brick models are: - Standard RDF format (<code>.ttl</code>, <code>.jsonld</code>, <code>.xml</code>) - Compatible with any RDF-aware tool - Queryable with SPARQL from any language (Python, Java, JavaScript, etc.)</p>"},{"location":"getting-started/understanding-brick/#key-takeaways","title":"Key Takeaways","text":"<p>Core Concepts</p> <ul> <li>\ud83c\udfaf Brick is a standardized vocabulary for describing buildings</li> <li>\ud83d\udd04 Enables portable analytics - write code once, deploy everywhere</li> <li>\ud83d\udd0d SPARQL queries auto-discover required sensors</li> <li>\ud83c\udfd7\ufe0f Based on semantic web standards (RDF, OWL, SPARQL)</li> <li>\ud83d\udcca HHW Brick automates the conversion from CSV to Brick</li> </ul> <p>For HHW Brick Users</p> <ul> <li>\u2705 You don't need to know RDF/OWL/SPARQL to use HHW Brick</li> <li>\u2705 Focus on preparing CSV data, we handle Brick complexity</li> <li>\u2705 Generated models are ready for portable analytics</li> <li>\u2705 Use SPARQL for advanced queries if you want more control</li> </ul> <p>Why This Matters</p> <p>Traditional Approach: 100 buildings \u00d7 3 hours coding each = 300 hours Brick Approach: 100 buildings \u00d7 0 hours coding = 0 hours </p> <p>Write analytics once, deploy to unlimited buildings! \ud83d\ude80</p>"},{"location":"getting-started/understanding-brick/#visual-summary","title":"Visual Summary","text":"<pre><code>graph TB\n    subgraph \"The Brick Advantage\"\n        direction LR\n\n        subgraph \"Step 1: Convert\"\n            CSV[CSV Files] --&gt;|HHW Brick| BM[Brick Models]\n        end\n\n        subgraph \"Step 2: Standardize\"\n            BM --&gt;|Standard Classes| SC[brick:Boiler&lt;br/&gt;brick:Temperature_Sensor&lt;br/&gt;brick:hasPoint]\n        end\n\n        subgraph \"Step 3: Query\"\n            SC --&gt;|SPARQL| Q[Auto-Discover&lt;br/&gt;Sensors]\n        end\n\n        subgraph \"Step 4: Analyze\"\n            Q --&gt;|Portable Code| A[Analytics Work&lt;br/&gt;on ANY Building]\n        end\n\n        A --&gt;|Results| R[\u2713 Scalable&lt;br/&gt;\u2713 Maintainable&lt;br/&gt;\u2713 Interoperable]\n    end\n\n    style CSV fill:#e3f2fd\n    style BM fill:#fff9c4\n    style SC fill:#c8e6c9\n    style Q fill:#ffe0b2\n    style A fill:#90caf9\n    style R fill:#a5d6a7</code></pre> <p>Ready to get started? Continue to CSV Data Format to learn how to prepare your data \u2192</p> <p>Or jump straight to practice: Quick Start Guide for a complete hands-on tutorial \u2192</p>"},{"location":"tutorials/","title":"Tutorials","text":"<p>Step-by-step tutorials to master HHW Brick Application.</p>"},{"location":"tutorials/#overview","title":"Overview","text":"<p>These tutorials provide in-depth, hands-on learning experiences. Each tutorial builds on previous knowledge and includes:</p> <ul> <li>Clear learning objectives</li> <li>Step-by-step instructions</li> <li>Complete code examples</li> <li>Exercises and challenges</li> <li>Summary and next steps</li> </ul>"},{"location":"tutorials/#available-tutorials","title":"Available Tutorials","text":""},{"location":"tutorials/#building-your-first-application","title":"Building Your First Application","text":"<p>Duration: 30-45 minutes Level: Beginner</p> <p>Learn how to create a custom analytics application from scratch.</p> <p>What you'll learn: - Application structure and requirements - Implementing qualify and analyze functions - Testing your application - Deploying to the package</p> <p>Start tutorial \u2192</p>"},{"location":"tutorials/#data-pipeline-workflow","title":"Data Pipeline Workflow","text":"<p>Duration: 45-60 minutes Level: Intermediate</p> <p>Build a complete data processing pipeline.</p> <p>What you'll learn: - Batch CSV conversion - Automated validation - Application qualification - Batch analytics execution - Results aggregation</p> <p>Start tutorial \u2192</p>"},{"location":"tutorials/#performance-optimization","title":"Performance Optimization","text":"<p>Duration: 30-45 minutes Level: Advanced</p> <p>Optimize your workflows for production use.</p> <p>What you'll learn: - Profiling bottlenecks - Parallel processing - Memory management - Caching strategies - Best practices</p> <p>Start tutorial \u2192</p>"},{"location":"tutorials/#tutorial-path","title":"Tutorial Path","text":"<pre><code>graph LR\n    A[First App] --&gt;|Build on| B[Data Pipeline]\n    B --&gt;|Optimize| C[Performance]\n\n    style A fill:#c8e6c9\n    style B fill:#fff9c4\n    style C fill:#f8bbd0</code></pre> <p>We recommend following the tutorials in order for the best learning experience.</p>"},{"location":"tutorials/#prerequisites","title":"Prerequisites","text":"<p>Before starting the tutorials, make sure you have:</p> <ul> <li> Installed HHW Brick Application</li> <li> Basic Python knowledge</li> <li> Completed the Quick Start Guide</li> <li> Familiarity with Core Concepts</li> </ul>"},{"location":"tutorials/#learning-resources","title":"Learning Resources","text":""},{"location":"tutorials/#complementary-materials","title":"Complementary Materials","text":"<ul> <li>Examples - Quick code snippets</li> <li>User Guide - Feature documentation</li> <li>Developer Guide - Advanced topics</li> <li>API Reference - Detailed API docs</li> </ul>"},{"location":"tutorials/#external-resources","title":"External Resources","text":"<ul> <li>Brick Schema Documentation</li> <li>RDFLib Tutorial</li> <li>Python Packaging Guide</li> </ul>"},{"location":"tutorials/#getting-help","title":"Getting Help","text":"<p>If you get stuck during a tutorial:</p> <ol> <li>Check the code - All tutorials include complete working examples</li> <li>Review the FAQ - Common issues are documented in the FAQ</li> <li>Search issues - Look for similar problems on GitHub</li> <li>Ask for help - Open a discussion</li> </ol>"},{"location":"tutorials/#contributing-tutorials","title":"Contributing Tutorials","text":"<p>Have an idea for a tutorial? We'd love to hear from you!</p> <p>See the Contributing Guide to learn how to contribute tutorials.</p> <p>Ready to learn? Start with Building Your First Application \u2192</p>"},{"location":"tutorials/#examples","title":"Examples","text":"<p>Practical examples to help you get started with HHW Brick Application.</p>"},{"location":"tutorials/#overview_1","title":"Overview","text":"<p>This section contains code examples ranging from basic to advanced usage. Each example includes:</p> <ul> <li>Complete working code</li> <li>Explanation of key concepts</li> <li>Expected output</li> <li>Common variations</li> </ul>"},{"location":"tutorials/#quick-examples","title":"Quick Examples","text":""},{"location":"tutorials/#simple-csv-conversion","title":"Simple CSV Conversion","text":"<pre><code>from hhw_brick import CSVToBrickConverter\n\nconverter = CSVToBrickConverter()\nresult = converter.convert_csv_to_brick(\n    input_file=\"building_105.csv\",\n    output_file=\"building_105.ttl\"\n)\n</code></pre>"},{"location":"tutorials/#validate-a-model","title":"Validate a Model","text":"<pre><code>from hhw_brick import BrickModelValidator\n\nvalidator = BrickModelValidator()\nis_valid, report = validator.validate_model(\"building_105.ttl\")\nprint(f\"Valid: {is_valid}\")\n</code></pre>"},{"location":"tutorials/#run-an-application","title":"Run an Application","text":"<pre><code>from hhw_brick import apps\n\napp = apps.load_app(\"secondary_loop_temp_diff\")\nqualified, details = app.qualify(brick_model)\nif qualified:\n    results = app.analyze(brick_model, timeseries_data, config)\n</code></pre>"},{"location":"tutorials/#example-categories","title":"Example Categories","text":""},{"location":"tutorials/#basic-examples","title":"Basic Examples","text":"<p>Simple examples for beginners:</p> <ul> <li>CSV to Brick Conversion</li> <li>Model Validation</li> <li>Running Applications</li> </ul>"},{"location":"tutorials/#advanced-examples","title":"Advanced Examples","text":"<p>Complex workflows for advanced users:</p> <ul> <li>Batch Processing</li> <li>Custom Applications</li> <li>System Integration</li> </ul>"},{"location":"tutorials/#example-data","title":"Example Data","text":"<p>All examples use sample data available in the <code>Example_Input_Data/</code> directory:</p> <pre><code>Example_Input_Data/\n\u251c\u2500\u2500 building_105.csv\n\u251c\u2500\u2500 building_127.csv\n\u251c\u2500\u2500 building_304.csv\n\u2514\u2500\u2500 timeseries/\n    \u251c\u2500\u2500 building_105_data.csv\n    \u2514\u2500\u2500 building_127_data.csv\n</code></pre>"},{"location":"tutorials/#running-examples","title":"Running Examples","text":""},{"location":"tutorials/#option-1-python-script","title":"Option 1: Python Script","text":"<p>Save the example code to a <code>.py</code> file and run:</p> <pre><code>python my_example.py\n</code></pre>"},{"location":"tutorials/#option-2-interactive-python","title":"Option 2: Interactive Python","text":"<p>Run in Python interactive mode:</p> <pre><code>python\n&gt;&gt;&gt; from hhw_brick import CSVToBrickConverter\n&gt;&gt;&gt; # ... rest of code\n</code></pre>"},{"location":"tutorials/#option-3-jupyter-notebook","title":"Option 3: Jupyter Notebook","text":"<p>Use examples in Jupyter notebooks for interactive exploration.</p>"},{"location":"tutorials/#common-patterns","title":"Common Patterns","text":""},{"location":"tutorials/#pattern-1-complete-workflow","title":"Pattern 1: Complete Workflow","text":"<pre><code>from hhw_brick import (\n    CSVToBrickConverter,\n    BrickModelValidator,\n    apps\n)\n\n# Convert\nconverter = CSVToBrickConverter()\nconverter.convert_csv_to_brick(\"input.csv\", \"model.ttl\")\n\n# Validate\nvalidator = BrickModelValidator()\nis_valid, report = validator.validate_model(\"model.ttl\")\n\nif is_valid:\n    # Run app\n    app = apps.load_app(\"secondary_loop_temp_diff\")\n    results = app.analyze(model, data, config)\n    print(\"Analysis complete!\")\n</code></pre>"},{"location":"tutorials/#pattern-2-batch-processing","title":"Pattern 2: Batch Processing","text":"<pre><code>from hhw_brick import BatchConverter\n\nconverter = BatchConverter()\nresults = converter.convert_batch(\n    input_dir=\"csv_files/\",\n    output_dir=\"brick_models/\"\n)\n</code></pre>"},{"location":"tutorials/#pattern-3-error-handling","title":"Pattern 3: Error Handling","text":"<pre><code>try:\n    converter.convert_csv_to_brick(\"input.csv\", \"output.ttl\")\nexcept FileNotFoundError:\n    print(\"Input file not found!\")\nexcept Exception as e:\n    print(f\"Conversion failed: {e}\")\n</code></pre>"},{"location":"tutorials/#next-steps","title":"Next Steps","text":"<ul> <li>Browse Basic Examples to get started</li> <li>Explore Advanced Examples for complex workflows</li> <li>Check Tutorials for step-by-step guides</li> <li>Read User Guide for detailed documentation</li> </ul> <p>Ready to try? Start with CSV Conversion \u2192</p>"},{"location":"tutorials/01_hello_world_app/","title":"Tutorial 1: Hello World App","text":"<p>Duration: 15 minutes Difficulty: Beginner Goal: Create your first Brick analytics app</p>"},{"location":"tutorials/01_hello_world_app/#what-youll-build","title":"What You'll Build","text":"<p>A simple app that: - Counts buildings in a Brick model - Lists all building names - Exports results to JSON</p>"},{"location":"tutorials/01_hello_world_app/#prerequisites","title":"Prerequisites","text":"<ul> <li>HHW Brick Application installed</li> <li>A Brick model file (e.g., <code>building_105.ttl</code>)</li> <li>Basic Python knowledge</li> </ul>"},{"location":"tutorials/01_hello_world_app/#step-1-create-app-file","title":"Step 1: Create App File","text":"<p>Create a new file called <code>hello_world_app.py</code>:</p> <pre><code>\"\"\"\nHello World App - Tutorial 1\nA simple app that counts and lists buildings.\n\"\"\"\n\nfrom hhw_brick.analytics.core.base_app import BaseApp, register_app\nfrom rdflib import Namespace\n\n# Register your app\n@register_app(\n    name=\"hello_world\",\n    description=\"Counts and lists all buildings in the model\",\n    version=\"1.0.0\"\n)\nclass HelloWorldApp(BaseApp):\n    \"\"\"My first Brick analytics app!\"\"\"\n\n    def analyze(self, graph, building_name=None, **kwargs):\n        \"\"\"\n        Count and list all buildings.\n\n        Args:\n            graph: The Brick model (rdflib.Graph)\n            building_name: Optional filter (not used in this example)\n\n        Returns:\n            dict: Contains building count and list\n        \"\"\"\n        # Step 1: Define SPARQL query\n        query = \"\"\"\n        PREFIX brick: &lt;https://brickschema.org/schema/Brick#&gt;\n        PREFIX rdfs: &lt;http://www.w3.org/2000/01/rdf-schema#&gt;\n\n        SELECT ?building ?label\n        WHERE {\n            ?building a brick:Building .\n            OPTIONAL { ?building rdfs:label ?label }\n        }\n        \"\"\"\n\n        # Step 2: Execute query\n        results = graph.query(query)\n\n        # Step 3: Process results\n        buildings = []\n        for row in results:\n            building_uri = str(row.building)\n            building_label = str(row.label) if row.label else building_uri\n\n            buildings.append({\n                'uri': building_uri,\n                'name': building_label\n            })\n\n        # Step 4: Return structured results\n        return {\n            'building_count': len(buildings),\n            'buildings': buildings,\n            'summary': f\"Found {len(buildings)} building(s) in the model\"\n        }\n</code></pre>"},{"location":"tutorials/01_hello_world_app/#step-2-test-your-app","title":"Step 2: Test Your App","text":""},{"location":"tutorials/01_hello_world_app/#option-a-run-via-cli","title":"Option A: Run via CLI","text":"<pre><code># List all apps (should show your new app)\nhhw-brick apps list\n\n# Run your app\nhhw-brick apps run hello_world building_105.ttl\n\n# Run with JSON output\nhhw-brick apps run hello_world building_105.ttl -o results.json\n</code></pre>"},{"location":"tutorials/01_hello_world_app/#option-b-run-in-python","title":"Option B: Run in Python","text":"<p>Create a test script <code>test_hello_world.py</code>:</p> <pre><code>from hello_world_app import HelloWorldApp\nfrom rdflib import Graph\n\n# Load Brick model\nprint(\"Loading Brick model...\")\ngraph = Graph()\ngraph.parse(\"building_105.ttl\", format=\"turtle\")\nprint(f\"Loaded {len(graph)} triples\")\n\n# Create and run app\nprint(\"\\nRunning Hello World app...\")\napp = HelloWorldApp()\nresults = app.analyze(graph)\n\n# Display results\nprint(f\"\\n{results['summary']}\")\nprint(f\"\\nBuildings:\")\nfor building in results['buildings']:\n    print(f\"  - {building['name']}\")\n</code></pre> <p>Run it:</p> <pre><code>python test_hello_world.py\n</code></pre>"},{"location":"tutorials/01_hello_world_app/#expected-output","title":"Expected Output","text":"<pre><code>Loading Brick model...\nLoaded 1,234 triples\n\nRunning Hello World app...\n\nFound 1 building(s) in the model\n\nBuildings:\n  - building105\n</code></pre>"},{"location":"tutorials/01_hello_world_app/#step-3-understand-the-code","title":"Step 3: Understand the Code","text":""},{"location":"tutorials/01_hello_world_app/#the-register_app-decorator","title":"The @register_app Decorator","text":"<pre><code>@register_app(\n    name=\"hello_world\",           # CLI command name\n    description=\"...\",             # Shows in help\n    version=\"1.0.0\"               # Your app version\n)\n</code></pre> <p>This makes your app discoverable by the framework.</p>"},{"location":"tutorials/01_hello_world_app/#the-analyze-method","title":"The analyze() Method","text":"<p>This is the core method that does the work:</p> <pre><code>def analyze(self, graph, building_name=None, **kwargs):\n    # Your analysis code here\n    return {...}  # Must return a dict\n</code></pre> <p>Parameters: - <code>graph</code>: The loaded Brick model (rdflib.Graph object) - <code>building_name</code>: Optional building filter - <code>**kwargs</code>: Additional parameters</p> <p>Returns: - Must return a dictionary - Can contain any structure - Will be converted to JSON/CSV automatically</p>"},{"location":"tutorials/01_hello_world_app/#the-sparql-query","title":"The SPARQL Query","text":"<pre><code>query = \"\"\"\nPREFIX brick: &lt;https://brickschema.org/schema/Brick#&gt;\n\nSELECT ?building ?label\nWHERE {\n    ?building a brick:Building .\n    OPTIONAL { ?building rdfs:label ?label }\n}\n\"\"\"\n</code></pre> <p>Breakdown: - <code>PREFIX</code>: Define namespaces - <code>SELECT</code>: Variables to return - <code>WHERE</code>: Pattern to match - <code>OPTIONAL</code>: Make label optional (building might not have one)</p>"},{"location":"tutorials/01_hello_world_app/#step-4-enhance-your-app","title":"Step 4: Enhance Your App","text":""},{"location":"tutorials/01_hello_world_app/#add-error-handling","title":"Add Error Handling","text":"<pre><code>def analyze(self, graph, building_name=None, **kwargs):\n    try:\n        query = \"...\"\n        results = graph.query(query)\n        # ... process results\n        return {...}\n    except Exception as e:\n        return {\n            'error': str(e),\n            'success': False\n        }\n</code></pre>"},{"location":"tutorials/01_hello_world_app/#add-filtering","title":"Add Filtering","text":"<pre><code>def analyze(self, graph, building_name=None, **kwargs):\n    # Filter by building name if provided\n    if building_name:\n        query = f\"\"\"\n        PREFIX brick: &lt;https://brickschema.org/schema/Brick#&gt;\n        PREFIX hhws: &lt;https://example.org/hhws#&gt;\n\n        SELECT ?building\n        WHERE {{\n            ?building a brick:Building .\n            FILTER(CONTAINS(STR(?building), \"{building_name}\"))\n        }}\n        \"\"\"\n    else:\n        query = \"...\"  # Original query\n</code></pre>"},{"location":"tutorials/01_hello_world_app/#add-logging","title":"Add Logging","text":"<pre><code>def analyze(self, graph, building_name=None, **kwargs):\n    print(f\"Analyzing {len(graph)} triples...\")\n\n    query = \"...\"\n    results = graph.query(query)\n\n    print(f\"Found {len(list(results))} buildings\")\n\n    return {...}\n</code></pre>"},{"location":"tutorials/01_hello_world_app/#step-5-export-results","title":"Step 5: Export Results","text":""},{"location":"tutorials/01_hello_world_app/#to-json","title":"To JSON","text":"<pre><code>hhw-brick apps run hello_world building_105.ttl -o results.json\n</code></pre> <p>Creates <code>results.json</code>:</p> <pre><code>{\n  \"building_count\": 1,\n  \"buildings\": [\n    {\n      \"uri\": \"https://example.org/hhws#building105\",\n      \"name\": \"building105\"\n    }\n  ],\n  \"summary\": \"Found 1 building(s) in the model\"\n}\n</code></pre>"},{"location":"tutorials/01_hello_world_app/#to-csv-with-pandas","title":"To CSV (with pandas)","text":"<p>Modify your app to return a DataFrame:</p> <pre><code>import pandas as pd\n\ndef analyze(self, graph, **kwargs):\n    # ... query and process ...\n\n    # Create DataFrame\n    df = pd.DataFrame(buildings)\n\n    return {\n        'dataframe': df,  # Auto-converts to CSV\n        'summary': {...}\n    }\n</code></pre>"},{"location":"tutorials/01_hello_world_app/#common-issues","title":"Common Issues","text":""},{"location":"tutorials/01_hello_world_app/#issue-1-no-results","title":"Issue 1: No Results","text":"<p>Problem: Query returns empty results</p> <p>Solution: Check that the Brick model actually contains buildings:</p> <pre><code># Debug: print all classes\nfor s, p, o in graph.triples((None, RDF.type, None)):\n    print(f\"{s} is a {o}\")\n</code></pre>"},{"location":"tutorials/01_hello_world_app/#issue-2-import-error","title":"Issue 2: Import Error","text":"<p>Problem: Cannot import BaseApp</p> <p>Solution: <pre><code>pip install -e .\n</code></pre></p>"},{"location":"tutorials/01_hello_world_app/#issue-3-app-not-listed","title":"Issue 3: App Not Listed","text":"<p>Problem: <code>hhw-brick apps list</code> doesn't show your app</p> <p>Solution: Ensure @register_app decorator is used and file is in correct location.</p>"},{"location":"tutorials/01_hello_world_app/#congratulations","title":"\ud83c\udf89 Congratulations!","text":"<p>You've created your first Brick analytics app!</p>"},{"location":"tutorials/01_hello_world_app/#what-you-learned","title":"What You Learned","text":"<p>\u2705 How to create an app class \u2705 How to use the @register_app decorator \u2705 How to write SPARQL queries \u2705 How to process and return results \u2705 How to run apps via CLI</p>"},{"location":"tutorials/01_hello_world_app/#next-steps","title":"Next Steps","text":"<ul> <li>Tutorial 2: Point Extraction App (extract all points from a building)</li> <li>Tutorial 3: Equipment Analysis App (analyze equipment relationships)</li> <li>Tutorial 4: Custom Analytics App (calculate performance metrics)</li> </ul>"},{"location":"tutorials/01_hello_world_app/#full-code","title":"Full Code","text":"<pre><code>\"\"\"Hello World App - Complete Code\"\"\"\n\nfrom hhw_brick.analytics.core.base_app import BaseApp, register_app\n\n@register_app(\n    name=\"hello_world\",\n    description=\"Counts and lists all buildings in the model\",\n    version=\"1.0.0\"\n)\nclass HelloWorldApp(BaseApp):\n    \"\"\"My first Brick analytics app!\"\"\"\n\n    def analyze(self, graph, building_name=None, **kwargs):\n        \"\"\"Count and list all buildings.\"\"\"\n\n        query = \"\"\"\n        PREFIX brick: &lt;https://brickschema.org/schema/Brick#&gt;\n        PREFIX rdfs: &lt;http://www.w3.org/2000/01/rdf-schema#&gt;\n\n        SELECT ?building ?label\n        WHERE {\n            ?building a brick:Building .\n            OPTIONAL { ?building rdfs:label ?label }\n        }\n        \"\"\"\n\n        results = graph.query(query)\n\n        buildings = []\n        for row in results:\n            buildings.append({\n                'uri': str(row.building),\n                'name': str(row.label) if row.label else str(row.building)\n            })\n\n        return {\n            'building_count': len(buildings),\n            'buildings': buildings,\n            'summary': f\"Found {len(buildings)} building(s) in the model\"\n        }\n</code></pre> <p>Happy coding! \ud83d\ude80</p>"},{"location":"user-guide/","title":"User Guide","text":"<p>Welcome to the HHW Brick Application User Guide! This comprehensive guide covers all features and functionalities of the package.</p>"},{"location":"user-guide/#overview","title":"Overview","text":"<p>The User Guide is organized into the following sections:</p>"},{"location":"user-guide/#csv-to-brick-conversion","title":"CSV to Brick Conversion","text":"<p>Learn how to convert your building equipment data from CSV format to Brick ontology models.</p> <ul> <li>Basic Usage - Simple conversion examples</li> <li>Batch Processing - Convert multiple files</li> <li>Configuration - Customize conversion settings</li> </ul>"},{"location":"user-guide/#model-validation","title":"Model Validation","text":"<p>Ensure your Brick models meet quality standards and specifications.</p> <ul> <li>Ontology Validation - Validate against Brick schema</li> <li>Subgraph Matching - Pattern-based validation</li> <li>Point Count Validation - Verify data completeness</li> </ul>"},{"location":"user-guide/#analytics-applications","title":"Analytics Applications","text":"<p>Use pre-built or custom analytics applications to analyze building systems.</p> <ul> <li>Available Apps - Browse built-in applications</li> <li>Running Applications - Execute analysis workflows</li> <li>Batch Analysis - Process multiple buildings</li> </ul>"},{"location":"user-guide/#command-line-interface","title":"Command Line Interface","text":"<p>Use the powerful CLI for quick operations and automation.</p> <ul> <li>Commands Reference - Complete command documentation</li> <li>Examples - Practical CLI usage examples</li> </ul>"},{"location":"user-guide/#common-workflows","title":"Common Workflows","text":""},{"location":"user-guide/#basic-workflow","title":"Basic Workflow","text":"<pre><code>graph LR\n    A[CSV Data] --&gt;|convert| B[Brick Model]\n    B --&gt;|validate| C[Validated Model]\n    C --&gt;|analyze| D[Results]\n\n    style A fill:#e1f5ff\n    style B fill:#fff9c4\n    style C fill:#c8e6c9\n    style D fill:#f8bbd0</code></pre> <ol> <li>Convert CSV data to Brick model</li> <li>Validate the generated model</li> <li>Analyze using applications</li> <li>Export results</li> </ol>"},{"location":"user-guide/#advanced-workflow","title":"Advanced Workflow","text":"<pre><code>graph TD\n    A[Multiple CSV Files] --&gt;|Batch Convert| B[Multiple Brick Models]\n    B --&gt;|Batch Validate| C[Valid Models]\n    C --&gt;|Qualify Buildings| D{Meet Criteria?}\n    D --&gt;|Yes| E[Run Analytics]\n    D --&gt;|No| F[Skip]\n    E --&gt;|Batch Process| G[Analysis Results]\n\n    style A fill:#e1f5ff\n    style C fill:#c8e6c9\n    style G fill:#f8bbd0</code></pre> <ol> <li>Batch convert multiple CSV files</li> <li>Batch validate all models</li> <li>Qualify buildings for analysis</li> <li>Run analytics on qualified buildings</li> <li>Aggregate results</li> </ol>"},{"location":"user-guide/#quick-navigation","title":"Quick Navigation","text":"<ul> <li> <p> Conversion</p> <p>Transform CSV to Brick models</p> </li> <li> <p> Validation</p> <p>Verify model quality</p> </li> <li> <p> Applications</p> <p>Analyze building systems</p> </li> <li> <p>:material-terminal: CLI</p> <p>Use command-line tools</p> </li> </ul>"},{"location":"user-guide/#need-more-help","title":"Need More Help?","text":"<ul> <li>New to Brick? Check out Core Concepts</li> <li>Looking for code examples? Browse Examples</li> <li>Want to build your own apps? See Developer Guide</li> <li>Have questions? Visit the FAQ</li> </ul> <p>Ready to start? Pick a topic above or continue to CSV to Brick Conversion \u2192</p>"},{"location":"user-guide/applications/","title":"Analytics Applications","text":"<p>Run analytics on validated Brick models to extract insights from building data.</p>"},{"location":"user-guide/applications/#overview","title":"Overview","text":"<p>HHW Brick Application provides a pluggable application framework for running analytics on building systems. Applications are self-contained modules that:</p> <ul> <li>Qualify buildings - Check if building has required sensors</li> <li>Analyze data - Perform calculations and generate insights</li> <li>Generate outputs - Create reports, plots, and metrics</li> </ul>"},{"location":"user-guide/applications/#available-applications","title":"Available Applications","text":""},{"location":"user-guide/applications/#current-applications","title":"Current Applications","text":"<p>The package includes two built-in applications:</p> Application Purpose Required Sensors secondary_loop_temp_diff Analyze secondary loop temperature difference Secondary supply, return temps primary_loop_temp_diff Analyze primary loop temperature difference Primary supply, return temps <p>More applications can be added by developers. See Developer Guide.</p>"},{"location":"user-guide/applications/#quick-start","title":"Quick Start","text":""},{"location":"user-guide/applications/#4-step-workflow","title":"4-Step Workflow","text":"<p>From <code>examples/07_run_application.py</code>:</p> <pre><code>from hhw_brick import apps\n\n# Step 1: Load application\napp = apps.load_app(\"secondary_loop_temp_diff\")\n\n# Step 2: Qualify building (check if it has required sensors)\nqualified, details = app.qualify(\"building_105.ttl\")\n\nif qualified:\n    # Step 3: Load configuration\n    config = apps.get_default_config(\"secondary_loop_temp_diff\")\n\n    # Step 4: Run analysis\n    results = app.analyze(\n        brick_model_path=\"building_105.ttl\",\n        timeseries_data_path=\"building_105_data.csv\",\n        config=config\n    )\n\n    print(f\"Analysis complete: {results['summary']}\")\n</code></pre>"},{"location":"user-guide/applications/#apps-manager","title":"Apps Manager","text":""},{"location":"user-guide/applications/#discover-applications","title":"Discover Applications","text":"<p>From <code>examples/06_application_management.py</code>:</p> <pre><code>from hhw_brick import apps\n\n# List all available applications\navailable_apps = apps.list_apps()\n\nprint(f\"Found {len(available_apps)} applications:\")\nfor app_info in available_apps:\n    print(f\"  \u2022 {app_info['name']}\")\n    print(f\"    {app_info['description']}\")\n</code></pre> <p>Expected output: <pre><code>Found 2 applications:\n  \u2022 secondary_loop_temp_diff\n    Analyzes temperature difference in secondary hot water loop\n  \u2022 primary_loop_temp_diff\n    Analyzes temperature difference in primary hot water loop\n</code></pre></p>"},{"location":"user-guide/applications/#load-application","title":"Load Application","text":"<pre><code># Load by name\napp = apps.load_app(\"secondary_loop_temp_diff\")\n\n# Now you can use app.qualify() and app.analyze()\n</code></pre>"},{"location":"user-guide/applications/#get-application-info","title":"Get Application Info","text":"<pre><code># Get detailed information\ninfo = apps.get_app_info(\"secondary_loop_temp_diff\")\n\nprint(f\"Name: {info['name']}\")\nprint(f\"Description: {info['description']}\")\nprint(f\"Functions: {[f['name'] for f in info['functions']]}\")\n</code></pre>"},{"location":"user-guide/applications/#get-default-configuration","title":"Get Default Configuration","text":"<pre><code># Get default config template\nconfig = apps.get_default_config(\"secondary_loop_temp_diff\")\n\n# Customize\nconfig['output']['output_dir'] = './my_results'\nconfig['output']['generate_plots'] = True\n\n# Save for later use\nimport yaml\nwith open('my_config.yaml', 'w') as f:\n    yaml.dump(config, f)\n</code></pre>"},{"location":"user-guide/applications/#application-lifecycle","title":"Application Lifecycle","text":""},{"location":"user-guide/applications/#complete-workflow","title":"Complete Workflow","text":"<pre><code>graph TD\n    A[Load App] --&gt;|apps.load_app| B[Qualify Building]\n    B --&gt;|app.qualify| C{Has Required&lt;br/&gt;Sensors?}\n    C --&gt;|No| D[Skip Building]\n    C --&gt;|Yes| E[Load Config]\n    E --&gt;|apps.get_default_config| F[Run Analysis]\n    F --&gt;|app.analyze| G[Generate Results]\n    G --&gt; H[Save Outputs]\n\n    style A fill:#e1f5ff\n    style C fill:#fff9c4\n    style G fill:#c8e6c9\n    style D fill:#ffcdd2</code></pre>"},{"location":"user-guide/applications/#step-by-step-example","title":"Step-by-Step Example","text":"<pre><code>\"\"\"\nComplete application workflow\nBased on examples/07_run_application.py\n\"\"\"\n\nfrom pathlib import Path\nfrom hhw_brick import apps\nimport yaml\n\ndef run_application_workflow(building_id, app_name):\n    \"\"\"Complete workflow for running an application.\"\"\"\n\n    # Paths\n    model_file = f\"brick_models/building_{building_id}.ttl\"\n    data_file = f\"timeseries_data/{building_id}_data.csv\"\n\n    print(f\"Running {app_name} on building {building_id}\")\n    print(\"=\"*60)\n\n    # ===== Step 1: Load Application =====\n    print(\"\\nStep 1: Load Application\")\n    app = apps.load_app(app_name)\n    print(f\"\u2713 Loaded {app_name}\")\n\n    # ===== Step 2: Qualify Building =====\n    print(\"\\nStep 2: Qualify Building\")\n    qualified, details = app.qualify(model_file)\n\n    if not qualified:\n        print(f\"\u2717 Building {building_id} not qualified\")\n        print(f\"  Reason: {details.get('reason', 'Missing required sensors')}\")\n        return None\n\n    print(f\"\u2713 Building {building_id} qualified\")\n    print(f\"  Found sensors:\")\n    for sensor_type, sensor_uri in details.items():\n        if sensor_uri and 'http' in str(sensor_uri):\n            sensor_name = str(sensor_uri).split('#')[-1]\n            print(f\"    - {sensor_type}: {sensor_name}\")\n\n    # ===== Step 3: Load Configuration =====\n    print(\"\\nStep 3: Load Configuration\")\n    config = apps.get_default_config(app_name)\n\n    # Customize config\n    config['output']['output_dir'] = f\"./results/{app_name}\"\n    config['output']['generate_plots'] = True\n\n    # Save config (optional)\n    config_file = f\"{app_name}_config.yaml\"\n    with open(config_file, 'w') as f:\n        yaml.dump(config, f)\n    print(f\"\u2713 Configuration ready\")\n    print(f\"  Output: {config['output']['output_dir']}\")\n\n    # ===== Step 4: Run Analysis =====\n    print(\"\\nStep 4: Run Analysis\")\n    print(f\"  Model: {model_file}\")\n    print(f\"  Data: {data_file}\")\n\n    results = app.analyze(\n        brick_model_path=model_file,\n        timeseries_data_path=data_file,\n        config=config\n    )\n\n    # ===== Display Results =====\n    print(\"\\n\" + \"=\"*60)\n    print(\"Analysis Results\")\n    print(\"=\"*60)\n\n    if 'summary' in results:\n        print(\"\\nSummary:\")\n        for key, value in results['summary'].items():\n            print(f\"  {key}: {value}\")\n\n    if 'outputs' in results:\n        print(\"\\nGenerated Files:\")\n        for output in results['outputs']:\n            print(f\"  \u2713 {output}\")\n\n    return results\n\n# Run it\nif __name__ == \"__main__\":\n    results = run_application_workflow(\n        building_id=\"105\",\n        app_name=\"secondary_loop_temp_diff\"\n    )\n</code></pre>"},{"location":"user-guide/applications/#batch-application","title":"Batch Application","text":""},{"location":"user-guide/applications/#qualify-multiple-buildings","title":"Qualify Multiple Buildings","text":"<p>From <code>examples/06_application_management.py</code>:</p> <pre><code>from hhw_brick import apps\n\n# Check all buildings in a directory\nbatch_results = apps.qualify_buildings(\"brick_models/\")\n\n# Analyze results\nfor building in batch_results:\n    building_name = Path(building['model']).stem\n    print(f\"\\nBuilding: {building_name}\")\n\n    for result in building['results']:\n        app_name = result['app']\n        qualified = result['qualified']\n\n        status = \"\u2713\" if qualified else \"\u2717\"\n        print(f\"  {status} {app_name}\")\n</code></pre>"},{"location":"user-guide/applications/#build-qualification-matrix","title":"Build Qualification Matrix","text":"<pre><code>\"\"\"\nCreate a matrix showing which buildings qualify for which apps\n\"\"\"\n\nfrom pathlib import Path\nfrom hhw_brick import apps\n\n# Batch qualify\nbatch_results = apps.qualify_buildings(\"brick_models/\")\n\n# Build matrix\napp_matrix = {}  # app -&gt; list of qualified buildings\nbuilding_matrix = {}  # building -&gt; list of qualified apps\n\nfor building in batch_results:\n    building_name = Path(building['model']).stem\n    building_matrix[building_name] = []\n\n    for r in building['results']:\n        app_name = r['app']\n\n        if app_name not in app_matrix:\n            app_matrix[app_name] = []\n\n        if r['qualified']:\n            app_matrix[app_name].append(building_name)\n            building_matrix[building_name].append(app_name)\n\n# Display by application\nprint(\"By Application:\")\nfor app_name, buildings in app_matrix.items():\n    print(f\"  {app_name}:\")\n    print(f\"    Qualified: {len(buildings)}/{len(batch_results)} buildings\")\n    for b in buildings[:5]:  # Show first 5\n        print(f\"      \u2713 {b}\")\n\n# Display by building\nprint(\"\\nBy Building:\")\nfor building_name, apps_list in building_matrix.items():\n    if apps_list:\n        print(f\"  {building_name}: {', '.join(apps_list)}\")\n</code></pre>"},{"location":"user-guide/applications/#batch-run-applications","title":"Batch Run Applications","text":"<pre><code>\"\"\"\nRun applications on all qualified buildings\n\"\"\"\n\nfrom hhw_brick import apps\nfrom pathlib import Path\nimport yaml\n\ndef batch_run_application(app_name, model_dir, data_dir, output_dir):\n    \"\"\"Run application on all qualified buildings.\"\"\"\n\n    # Load app\n    app = apps.load_app(app_name)\n    config = apps.get_default_config(app_name)\n\n    # Find all models\n    model_files = list(Path(model_dir).glob(\"*.ttl\"))\n\n    results_summary = {\n        'total': len(model_files),\n        'qualified': 0,\n        'analyzed': 0,\n        'failed': 0,\n        'results': []\n    }\n\n    for model_file in model_files:\n        building_id = model_file.stem.split('_')[1]  # Extract ID\n\n        # Qualify\n        qualified, details = app.qualify(str(model_file))\n\n        if not qualified:\n            continue\n\n        results_summary['qualified'] += 1\n\n        # Find corresponding data file\n        data_file = Path(data_dir) / f\"{building_id}_data.csv\"\n\n        if not data_file.exists():\n            print(f\"\u26a0 Data file not found for building {building_id}\")\n            results_summary['failed'] += 1\n            continue\n\n        try:\n            # Run analysis\n            result = app.analyze(\n                brick_model_path=str(model_file),\n                timeseries_data_path=str(data_file),\n                config=config\n            )\n\n            results_summary['analyzed'] += 1\n            results_summary['results'].append({\n                'building_id': building_id,\n                'status': 'success',\n                'summary': result.get('summary', {})\n            })\n\n            print(f\"\u2713 Building {building_id}\")\n\n        except Exception as e:\n            results_summary['failed'] += 1\n            results_summary['results'].append({\n                'building_id': building_id,\n                'status': 'failed',\n                'error': str(e)\n            })\n\n            print(f\"\u2717 Building {building_id}: {e}\")\n\n    # Summary\n    print(f\"\\n{'='*60}\")\n    print(f\"Batch Analysis Summary - {app_name}\")\n    print(f\"{'='*60}\")\n    print(f\"Total buildings: {results_summary['total']}\")\n    print(f\"Qualified: {results_summary['qualified']}\")\n    print(f\"Analyzed: {results_summary['analyzed']}\")\n    print(f\"Failed: {results_summary['failed']}\")\n\n    return results_summary\n\n# Use it\nresults = batch_run_application(\n    app_name=\"secondary_loop_temp_diff\",\n    model_dir=\"brick_models/\",\n    data_dir=\"timeseries_data/\",\n    output_dir=\"analysis_results/\"\n)\n</code></pre>"},{"location":"user-guide/applications/#application-interface","title":"Application Interface","text":""},{"location":"user-guide/applications/#standard-interface","title":"Standard Interface","text":"<p>All applications follow the same interface:</p> <pre><code># All apps have these three functions:\n\n__all__ = ['qualify', 'analyze', 'load_config']\n\ndef qualify(brick_model_path: str) -&gt; Tuple[bool, Dict]:\n    \"\"\"\n    Check if building has required sensors.\n\n    Returns:\n        (qualified, details) tuple\n        - qualified: True if building can use this app\n        - details: Dict with sensor URIs or qualification info\n    \"\"\"\n    pass\n\ndef analyze(brick_model_path: str,\n           timeseries_data_path: str,\n           config: Dict) -&gt; Dict:\n    \"\"\"\n    Run analysis on building data.\n\n    Returns:\n        Dict with analysis results, including:\n        - summary: Key metrics\n        - outputs: List of generated files\n        - data: Detailed results\n    \"\"\"\n    pass\n\ndef load_config(config_path: str = None) -&gt; Dict:\n    \"\"\"\n    Load application configuration.\n\n    Returns:\n        Configuration dictionary\n    \"\"\"\n    pass\n</code></pre>"},{"location":"user-guide/applications/#common-patterns","title":"Common Patterns","text":""},{"location":"user-guide/applications/#pattern-1-single-building-analysis","title":"Pattern 1: Single Building Analysis","text":"<pre><code># Load app\napp = apps.load_app(\"secondary_loop_temp_diff\")\n\n# Qualify\nqualified, details = app.qualify(\"building_105.ttl\")\n\nif qualified:\n    # Load config\n    config = apps.get_default_config(\"secondary_loop_temp_diff\")\n\n    # Run\n    results = app.analyze(\n        \"building_105.ttl\",\n        \"building_105_data.csv\",\n        config\n    )\n</code></pre>"},{"location":"user-guide/applications/#pattern-2-try-multiple-apps","title":"Pattern 2: Try Multiple Apps","text":"<pre><code># Try all apps on one building\navailable_apps = apps.list_apps()\nmodel_path = \"building_105.ttl\"\n\nfor app_info in available_apps:\n    app = apps.load_app(app_info['name'])\n    qualified, details = app.qualify(model_path)\n\n    if qualified:\n        print(f\"\u2713 Can run: {app_info['name']}\")\n        # Run it...\n    else:\n        print(f\"\u2717 Cannot run: {app_info['name']}\")\n</code></pre>"},{"location":"user-guide/applications/#pattern-3-conditional-analysis","title":"Pattern 3: Conditional Analysis","text":"<pre><code># Run different apps based on system type\nfrom hhw_brick.validation import SubgraphPatternValidator\n\npattern_validator = SubgraphPatternValidator()\nresult = pattern_validator.check_pattern_2_district_system(model_path)\n\nif result['matched']:\n    # District system - use district-specific apps\n    app = apps.load_app(\"district_efficiency\")\nelse:\n    # Boiler system - use boiler-specific apps  \n    app = apps.load_app(\"boiler_efficiency\")\n\n# Then qualify and analyze...\n</code></pre>"},{"location":"user-guide/applications/#configuration-management","title":"Configuration Management","text":""},{"location":"user-guide/applications/#default-configuration","title":"Default Configuration","text":"<pre><code># Get default config\nconfig = apps.get_default_config(\"secondary_loop_temp_diff\")\n\n# Typical structure:\n{\n    'analysis': {\n        'time_window': '1D',\n        'aggregation': 'mean'\n    },\n    'output': {\n        'save_results': True,\n        'output_dir': './results',\n        'generate_plots': True\n    }\n}\n</code></pre>"},{"location":"user-guide/applications/#custom-configuration","title":"Custom Configuration","text":"<pre><code>import yaml\n\n# Load and customize\nconfig = apps.get_default_config(\"secondary_loop_temp_diff\")\nconfig['output']['output_dir'] = './custom_results'\nconfig['output']['generate_plots'] = False\nconfig['analysis']['time_window'] = '6H'\n\n# Save\nwith open('custom_config.yaml', 'w') as f:\n    yaml.dump(config, f)\n\n# Load later\nwith open('custom_config.yaml', 'r') as f:\n    config = yaml.safe_load(f)\n\n# Use it\nresults = app.analyze(model_path, data_path, config)\n</code></pre>"},{"location":"user-guide/applications/#output-management","title":"Output Management","text":""},{"location":"user-guide/applications/#typical-outputs","title":"Typical Outputs","text":"<p>Applications generate various outputs:</p> <pre><code>results = app.analyze(model_path, data_path, config)\n\n# Results structure\n{\n    'summary': {\n        'mean_temp_diff': 5.2,\n        'max_temp_diff': 12.1,\n        'data_points': 8760\n    },\n    'outputs': [\n        'results/temp_diff_plot.png',\n        'results/statistics.csv',\n        'results/hourly_data.csv'\n    ],\n    'data': {\n        # Detailed results...\n    }\n}\n</code></pre>"},{"location":"user-guide/applications/#handling-outputs","title":"Handling Outputs","text":"<pre><code># Check generated files\nif 'outputs' in results:\n    print(\"Generated files:\")\n    for output_file in results['outputs']:\n        if Path(output_file).exists():\n            print(f\"  \u2713 {output_file}\")\n        else:\n            print(f\"  \u2717 {output_file} (not found)\")\n\n# Access summary metrics\nif 'summary' in results:\n    for metric, value in results['summary'].items():\n        print(f\"{metric}: {value}\")\n</code></pre>"},{"location":"user-guide/applications/#troubleshooting","title":"Troubleshooting","text":""},{"location":"user-guide/applications/#issue-app-not-found","title":"Issue: \"App not found\"","text":"<p>Solution: <pre><code># List available apps\nprint(apps.list_apps())\n\n# Use exact name\napp = apps.load_app(\"secondary_loop_temp_diff\")  # Correct\n# app = apps.load_app(\"secondary_loop\")  # Wrong\n</code></pre></p>"},{"location":"user-guide/applications/#issue-building-not-qualified","title":"Issue: Building not qualified","text":"<p>Investigation: <pre><code>qualified, details = app.qualify(\"building_105.ttl\")\n\nif not qualified:\n    print(\"Qualification failed:\")\n    print(f\"  Reason: {details.get('reason', 'Unknown')}\")\n    print(f\"  Missing: {details.get('missing', [])}\")\n</code></pre></p>"},{"location":"user-guide/applications/#issue-analysis-fails","title":"Issue: Analysis fails","text":"<p>Check: 1. Data file exists and is readable 2. Data format matches expected format 3. Configuration is valid</p> <pre><code># Debug\ntry:\n    results = app.analyze(model_path, data_path, config)\nexcept FileNotFoundError as e:\n    print(f\"File not found: {e}\")\nexcept Exception as e:\n    print(f\"Analysis failed: {e}\")\n    import traceback\n    traceback.print_exc()\n</code></pre>"},{"location":"user-guide/applications/#best-practices","title":"Best Practices","text":""},{"location":"user-guide/applications/#1-always-qualify-first","title":"1. Always Qualify First","text":"<pre><code># Good \u2713\nqualified, details = app.qualify(model_path)\nif qualified:\n    results = app.analyze(model_path, data_path, config)\n\n# Bad \u2717\n# Skip qualification - might fail\nresults = app.analyze(model_path, data_path, config)\n</code></pre>"},{"location":"user-guide/applications/#2-use-configuration-files","title":"2. Use Configuration Files","text":"<pre><code># Good \u2713 - Reusable configuration\nconfig = yaml.safe_load(open('config.yaml'))\nresults = app.analyze(model_path, data_path, config)\n\n# Bad \u2717 - Hard-coded config\nconfig = {'output': {'output_dir': './results'}}\n</code></pre>"},{"location":"user-guide/applications/#3-handle-failures-gracefully","title":"3. Handle Failures Gracefully","text":"<pre><code># Good \u2713\ntry:\n    results = app.analyze(model_path, data_path, config)\n    save_results(results)\nexcept Exception as e:\n    log_error(f\"Analysis failed: {e}\")\n    notify_admin()\n\n# Bad \u2717\nresults = app.analyze(model_path, data_path, config)\n# No error handling\n</code></pre>"},{"location":"user-guide/applications/#next-steps","title":"Next Steps","text":"<p>Learn about specific applications:</p> <ul> <li>Apps Manager - Detailed apps manager API</li> <li>Secondary Loop Temp Diff - Temperature difference analysis</li> <li>Primary Loop Temp Diff - Primary loop analysis</li> <li>Running Apps - Complete guide to running applications</li> </ul> <p>Or explore related topics:</p> <ul> <li>Developer Guide - Create your own applications</li> <li>Examples - Working code samples</li> </ul> <p>Continue to: Apps Manager Details \u2192</p>"},{"location":"user-guide/applications/apps-manager/","title":"Apps Manager","text":"<p>Detailed guide to the Apps Manager API for discovering and managing analytics applications.</p>"},{"location":"user-guide/applications/apps-manager/#overview","title":"Overview","text":"<p>The Apps Manager (<code>apps</code>) provides a simple interface to:</p> <ul> <li>Discover available applications</li> <li>Load applications dynamically</li> <li>Get information about applications</li> <li>Manage configurations</li> <li>Batch qualify buildings</li> </ul>"},{"location":"user-guide/applications/apps-manager/#importing-apps-manager","title":"Importing Apps Manager","text":"<pre><code>from hhw_brick import apps\n</code></pre> <p>The <code>apps</code> object is a singleton instance of <code>AppsManager</code> that provides all functionality.</p>"},{"location":"user-guide/applications/apps-manager/#core-functions","title":"Core Functions","text":""},{"location":"user-guide/applications/apps-manager/#list_apps","title":"list_apps()","text":"<p>List all available analytics applications.</p> <p>Signature: <pre><code>def list_apps() -&gt; List[Dict[str, str]]\n</code></pre></p> <p>Returns: <pre><code>[\n    {\n        'name': 'secondary_loop_temp_diff',\n        'description': 'Analyzes temperature difference in secondary hot water loop',\n        'path': '/path/to/app'\n    },\n    # ... more apps\n]\n</code></pre></p> <p>Example: <pre><code>from hhw_brick import apps\n\n# List all apps\navailable = apps.list_apps()\n\nprint(f\"Found {len(available)} applications:\")\nfor app in available:\n    print(f\"  \u2022 {app['name']}\")\n    print(f\"    {app['description']}\")\n</code></pre></p> <p>Output: <pre><code>Found 2 applications:\n  \u2022 secondary_loop_temp_diff\n    Analyzes temperature difference in secondary hot water loop\n  \u2022 primary_loop_temp_diff\n    Analyzes temperature difference in primary hot water loop\n</code></pre></p>"},{"location":"user-guide/applications/apps-manager/#load_app","title":"load_app()","text":"<p>Load an application by name.</p> <p>Signature: <pre><code>def load_app(app_name: str) -&gt; Module\n</code></pre></p> <p>Parameters: - <code>app_name</code> (str): Name of the application (e.g., \"secondary_loop_temp_diff\")</p> <p>Returns: - App module with <code>qualify()</code>, <code>analyze()</code>, and <code>load_config()</code> functions</p> <p>Example: <pre><code># Load application\napp = apps.load_app(\"secondary_loop_temp_diff\")\n\n# Now you can use app functions\nqualified, details = app.qualify(\"building_105.ttl\")\n</code></pre></p> <p>Raises: - <code>ImportError</code>: If app not found or cannot be loaded</p> <pre><code>try:\n    app = apps.load_app(\"non_existent_app\")\nexcept ImportError as e:\n    print(f\"Error: {e}\")\n</code></pre>"},{"location":"user-guide/applications/apps-manager/#get_app_info","title":"get_app_info()","text":"<p>Get detailed information about an application.</p> <p>Signature: <pre><code>def get_app_info(app_name: str) -&gt; Dict[str, Any]\n</code></pre></p> <p>Returns: <pre><code>{\n    'name': 'secondary_loop_temp_diff',\n    'description': 'Analyzes temperature difference in secondary hot water loop',\n    'functions': [\n        {'name': 'qualify', 'signature': '...'},\n        {'name': 'analyze', 'signature': '...'},\n        {'name': 'load_config', 'signature': '...'}\n    ]\n}\n</code></pre></p> <p>Example: <pre><code>info = apps.get_app_info(\"secondary_loop_temp_diff\")\n\nprint(f\"App: {info['name']}\")\nprint(f\"Description: {info['description']}\")\nprint(f\"Functions:\")\nfor func in info['functions']:\n    print(f\"  - {func['name']}\")\n</code></pre></p>"},{"location":"user-guide/applications/apps-manager/#get_default_config","title":"get_default_config()","text":"<p>Get default configuration template for an application.</p> <p>Signature: <pre><code>def get_default_config(app_name: str) -&gt; Dict[str, Any]\n</code></pre></p> <p>Returns: <pre><code>{\n    'analysis': {\n        'threshold_min_delta': 0.5,\n        'threshold_max_delta': 10.0\n    },\n    'output': {\n        'save_results': True,\n        'output_dir': './results',\n        'generate_plots': True\n    }\n}\n</code></pre></p> <p>Example: <pre><code># Get default config\nconfig = apps.get_default_config(\"secondary_loop_temp_diff\")\n\n# Customize\nconfig['output']['output_dir'] = './my_results'\nconfig['analysis']['threshold_min_delta'] = 1.0\n\n# Use it\nresults = app.analyze(model_path, data_path, config)\n</code></pre></p>"},{"location":"user-guide/applications/apps-manager/#batch-operations","title":"Batch Operations","text":""},{"location":"user-guide/applications/apps-manager/#qualify_building","title":"qualify_building()","text":"<p>Qualify a single building against all available applications.</p> <p>Signature: <pre><code>def qualify_building(model_path: str, verbose: bool = True) -&gt; Dict\n</code></pre></p> <p>Parameters: - <code>model_path</code> (str): Path to Brick model file - <code>verbose</code> (bool): Print detailed output (default: True)</p> <p>Returns: <pre><code>{\n    'model': 'building_105.ttl',\n    'results': [\n        {\n            'app': 'secondary_loop_temp_diff',\n            'qualified': True,\n            'details': {...}\n        },\n        {\n            'app': 'primary_loop_temp_diff',\n            'qualified': False,\n            'details': {...}\n        }\n    ]\n}\n</code></pre></p> <p>Example: <pre><code>from hhw_brick import apps\n\n# Qualify one building\nresult = apps.qualify_building(\"building_105.ttl\")\n\nprint(f\"Building: {result['model']}\")\nfor r in result['results']:\n    status = \"\u2713\" if r['qualified'] else \"\u2717\"\n    print(f\"  {status} {r['app']}\")\n</code></pre></p> <p>With verbose=False: <pre><code># Silent qualification (no print output)\nresult = apps.qualify_building(\"building_105.ttl\", verbose=False)\n\n# Process results programmatically\nqualified_apps = [\n    r['app'] for r in result['results'] if r['qualified']\n]\nprint(f\"Qualified for: {', '.join(qualified_apps)}\")\n</code></pre></p>"},{"location":"user-guide/applications/apps-manager/#qualify_buildings","title":"qualify_buildings()","text":"<p>Qualify multiple buildings against all applications.</p> <p>Signature: <pre><code>def qualify_buildings(model_dir: str, verbose: bool = False) -&gt; List[Dict]\n</code></pre></p> <p>Parameters: - <code>model_dir</code> (str): Directory containing Brick model files - <code>verbose</code> (bool): Print progress (default: False)</p> <p>Returns: <pre><code>[\n    {\n        'model': 'building_105.ttl',\n        'results': [\n            {'app': 'secondary_loop_temp_diff', 'qualified': True, 'details': {...}},\n            {'app': 'primary_loop_temp_diff', 'qualified': False, 'details': {...}}\n        ]\n    },\n    # ... more buildings\n]\n</code></pre></p> <p>Example: <pre><code>from hhw_brick import apps\nfrom pathlib import Path\n\n# Batch qualify\nbatch_results = apps.qualify_buildings(\"brick_models/\")\n\n# Analyze results\nfor building in batch_results:\n    building_name = Path(building['model']).stem\n    qualified_apps = [\n        r['app'] for r in building['results'] if r['qualified']\n    ]\n\n    if qualified_apps:\n        print(f\"{building_name}: {', '.join(qualified_apps)}\")\n    else:\n        print(f\"{building_name}: No apps available\")\n</code></pre></p>"},{"location":"user-guide/applications/apps-manager/#advanced-usage","title":"Advanced Usage","text":""},{"location":"user-guide/applications/apps-manager/#building-qualification-matrix","title":"Building Qualification Matrix","text":"<p>Create a comprehensive view of which buildings qualify for which apps:</p> <pre><code>\"\"\"\nBuild a qualification matrix\n\"\"\"\nfrom hhw_brick import apps\nfrom pathlib import Path\n\ndef build_qualification_matrix(model_dir):\n    \"\"\"Build matrix of buildings vs applications.\"\"\"\n\n    # Batch qualify\n    batch_results = apps.qualify_buildings(model_dir)\n\n    # Initialize matrices\n    app_to_buildings = {}  # app -&gt; [buildings]\n    building_to_apps = {}  # building -&gt; [apps]\n\n    # Process results\n    for building in batch_results:\n        building_name = Path(building['model']).stem\n        building_to_apps[building_name] = []\n\n        for result in building['results']:\n            app_name = result['app']\n\n            # Initialize app entry\n            if app_name not in app_to_buildings:\n                app_to_buildings[app_name] = []\n\n            # Record qualification\n            if result['qualified']:\n                app_to_buildings[app_name].append(building_name)\n                building_to_apps[building_name].append(app_name)\n\n    return {\n        'by_app': app_to_buildings,\n        'by_building': building_to_apps,\n        'total_buildings': len(batch_results)\n    }\n\n# Use it\nmatrix = build_qualification_matrix(\"brick_models/\")\n\n# Display by application\nprint(\"Qualification by Application:\")\nfor app_name, buildings in matrix['by_app'].items():\n    pct = len(buildings) / matrix['total_buildings'] * 100\n    print(f\"  {app_name}:\")\n    print(f\"    {len(buildings)}/{matrix['total_buildings']} ({pct:.1f}%)\")\n\n# Display by building\nprint(\"\\nQualification by Building:\")\nfor building, apps_list in matrix['by_building'].items():\n    if apps_list:\n        print(f\"  {building}: {', '.join(apps_list)}\")\n</code></pre>"},{"location":"user-guide/applications/apps-manager/#export-qualification-results","title":"Export Qualification Results","text":"<p>Save qualification results to CSV:</p> <pre><code>\"\"\"\nExport qualification matrix to CSV\n\"\"\"\nimport pandas as pd\nfrom hhw_brick import apps\n\ndef export_qualification_matrix(model_dir, output_csv):\n    \"\"\"Export qualification results to CSV.\"\"\"\n\n    batch_results = apps.qualify_buildings(model_dir)\n\n    # Flatten results for CSV\n    rows = []\n    for building in batch_results:\n        building_name = Path(building['model']).stem\n\n        for result in building['results']:\n            rows.append({\n                'building': building_name,\n                'application': result['app'],\n                'qualified': result['qualified']\n            })\n\n    # Create DataFrame\n    df = pd.DataFrame(rows)\n\n    # Pivot for matrix view\n    matrix = df.pivot(\n        index='building',\n        columns='application',\n        values='qualified'\n    )\n\n    # Save\n    matrix.to_csv(output_csv)\n    print(f\"Saved qualification matrix to: {output_csv}\")\n\n    # Summary\n    print(f\"\\nSummary:\")\n    for app in matrix.columns:\n        qualified_count = matrix[app].sum()\n        total = len(matrix)\n        print(f\"  {app}: {qualified_count}/{total} buildings\")\n\n    return matrix\n\n# Use it\nmatrix = export_qualification_matrix(\n    \"brick_models/\",\n    \"qualification_matrix.csv\"\n)\n</code></pre>"},{"location":"user-guide/applications/apps-manager/#dynamic-app-loading","title":"Dynamic App Loading","text":"<p>Load apps dynamically based on conditions:</p> <pre><code>\"\"\"\nDynamically select and load apps\n\"\"\"\nfrom hhw_brick import apps\n\ndef select_app_for_building(model_path, preferred_apps=None):\n    \"\"\"\n    Select best app for a building.\n\n    Args:\n        model_path: Path to Brick model\n        preferred_apps: List of preferred app names (in priority order)\n\n    Returns:\n        Tuple of (app_module, app_name) or (None, None)\n    \"\"\"\n    # Get all available apps\n    available = apps.list_apps()\n\n    # Set default preference\n    if preferred_apps is None:\n        preferred_apps = [a['name'] for a in available]\n\n    # Try apps in order of preference\n    for app_name in preferred_apps:\n        try:\n            app = apps.load_app(app_name)\n            qualified, details = app.qualify(model_path)\n\n            if qualified:\n                return app, app_name\n        except Exception as e:\n            print(f\"Error loading {app_name}: {e}\")\n            continue\n\n    return None, None\n\n# Use it\nmodel_path = \"building_105.ttl\"\npreferred = [\"secondary_loop_temp_diff\", \"primary_loop_temp_diff\"]\n\napp, app_name = select_app_for_building(model_path, preferred)\n\nif app:\n    print(f\"Selected: {app_name}\")\n    # Run analysis\n    config = apps.get_default_config(app_name)\n    results = app.analyze(model_path, data_path, config)\nelse:\n    print(\"No suitable app found\")\n</code></pre>"},{"location":"user-guide/applications/apps-manager/#configuration-management","title":"Configuration Management","text":""},{"location":"user-guide/applications/apps-manager/#load-configuration-from-file","title":"Load Configuration from File","text":"<pre><code>import yaml\n\n# Create config file\nconfig = apps.get_default_config(\"secondary_loop_temp_diff\")\nwith open('my_config.yaml', 'w') as f:\n    yaml.dump(config, f)\n\n# Load and use\nwith open('my_config.yaml', 'r') as f:\n    config = yaml.safe_load(f)\n\nresults = app.analyze(model_path, data_path, config)\n</code></pre>"},{"location":"user-guide/applications/apps-manager/#configuration-templates","title":"Configuration Templates","text":"<pre><code>\"\"\"\nCreate configuration templates for all apps\n\"\"\"\nfrom hhw_brick import apps\nimport yaml\nfrom pathlib import Path\n\ndef create_config_templates(output_dir):\n    \"\"\"Create config templates for all apps.\"\"\"\n\n    output_path = Path(output_dir)\n    output_path.mkdir(exist_ok=True)\n\n    available = apps.list_apps()\n\n    for app_info in available:\n        app_name = app_info['name']\n        config = apps.get_default_config(app_name)\n\n        config_file = output_path / f\"{app_name}_config.yaml\"\n        with open(config_file, 'w') as f:\n            yaml.dump(config, f, default_flow_style=False)\n\n        print(f\"Created: {config_file}\")\n\n# Use it\ncreate_config_templates(\"config_templates/\")\n</code></pre>"},{"location":"user-guide/applications/apps-manager/#error-handling","title":"Error Handling","text":""},{"location":"user-guide/applications/apps-manager/#handle-missing-apps","title":"Handle Missing Apps","text":"<pre><code>from hhw_brick import apps\n\napp_name = \"my_custom_app\"\n\ntry:\n    app = apps.load_app(app_name)\nexcept ImportError:\n    print(f\"App '{app_name}' not found\")\n    print(\"Available apps:\")\n    for a in apps.list_apps():\n        print(f\"  - {a['name']}\")\n</code></pre>"},{"location":"user-guide/applications/apps-manager/#handle-qualification-failures","title":"Handle Qualification Failures","text":"<pre><code>app = apps.load_app(\"secondary_loop_temp_diff\")\nqualified, details = app.qualify(\"building_105.ttl\")\n\nif not qualified:\n    print(\"Building not qualified\")\n\n    # Check details for reason\n    if 'reason' in details:\n        print(f\"Reason: {details['reason']}\")\n\n    if 'missing' in details:\n        print(f\"Missing: {details['missing']}\")\n</code></pre>"},{"location":"user-guide/applications/apps-manager/#best-practices","title":"Best Practices","text":""},{"location":"user-guide/applications/apps-manager/#1-check-available-apps-first","title":"1. Check Available Apps First","text":"<pre><code># Good \u2713\navailable = apps.list_apps()\nif available:\n    app = apps.load_app(available[0]['name'])\n\n# Bad \u2717\napp = apps.load_app(\"some_app\")  # Might not exist\n</code></pre>"},{"location":"user-guide/applications/apps-manager/#2-always-qualify-before-analyzing","title":"2. Always Qualify Before Analyzing","text":"<pre><code># Good \u2713\nqualified, details = app.qualify(model_path)\nif qualified:\n    results = app.analyze(model_path, data_path, config)\n\n# Bad \u2717\nresults = app.analyze(model_path, data_path, config)  # Might fail\n</code></pre>"},{"location":"user-guide/applications/apps-manager/#3-use-configuration-files","title":"3. Use Configuration Files","text":"<pre><code># Good \u2713 - Maintainable\nconfig = yaml.safe_load(open('config.yaml'))\n\n# Bad \u2717 - Hard-coded\nconfig = {'output': {'output_dir': './results'}}\n</code></pre>"},{"location":"user-guide/applications/apps-manager/#4-handle-errors-gracefully","title":"4. Handle Errors Gracefully","text":"<pre><code># Good \u2713\ntry:\n    app = apps.load_app(app_name)\n    qualified, details = app.qualify(model_path)\n    if qualified:\n        results = app.analyze(model_path, data_path, config)\nexcept ImportError:\n    print(f\"App not found: {app_name}\")\nexcept FileNotFoundError:\n    print(f\"File not found\")\nexcept Exception as e:\n    print(f\"Error: {e}\")\n</code></pre>"},{"location":"user-guide/applications/apps-manager/#api-reference-summary","title":"API Reference Summary","text":"Function Purpose Returns <code>list_apps()</code> List all applications List of app info dicts <code>load_app(name)</code> Load an application App module <code>get_app_info(name)</code> Get app details Info dict <code>get_default_config(name)</code> Get default config Config dict <code>qualify_building(path)</code> Qualify one building Qualification result <code>qualify_buildings(dir)</code> Qualify multiple buildings List of results"},{"location":"user-guide/applications/apps-manager/#next-steps","title":"Next Steps","text":"<ul> <li>Secondary Loop App - Learn about temperature difference analysis</li> <li>Running Apps - Complete guide to running applications</li> <li>Developer Guide - Create your own apps</li> </ul> <p>Continue to: Secondary Loop Temperature Difference \u2192</p>"},{"location":"user-guide/applications/running-apps/","title":"Running Applications","text":"<p>Complete guide to running analytics applications on building data.</p>"},{"location":"user-guide/applications/running-apps/#overview","title":"Overview","text":"<p>This guide covers the complete workflow for running applications, including:</p> <ul> <li>Preparation - Setting up data and models</li> <li>Qualification - Checking building compatibility</li> <li>Configuration - Customizing analysis parameters</li> <li>Execution - Running the analysis</li> <li>Results - Understanding and using outputs</li> </ul>"},{"location":"user-guide/applications/running-apps/#complete-workflow","title":"Complete Workflow","text":""},{"location":"user-guide/applications/running-apps/#end-to-end-example","title":"End-to-End Example","text":"<p>Based on <code>examples/07_run_application.py</code>:</p> <pre><code>\"\"\"\nComplete workflow: Convert \u2192 Validate \u2192 Analyze\n\"\"\"\n\nfrom pathlib import Path\nfrom hhw_brick import (\n    CSVToBrickConverter,\n    BrickModelValidator,\n    apps\n)\nimport yaml\n\ndef complete_workflow(building_id):\n    \"\"\"Complete workflow from CSV to analysis results.\"\"\"\n\n    # ===== Step 1: Convert CSV to Brick =====\n    print(\"Step 1: Convert CSV to Brick\")\n    print(\"=\"*60)\n\n    converter = CSVToBrickConverter()\n    model_file = f\"building_{building_id}.ttl\"\n\n    converter.convert_to_brick(\n        metadata_csv=\"metadata.csv\",\n        vars_csv=\"vars.csv\",\n        building_tag=building_id,\n        output_path=model_file\n    )\n    print(f\"\u2713 Created Brick model: {model_file}\\n\")\n\n    # ===== Step 2: Validate Model =====\n    print(\"Step 2: Validate Model\")\n    print(\"=\"*60)\n\n    validator = BrickModelValidator(use_local_brick=True)\n    is_valid = validator.validate_ontology(model_file)['valid']\n\n    if not is_valid:\n        print(\"\u2717 Model validation failed\\n\")\n        return None\n\n    print(f\"\u2713 Model is valid\\n\")\n\n    # ===== Step 3: Discover Available Apps =====\n    print(\"Step 3: Discover Available Apps\")\n    print(\"=\"*60)\n\n    available_apps = apps.list_apps()\n    print(f\"Found {len(available_apps)} applications:\")\n    for app_info in available_apps:\n        print(f\"  \u2022 {app_info['name']}\")\n    print()\n\n    # ===== Step 4: Qualify Building =====\n    print(\"Step 4: Qualify Building\")\n    print(\"=\"*60)\n\n    result = apps.qualify_building(model_file, verbose=False)\n\n    qualified_apps = [\n        r['app'] for r in result['results'] if r['qualified']\n    ]\n\n    if not qualified_apps:\n        print(f\"\u2717 Building {building_id} not qualified for any apps\\n\")\n        return None\n\n    print(f\"\u2713 Qualified for: {', '.join(qualified_apps)}\\n\")\n\n    # ===== Step 5: Run Analysis =====\n    print(\"Step 5: Run Analysis\")\n    print(\"=\"*60)\n\n    app_name = qualified_apps[0]  # Use first qualified app\n    app = apps.load_app(app_name)\n\n    # Load config\n    config = apps.get_default_config(app_name)\n    config['output']['output_dir'] = f\"./results/building_{building_id}\"\n\n    # Run analysis\n    data_file = f\"{building_id}_data.csv\"\n    results = app.analyze(model_file, data_file, config)\n\n    print(f\"\u2713 Analysis complete: {app_name}\")\n    print(f\"\\nSummary:\")\n    for key, value in results['summary'].items():\n        print(f\"  {key}: {value}\")\n\n    print(f\"\\nOutputs:\")\n    for output in results['outputs']:\n        print(f\"  - {output}\")\n\n    return results\n\n# Run it\nif __name__ == \"__main__\":\n    results = complete_workflow(\"105\")\n</code></pre>"},{"location":"user-guide/applications/running-apps/#preparation","title":"Preparation","text":""},{"location":"user-guide/applications/running-apps/#required-files","title":"Required Files","text":"<p>Before running an application, prepare:</p> File Description Example Brick Model TTL file with building model <code>building_105.ttl</code> Timeseries Data CSV with sensor data <code>105_data.csv</code> Configuration (optional) YAML with analysis settings <code>config.yaml</code>"},{"location":"user-guide/applications/running-apps/#data-file-requirements","title":"Data File Requirements","text":"<p>Timeseries CSV format:</p> <pre><code>datetime,secondary_supply_temp,secondary_return_temp,flow_rate\n2024-01-01 00:00:00,70.5,65.3,150.2\n2024-01-01 01:00:00,71.2,66.1,155.8\n2024-01-01 02:00:00,69.8,64.7,148.3\n...\n</code></pre> <p>Requirements: - \u2713 <code>datetime</code> column (timestamp) - \u2713 Sensor data columns (names can vary) - \u2713 Numeric values - \u2713 No missing critical timestamps</p>"},{"location":"user-guide/applications/running-apps/#verify-data-quality","title":"Verify Data Quality","text":"<pre><code>import pandas as pd\n\n# Load data\ndf = pd.read_csv(\"105_data.csv\", parse_dates=['datetime'])\n\n# Check quality\nprint(f\"Data points: {len(df)}\")\nprint(f\"Date range: {df['datetime'].min()} to {df['datetime'].max()}\")\nprint(f\"Columns: {df.columns.tolist()}\")\n\n# Check for missing values\nmissing = df.isnull().sum()\nif missing.any():\n    print(\"\\nMissing values:\")\n    print(missing[missing &gt; 0])\n</code></pre>"},{"location":"user-guide/applications/running-apps/#application-types","title":"Application Types","text":""},{"location":"user-guide/applications/running-apps/#primary-loop-temperature-difference","title":"Primary Loop Temperature Difference","text":"<p>Analyzes primary loop (boiler-side) temperature difference.</p> <p>Required Sensors: - Primary supply temperature - Primary return temperature</p> <p>Use Cases: - Boiler efficiency monitoring - Primary loop performance - Heat exchanger effectiveness</p> <p>Quick Example: <pre><code>app = apps.load_app(\"primary_loop_temp_diff\")\n\n# Qualify\nqualified, details = app.qualify(\"building_105.ttl\")\n\nif qualified:\n    # Get config\n    config = apps.get_default_config(\"primary_loop_temp_diff\")\n\n    # Run\n    results = app.analyze(\n        \"building_105.ttl\",\n        \"105_data.csv\",\n        config\n    )\n\n    print(f\"Primary loop temp diff: {results['summary']['mean_temp_diff']:.2f}\u00b0C\")\n</code></pre></p> <p>Similar to Secondary Loop:</p> <p>The primary loop app works identically to the secondary loop app, but: - Looks for primary loop sensors (not secondary) - Analyzes boiler-side temperatures - Useful for boiler systems (not district systems)</p> <p>See Secondary Loop for detailed documentation - the workflow is the same.</p>"},{"location":"user-guide/applications/running-apps/#secondary-loop-temperature-difference","title":"Secondary Loop Temperature Difference","text":"<p>See Secondary Loop App for complete documentation.</p>"},{"location":"user-guide/applications/running-apps/#batch-processing","title":"Batch Processing","text":""},{"location":"user-guide/applications/running-apps/#run-on-multiple-buildings","title":"Run on Multiple Buildings","text":"<pre><code>\"\"\"\nBatch process multiple buildings\n\"\"\"\nfrom pathlib import Path\nfrom hhw_brick import apps\n\ndef batch_run_app(app_name, model_dir, data_dir, output_base):\n    \"\"\"Run app on all qualified buildings.\"\"\"\n\n    # Load app\n    app = apps.load_app(app_name)\n    base_config = apps.get_default_config(app_name)\n\n    # Find models\n    model_files = list(Path(model_dir).glob(\"*.ttl\"))\n\n    results_summary = []\n\n    for model_file in model_files:\n        building_id = model_file.stem.split('_')[1]\n\n        # Qualify\n        qualified, details = app.qualify(str(model_file))\n        if not qualified:\n            print(f\"\u2298 Building {building_id}: Not qualified\")\n            continue\n\n        # Find data\n        data_file = Path(data_dir) / f\"{building_id}_data.csv\"\n        if not data_file.exists():\n            print(f\"\u2298 Building {building_id}: Data file not found\")\n            continue\n\n        # Configure\n        config = base_config.copy()\n        config['output']['output_dir'] = f\"{output_base}/building_{building_id}\"\n\n        # Run\n        try:\n            results = app.analyze(str(model_file), str(data_file), config)\n\n            results_summary.append({\n                'building_id': building_id,\n                'status': 'success',\n                'mean_temp_diff': results['summary']['mean_temp_diff'],\n                'data_points': results['summary']['data_points']\n            })\n\n            print(f\"\u2713 Building {building_id}: {results['summary']['mean_temp_diff']:.2f}\u00b0C\")\n\n        except Exception as e:\n            results_summary.append({\n                'building_id': building_id,\n                'status': 'failed',\n                'error': str(e)\n            })\n            print(f\"\u2717 Building {building_id}: {e}\")\n\n    # Summary\n    print(f\"\\n{'='*60}\")\n    print(f\"Batch Analysis Summary - {app_name}\")\n    print(f\"{'='*60}\")\n\n    successful = [r for r in results_summary if r['status'] == 'success']\n    failed = [r for r in results_summary if r['status'] == 'failed']\n\n    print(f\"Total: {len(model_files)}\")\n    print(f\"Analyzed: {len(successful)}\")\n    print(f\"Failed: {len(failed)}\")\n\n    if successful:\n        avg_temp_diff = sum(r['mean_temp_diff'] for r in successful) / len(successful)\n        print(f\"\\nAverage temp diff: {avg_temp_diff:.2f}\u00b0C\")\n\n    return results_summary\n\n# Use it\nresults = batch_run_app(\n    app_name=\"secondary_loop_temp_diff\",\n    model_dir=\"brick_models/\",\n    data_dir=\"timeseries_data/\",\n    output_base=\"./results\"\n)\n</code></pre>"},{"location":"user-guide/applications/running-apps/#parallel-batch-processing","title":"Parallel Batch Processing","text":"<pre><code>\"\"\"\nRun apps in parallel for faster processing\n\"\"\"\nfrom concurrent.futures import ProcessPoolExecutor, as_completed\nfrom hhw_brick import apps\n\ndef analyze_one_building(args):\n    \"\"\"Analyze one building (for parallel processing).\"\"\"\n    model_file, data_file, app_name, config = args\n\n    try:\n        app = apps.load_app(app_name)\n        results = app.analyze(str(model_file), str(data_file), config)\n        return {\n            'building': model_file.stem,\n            'status': 'success',\n            'summary': results['summary']\n        }\n    except Exception as e:\n        return {\n            'building': model_file.stem,\n            'status': 'failed',\n            'error': str(e)\n        }\n\ndef parallel_batch_run(app_name, model_dir, data_dir, max_workers=4):\n    \"\"\"Run app in parallel.\"\"\"\n\n    from pathlib import Path\n\n    app = apps.load_app(app_name)\n    config = apps.get_default_config(app_name)\n\n    # Prepare tasks\n    tasks = []\n    for model_file in Path(model_dir).glob(\"*.ttl\"):\n        building_id = model_file.stem.split('_')[1]\n\n        # Qualify\n        qualified, _ = app.qualify(str(model_file))\n        if not qualified:\n            continue\n\n        # Find data\n        data_file = Path(data_dir) / f\"{building_id}_data.csv\"\n        if not data_file.exists():\n            continue\n\n        # Configure\n        bldg_config = config.copy()\n        bldg_config['output']['output_dir'] = f\"./results/building_{building_id}\"\n\n        tasks.append((model_file, data_file, app_name, bldg_config))\n\n    # Execute in parallel\n    results = []\n    with ProcessPoolExecutor(max_workers=max_workers) as executor:\n        futures = {\n            executor.submit(analyze_one_building, task): task[0]\n            for task in tasks\n        }\n\n        for future in as_completed(futures):\n            result = future.result()\n            results.append(result)\n\n            status = \"\u2713\" if result['status'] == 'success' else \"\u2717\"\n            print(f\"{status} {result['building']}\")\n\n    return results\n\n# Use it\nresults = parallel_batch_run(\n    \"secondary_loop_temp_diff\",\n    \"brick_models/\",\n    \"timeseries_data/\",\n    max_workers=8\n)\n</code></pre>"},{"location":"user-guide/applications/running-apps/#configuration-management","title":"Configuration Management","text":""},{"location":"user-guide/applications/running-apps/#configuration-file-structure","title":"Configuration File Structure","text":"<pre><code># app_config.yaml\n\nanalysis:\n  # Analysis-specific parameters\n  threshold_min_delta: 0.5\n  threshold_max_delta: 10.0\n\noutput:\n  # Output settings\n  save_results: true\n  output_dir: ./results\n  export_format: csv\n  generate_plots: true\n  plot_format: png\n\ntime_range:\n  # Optional time filtering\n  start_time: \"2024-01-01 00:00:00\"\n  end_time: \"2024-12-31 23:59:59\"\n</code></pre>"},{"location":"user-guide/applications/running-apps/#using-configuration-files","title":"Using Configuration Files","text":"<pre><code>import yaml\n\n# Load config from file\nwith open('app_config.yaml', 'r') as f:\n    config = yaml.safe_load(f)\n\n# Use it\nresults = app.analyze(model_path, data_path, config)\n</code></pre>"},{"location":"user-guide/applications/running-apps/#dynamic-configuration","title":"Dynamic Configuration","text":"<pre><code>\"\"\"\nGenerate configs for different scenarios\n\"\"\"\n\ndef create_seasonal_configs(base_config, year=2024):\n    \"\"\"Create configs for seasonal analysis.\"\"\"\n\n    seasons = {\n        'winter': ('01-01', '03-31'),\n        'spring': ('04-01', '06-30'),\n        'summer': ('07-01', '09-30'),\n        'fall': ('10-01', '12-31')\n    }\n\n    configs = {}\n    for season, (start, end) in seasons.items():\n        config = base_config.copy()\n        config['time_range']['start_time'] = f\"{year}-{start} 00:00:00\"\n        config['time_range']['end_time'] = f\"{year}-{end} 23:59:59\"\n        config['output']['output_dir'] = f\"./results/{season}_{year}\"\n        configs[season] = config\n\n    return configs\n\n# Use it\nbase = apps.get_default_config(\"secondary_loop_temp_diff\")\nseasonal_configs = create_seasonal_configs(base, 2024)\n\nfor season, config in seasonal_configs.items():\n    results = app.analyze(model_path, data_path, config)\n    print(f\"{season}: {results['summary']['mean_temp_diff']:.2f}\u00b0C\")\n</code></pre>"},{"location":"user-guide/applications/running-apps/#results-management","title":"Results Management","text":""},{"location":"user-guide/applications/running-apps/#saving-results","title":"Saving Results","text":"<pre><code>\"\"\"\nSave and organize results\n\"\"\"\nimport json\nfrom datetime import datetime\n\ndef save_analysis_results(results, building_id, app_name, output_dir):\n    \"\"\"Save results with metadata.\"\"\"\n\n    from pathlib import Path\n    import pandas as pd\n\n    output_path = Path(output_dir)\n    output_path.mkdir(parents=True, exist_ok=True)\n\n    # Save summary as JSON\n    summary_file = output_path / f\"{building_id}_{app_name}_summary.json\"\n    summary_data = {\n        'building_id': building_id,\n        'app_name': app_name,\n        'analysis_date': datetime.now().isoformat(),\n        'summary': results['summary']\n    }\n    with open(summary_file, 'w') as f:\n        json.dump(summary_data, f, indent=2)\n\n    # Save detailed data as CSV\n    if 'data' in results:\n        data_file = output_path / f\"{building_id}_{app_name}_data.csv\"\n        df = pd.DataFrame(results['data'])\n        df.to_csv(data_file, index=False)\n\n    print(f\"Saved results to: {output_dir}\")\n\n# Use it\nresults = app.analyze(model_path, data_path, config)\nsave_analysis_results(results, \"105\", \"secondary_loop_temp_diff\", \"./results\")\n</code></pre>"},{"location":"user-guide/applications/running-apps/#aggregating-results","title":"Aggregating Results","text":"<pre><code>\"\"\"\nAggregate results from multiple buildings\n\"\"\"\nimport pandas as pd\n\ndef aggregate_building_results(results_dir):\n    \"\"\"Aggregate results from multiple analyses.\"\"\"\n\n    from pathlib import Path\n    import json\n\n    summary_files = Path(results_dir).rglob(\"*_summary.json\")\n\n    all_results = []\n    for file in summary_files:\n        with open(file, 'r') as f:\n            data = json.load(f)\n            all_results.append({\n                'building_id': data['building_id'],\n                'app': data['app_name'],\n                **data['summary']\n            })\n\n    # Create DataFrame\n    df = pd.DataFrame(all_results)\n\n    # Calculate statistics\n    print(\"Aggregated Results:\")\n    print(f\"  Total buildings: {len(df)}\")\n    print(f\"  Average temp diff: {df['mean_temp_diff'].mean():.2f}\u00b0C\")\n    print(f\"  Min temp diff: {df['mean_temp_diff'].min():.2f}\u00b0C\")\n    print(f\"  Max temp diff: {df['mean_temp_diff'].max():.2f}\u00b0C\")\n\n    # Save aggregate\n    df.to_csv(Path(results_dir) / \"aggregate_results.csv\", index=False)\n\n    return df\n\n# Use it\naggregate_df = aggregate_building_results(\"./results\")\n</code></pre>"},{"location":"user-guide/applications/running-apps/#error-handling","title":"Error Handling","text":""},{"location":"user-guide/applications/running-apps/#robust-execution","title":"Robust Execution","text":"<pre><code>\"\"\"\nProduction-ready application runner\n\"\"\"\nimport logging\nfrom pathlib import Path\n\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\ndef safe_run_app(model_path, data_path, app_name, config):\n    \"\"\"Run app with comprehensive error handling.\"\"\"\n\n    from hhw_brick import apps\n\n    try:\n        # Load app\n        app = apps.load_app(app_name)\n        logger.info(f\"Loaded app: {app_name}\")\n\n    except ImportError as e:\n        logger.error(f\"App not found: {app_name}\")\n        return None\n\n    try:\n        # Qualify\n        qualified, details = app.qualify(model_path)\n\n        if not qualified:\n            logger.warning(f\"Building not qualified for {app_name}\")\n            return None\n\n        logger.info(f\"Building qualified\")\n\n    except FileNotFoundError:\n        logger.error(f\"Model file not found: {model_path}\")\n        return None\n    except Exception as e:\n        logger.error(f\"Qualification failed: {e}\")\n        return None\n\n    try:\n        # Analyze\n        results = app.analyze(model_path, data_path, config)\n        logger.info(f\"Analysis complete\")\n        return results\n\n    except FileNotFoundError:\n        logger.error(f\"Data file not found: {data_path}\")\n        return None\n    except KeyError as e:\n        logger.error(f\"Missing data column: {e}\")\n        return None\n    except Exception as e:\n        logger.error(f\"Analysis failed: {e}\", exc_info=True)\n        return None\n\n# Use it\nresults = safe_run_app(\n    \"building_105.ttl\",\n    \"105_data.csv\",\n    \"secondary_loop_temp_diff\",\n    config\n)\n\nif results:\n    print(\"\u2713 Analysis successful\")\nelse:\n    print(\"\u2717 Analysis failed - check logs\")\n</code></pre>"},{"location":"user-guide/applications/running-apps/#best-practices","title":"Best Practices","text":""},{"location":"user-guide/applications/running-apps/#1-validate-before-analyzing","title":"1. Validate Before Analyzing","text":"<pre><code># Good \u2713\nvalidator = BrickModelValidator(use_local_brick=True)\nif validator.validate_ontology(model_path)['valid']:\n    results = app.analyze(model_path, data_path, config)\n\n# Bad \u2717\nresults = app.analyze(model_path, data_path, config)  # Might fail\n</code></pre>"},{"location":"user-guide/applications/running-apps/#2-check-data-quality","title":"2. Check Data Quality","text":"<pre><code># Good \u2713\ndf = pd.read_csv(data_path)\nif len(df) &lt; 100:\n    print(\"Warning: Limited data points\")\nif df.isnull().any().any():\n    print(\"Warning: Missing values detected\")\n\n# Then analyze\nresults = app.analyze(model_path, data_path, config)\n</code></pre>"},{"location":"user-guide/applications/running-apps/#3-use-configuration-files","title":"3. Use Configuration Files","text":"<pre><code># Good \u2713 - Reproducible\nconfig = yaml.safe_load(open('config.yaml'))\nresults = app.analyze(model_path, data_path, config)\n\n# Save config with results\nwith open('results/config_used.yaml', 'w') as f:\n    yaml.dump(config, f)\n</code></pre>"},{"location":"user-guide/applications/running-apps/#4-handle-failures-gracefully","title":"4. Handle Failures Gracefully","text":"<pre><code># Good \u2713\nfor building in buildings:\n    try:\n        results = app.analyze(building.model, building.data, config)\n        save_results(results)\n    except Exception as e:\n        logger.error(f\"Failed: {building.id} - {e}\")\n        continue  # Continue with next building\n</code></pre>"},{"location":"user-guide/applications/running-apps/#next-steps","title":"Next Steps","text":"<ul> <li>Developer Guide - Create your own applications</li> <li>Examples - More code samples</li> <li>API Reference - Complete API docs</li> </ul> <p>Applications documentation complete! \ud83c\udf89</p> <p>Ready to analyze your building data! Start with Apps Manager or Secondary Loop.</p>"},{"location":"user-guide/applications/secondary-loop/","title":"Secondary Loop Temperature Difference","text":"<p>Analyze temperature difference between supply and return water in secondary hot water loops.</p>"},{"location":"user-guide/applications/secondary-loop/#overview","title":"Overview","text":"<p>The Secondary Loop Temperature Difference application analyzes the temperature differential in building secondary loops. This helps:</p> <ul> <li>Monitor performance - Track loop efficiency</li> <li>Identify issues - Detect circulation problems</li> <li>Optimize operation - Understand load patterns</li> <li>Save energy - Find opportunities for improvement</li> </ul>"},{"location":"user-guide/applications/secondary-loop/#what-it-does","title":"What It Does","text":""},{"location":"user-guide/applications/secondary-loop/#analysis","title":"Analysis","text":"<pre><code>graph LR\n    SS[Secondary&lt;br/&gt;Supply Temp] --&gt;|Subtract| TD[Temperature&lt;br/&gt;Difference]\n    SR[Secondary&lt;br/&gt;Return Temp] --&gt;|Subtract| TD\n    TD --&gt; A[Analysis]\n    A --&gt; M[Metrics]\n    A --&gt; P[Plots]\n    A --&gt; R[Reports]\n\n    style SS fill:#ff9800\n    style SR fill:#2196f3\n    style TD fill:#4caf50</code></pre> <p>Calculates: - Temperature difference: Supply - Return - Statistical metrics: Mean, max, min, std dev - Time-series analysis: Trends over time - Visualizations: Plots and charts</p>"},{"location":"user-guide/applications/secondary-loop/#required-sensors","title":"Required Sensors","text":"<p>The building must have both sensors on the same secondary loop:</p> Sensor Type Brick Class Purpose Supply Temperature <code>Supply_Water_Temperature_Sensor</code> or<code>Leaving_Hot_Water_Temperature_Sensor</code> or<code>Hot_Water_Supply_Temperature_Sensor</code> Measures temperature leaving loop Return Temperature <code>Return_Water_Temperature_Sensor</code> or<code>Entering_Hot_Water_Temperature_Sensor</code> or<code>Hot_Water_Return_Temperature_Sensor</code> Measures temperature returning to loop <p>Secondary Loop Only</p> <p>This app specifically looks for sensors on secondary loops (not primary loops). It identifies secondary loops by checking if the equipment URI contains \"secondary\".</p>"},{"location":"user-guide/applications/secondary-loop/#quick-start","title":"Quick Start","text":""},{"location":"user-guide/applications/secondary-loop/#basic-usage","title":"Basic Usage","text":"<pre><code>from hhw_brick import apps\n\n# Load app\napp = apps.load_app(\"secondary_loop_temp_diff\")\n\n# Qualify building\nqualified, details = app.qualify(\"building_105.ttl\")\n\nif qualified:\n    # Get config\n    config = apps.get_default_config(\"secondary_loop_temp_diff\")\n\n    # Run analysis\n    results = app.analyze(\n        brick_model_path=\"building_105.ttl\",\n        timeseries_data_path=\"building_105_data.csv\",\n        config=config\n    )\n\n    # View results\n    print(f\"Mean Temp Diff: {results['summary']['mean_temp_diff']:.2f}\u00b0C\")\n    print(f\"Max Temp Diff: {results['summary']['max_temp_diff']:.2f}\u00b0C\")\n</code></pre>"},{"location":"user-guide/applications/secondary-loop/#qualification","title":"Qualification","text":""},{"location":"user-guide/applications/secondary-loop/#qualify","title":"qualify()","text":"<p>Check if building has required sensors.</p> <p>Signature: <pre><code>def qualify(brick_model_path: str) -&gt; Tuple[bool, Dict]\n</code></pre></p> <p>Returns: <pre><code>(True, {\n    'loop': 'https://hhws.example.org#Secondary_Loop',\n    'supply': 'https://hhws.example.org#Secondary_Supply_Temp',\n    'return': 'https://hhws.example.org#Secondary_Return_Temp'\n})\n</code></pre></p> <p>Example: <pre><code>qualified, details = app.qualify(\"building_105.ttl\")\n\nif qualified:\n    print(\"\u2713 Building qualified\")\n    print(f\"  Loop: {details['loop'].split('#')[-1]}\")\n    print(f\"  Supply: {details['supply'].split('#')[-1]}\")\n    print(f\"  Return: {details['return'].split('#')[-1]}\")\nelse:\n    print(\"\u2717 Building not qualified\")\n    print(\"  Missing secondary loop sensors\")\n</code></pre></p>"},{"location":"user-guide/applications/secondary-loop/#what-gets-checked","title":"What Gets Checked","text":"<p>The qualification process:</p> <ol> <li>Loads Brick model - Parses TTL file</li> <li>Finds secondary loops - Looks for <code>Hot_Water_Loop</code> entities with \"secondary\" in URI</li> <li>Searches for sensors - Finds supply and return temperature sensors</li> <li>Validates pairing - Ensures both sensors are on the same loop</li> </ol> <p>SPARQL Query Used: <pre><code>SELECT ?equipment ?supply ?return WHERE {\n    # Find secondary hot water loops\n    ?equipment rdf:type/rdfs:subClassOf* brick:Hot_Water_Loop .\n    FILTER(CONTAINS(LCASE(STR(?equipment)), \"secondary\"))\n\n    # Find supply temperature sensor\n    ?supply rdf:type/rdfs:subClassOf* ?supply_type .\n    VALUES ?supply_type {\n        brick:Supply_Water_Temperature_Sensor\n        brick:Leaving_Hot_Water_Temperature_Sensor\n        brick:Hot_Water_Supply_Temperature_Sensor\n    }\n\n    # Find return temperature sensor\n    ?return rdf:type/rdfs:subClassOf* ?return_type .\n    VALUES ?return_type {\n        brick:Return_Water_Temperature_Sensor\n        brick:Entering_Hot_Water_Temperature_Sensor\n        brick:Hot_Water_Return_Temperature_Sensor\n    }\n\n    # Both must be associated with the loop\n    {\n        ?equipment brick:hasPart ?supply .\n        ?equipment brick:hasPart ?return .\n    } UNION {\n        ?supply brick:isPointOf ?equipment .\n        ?return brick:isPointOf ?equipment .\n    }\n}\n</code></pre></p>"},{"location":"user-guide/applications/secondary-loop/#analysis_1","title":"Analysis","text":""},{"location":"user-guide/applications/secondary-loop/#analyze","title":"analyze()","text":"<p>Run temperature difference analysis.</p> <p>Signature: <pre><code>def analyze(\n    brick_model_path: str,\n    timeseries_data_path: str,\n    config: Dict\n) -&gt; Dict\n</code></pre></p> <p>Parameters: - <code>brick_model_path</code> (str): Path to Brick model TTL file - <code>timeseries_data_path</code> (str): Path to CSV data file - <code>config</code> (dict): Configuration dictionary</p> <p>Returns: <pre><code>{\n    'summary': {\n        'mean_temp_diff': 5.2,\n        'max_temp_diff': 12.1,\n        'min_temp_diff': 0.3,\n        'std_temp_diff': 2.1,\n        'data_points': 8760\n    },\n    'outputs': [\n        'results/temp_diff_plot.png',\n        'results/statistics.csv',\n        'results/hourly_data.csv'\n    ],\n    'data': {\n        'timestamps': [...],\n        'temp_diff': [...],\n        'supply_temp': [...],\n        'return_temp': [...]\n    }\n}\n</code></pre></p>"},{"location":"user-guide/applications/secondary-loop/#analysis-workflow","title":"Analysis Workflow","text":"<pre><code>graph TD\n    A[Load Brick Model] --&gt; B[Qualify Sensors]\n    B --&gt; C[Load Timeseries Data]\n    C --&gt; D[Map Sensors to Columns]\n    D --&gt; E[Calculate Temp Diff]\n    E --&gt; F[Compute Statistics]\n    F --&gt; G[Generate Plots]\n    G --&gt; H[Save Results]\n\n    style A fill:#e1f5ff\n    style E fill:#fff9c4\n    style H fill:#c8e6c9</code></pre> <p>Steps:</p> <ol> <li>QUALIFY - Check for required sensors</li> <li>FETCH - Load timeseries data</li> <li>MAP - Match sensors to data columns</li> <li>CALCULATE - Compute temperature difference</li> <li>ANALYZE - Calculate statistics</li> <li>VISUALIZE - Generate plots</li> <li>OUTPUT - Save results</li> </ol>"},{"location":"user-guide/applications/secondary-loop/#configuration","title":"Configuration","text":""},{"location":"user-guide/applications/secondary-loop/#default-configuration","title":"Default Configuration","text":"<pre><code>analysis:\n  threshold_min_delta: 0.5    # Minimum expected temp diff (\u00b0C)\n  threshold_max_delta: 10.0   # Maximum expected temp diff (\u00b0C)\n\noutput:\n  save_results: true\n  output_dir: ./results\n  export_format: csv\n  generate_plots: true\n  plot_format: png\n\ntime_range:\n  start_time: null  # Optional: \"2024-01-01 00:00:00\"\n  end_time: null    # Optional: \"2024-12-31 23:59:59\"\n</code></pre>"},{"location":"user-guide/applications/secondary-loop/#configuration-options","title":"Configuration Options","text":"Parameter Type Default Description <code>analysis.threshold_min_delta</code> float 0.5 Minimum expected temperature difference (\u00b0C) <code>analysis.threshold_max_delta</code> float 10.0 Maximum expected temperature difference (\u00b0C) <code>output.save_results</code> bool true Save analysis results to files <code>output.output_dir</code> str \"./results\" Directory for output files <code>output.export_format</code> str \"csv\" Format for data export (csv, excel) <code>output.generate_plots</code> bool true Generate visualization plots <code>output.plot_format</code> str \"png\" Plot image format (png, pdf, svg) <code>time_range.start_time</code> str null Start time for analysis (ISO format) <code>time_range.end_time</code> str null End time for analysis (ISO format)"},{"location":"user-guide/applications/secondary-loop/#custom-configuration","title":"Custom Configuration","text":"<pre><code>import yaml\n\n# Load default\nconfig = apps.get_default_config(\"secondary_loop_temp_diff\")\n\n# Customize\nconfig['analysis']['threshold_min_delta'] = 1.0\nconfig['analysis']['threshold_max_delta'] = 15.0\nconfig['output']['output_dir'] = './custom_results'\nconfig['output']['generate_plots'] = True\nconfig['time_range']['start_time'] = \"2024-01-01 00:00:00\"\nconfig['time_range']['end_time'] = \"2024-03-31 23:59:59\"\n\n# Save\nwith open('custom_config.yaml', 'w') as f:\n    yaml.dump(config, f)\n\n# Use it\nresults = app.analyze(model_path, data_path, config)\n</code></pre>"},{"location":"user-guide/applications/secondary-loop/#data-format","title":"Data Format","text":""},{"location":"user-guide/applications/secondary-loop/#timeseries-data-csv","title":"Timeseries Data CSV","text":"<p>Expected format:</p> <pre><code>datetime,secondary_supply_temp,secondary_return_temp\n2024-01-01 00:00:00,70.5,65.3\n2024-01-01 01:00:00,71.2,66.1\n2024-01-01 02:00:00,69.8,64.7\n...\n</code></pre> <p>Requirements: - datetime column - Timestamp for each row - Temperature columns - Sensor data (column names will be matched to Brick model) - Numeric values - Temperature in \u00b0C or \u00b0F - Regular intervals - Hourly, 15-min, etc. (any interval works)</p>"},{"location":"user-guide/applications/secondary-loop/#column-mapping","title":"Column Mapping","text":"<p>The app automatically maps Brick sensors to CSV columns:</p> <pre><code># Brick model has:\n# :Secondary_Supply_Temp a brick:Supply_Water_Temperature_Sensor\n\n# CSV column might be:\n# \"secondary_supply_temp\" or \"sup_temp_sec\" or \"sec_loop_supply\"\n\n# App automatically finds the match!\n</code></pre>"},{"location":"user-guide/applications/secondary-loop/#results","title":"Results","text":""},{"location":"user-guide/applications/secondary-loop/#summary-metrics","title":"Summary Metrics","text":"<pre><code>results['summary'] = {\n    'mean_temp_diff': 5.2,      # Average temperature difference\n    'max_temp_diff': 12.1,      # Maximum observed\n    'min_temp_diff': 0.3,       # Minimum observed\n    'std_temp_diff': 2.1,       # Standard deviation\n    'data_points': 8760,        # Number of data points analyzed\n    'start_time': '2024-01-01', # Analysis period start\n    'end_time': '2024-12-31'    # Analysis period end\n}\n</code></pre>"},{"location":"user-guide/applications/secondary-loop/#generated-files","title":"Generated Files","text":"<p>Typical outputs (when <code>save_results=true</code>):</p> <pre><code>results/\n\u251c\u2500\u2500 temp_diff_plot.png          # Time-series plot\n\u251c\u2500\u2500 statistics.csv              # Statistical summary\n\u251c\u2500\u2500 hourly_data.csv            # Detailed hourly results\n\u2514\u2500\u2500 distribution_plot.png       # Temperature difference distribution\n</code></pre>"},{"location":"user-guide/applications/secondary-loop/#visualizations","title":"Visualizations","text":"<p>Time-Series Plot: Shows temperature difference over time with supply and return temperatures.</p> <p>Distribution Plot: Histogram of temperature differences showing frequency distribution.</p>"},{"location":"user-guide/applications/secondary-loop/#examples","title":"Examples","text":""},{"location":"user-guide/applications/secondary-loop/#basic-analysis","title":"Basic Analysis","text":"<pre><code>from hhw_brick import apps\n\napp = apps.load_app(\"secondary_loop_temp_diff\")\n\n# Qualify\nqualified, details = app.qualify(\"building_105.ttl\")\n\nif qualified:\n    # Run with defaults\n    config = apps.get_default_config(\"secondary_loop_temp_diff\")\n    results = app.analyze(\n        \"building_105.ttl\",\n        \"building_105_data.csv\",\n        config\n    )\n\n    # Print summary\n    print(\"Analysis Summary:\")\n    for key, value in results['summary'].items():\n        print(f\"  {key}: {value}\")\n</code></pre>"},{"location":"user-guide/applications/secondary-loop/#time-range-analysis","title":"Time-Range Analysis","text":"<pre><code># Analyze specific time period\nconfig = apps.get_default_config(\"secondary_loop_temp_diff\")\nconfig['time_range']['start_time'] = \"2024-06-01 00:00:00\"\nconfig['time_range']['end_time'] = \"2024-08-31 23:59:59\"\n\nresults = app.analyze(model_path, data_path, config)\nprint(f\"Summer average temp diff: {results['summary']['mean_temp_diff']:.2f}\u00b0C\")\n</code></pre>"},{"location":"user-guide/applications/secondary-loop/#custom-output-directory","title":"Custom Output Directory","text":"<pre><code># Save to specific directory\nconfig = apps.get_default_config(\"secondary_loop_temp_diff\")\nconfig['output']['output_dir'] = f\"./results/building_105\"\nconfig['output']['generate_plots'] = True\n\nresults = app.analyze(model_path, data_path, config)\n\nprint(\"Generated files:\")\nfor file_path in results['outputs']:\n    print(f\"  - {file_path}\")\n</code></pre>"},{"location":"user-guide/applications/secondary-loop/#batch-analysis","title":"Batch Analysis","text":"<pre><code>\"\"\"\nRun secondary loop analysis on multiple buildings\n\"\"\"\nfrom pathlib import Path\nfrom hhw_brick import apps\n\napp = apps.load_app(\"secondary_loop_temp_diff\")\nconfig = apps.get_default_config(\"secondary_loop_temp_diff\")\n\nmodel_dir = Path(\"brick_models\")\ndata_dir = Path(\"timeseries_data\")\n\nfor model_file in model_dir.glob(\"*.ttl\"):\n    building_id = model_file.stem.split('_')[1]\n\n    # Qualify\n    qualified, details = app.qualify(str(model_file))\n\n    if not qualified:\n        continue\n\n    # Find data file\n    data_file = data_dir / f\"{building_id}_data.csv\"\n\n    if not data_file.exists():\n        continue\n\n    # Run analysis\n    try:\n        config['output']['output_dir'] = f\"./results/building_{building_id}\"\n        results = app.analyze(str(model_file), str(data_file), config)\n\n        print(f\"Building {building_id}:\")\n        print(f\"  Mean temp diff: {results['summary']['mean_temp_diff']:.2f}\u00b0C\")\n    except Exception as e:\n        print(f\"Building {building_id}: Failed - {e}\")\n</code></pre>"},{"location":"user-guide/applications/secondary-loop/#troubleshooting","title":"Troubleshooting","text":""},{"location":"user-guide/applications/secondary-loop/#issue-building-not-qualified","title":"Issue: Building not qualified","text":"<p>Check: 1. Building has secondary loop (URI contains \"secondary\") 2. Loop has both supply and return temperature sensors 3. Sensors use recognized Brick classes</p> <pre><code># Debug\nfrom rdflib import Graph\n\ng = Graph()\ng.parse(\"building_105.ttl\", format=\"turtle\")\n\n# Check for secondary loops\nquery = \"\"\"\nSELECT ?loop WHERE {\n    ?loop a/rdfs:subClassOf* brick:Hot_Water_Loop .\n    FILTER(CONTAINS(LCASE(STR(?loop)), \"secondary\"))\n}\n\"\"\"\n\nfor row in g.query(query):\n    print(f\"Found loop: {row.loop}\")\n</code></pre>"},{"location":"user-guide/applications/secondary-loop/#issue-column-mapping-failed","title":"Issue: Column mapping failed","text":"<p>Solution: Check CSV column names match sensors:</p> <pre><code>import pandas as pd\n\ndf = pd.read_csv(\"building_105_data.csv\")\nprint(\"Available columns:\")\nprint(df.columns.tolist())\n</code></pre>"},{"location":"user-guide/applications/secondary-loop/#issue-no-data-in-time-range","title":"Issue: No data in time range","text":"<p>Check: Time range configuration:</p> <pre><code>config['time_range']['start_time'] = \"2024-01-01 00:00:00\"\nconfig['time_range']['end_time'] = \"2024-12-31 23:59:59\"\n</code></pre>"},{"location":"user-guide/applications/secondary-loop/#best-practices","title":"Best Practices","text":""},{"location":"user-guide/applications/secondary-loop/#1-always-qualify-first","title":"1. Always Qualify First","text":"<pre><code># Good \u2713\nqualified, details = app.qualify(model_path)\nif qualified:\n    results = app.analyze(model_path, data_path, config)\n</code></pre>"},{"location":"user-guide/applications/secondary-loop/#2-check-data-quality","title":"2. Check Data Quality","text":"<pre><code># Verify data before analysis\ndf = pd.read_csv(data_path)\nprint(f\"Data points: {len(df)}\")\nprint(f\"Date range: {df['datetime'].min()} to {df['datetime'].max()}\")\n</code></pre>"},{"location":"user-guide/applications/secondary-loop/#3-save-configuration","title":"3. Save Configuration","text":"<pre><code># Save config for reproducibility\nwith open('analysis_config.yaml', 'w') as f:\n    yaml.dump(config, f)\n</code></pre>"},{"location":"user-guide/applications/secondary-loop/#next-steps","title":"Next Steps","text":"<ul> <li>Primary Loop App - Analyze primary loop temperature difference</li> <li>Running Apps Guide - Complete application workflow</li> <li>Examples - More code samples</li> </ul> <p>Continue to: Primary Loop Temperature Difference \u2192</p>"},{"location":"user-guide/conversion/","title":"CSV to Brick Conversion","text":"<p>Complete guide to converting heating hot water system data from CSV format to Brick ontology models.</p>"},{"location":"user-guide/conversion/#overview","title":"Overview","text":"<p>The conversion module transforms your building equipment data into standardized Brick ontology format. This enables:</p> <ul> <li>Interoperability - Use the same data with different tools</li> <li>Portability - Move analytics between buildings</li> <li>Standardization - Common vocabulary for all buildings</li> </ul>"},{"location":"user-guide/conversion/#conversion-process","title":"Conversion Process","text":"<pre><code>graph TD\n    A[CSV Files] --&gt;|Read| B[Parse Data]\n    B --&gt;|Identify| C[System Type]\n    C --&gt;|Map| D[Brick Classes]\n    D --&gt;|Create| E[Equipment Entities]\n    E --&gt;|Add| F[Points/Sensors]\n    F --&gt;|Link| G[Relationships]\n    G --&gt;|Generate| H[RDF Graph]\n    H --&gt;|Serialize| I[TTL File]\n\n    style A fill:#e1f5ff\n    style I fill:#c8e6c9</code></pre>"},{"location":"user-guide/conversion/#what-gets-converted","title":"What Gets Converted","text":"Source Destination Building metadata <code>rec:Building</code> entity System type Equipment classes (Boiler, HX, etc.) Sensor availability Point entities and <code>hasPoint</code> relationships System topology <code>feeds</code> relationships between equipment"},{"location":"user-guide/conversion/#conversion-methods","title":"Conversion Methods","text":""},{"location":"user-guide/conversion/#1-single-building-conversion","title":"1. Single Building Conversion","text":"<p>Convert one building at a time with full control:</p> <pre><code>from hhw_brick import CSVToBrickConverter\n\nconverter = CSVToBrickConverter()\nresult = converter.convert_to_brick(\n    metadata_csv=\"metadata.csv\",\n    vars_csv=\"vars_available_by_building.csv\",\n    building_tag=\"105\",\n    output_path=\"building_105.ttl\"\n)\n</code></pre> <p>Best for: - Testing and development - Single building focus - Custom output paths</p> <p>Learn more \u2192</p>"},{"location":"user-guide/conversion/#2-batch-conversion","title":"2. Batch Conversion","text":"<p>Convert multiple buildings at once:</p> <pre><code>from hhw_brick import BatchConverter\n\nbatch = BatchConverter()\nresults = batch.convert_all_buildings(\n    metadata_csv=\"metadata.csv\",\n    vars_csv=\"vars_available_by_building.csv\",\n    output_dir=\"brick_models/\",\n    show_progress=True\n)\n</code></pre> <p>Best for: - Portfolio-wide conversion - Production workflows - Large datasets</p> <p>Learn more \u2192</p>"},{"location":"user-guide/conversion/#3-system-type-filtering","title":"3. System Type Filtering","text":"<p>Convert only specific system types:</p> <pre><code># Convert only condensing systems\nresult = converter.convert_to_brick(\n    metadata_csv=\"metadata.csv\",\n    vars_csv=\"vars_available_by_building.csv\",\n    system_type=\"Condensing\",\n    output_path=\"condensing_systems.ttl\"\n)\n</code></pre> <p>Learn more \u2192</p>"},{"location":"user-guide/conversion/#module-components","title":"Module Components","text":""},{"location":"user-guide/conversion/#csvtobrickconverter","title":"CSVToBrickConverter","text":"<p>Main conversion class for single buildings.</p> <p>Key Methods:</p> <pre><code>converter = CSVToBrickConverter()\n\n# Primary conversion method\nresult = converter.convert_to_brick(\n    metadata_csv: str,\n    vars_csv: str,\n    system_type: Optional[str] = None,\n    building_tag: Optional[str] = None,\n    sensor_mapping: Optional[str] = None,\n    output_path: str = \"output.ttl\"\n) -&gt; Graph\n</code></pre> <p>Parameters: - <code>metadata_csv</code> - Building information file - <code>vars_csv</code> - Sensor availability file - <code>system_type</code> - Filter by system (optional) - <code>building_tag</code> - Specific building ID (optional) - <code>sensor_mapping</code> - Custom mapping file (optional) - <code>output_path</code> - Where to save the model</p> <p>Returns: RDFLib Graph object</p> <p>API Reference \u2192</p>"},{"location":"user-guide/conversion/#batchconverter","title":"BatchConverter","text":"<p>Batch processing for multiple buildings.</p> <p>Key Methods:</p> <pre><code>batch = BatchConverter()\n\n# Convert all buildings\nresults = batch.convert_all_buildings(\n    metadata_csv: str,\n    vars_csv: str,\n    output_dir: str,\n    system_type: Optional[str] = None,\n    building_tags: Optional[List[str]] = None,\n    show_progress: bool = True\n) -&gt; Dict[str, Any]\n</code></pre> <p>Returns: Statistics dictionary with: - <code>total</code> - Total buildings processed - <code>successful</code> - Successfully converted - <code>failed</code> - Failed conversions - <code>by_system</code> - Breakdown by system type - <code>total_triples</code> - Total RDF statements created</p> <p>API Reference \u2192</p>"},{"location":"user-guide/conversion/#common-workflows","title":"Common Workflows","text":""},{"location":"user-guide/conversion/#workflow-1-single-building-development","title":"Workflow 1: Single Building Development","text":"<pre><code>\"\"\"\nDevelopment workflow for a single building\n\"\"\"\nfrom hhw_brick import CSVToBrickConverter, BrickModelValidator\n\n# Convert\nconverter = CSVToBrickConverter()\nmodel = converter.convert_to_brick(\n    metadata_csv=\"metadata.csv\",\n    vars_csv=\"vars.csv\",\n    building_tag=\"105\",\n    output_path=\"building_105.ttl\"\n)\n\nprint(f\"Created {len(model)} triples\")\n\n# Validate\nvalidator = BrickModelValidator()\nis_valid, report = validator.validate_model(\"building_105.ttl\")\n\nif is_valid:\n    print(\"\u2713 Model is valid\")\nelse:\n    print(\"\u26a0 Warnings:\", report)\n</code></pre>"},{"location":"user-guide/conversion/#workflow-2-batch-production","title":"Workflow 2: Batch Production","text":"<pre><code>\"\"\"\nProduction workflow for multiple buildings\n\"\"\"\nfrom hhw_brick import BatchConverter\nfrom pathlib import Path\n\n# Set up output directory\noutput_dir = Path(\"brick_models\")\noutput_dir.mkdir(exist_ok=True)\n\n# Batch convert\nbatch = BatchConverter()\nresults = batch.convert_all_buildings(\n    metadata_csv=\"metadata.csv\",\n    vars_csv=\"vars.csv\",\n    output_dir=str(output_dir),\n    show_progress=True\n)\n\n# Report results\nprint(f\"\\nConversion Summary:\")\nprint(f\"  Total: {results['total']}\")\nprint(f\"  Successful: {results['successful']}\")\nprint(f\"  Failed: {results['failed']}\")\nprint(f\"  Total RDF triples: {results['total_triples']:,}\")\n\n# Breakdown by system\nprint(f\"\\nBy System Type:\")\nfor system, count in results['by_system'].items():\n    print(f\"  {system}: {count}\")\n</code></pre>"},{"location":"user-guide/conversion/#workflow-3-filtered-conversion","title":"Workflow 3: Filtered Conversion","text":"<pre><code>\"\"\"\nConvert only specific buildings or system types\n\"\"\"\n\n# Option 1: Specific buildings\ntarget_buildings = [\"105\", \"106\", \"107\"]\nbatch = BatchConverter()\nresults = batch.convert_all_buildings(\n    metadata_csv=\"metadata.csv\",\n    vars_csv=\"vars.csv\",\n    output_dir=\"selected_buildings/\",\n    building_tags=target_buildings\n)\n\n# Option 2: Specific system type\nresults = batch.convert_all_buildings(\n    metadata_csv=\"metadata.csv\",\n    vars_csv=\"vars.csv\",\n    output_dir=\"condensing_only/\",\n    system_type=\"Condensing\"\n)\n</code></pre>"},{"location":"user-guide/conversion/#output-files","title":"Output Files","text":""},{"location":"user-guide/conversion/#file-naming-convention","title":"File Naming Convention","text":"<p>Single building: <pre><code>building_{tag}_{system}_{variant}.ttl\n</code></pre></p> <p>Example: <code>building_105_non-condensing_h.ttl</code></p> <p>Batch conversion: <pre><code>building_{tag}_{system_abbrev}_{variant}.ttl\n</code></pre></p> <p>All files go to the specified <code>output_dir</code>.</p>"},{"location":"user-guide/conversion/#file-contents","title":"File Contents","text":"<p>Each TTL file contains:</p> <pre><code># Ontology declaration\n@prefix brick: &lt;https://brickschema.org/schema/Brick#&gt; .\n@prefix hhws: &lt;https://hhws.example.org#&gt; .\n@prefix rec: &lt;https://w3id.org/rec#&gt; .\n\n&lt;ontology_uri&gt; a owl:Ontology ;\n    owl:imports &lt;https://brickschema.org/schema/1.3/Brick&gt; .\n\n# Building entity\n:Building_105 a rec:Building ;\n    brick:hasLocation :Building_105_location .\n\n# Equipment entities\n:Boiler_Primary a brick:Boiler ;\n    brick:feeds :Heat_Exchanger .\n\n# Points/sensors\n:HW_Supply_Temp a brick:Hot_Water_Supply_Temperature_Sensor .\n\n# Relationships\n:Boiler_Primary brick:hasPoint :HW_Supply_Temp .\n</code></pre>"},{"location":"user-guide/conversion/#advanced-features","title":"Advanced Features","text":""},{"location":"user-guide/conversion/#custom-sensor-mapping","title":"Custom Sensor Mapping","text":"<p>Provide your own sensor mapping:</p> <pre><code>result = converter.convert_to_brick(\n    metadata_csv=\"metadata.csv\",\n    vars_csv=\"vars.csv\",\n    sensor_mapping=\"my_custom_mapping.yaml\",\n    output_path=\"output.ttl\"\n)\n</code></pre> <p>Learn more \u2192</p>"},{"location":"user-guide/conversion/#accessing-warnings","title":"Accessing Warnings","text":"<p>Check conversion warnings:</p> <pre><code>converter = CSVToBrickConverter()\nresult = converter.convert_to_brick(...)\n\n# Check for warnings\nif converter.validation_warnings:\n    print(\"Conversion warnings:\")\n    for warning in converter.validation_warnings:\n        print(f\"  - {warning}\")\n</code></pre>"},{"location":"user-guide/conversion/#working-with-graph-objects","title":"Working with Graph Objects","text":"<p>Use the returned Graph object directly:</p> <pre><code># Get the graph without saving\nresult_graph = converter.convert_to_brick(\n    metadata_csv=\"metadata.csv\",\n    vars_csv=\"vars.csv\",\n    building_tag=\"105\",\n    output_path=\"temp.ttl\"\n)\n\n# Query it\nquery = \"\"\"\nSELECT ?equip WHERE {\n    ?equip a brick:Boiler .\n}\n\"\"\"\n\nfor row in result_graph.query(query):\n    print(f\"Found boiler: {row.equip}\")\n\n# Serialize in different formats\nresult_graph.serialize(\"output.xml\", format=\"xml\")\nresult_graph.serialize(\"output.json\", format=\"json-ld\")\n</code></pre>"},{"location":"user-guide/conversion/#performance-considerations","title":"Performance Considerations","text":""},{"location":"user-guide/conversion/#large-datasets","title":"Large Datasets","text":"<p>For hundreds of buildings:</p> <pre><code># Use batch converter with progress bar\nbatch = BatchConverter()\nresults = batch.convert_all_buildings(\n    metadata_csv=\"large_dataset.csv\",\n    vars_csv=\"large_vars.csv\",\n    output_dir=\"models/\",\n    show_progress=True  # Shows progress bar\n)\n</code></pre>"},{"location":"user-guide/conversion/#memory-usage","title":"Memory Usage","text":"<p>Each building's graph is created and cleared independently, so memory usage stays constant regardless of dataset size.</p>"},{"location":"user-guide/conversion/#error-handling","title":"Error Handling","text":""},{"location":"user-guide/conversion/#common-errors","title":"Common Errors","text":"<p>FileNotFoundError: <pre><code>try:\n    result = converter.convert_to_brick(\n        metadata_csv=\"missing.csv\",\n        vars_csv=\"vars.csv\"\n    )\nexcept FileNotFoundError as e:\n    print(f\"File not found: {e}\")\n</code></pre></p> <p>ValueError (no data): <pre><code>try:\n    result = converter.convert_to_brick(\n        metadata_csv=\"metadata.csv\",\n        vars_csv=\"vars.csv\",\n        building_tag=\"999\"  # Doesn't exist\n    )\nexcept ValueError as e:\n    print(f\"No data for building: {e}\")\n</code></pre></p>"},{"location":"user-guide/conversion/#robust-conversion-script","title":"Robust Conversion Script","text":"<pre><code>\"\"\"\nProduction conversion script with error handling\n\"\"\"\nfrom hhw_brick import BatchConverter\nimport logging\n\n# Set up logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(levelname)s - %(message)s'\n)\n\ndef convert_with_error_handling():\n    batch = BatchConverter()\n\n    try:\n        results = batch.convert_all_buildings(\n            metadata_csv=\"metadata.csv\",\n            vars_csv=\"vars.csv\",\n            output_dir=\"brick_models/\",\n            show_progress=True\n        )\n\n        # Log results\n        logging.info(f\"Converted {results['successful']} buildings\")\n\n        if results['failed'] &gt; 0:\n            logging.warning(f\"Failed: {results['failed']}\")\n            for building in results.get('failed_buildings', []):\n                logging.error(f\"  - Building {building}\")\n\n        return results\n\n    except FileNotFoundError as e:\n        logging.error(f\"Input file not found: {e}\")\n        return None\n    except Exception as e:\n        logging.error(f\"Unexpected error: {e}\")\n        return None\n\nif __name__ == \"__main__\":\n    convert_with_error_handling()\n</code></pre>"},{"location":"user-guide/conversion/#next-steps","title":"Next Steps","text":""},{"location":"user-guide/conversion/#deep-dive-into-conversion","title":"Deep Dive into Conversion","text":"<ul> <li>Single Building - Detailed single building guide</li> <li>Batch Conversion - Multi-building workflows</li> <li>System Types - Understanding HVAC systems</li> <li>Sensor Mapping - Customize sensor mapping</li> </ul>"},{"location":"user-guide/conversion/#related-topics","title":"Related Topics","text":"<ul> <li>Validation - Validate converted models</li> <li>Examples - Working code samples</li> <li>API Reference - Complete API docs</li> </ul> <p>Continue to: Single Building Conversion \u2192</p>"},{"location":"user-guide/conversion/batch-conversion/","title":"Batch Conversion","text":"<p>Efficiently convert multiple buildings from CSV to Brick format in a single operation.</p>"},{"location":"user-guide/conversion/batch-conversion/#overview","title":"Overview","text":"<p>Batch conversion is designed for processing multiple buildings at once. It's ideal for:</p> <ul> <li>Portfolio-wide conversion - Convert all buildings in a dataset</li> <li>Production workflows - Automated, repeatable processes  </li> <li>Large-scale operations - Hundreds of buildings</li> <li>Progress tracking - Visual progress bars</li> </ul>"},{"location":"user-guide/conversion/batch-conversion/#basic-usage","title":"Basic Usage","text":""},{"location":"user-guide/conversion/batch-conversion/#minimal-example","title":"Minimal Example","text":"<p>Convert all buildings in your CSV files:</p> <pre><code>from hhw_brick import BatchConverter\n\nbatch = BatchConverter()\nresults = batch.convert_all_buildings(\n    metadata_csv=\"metadata.csv\",\n    vars_csv=\"vars_available_by_building.csv\",\n    output_dir=\"brick_models/\"\n)\n\nprint(f\"Converted {results['successful']} buildings\")\nprint(f\"Failed: {results['failed']}\")\n</code></pre> <p>Output: <pre><code>Converted 150 buildings\nFailed: 0\n</code></pre></p>"},{"location":"user-guide/conversion/batch-conversion/#with-progress-bar","title":"With Progress Bar","text":"<p>Show progress during conversion:</p> <pre><code>batch = BatchConverter()\nresults = batch.convert_all_buildings(\n    metadata_csv=\"metadata.csv\",\n    vars_csv=\"vars_available_by_building.csv\",\n    output_dir=\"brick_models/\",\n    show_progress=True  # Enable progress bar\n)\n</code></pre> <p>Output: <pre><code>Converting buildings: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 150/150 [01:23&lt;00:00,  1.80it/s]\n</code></pre></p>"},{"location":"user-guide/conversion/batch-conversion/#parameters","title":"Parameters","text":""},{"location":"user-guide/conversion/batch-conversion/#required-parameters","title":"Required Parameters","text":""},{"location":"user-guide/conversion/batch-conversion/#metadata_csv","title":"metadata_csv","text":"<p>Path to building metadata file:</p> <pre><code>metadata_csv=\"path/to/metadata.csv\"\n</code></pre>"},{"location":"user-guide/conversion/batch-conversion/#vars_csv","title":"vars_csv","text":"<p>Path to sensor availability file:</p> <pre><code>vars_csv=\"path/to/vars_available_by_building.csv\"\n</code></pre>"},{"location":"user-guide/conversion/batch-conversion/#output_dir","title":"output_dir","text":"<p>Directory where TTL files will be saved:</p> <pre><code>output_dir=\"brick_models/\"\n</code></pre> <p>The directory will be created if it doesn't exist.</p>"},{"location":"user-guide/conversion/batch-conversion/#optional-parameters","title":"Optional Parameters","text":""},{"location":"user-guide/conversion/batch-conversion/#system_type","title":"system_type","text":"<p>Filter by HVAC system type:</p> <pre><code>system_type=\"Condensing\"  # Only condensing systems\n</code></pre> <ul> <li>Type: String</li> <li>Default: <code>None</code> (convert all systems)</li> <li>Options: <code>\"Boiler\"</code>, <code>\"Non-condensing\"</code>, <code>\"Condensing\"</code>, <code>\"District HW\"</code>, <code>\"District Steam\"</code></li> </ul> <p>Example: <pre><code># Convert only district hot water systems\nresults = batch.convert_all_buildings(\n    metadata_csv=\"metadata.csv\",\n    vars_csv=\"vars.csv\",\n    output_dir=\"district_hw_models/\",\n    system_type=\"District HW\"\n)\n</code></pre></p>"},{"location":"user-guide/conversion/batch-conversion/#building_tags","title":"building_tags","text":"<p>List of specific buildings to convert:</p> <pre><code>building_tags=[\"105\", \"106\", \"107\"]\n</code></pre> <ul> <li>Type: List of strings</li> <li>Default: <code>None</code> (convert all buildings)</li> </ul> <p>Example: <pre><code># Convert only selected buildings\ntarget_buildings = [\"105\", \"106\", \"107\", \"108\", \"109\"]\n\nresults = batch.convert_all_buildings(\n    metadata_csv=\"metadata.csv\",\n    vars_csv=\"vars.csv\",\n    output_dir=\"selected_buildings/\",\n    building_tags=target_buildings\n)\n</code></pre></p>"},{"location":"user-guide/conversion/batch-conversion/#show_progress","title":"show_progress","text":"<p>Show progress bar during conversion:</p> <pre><code>show_progress=True  # Default: True\n</code></pre> <ul> <li>Type: Boolean</li> <li>Default: <code>True</code></li> <li>Uses <code>tqdm</code> for progress visualization</li> </ul>"},{"location":"user-guide/conversion/batch-conversion/#return-value","title":"Return Value","text":"<p>The <code>convert_all_buildings()</code> method returns a dictionary with statistics:</p> <pre><code>results = batch.convert_all_buildings(...)\n\n# Results structure\n{\n    'total': 150,              # Total buildings processed\n    'successful': 148,         # Successfully converted\n    'failed': 2,               # Failed conversions\n    'by_system': {             # Breakdown by system type\n        'Condensing': 85,\n        'Non-condensing': 45,\n        'District HW': 18\n    },\n    'total_triples': 156789,   # Total RDF statements created\n    'failed_buildings': [      # List of failed building IDs\n        '127', '304'\n    ],\n    'successful_files': [      # List of created files\n        'brick_models/building_105_non-condensing_h.ttl',\n        'brick_models/building_106_condensing_n.ttl',\n        # ...\n    ]\n}\n</code></pre>"},{"location":"user-guide/conversion/batch-conversion/#processing-results","title":"Processing Results","text":"<pre><code>results = batch.convert_all_buildings(...)\n\nprint(\"Conversion Summary:\")\nprint(f\"  Total: {results['total']}\")\nprint(f\"  Successful: {results['successful']}\")\nprint(f\"  Failed: {results['failed']}\")\nprint(f\"  Success Rate: {results['successful']/results['total']*100:.1f}%\")\n\nprint(\"\\nBy System Type:\")\nfor system, count in results['by_system'].items():\n    print(f\"  {system}: {count}\")\n\nif results['failed'] &gt; 0:\n    print(\"\\nFailed Buildings:\")\n    for building_id in results['failed_buildings']:\n        print(f\"  - Building {building_id}\")\n</code></pre>"},{"location":"user-guide/conversion/batch-conversion/#output-files","title":"Output Files","text":""},{"location":"user-guide/conversion/batch-conversion/#file-naming","title":"File Naming","text":"<p>Files are automatically named using the pattern:</p> <pre><code>building_{tag}_{system_abbreviation}_{variant}.ttl\n</code></pre> <p>Examples: - <code>building_105_non-condensing_h.ttl</code> - <code>building_106_condensing_n.ttl</code> - <code>building_107_district_hw_aa.ttl</code></p>"},{"location":"user-guide/conversion/batch-conversion/#output-directory-structure","title":"Output Directory Structure","text":"<pre><code>brick_models/\n\u251c\u2500\u2500 building_105_non-condensing_h.ttl\n\u251c\u2500\u2500 building_106_condensing_n.ttl\n\u251c\u2500\u2500 building_107_condensing_an.ttl\n\u251c\u2500\u2500 building_108_district_hw_aa.ttl\n\u2514\u2500\u2500 ...\n</code></pre>"},{"location":"user-guide/conversion/batch-conversion/#common-workflows","title":"Common Workflows","text":""},{"location":"user-guide/conversion/batch-conversion/#workflow-1-convert-all-buildings","title":"Workflow 1: Convert All Buildings","text":"<pre><code>\"\"\"\nSimple batch conversion of all buildings\n\"\"\"\nfrom hhw_brick import BatchConverter\nfrom pathlib import Path\n\n# Create output directory\noutput_dir = Path(\"brick_models\")\noutput_dir.mkdir(exist_ok=True)\n\n# Convert\nbatch = BatchConverter()\nresults = batch.convert_all_buildings(\n    metadata_csv=\"metadata.csv\",\n    vars_csv=\"vars_available_by_building.csv\",\n    output_dir=str(output_dir),\n    show_progress=True\n)\n\n# Report\nprint(f\"\\n{'='*60}\")\nprint(\"Conversion Complete!\")\nprint(f\"{'='*60}\")\nprint(f\"Total Buildings: {results['total']}\")\nprint(f\"Successful: {results['successful']}\")\nprint(f\"Failed: {results['failed']}\")\nprint(f\"Total RDF Triples: {results['total_triples']:,}\")\n\nif results['failed'] &gt; 0:\n    print(f\"\\n\u26a0 Failed buildings: {results['failed_buildings']}\")\n</code></pre>"},{"location":"user-guide/conversion/batch-conversion/#workflow-2-filter-by-system-type","title":"Workflow 2: Filter by System Type","text":"<pre><code>\"\"\"\nConvert buildings of specific system types\n\"\"\"\nfrom hhw_brick import BatchConverter\n\n# Convert condensing systems only\nbatch = BatchConverter()\ncondensing_results = batch.convert_all_buildings(\n    metadata_csv=\"metadata.csv\",\n    vars_csv=\"vars.csv\",\n    output_dir=\"condensing_systems/\",\n    system_type=\"Condensing\",\n    show_progress=True\n)\n\nprint(f\"Converted {condensing_results['successful']} condensing systems\")\n\n# Convert district systems separately\ndistrict_results = batch.convert_all_buildings(\n    metadata_csv=\"metadata.csv\",\n    vars_csv=\"vars.csv\",\n    output_dir=\"district_systems/\",\n    system_type=\"District HW\",\n    show_progress=True\n)\n\nprint(f\"Converted {district_results['successful']} district systems\")\n</code></pre>"},{"location":"user-guide/conversion/batch-conversion/#workflow-3-convert-by-organization","title":"Workflow 3: Convert by Organization","text":"<pre><code>\"\"\"\nBatch convert buildings grouped by organization\n\"\"\"\nimport pandas as pd\nfrom hhw_brick import BatchConverter\n\n# Load metadata\nmetadata = pd.read_csv(\"metadata.csv\")\n\n# Get unique organizations\norganizations = metadata['org'].unique()\n\nbatch = BatchConverter()\n\nfor org in organizations:\n    print(f\"\\nConverting buildings for: {org}\")\n\n    # Get building IDs for this org\n    org_buildings = metadata[metadata['org'] == org]['tag'].astype(str).tolist()\n\n    # Create org-specific output directory\n    output_dir = f\"brick_models/{org.replace(' ', '_')}\"\n\n    # Convert\n    results = batch.convert_all_buildings(\n        metadata_csv=\"metadata.csv\",\n        vars_csv=\"vars.csv\",\n        output_dir=output_dir,\n        building_tags=org_buildings,\n        show_progress=True\n    )\n\n    print(f\"  Converted: {results['successful']}/{results['total']}\")\n</code></pre>"},{"location":"user-guide/conversion/batch-conversion/#workflow-4-production-with-logging","title":"Workflow 4: Production with Logging","text":"<pre><code>\"\"\"\nProduction batch conversion with comprehensive logging\n\"\"\"\nfrom hhw_brick import BatchConverter\nimport logging\nfrom datetime import datetime\nfrom pathlib import Path\n\n# Set up logging\nlog_file = f\"conversion_{datetime.now().strftime('%Y%m%d_%H%M%S')}.log\"\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(levelname)s - %(message)s',\n    handlers=[\n        logging.FileHandler(log_file),\n        logging.StreamHandler()\n    ]\n)\n\ndef production_conversion():\n    \"\"\"Production batch conversion with error handling.\"\"\"\n\n    logging.info(\"Starting batch conversion\")\n\n    # Set up paths\n    output_dir = Path(\"brick_models_production\")\n    output_dir.mkdir(exist_ok=True)\n\n    try:\n        # Convert\n        batch = BatchConverter()\n        results = batch.convert_all_buildings(\n            metadata_csv=\"metadata.csv\",\n            vars_csv=\"vars.csv\",\n            output_dir=str(output_dir),\n            show_progress=True\n        )\n\n        # Log results\n        logging.info(f\"Conversion complete: {results['successful']}/{results['total']}\")\n        logging.info(f\"Total triples created: {results['total_triples']:,}\")\n\n        # Log by system type\n        logging.info(\"Breakdown by system:\")\n        for system, count in results['by_system'].items():\n            logging.info(f\"  {system}: {count}\")\n\n        # Log failures\n        if results['failed'] &gt; 0:\n            logging.warning(f\"{results['failed']} buildings failed:\")\n            for building_id in results['failed_buildings']:\n                logging.warning(f\"  - Building {building_id}\")\n\n        # Save results summary\n        summary_file = output_dir / \"conversion_summary.txt\"\n        with open(summary_file, 'w') as f:\n            f.write(f\"Conversion Date: {datetime.now()}\\n\")\n            f.write(f\"Total: {results['total']}\\n\")\n            f.write(f\"Successful: {results['successful']}\\n\")\n            f.write(f\"Failed: {results['failed']}\\n\")\n            f.write(f\"Total Triples: {results['total_triples']:,}\\n\")\n\n        logging.info(f\"Summary saved to {summary_file}\")\n        return results\n\n    except FileNotFoundError as e:\n        logging.error(f\"Input file not found: {e}\")\n        return None\n    except Exception as e:\n        logging.error(f\"Conversion failed: {e}\", exc_info=True)\n        return None\n\nif __name__ == \"__main__\":\n    results = production_conversion()\n</code></pre>"},{"location":"user-guide/conversion/batch-conversion/#advanced-usage","title":"Advanced Usage","text":""},{"location":"user-guide/conversion/batch-conversion/#parallel-processing-custom-implementation","title":"Parallel Processing (Custom Implementation)","text":"<p>For very large datasets, you can implement parallel processing:</p> <pre><code>\"\"\"\nCustom parallel batch conversion\n\"\"\"\nfrom hhw_brick import CSVToBrickConverter\nimport pandas as pd\nfrom multiprocessing import Pool\nfrom pathlib import Path\n\ndef convert_single_building(args):\n    \"\"\"Convert a single building (for use with multiprocessing).\"\"\"\n    building_tag, metadata_csv, vars_csv, output_dir = args\n\n    try:\n        converter = CSVToBrickConverter()\n        result = converter.convert_to_brick(\n            metadata_csv=metadata_csv,\n            vars_csv=vars_csv,\n            building_tag=building_tag,\n            output_path=f\"{output_dir}/building_{building_tag}.ttl\"\n        )\n        return building_tag, 'success', len(result)\n    except Exception as e:\n        return building_tag, 'failed', str(e)\n\ndef parallel_batch_conversion(metadata_csv, vars_csv, output_dir, num_workers=4):\n    \"\"\"Batch convert using multiple processes.\"\"\"\n\n    # Get building IDs\n    metadata = pd.read_csv(metadata_csv)\n    building_ids = metadata['tag'].astype(str).tolist()\n\n    # Create output directory\n    Path(output_dir).mkdir(exist_ok=True)\n\n    # Prepare arguments\n    args = [\n        (bid, metadata_csv, vars_csv, output_dir)\n        for bid in building_ids\n    ]\n\n    # Process in parallel\n    with Pool(num_workers) as pool:\n        results = pool.map(convert_single_building, args)\n\n    # Summarize\n    successful = sum(1 for _, status, _ in results if status == 'success')\n    failed = sum(1 for _, status, _ in results if status == 'failed')\n\n    print(f\"Parallel conversion complete:\")\n    print(f\"  Workers: {num_workers}\")\n    print(f\"  Successful: {successful}\")\n    print(f\"  Failed: {failed}\")\n\n    return results\n\n# Use it\nresults = parallel_batch_conversion(\n    \"metadata.csv\",\n    \"vars.csv\",\n    \"brick_models/\",\n    num_workers=8\n)\n</code></pre>"},{"location":"user-guide/conversion/batch-conversion/#incremental-conversion","title":"Incremental Conversion","text":"<p>Convert only new buildings:</p> <pre><code>\"\"\"\nIncremental conversion - skip already converted buildings\n\"\"\"\nfrom hhw_brick import BatchConverter\nimport pandas as pd\nfrom pathlib import Path\n\ndef incremental_conversion(metadata_csv, vars_csv, output_dir):\n    \"\"\"Convert only buildings not already in output directory.\"\"\"\n\n    # Get all buildings\n    metadata = pd.read_csv(metadata_csv)\n    all_buildings = set(metadata['tag'].astype(str))\n\n    # Get already converted buildings\n    output_path = Path(output_dir)\n    if output_path.exists():\n        existing_files = list(output_path.glob(\"building_*.ttl\"))\n        converted = set()\n        for file in existing_files:\n            # Extract building ID from filename\n            parts = file.stem.split('_')\n            if len(parts) &gt; 1:\n                converted.add(parts[1])  # building_105_... -&gt; 105\n    else:\n        converted = set()\n        output_path.mkdir(exist_ok=True)\n\n    # Find new buildings\n    new_buildings = all_buildings - converted\n\n    print(f\"Total buildings: {len(all_buildings)}\")\n    print(f\"Already converted: {len(converted)}\")\n    print(f\"New buildings: {len(new_buildings)}\")\n\n    if not new_buildings:\n        print(\"No new buildings to convert\")\n        return\n\n    # Convert new buildings\n    batch = BatchConverter()\n    results = batch.convert_all_buildings(\n        metadata_csv=metadata_csv,\n        vars_csv=vars_csv,\n        output_dir=output_dir,\n        building_tags=list(new_buildings),\n        show_progress=True\n    )\n\n    print(f\"\\nConverted {results['successful']} new buildings\")\n    return results\n\n# Use it\nresults = incremental_conversion(\n    \"metadata.csv\",\n    \"vars.csv\",\n    \"brick_models/\"\n)\n</code></pre>"},{"location":"user-guide/conversion/batch-conversion/#performance","title":"Performance","text":""},{"location":"user-guide/conversion/batch-conversion/#benchmarks","title":"Benchmarks","text":"<p>Typical performance on a standard laptop:</p> Buildings Time Rate 10 ~6 seconds 1.7 builds/sec 50 ~28 seconds 1.8 builds/sec 100 ~55 seconds 1.8 builds/sec 500 ~4.5 minutes 1.9 builds/sec"},{"location":"user-guide/conversion/batch-conversion/#optimization-tips","title":"Optimization Tips","text":"<ol> <li>Use SSD storage - Faster file I/O</li> <li>Disable progress bar for scripts - Slight speedup</li> <li>Consider parallel processing - For very large datasets (&gt;1000 buildings)</li> <li>Close other applications - More memory available</li> </ol>"},{"location":"user-guide/conversion/batch-conversion/#troubleshooting","title":"Troubleshooting","text":""},{"location":"user-guide/conversion/batch-conversion/#issue-no-such-file-or-directory","title":"Issue: \"No such file or directory\"","text":"<p>Cause: Output directory path is invalid</p> <p>Solution: <pre><code>from pathlib import Path\n\n# Create directory first\noutput_dir = Path(\"brick_models\")\noutput_dir.mkdir(parents=True, exist_ok=True)\n\n# Then convert\nresults = batch.convert_all_buildings(\n    metadata_csv=\"metadata.csv\",\n    vars_csv=\"vars.csv\",\n    output_dir=str(output_dir)\n)\n</code></pre></p>"},{"location":"user-guide/conversion/batch-conversion/#issue-some-buildings-failed","title":"Issue: Some buildings failed","text":"<p>Cause: Data issues in specific buildings</p> <p>Solution: <pre><code>results = batch.convert_all_buildings(...)\n\nif results['failed'] &gt; 0:\n    print(f\"Failed buildings: {results['failed_buildings']}\")\n\n    # Try converting failed buildings individually for debugging\n    from hhw_brick import CSVToBrickConverter\n    converter = CSVToBrickConverter()\n\n    for building_id in results['failed_buildings']:\n        try:\n            converter.convert_to_brick(\n                metadata_csv=\"metadata.csv\",\n                vars_csv=\"vars.csv\",\n                building_tag=building_id,\n                output_path=f\"debug_building_{building_id}.ttl\"\n            )\n        except Exception as e:\n            print(f\"Building {building_id} error: {e}\")\n</code></pre></p>"},{"location":"user-guide/conversion/batch-conversion/#issue-progress-bar-not-showing","title":"Issue: Progress bar not showing","text":"<p>Cause: <code>tqdm</code> not installed</p> <p>Solution: <pre><code>pip install tqdm\n</code></pre></p> <p>Or disable progress bar: <pre><code>results = batch.convert_all_buildings(\n    ...,\n    show_progress=False\n)\n</code></pre></p>"},{"location":"user-guide/conversion/batch-conversion/#best-practices","title":"Best Practices","text":""},{"location":"user-guide/conversion/batch-conversion/#1-test-first","title":"1. Test First","text":"<p>Test on a small subset before full conversion:</p> <pre><code># Test with 10 buildings\ntest_buildings = [\"105\", \"106\", \"107\", \"108\", \"109\"]\n\nresults = batch.convert_all_buildings(\n    metadata_csv=\"metadata.csv\",\n    vars_csv=\"vars.csv\",\n    output_dir=\"test_output/\",\n    building_tags=test_buildings\n)\n\n# If successful, run full conversion\nif results['failed'] == 0:\n    results = batch.convert_all_buildings(\n        metadata_csv=\"metadata.csv\",\n        vars_csv=\"vars.csv\",\n        output_dir=\"production_output/\"\n    )\n</code></pre>"},{"location":"user-guide/conversion/batch-conversion/#2-separate-by-system-type","title":"2. Separate by System Type","text":"<p>Organize outputs by system type:</p> <pre><code>system_types = [\"Condensing\", \"Non-condensing\", \"District HW\"]\n\nfor system in system_types:\n    results = batch.convert_all_buildings(\n        metadata_csv=\"metadata.csv\",\n        vars_csv=\"vars.csv\",\n        output_dir=f\"brick_models/{system.lower().replace(' ', '_')}/\",\n        system_type=system\n    )\n</code></pre>"},{"location":"user-guide/conversion/batch-conversion/#3-keep-conversion-logs","title":"3. Keep Conversion Logs","text":"<p>Save detailed logs for auditing:</p> <pre><code>import json\nfrom datetime import datetime\n\nresults = batch.convert_all_buildings(...)\n\n# Save results\nlog_data = {\n    'timestamp': datetime.now().isoformat(),\n    'results': results,\n    'metadata_file': 'metadata.csv',\n    'vars_file': 'vars.csv'\n}\n\nwith open('conversion_log.json', 'w') as f:\n    json.dump(log_data, f, indent=2)\n</code></pre>"},{"location":"user-guide/conversion/batch-conversion/#next-steps","title":"Next Steps","text":"<ul> <li>System Types - Learn about different HVAC systems</li> <li>Sensor Mapping - Customize sensor mappings</li> <li>Validation - Validate converted models</li> <li>Examples - More code examples</li> </ul> <p>Continue to: System Types \u2192</p>"},{"location":"user-guide/conversion/sensor-mapping/","title":"Sensor Mapping","text":"<p>Customize how CSV sensor columns map to Brick ontology classes.</p>"},{"location":"user-guide/conversion/sensor-mapping/#overview","title":"Overview","text":"<p>The sensor mapping file (<code>sensor_to_brick_mapping.yaml</code>) defines how CSV column names translate to Brick point classes. This allows you to:</p> <ul> <li>Customize mappings for your specific data</li> <li>Add new sensor types not in the default mapping</li> <li>Modify Brick classes for existing sensors</li> <li>Document sensor meanings with descriptions</li> </ul>"},{"location":"user-guide/conversion/sensor-mapping/#default-mapping-file","title":"Default Mapping File","text":"<p>The package includes a default mapping at: <pre><code>hhw_brick/conversion/sensor_to_brick_mapping.yaml\n</code></pre></p> <p>This is used automatically unless you provide a custom file.</p>"},{"location":"user-guide/conversion/sensor-mapping/#mapping-file-format","title":"Mapping File Format","text":""},{"location":"user-guide/conversion/sensor-mapping/#yaml-structure","title":"YAML Structure","text":"<p>Each sensor mapping has four fields:</p> <pre><code>sensor_name:\n  brick_class: \"brick:ClassName\"\n  description: \"Human-readable description\"\n  unit: \"UNIT_TYPE\"\n  equipment: \"equipment_type\"\n</code></pre>"},{"location":"user-guide/conversion/sensor-mapping/#example-entry","title":"Example Entry","text":"<pre><code>hw_supply_temp:\n  brick_class: \"brick:Hot_Water_Supply_Temperature_Sensor\"\n  description: \"Hot water supply temperature\"\n  unit: \"DEG_C\"\n  equipment: \"primary_loop\"\n</code></pre>"},{"location":"user-guide/conversion/sensor-mapping/#fields-explained","title":"Fields Explained","text":"Field Required Description Example <code>brick_class</code> Yes Full Brick class name <code>brick:Hot_Water_Supply_Temperature_Sensor</code> <code>description</code> Yes Sensor description <code>\"Primary loop supply temperature\"</code> <code>unit</code> No Unit of measurement <code>DEG_C</code>, <code>L_PER_MIN</code>, <code>KW</code> <code>equipment</code> No Associated equipment <code>boiler</code>, <code>heat_exchanger</code>, <code>pump</code>"},{"location":"user-guide/conversion/sensor-mapping/#default-mappings","title":"Default Mappings","text":""},{"location":"user-guide/conversion/sensor-mapping/#temperature-sensors","title":"Temperature Sensors","text":"<pre><code># Primary Loop\nhw_supply_temp:\n  brick_class: \"brick:Hot_Water_Supply_Temperature_Sensor\"\n  description: \"Primary hot water supply temperature\"\n  unit: \"DEG_C\"\n  equipment: \"primary_loop\"\n\nhw_return_temp:\n  brick_class: \"brick:Hot_Water_Return_Temperature_Sensor\"\n  description: \"Primary hot water return temperature\"\n  unit: \"DEG_C\"\n  equipment: \"primary_loop\"\n\n# Secondary Loop\nsecondary_supply_temp:\n  brick_class: \"brick:Hot_Water_Supply_Temperature_Sensor\"\n  description: \"Secondary loop supply temperature\"\n  unit: \"DEG_C\"\n  equipment: \"secondary_loop\"\n\nsecondary_return_temp:\n  brick_class: \"brick:Hot_Water_Return_Temperature_Sensor\"\n  description: \"Secondary loop return temperature\"\n  unit: \"DEG_C\"\n  equipment: \"secondary_loop\"\n\n# Outdoor\noutdoor_temp:\n  brick_class: \"brick:Outside_Air_Temperature_Sensor\"\n  description: \"Outdoor air temperature\"\n  unit: \"DEG_C\"\n  equipment: \"building\"\n</code></pre>"},{"location":"user-guide/conversion/sensor-mapping/#flow-sensors","title":"Flow Sensors","text":"<pre><code>hw_flow:\n  brick_class: \"brick:Water_Flow_Sensor\"\n  description: \"Primary hot water flow rate\"\n  unit: \"L_PER_MIN\"\n  equipment: \"primary_loop\"\n\nsecondary_flow:\n  brick_class: \"brick:Water_Flow_Sensor\"\n  description: \"Secondary loop flow rate\"\n  unit: \"L_PER_MIN\"\n  equipment: \"secondary_loop\"\n</code></pre>"},{"location":"user-guide/conversion/sensor-mapping/#numbered-sensors-boilers","title":"Numbered Sensors (Boilers)","text":"<pre><code>sup1:\n  brick_class: \"brick:Leaving_Hot_Water_Temperature_Sensor\"\n  description: \"Supply water temperature leaving boiler 1\"\n  unit: \"DEG_C\"\n  equipment: \"boiler\"\n\nret1:\n  brick_class: \"brick:Entering_Hot_Water_Temperature_Sensor\"\n  description: \"Return water temperature entering boiler 1\"\n  unit: \"DEG_C\"\n  equipment: \"boiler\"\n\nfire1:\n  brick_class: \"brick:Firing_Rate_Sensor\"\n  description: \"Boiler 1 firing rate\"\n  unit: \"PERCENT\"\n  equipment: \"boiler\"\n</code></pre>"},{"location":"user-guide/conversion/sensor-mapping/#pump-sensors","title":"Pump Sensors","text":"<pre><code>pmp1_pwr:\n  brick_class: \"brick:Power_Sensor\"\n  description: \"Pump 1 power consumption\"\n  unit: \"KW\"\n  equipment: \"pump\"\n\npmp1_spd:\n  brick_class: \"brick:Speed_Sensor\"\n  description: \"Pump 1 speed\"\n  unit: \"PERCENT\"\n  equipment: \"pump\"\n\npmp1_vfd:\n  brick_class: \"brick:VFD_Enable_Command\"\n  description: \"Pump 1 VFD enable status\"\n  unit: \"BINARY\"\n  equipment: \"pump\"\n</code></pre>"},{"location":"user-guide/conversion/sensor-mapping/#valves","title":"Valves","text":"<pre><code>hw_valve:\n  brick_class: \"brick:Heating_Valve\"\n  description: \"Hot water control valve position\"\n  unit: \"PERCENT\"\n  equipment: \"valve\"\n</code></pre>"},{"location":"user-guide/conversion/sensor-mapping/#creating-custom-mappings","title":"Creating Custom Mappings","text":""},{"location":"user-guide/conversion/sensor-mapping/#step-1-copy-default-file","title":"Step 1: Copy Default File","text":"<p>Start with the default as a template:</p> <pre><code>cp hhw_brick/conversion/sensor_to_brick_mapping.yaml custom_mapping.yaml\n</code></pre>"},{"location":"user-guide/conversion/sensor-mapping/#step-2-edit-mappings","title":"Step 2: Edit Mappings","text":"<p>Open <code>custom_mapping.yaml</code> and modify:</p> <pre><code># Add your custom sensors\nchilled_water_supply:\n  brick_class: \"brick:Chilled_Water_Supply_Temperature_Sensor\"\n  description: \"Chilled water supply temperature\"\n  unit: \"DEG_C\"\n  equipment: \"chiller\"\n\nchilled_water_return:\n  brick_class: \"brick:Chilled_Water_Return_Temperature_Sensor\"\n  description: \"Chilled water return temperature\"\n  unit: \"DEG_C\"\n  equipment: \"chiller\"\n\n# Modify existing mappings\noutdoor_temp:\n  brick_class: \"brick:Outside_Air_Temperature_Sensor\"\n  description: \"Custom outdoor sensor at roof level\"  # Changed\n  unit: \"DEG_F\"  # Changed to Fahrenheit\n  equipment: \"building\"\n</code></pre>"},{"location":"user-guide/conversion/sensor-mapping/#step-3-use-custom-mapping","title":"Step 3: Use Custom Mapping","text":"<pre><code>from hhw_brick import CSVToBrickConverter\n\nconverter = CSVToBrickConverter()\nresult = converter.convert_to_brick(\n    metadata_csv=\"metadata.csv\",\n    vars_csv=\"vars.csv\",\n    sensor_mapping=\"custom_mapping.yaml\",  # Your custom file\n    output_path=\"output.ttl\"\n)\n</code></pre>"},{"location":"user-guide/conversion/sensor-mapping/#common-customizations","title":"Common Customizations","text":""},{"location":"user-guide/conversion/sensor-mapping/#add-building-specific-sensors","title":"Add Building-Specific Sensors","text":"<p>Your building has unique sensors:</p> <pre><code># custom_mapping.yaml\n\n# Add solar collector sensors\nsolar_panel_temp:\n  brick_class: \"brick:Solar_Panel_Temperature_Sensor\"\n  description: \"Solar thermal panel temperature\"\n  unit: \"DEG_C\"\n  equipment: \"solar_collector\"\n\nsolar_flow:\n  brick_class: \"brick:Water_Flow_Sensor\"\n  description: \"Solar collector flow rate\"\n  unit: \"L_PER_MIN\"\n  equipment: \"solar_collector\"\n\n# Add thermal storage sensors\nstorage_tank_top:\n  brick_class: \"brick:Temperature_Sensor\"\n  description: \"Thermal storage tank top temperature\"\n  unit: \"DEG_C\"\n  equipment: \"thermal_storage\"\n\nstorage_tank_bottom:\n  brick_class: \"brick:Temperature_Sensor\"\n  description: \"Thermal storage tank bottom temperature\"\n  unit: \"DEG_C\"\n  equipment: \"thermal_storage\"\n</code></pre>"},{"location":"user-guide/conversion/sensor-mapping/#change-units","title":"Change Units","text":"<p>Convert between measurement systems:</p> <pre><code># Use Fahrenheit instead of Celsius\nhw_supply_temp:\n  brick_class: \"brick:Hot_Water_Supply_Temperature_Sensor\"\n  description: \"Hot water supply temperature\"\n  unit: \"DEG_F\"  # Changed from DEG_C\n  equipment: \"primary_loop\"\n\n# Use gallons per minute instead of liters\nhw_flow:\n  brick_class: \"brick:Water_Flow_Sensor\"\n  description: \"Primary hot water flow rate\"\n  unit: \"GAL_PER_MIN\"  # Changed from L_PER_MIN\n  equipment: \"primary_loop\"\n</code></pre>"},{"location":"user-guide/conversion/sensor-mapping/#use-more-specific-classes","title":"Use More Specific Classes","text":"<p>Brick has many specialized classes:</p> <pre><code># Instead of generic Temperature_Sensor\n# Use specific class:\nsupply_temp:\n  brick_class: \"brick:Leaving_Hot_Water_Temperature_Sensor\"  # Specific\n  # vs brick:Temperature_Sensor (generic)\n  description: \"Hot water leaving temperature\"\n  unit: \"DEG_C\"\n  equipment: \"boiler\"\n\n# Instead of generic Sensor\n# Use specific measurement type:\nenergy_meter:\n  brick_class: \"brick:Thermal_Energy_Sensor\"  # Specific\n  # vs brick:Sensor (generic)\n  description: \"Thermal energy meter\"\n  unit: \"KWH\"\n  equipment: \"primary_loop\"\n</code></pre>"},{"location":"user-guide/conversion/sensor-mapping/#brick-class-reference","title":"Brick Class Reference","text":""},{"location":"user-guide/conversion/sensor-mapping/#common-brick-classes","title":"Common Brick Classes","text":""},{"location":"user-guide/conversion/sensor-mapping/#temperature","title":"Temperature","text":"<ul> <li><code>brick:Temperature_Sensor</code> - Generic</li> <li><code>brick:Hot_Water_Supply_Temperature_Sensor</code> - HW supply</li> <li><code>brick:Hot_Water_Return_Temperature_Sensor</code> - HW return</li> <li><code>brick:Leaving_Hot_Water_Temperature_Sensor</code> - Equipment leaving</li> <li><code>brick:Entering_Hot_Water_Temperature_Sensor</code> - Equipment entering</li> <li><code>brick:Outside_Air_Temperature_Sensor</code> - Outdoor</li> <li><code>brick:Chilled_Water_Supply_Temperature_Sensor</code> - CHW supply</li> <li><code>brick:Chilled_Water_Return_Temperature_Sensor</code> - CHW return</li> </ul>"},{"location":"user-guide/conversion/sensor-mapping/#flow","title":"Flow","text":"<ul> <li><code>brick:Water_Flow_Sensor</code> - Water flow rate</li> <li><code>brick:Air_Flow_Sensor</code> - Air flow rate</li> <li><code>brick:Steam_Flow_Sensor</code> - Steam flow</li> </ul>"},{"location":"user-guide/conversion/sensor-mapping/#pressure","title":"Pressure","text":"<ul> <li><code>brick:Water_Pressure_Sensor</code> - Water pressure</li> <li><code>brick:Steam_Pressure_Sensor</code> - Steam pressure</li> <li><code>brick:Differential_Pressure_Sensor</code> - Pressure difference</li> </ul>"},{"location":"user-guide/conversion/sensor-mapping/#powerenergy","title":"Power/Energy","text":"<ul> <li><code>brick:Power_Sensor</code> - Electrical power</li> <li><code>brick:Energy_Sensor</code> - Energy consumption</li> <li><code>brick:Thermal_Power_Sensor</code> - Thermal power</li> <li><code>brick:Thermal_Energy_Sensor</code> - Thermal energy</li> </ul>"},{"location":"user-guide/conversion/sensor-mapping/#control","title":"Control","text":"<ul> <li><code>brick:Valve_Command</code> - Valve position</li> <li><code>brick:Heating_Valve</code> - Heating valve</li> <li><code>brick:VFD_Enable_Command</code> - VFD status</li> <li><code>brick:Speed_Setpoint</code> - Speed setpoint</li> </ul>"},{"location":"user-guide/conversion/sensor-mapping/#status","title":"Status","text":"<ul> <li><code>brick:Run_Status</code> - Equipment running</li> <li><code>brick:Enable_Status</code> - Equipment enabled</li> <li><code>brick:Alarm_Status</code> - Alarm condition</li> </ul>"},{"location":"user-guide/conversion/sensor-mapping/#finding-brick-classes","title":"Finding Brick Classes","text":"<p>Browse online: Brick Schema Explorer</p> <p>Search in Python: <pre><code>from brickschema import Graph\n\ng = Graph(load_brick=True)\n\n# Find all sensor types\nquery = \"\"\"\nPREFIX brick: &lt;https://brickschema.org/schema/Brick#&gt;\nSELECT ?sensor WHERE {\n    ?sensor rdfs:subClassOf* brick:Sensor .\n}\n\"\"\"\n\nfor row in g.query(query):\n    print(row.sensor)\n</code></pre></p>"},{"location":"user-guide/conversion/sensor-mapping/#validation","title":"Validation","text":""},{"location":"user-guide/conversion/sensor-mapping/#check-your-mapping","title":"Check Your Mapping","text":"<p>Validate mapping file structure:</p> <pre><code>import yaml\n\n# Load mapping\nwith open('custom_mapping.yaml', 'r') as f:\n    mapping = yaml.safe_load(f)\n\n# Check required fields\nfor sensor, config in mapping.items():\n    if 'brick_class' not in config:\n        print(f\"\u274c {sensor}: missing brick_class\")\n    if 'description' not in config:\n        print(f\"\u26a0\ufe0f  {sensor}: missing description (optional)\")\n\n    # Check brick_class format\n    if not config['brick_class'].startswith('brick:'):\n        print(f\"\u26a0\ufe0f  {sensor}: brick_class should start with 'brick:'\")\n</code></pre>"},{"location":"user-guide/conversion/sensor-mapping/#test-custom-mapping","title":"Test Custom Mapping","text":"<p>Test with a small dataset:</p> <pre><code>from hhw_brick import CSVToBrickConverter\n\nconverter = CSVToBrickConverter()\n\ntry:\n    result = converter.convert_to_brick(\n        metadata_csv=\"test_metadata.csv\",\n        vars_csv=\"test_vars.csv\",\n        building_tag=\"105\",\n        sensor_mapping=\"custom_mapping.yaml\",\n        output_path=\"test_output.ttl\"\n    )\n    print(f\"\u2713 Custom mapping works! Created {len(result)} triples\")\nexcept Exception as e:\n    print(f\"\u274c Error with custom mapping: {e}\")\n</code></pre>"},{"location":"user-guide/conversion/sensor-mapping/#complete-custom-mapping-example","title":"Complete Custom Mapping Example","text":""},{"location":"user-guide/conversion/sensor-mapping/#building-with-geothermal-system","title":"Building with Geothermal System","text":"<pre><code># geothermal_mapping.yaml\n\n# Geothermal loop sensors\ngeo_source_supply:\n  brick_class: \"brick:Leaving_Water_Temperature_Sensor\"\n  description: \"Geothermal source loop supply temperature\"\n  unit: \"DEG_C\"\n  equipment: \"geothermal_loop\"\n\ngeo_source_return:\n  brick_class: \"brick:Entering_Water_Temperature_Sensor\"\n  description: \"Geothermal source loop return temperature\"\n  unit: \"DEG_C\"\n  equipment: \"geothermal_loop\"\n\ngeo_flow:\n  brick_class: \"brick:Water_Flow_Sensor\"\n  description: \"Geothermal loop flow rate\"\n  unit: \"L_PER_MIN\"\n  equipment: \"geothermal_loop\"\n\n# Heat pump sensors\nhp_leaving_temp:\n  brick_class: \"brick:Leaving_Hot_Water_Temperature_Sensor\"\n  description: \"Heat pump leaving water temperature\"\n  unit: \"DEG_C\"\n  equipment: \"heat_pump\"\n\nhp_entering_temp:\n  brick_class: \"brick:Entering_Hot_Water_Temperature_Sensor\"\n  description: \"Heat pump entering water temperature\"\n  unit: \"DEG_C\"\n  equipment: \"heat_pump\"\n\nhp_power:\n  brick_class: \"brick:Power_Sensor\"\n  description: \"Heat pump electrical power\"\n  unit: \"KW\"\n  equipment: \"heat_pump\"\n\nhp_cop:\n  brick_class: \"brick:Sensor\"\n  description: \"Heat pump coefficient of performance\"\n  unit: \"DIMENSIONLESS\"\n  equipment: \"heat_pump\"\n\n# Building loop (same as standard)\nhw_supply_temp:\n  brick_class: \"brick:Hot_Water_Supply_Temperature_Sensor\"\n  description: \"Building hot water supply\"\n  unit: \"DEG_C\"\n  equipment: \"building_loop\"\n\nhw_return_temp:\n  brick_class: \"brick:Hot_Water_Return_Temperature_Sensor\"\n  description: \"Building hot water return\"\n  unit: \"DEG_C\"\n  equipment: \"building_loop\"\n</code></pre>"},{"location":"user-guide/conversion/sensor-mapping/#usage","title":"Usage","text":"<pre><code>from hhw_brick import CSVToBrickConverter\n\nconverter = CSVToBrickConverter()\nresult = converter.convert_to_brick(\n    metadata_csv=\"geothermal_buildings.csv\",\n    vars_csv=\"geothermal_sensors.csv\",\n    building_tag=\"205\",\n    sensor_mapping=\"geothermal_mapping.yaml\",\n    output_path=\"geothermal_building_205.ttl\"\n)\n</code></pre>"},{"location":"user-guide/conversion/sensor-mapping/#troubleshooting","title":"Troubleshooting","text":""},{"location":"user-guide/conversion/sensor-mapping/#issue-unknown-sensor-type","title":"Issue: \"Unknown sensor type\"","text":"<p>Cause: Sensor in CSV not in mapping file</p> <p>Solution: Add it to your custom mapping: <pre><code>new_sensor:\n  brick_class: \"brick:Sensor\"\n  description: \"New sensor type\"\n  unit: \"UNIT\"\n  equipment: \"equipment_type\"\n</code></pre></p>"},{"location":"user-guide/conversion/sensor-mapping/#issue-invalid-brick-class","title":"Issue: \"Invalid Brick class\"","text":"<p>Cause: Brick class doesn't exist</p> <p>Solution: Check class name at Brick Explorer</p> <pre><code># Wrong:\ntemp_sensor:\n  brick_class: \"brick:TemperatureSensor\"  # No such class\n\n# Right:\ntemp_sensor:\n  brick_class: \"brick:Temperature_Sensor\"  # Underscores\n</code></pre>"},{"location":"user-guide/conversion/sensor-mapping/#issue-mapping-not-being-used","title":"Issue: Mapping not being used","text":"<p>Cause: File path incorrect</p> <p>Solution: <pre><code>import os\n\n# Check file exists\nmapping_file = \"custom_mapping.yaml\"\nif not os.path.exists(mapping_file):\n    print(f\"\u274c File not found: {mapping_file}\")\nelse:\n    print(f\"\u2713 File exists: {os.path.abspath(mapping_file)}\")\n\n# Use absolute path\nresult = converter.convert_to_brick(\n    metadata_csv=\"metadata.csv\",\n    vars_csv=\"vars.csv\",\n    sensor_mapping=os.path.abspath(\"custom_mapping.yaml\"),\n    output_path=\"output.ttl\"\n)\n</code></pre></p>"},{"location":"user-guide/conversion/sensor-mapping/#best-practices","title":"Best Practices","text":""},{"location":"user-guide/conversion/sensor-mapping/#1-start-with-default","title":"1. Start with Default","text":"<p>Don't create from scratch: <pre><code># Copy default as starting point\ncp hhw_brick/conversion/sensor_to_brick_mapping.yaml my_mapping.yaml\n\n# Edit only what you need to change\n</code></pre></p>"},{"location":"user-guide/conversion/sensor-mapping/#2-use-specific-classes","title":"2. Use Specific Classes","text":"<p>Prefer specific Brick classes over generic: <pre><code># \u2713 Good - Specific\nsupply_temp:\n  brick_class: \"brick:Leaving_Hot_Water_Temperature_Sensor\"\n\n# \u2717 Avoid - Too generic\nsupply_temp:\n  brick_class: \"brick:Sensor\"\n</code></pre></p>"},{"location":"user-guide/conversion/sensor-mapping/#3-document-well","title":"3. Document Well","text":"<p>Write clear descriptions: <pre><code># \u2713 Good - Clear description\npmp1_vfd:\n  brick_class: \"brick:VFD_Enable_Command\"\n  description: \"Primary pump 1 variable frequency drive enable status\"\n  unit: \"BINARY\"\n  equipment: \"pump\"\n\n# \u2717 Avoid - Vague\npmp1_vfd:\n  brick_class: \"brick:VFD_Enable_Command\"\n  description: \"VFD\"  # Too brief\n  unit: \"BINARY\"\n  equipment: \"pump\"\n</code></pre></p>"},{"location":"user-guide/conversion/sensor-mapping/#4-version-control","title":"4. Version Control","text":"<p>Keep mapping files in version control: <pre><code>git add custom_mapping.yaml\ngit commit -m \"Add geothermal sensor mappings\"\n</code></pre></p>"},{"location":"user-guide/conversion/sensor-mapping/#5-test-thoroughly","title":"5. Test Thoroughly","text":"<p>Test with sample data before production use.</p>"},{"location":"user-guide/conversion/sensor-mapping/#next-steps","title":"Next Steps","text":"<ul> <li>Validation - Validate converted models</li> <li>Applications - Run analytics</li> <li>Examples - More examples</li> </ul> <p>Conversion documentation complete! \ud83c\udf89</p> <p>Continue to Validation Guide \u2192</p>"},{"location":"user-guide/conversion/single-building/","title":"Single Building Conversion","text":"<p>Detailed guide to converting individual buildings from CSV to Brick format.</p>"},{"location":"user-guide/conversion/single-building/#overview","title":"Overview","text":"<p>Single building conversion gives you precise control over the conversion process. It's ideal for:</p> <ul> <li>Development and testing - Work with one building at a time</li> <li>Custom workflows - Integrate into your own scripts</li> <li>Detailed inspection - Examine the output carefully</li> <li>Targeted conversion - Convert specific buildings</li> </ul>"},{"location":"user-guide/conversion/single-building/#basic-usage","title":"Basic Usage","text":""},{"location":"user-guide/conversion/single-building/#minimal-example","title":"Minimal Example","text":"<p>The simplest possible conversion:</p> <pre><code>from hhw_brick import CSVToBrickConverter\n\nconverter = CSVToBrickConverter()\nresult = converter.convert_to_brick(\n    metadata_csv=\"metadata.csv\",\n    vars_csv=\"vars_available_by_building.csv\",\n    building_tag=\"105\",\n    output_path=\"building_105.ttl\"\n)\n\nprint(f\"\u2713 Created {len(result)} RDF triples\")\n</code></pre> <p>This will: 1. Read building #105 from the CSV files 2. Auto-detect the system type 3. Create appropriate Brick entities 4. Save to <code>building_105.ttl</code></p>"},{"location":"user-guide/conversion/single-building/#complete-example","title":"Complete Example","text":"<p>With all parameters:</p> <pre><code>from hhw_brick import CSVToBrickConverter\n\nconverter = CSVToBrickConverter()\n\nresult = converter.convert_to_brick(\n    metadata_csv=\"metadata.csv\",\n    vars_csv=\"vars_available_by_building.csv\",\n    building_tag=\"105\",\n    system_type=\"Non-condensing\",  # Optional: specify type\n    sensor_mapping=\"custom_mapping.yaml\",  # Optional: custom mapping\n    output_path=\"output/building_105_non-condensing.ttl\"\n)\n\n# Check for warnings\nif converter.validation_warnings:\n    print(\"Warnings during conversion:\")\n    for warning in converter.validation_warnings:\n        print(f\"  \u26a0 {warning}\")\n\nprint(f\"\u2713 Conversion complete: {len(result)} triples\")\n</code></pre>"},{"location":"user-guide/conversion/single-building/#parameters-explained","title":"Parameters Explained","text":""},{"location":"user-guide/conversion/single-building/#required-parameters","title":"Required Parameters","text":""},{"location":"user-guide/conversion/single-building/#metadata_csv","title":"metadata_csv","text":"<p>Path to the building metadata file.</p> <pre><code>metadata_csv=\"path/to/metadata.csv\"\n</code></pre> <p>Format: <pre><code>tag,system,org\n105,Non-condensing,Organization A\n106,Condensing,Organization B\n</code></pre></p>"},{"location":"user-guide/conversion/single-building/#vars_csv","title":"vars_csv","text":"<p>Path to the sensor availability file.</p> <pre><code>vars_csv=\"path/to/vars_available_by_building.csv\"\n</code></pre> <p>Format: <pre><code>tag,hw_supply_temp,hw_return_temp,hw_flow\n105,1,1,1\n106,1,1,0\n</code></pre></p>"},{"location":"user-guide/conversion/single-building/#optional-parameters","title":"Optional Parameters","text":""},{"location":"user-guide/conversion/single-building/#building_tag","title":"building_tag","text":"<p>Specific building ID to convert.</p> <pre><code>building_tag=\"105\"  # Convert only building 105\n</code></pre> <ul> <li>Type: String or Integer</li> <li>Default: <code>None</code> (converts all matching buildings)</li> <li>When to use: Convert a single specific building</li> </ul> <p>Example: <pre><code># Convert building 105 only\nresult = converter.convert_to_brick(\n    metadata_csv=\"metadata.csv\",\n    vars_csv=\"vars.csv\",\n    building_tag=\"105\",  # Specific building\n    output_path=\"building_105.ttl\"\n)\n</code></pre></p>"},{"location":"user-guide/conversion/single-building/#system_type","title":"system_type","text":"<p>Filter by HVAC system type.</p> <pre><code>system_type=\"Condensing\"  # Only condensing systems\n</code></pre> <ul> <li>Type: String</li> <li>Default: <code>None</code> (auto-detect from metadata)</li> <li>Options: <code>\"Boiler\"</code>, <code>\"Non-condensing\"</code>, <code>\"Condensing\"</code>, <code>\"District HW\"</code>, <code>\"District Steam\"</code></li> <li>Case insensitive</li> </ul> <p>When to use: - Converting multiple buildings of the same type - Filtering a large dataset - Validation (ensure building matches expected type)</p> <p>Example: <pre><code># Convert all condensing systems\nresult = converter.convert_to_brick(\n    metadata_csv=\"metadata.csv\",\n    vars_csv=\"vars.csv\",\n    system_type=\"Condensing\",\n    output_path=\"all_condensing.ttl\"\n)\n</code></pre></p>"},{"location":"user-guide/conversion/single-building/#sensor_mapping","title":"sensor_mapping","text":"<p>Custom sensor mapping file.</p> <pre><code>sensor_mapping=\"my_custom_mapping.yaml\"\n</code></pre> <ul> <li>Type: String (file path)</li> <li>Default: Uses built-in mapping</li> <li>Format: YAML file</li> </ul> <p>See Sensor Mapping for details.</p>"},{"location":"user-guide/conversion/single-building/#output_path","title":"output_path","text":"<p>Where to save the generated Brick model.</p> <pre><code>output_path=\"output/building_105.ttl\"\n</code></pre> <ul> <li>Type: String (file path)</li> <li>Default: <code>\"output.ttl\"</code></li> <li>Format: Creates TTL (Turtle) format file</li> </ul>"},{"location":"user-guide/conversion/single-building/#return-value","title":"Return Value","text":"<p>The <code>convert_to_brick()</code> method returns an RDFLib Graph object.</p> <pre><code>result = converter.convert_to_brick(...)\n\n# Result is an rdflib.Graph\nprint(type(result))  # &lt;class 'rdflib.graph.Graph'&gt;\nprint(len(result))   # Number of RDF triples\n\n# Query the graph\nfor s, p, o in result:\n    print(f\"{s} {p} {o}\")\n</code></pre>"},{"location":"user-guide/conversion/single-building/#working-with-the-graph","title":"Working with the Graph","text":"<pre><code>from rdflib import Namespace\n\nresult = converter.convert_to_brick(\n    metadata_csv=\"metadata.csv\",\n    vars_csv=\"vars.csv\",\n    building_tag=\"105\",\n    output_path=\"building_105.ttl\"\n)\n\n# Define namespaces\nBRICK = Namespace(\"https://brickschema.org/schema/Brick#\")\n\n# Query for equipment\nquery = \"\"\"\nPREFIX brick: &lt;https://brickschema.org/schema/Brick#&gt;\n\nSELECT ?equip ?type WHERE {\n    ?equip a ?type .\n    FILTER(STRSTARTS(STR(?type), STR(brick:)))\n}\n\"\"\"\n\nprint(\"Equipment in model:\")\nfor row in result.query(query):\n    equip_name = str(row.equip).split('#')[-1]\n    type_name = str(row.type).split('#')[-1]\n    print(f\"  - {equip_name}: {type_name}\")\n\n# Serialize in different formats\nresult.serialize(\"output.xml\", format=\"xml\")\nresult.serialize(\"output.json\", format=\"json-ld\")\nresult.serialize(\"output.nt\", format=\"nt\")  # N-Triples\n</code></pre>"},{"location":"user-guide/conversion/single-building/#step-by-step-workflow","title":"Step-by-Step Workflow","text":""},{"location":"user-guide/conversion/single-building/#step-1-prepare-data","title":"Step 1: Prepare Data","text":"<p>Ensure your CSV files are ready:</p> <pre><code>import pandas as pd\n\n# Check metadata\nmetadata = pd.read_csv(\"metadata.csv\")\nprint(\"Buildings in metadata:\")\nprint(metadata[['tag', 'system', 'org']])\n\n# Check vars\nvars_df = pd.read_csv(\"vars_available_by_building.csv\")\nprint(\"\\nSensors available:\")\nprint(vars_df.head())\n</code></pre>"},{"location":"user-guide/conversion/single-building/#step-2-initialize-converter","title":"Step 2: Initialize Converter","text":"<pre><code>from hhw_brick import CSVToBrickConverter\n\nconverter = CSVToBrickConverter()\n</code></pre> <p>The converter initializes with: - Default namespaces (Brick, REC, etc.) - Empty RDF graph - Built-in sensor mapping</p>"},{"location":"user-guide/conversion/single-building/#step-3-convert","title":"Step 3: Convert","text":"<pre><code>result = converter.convert_to_brick(\n    metadata_csv=\"metadata.csv\",\n    vars_csv=\"vars_available_by_building.csv\",\n    building_tag=\"105\",\n    output_path=\"building_105.ttl\"\n)\n</code></pre> <p>During conversion: 1. \u2713 Reads CSV files 2. \u2713 Finds building #105 3. \u2713 Identifies system type 4. \u2713 Creates building entity 5. \u2713 Creates equipment entities 6. \u2713 Creates sensor/point entities 7. \u2713 Adds relationships 8. \u2713 Writes to file</p>"},{"location":"user-guide/conversion/single-building/#step-4-validate-output","title":"Step 4: Validate Output","text":"<pre><code>from hhw_brick import BrickModelValidator\n\nvalidator = BrickModelValidator()\nis_valid, report = validator.validate_model(\"building_105.ttl\")\n\nif is_valid:\n    print(\"\u2713 Model is valid!\")\nelse:\n    print(\"Validation report:\")\n    print(report)\n</code></pre>"},{"location":"user-guide/conversion/single-building/#step-5-inspect-results","title":"Step 5: Inspect Results","text":"<pre><code>from rdflib import Graph\n\n# Load the model\ng = Graph()\ng.parse(\"building_105.ttl\", format=\"turtle\")\n\n# Count entities\nprint(f\"Total triples: {len(g)}\")\n\n# List all equipment\nquery = \"\"\"\nPREFIX brick: &lt;https://brickschema.org/schema/Brick#&gt;\n\nSELECT DISTINCT ?type WHERE {\n    ?equip a ?type .\n    FILTER(STRSTARTS(STR(?type), STR(brick:)))\n}\n\"\"\"\n\nprint(\"\\nEquipment types:\")\nfor row in g.query(query):\n    print(f\"  - {str(row.type).split('#')[-1]}\")\n</code></pre>"},{"location":"user-guide/conversion/single-building/#common-patterns","title":"Common Patterns","text":""},{"location":"user-guide/conversion/single-building/#pattern-1-convert-multiple-buildings-sequentially","title":"Pattern 1: Convert Multiple Buildings Sequentially","text":"<pre><code>\"\"\"\nConvert multiple specific buildings one by one\n\"\"\"\nfrom hhw_brick import CSVToBrickConverter\n\nconverter = CSVToBrickConverter()\nbuilding_ids = [\"105\", \"106\", \"107\", \"108\"]\n\nfor building_id in building_ids:\n    print(f\"Converting building {building_id}...\")\n\n    try:\n        result = converter.convert_to_brick(\n            metadata_csv=\"metadata.csv\",\n            vars_csv=\"vars.csv\",\n            building_tag=building_id,\n            output_path=f\"output/building_{building_id}.ttl\"\n        )\n\n        print(f\"  \u2713 Success: {len(result)} triples\")\n\n    except Exception as e:\n        print(f\"  \u2717 Failed: {e}\")\n\n    # Clear graph for next building\n    converter.graph = converter.graph.__class__()\n</code></pre>"},{"location":"user-guide/conversion/single-building/#pattern-2-conditional-conversion","title":"Pattern 2: Conditional Conversion","text":"<pre><code>\"\"\"\nConvert only if building meets criteria\n\"\"\"\nimport pandas as pd\nfrom hhw_brick import CSVToBrickConverter\n\nmetadata = pd.read_csv(\"metadata.csv\")\nconverter = CSVToBrickConverter()\n\nfor _, building in metadata.iterrows():\n    building_id = str(int(building['tag']))\n    system = building['system']\n\n    # Only convert condensing systems\n    if 'condensing' in system.lower():\n        print(f\"Converting {building_id} ({system})...\")\n\n        result = converter.convert_to_brick(\n            metadata_csv=\"metadata.csv\",\n            vars_csv=\"vars.csv\",\n            building_tag=building_id,\n            output_path=f\"condensing/building_{building_id}.ttl\"\n        )\n\n        print(f\"  \u2713 {len(result)} triples\")\n</code></pre>"},{"location":"user-guide/conversion/single-building/#pattern-3-conversion-with-validation","title":"Pattern 3: Conversion with Validation","text":"<pre><code>\"\"\"\nConvert and validate in one workflow\n\"\"\"\nfrom hhw_brick import CSVToBrickConverter, BrickModelValidator\n\ndef convert_and_validate(building_id):\n    \"\"\"Convert a building and validate the result.\"\"\"\n\n    # Convert\n    converter = CSVToBrickConverter()\n    output_file = f\"building_{building_id}.ttl\"\n\n    result = converter.convert_to_brick(\n        metadata_csv=\"metadata.csv\",\n        vars_csv=\"vars.csv\",\n        building_tag=building_id,\n        output_path=output_file\n    )\n\n    print(f\"Converted: {len(result)} triples\")\n\n    # Validate\n    validator = BrickModelValidator()\n    is_valid, report = validator.validate_model(output_file)\n\n    if is_valid:\n        print(\"\u2713 Validation passed\")\n        return True, output_file\n    else:\n        print(\"\u26a0 Validation warnings:\")\n        for warning in report.get('warnings', []):\n            print(f\"  - {warning}\")\n        return False, output_file\n\n# Use it\nsuccess, file = convert_and_validate(\"105\")\n</code></pre>"},{"location":"user-guide/conversion/single-building/#advanced-usage","title":"Advanced Usage","text":""},{"location":"user-guide/conversion/single-building/#custom-output-processing","title":"Custom Output Processing","text":"<pre><code>\"\"\"\nProcess the graph before saving\n\"\"\"\nfrom hhw_brick import CSVToBrickConverter\nfrom rdflib import Namespace, Literal\n\nconverter = CSVToBrickConverter()\nresult = converter.convert_to_brick(\n    metadata_csv=\"metadata.csv\",\n    vars_csv=\"vars.csv\",\n    building_tag=\"105\",\n    output_path=\"temp.ttl\"\n)\n\n# Add custom metadata\nHHWS = Namespace(\"https://hhws.example.org#\")\nbuilding_uri = HHWS.Building_105\n\nresult.add((\n    building_uri,\n    HHWS.conversionDate,\n    Literal(\"2025-10-30\")\n))\n\nresult.add((\n    building_uri,\n    HHWS.conversionTool,\n    Literal(\"HHW Brick Application v0.2.0\")\n))\n\n# Save with custom metadata\nresult.serialize(\"building_105_annotated.ttl\", format=\"turtle\")\n</code></pre>"},{"location":"user-guide/conversion/single-building/#merging-multiple-buildings","title":"Merging Multiple Buildings","text":"<pre><code>\"\"\"\nCombine multiple buildings into one graph\n\"\"\"\nfrom hhw_brick import CSVToBrickConverter\nfrom rdflib import Graph\n\nconverter = CSVToBrickConverter()\ncombined = Graph()\n\n# Bind namespaces\nfor prefix, namespace in converter.graph.namespace_manager.namespaces():\n    combined.bind(prefix, namespace)\n\n# Convert and merge multiple buildings\nfor building_id in [\"105\", \"106\", \"107\"]:\n    result = converter.convert_to_brick(\n        metadata_csv=\"metadata.csv\",\n        vars_csv=\"vars.csv\",\n        building_tag=building_id,\n        output_path=f\"temp_{building_id}.ttl\"\n    )\n\n    # Add to combined graph\n    combined += result\n\n    print(f\"Added building {building_id}: {len(result)} triples\")\n\n# Save combined graph\ncombined.serialize(\"campus_model.ttl\", format=\"turtle\")\nprint(f\"\\nCombined model: {len(combined)} total triples\")\n</code></pre>"},{"location":"user-guide/conversion/single-building/#troubleshooting","title":"Troubleshooting","text":""},{"location":"user-guide/conversion/single-building/#issue-no-data-found-for-building-tag","title":"Issue: \"No data found for building tag\"","text":"<p>Cause: Building ID doesn't exist in CSV files</p> <p>Solution: <pre><code>import pandas as pd\n\n# Check which buildings exist\nmetadata = pd.read_csv(\"metadata.csv\")\nprint(\"Available building IDs:\")\nprint(metadata['tag'].tolist())\n\n# Then use a valid ID\nresult = converter.convert_to_brick(\n    metadata_csv=\"metadata.csv\",\n    vars_csv=\"vars.csv\",\n    building_tag=\"105\",  # Must be in the list above\n    output_path=\"output.ttl\"\n)\n</code></pre></p>"},{"location":"user-guide/conversion/single-building/#issue-conversion-warnings","title":"Issue: Conversion warnings","text":"<p>Cause: Some data issues (usually minor)</p> <p>Solution: <pre><code>converter = CSVToBrickConverter()\nresult = converter.convert_to_brick(...)\n\n# Check warnings\nif converter.validation_warnings:\n    print(\"Conversion completed with warnings:\")\n    for w in converter.validation_warnings:\n        print(f\"  {w}\")\n    print(\"\\nThese are usually safe to ignore.\")\n</code></pre></p>"},{"location":"user-guide/conversion/single-building/#issue-empty-output-file","title":"Issue: Empty output file","text":"<p>Cause: No matching data or wrong filters</p> <p>Solution: <pre><code># Don't use system_type filter unless needed\nresult = converter.convert_to_brick(\n    metadata_csv=\"metadata.csv\",\n    vars_csv=\"vars.csv\",\n    building_tag=\"105\",\n    # system_type=\"Condensing\",  # Remove this if not needed\n    output_path=\"output.ttl\"\n)\n</code></pre></p>"},{"location":"user-guide/conversion/single-building/#performance-tips","title":"Performance Tips","text":""},{"location":"user-guide/conversion/single-building/#memory-management","title":"Memory Management","text":"<p>Clear the graph between conversions:</p> <pre><code>converter = CSVToBrickConverter()\n\nfor building_id in range(105, 200):\n    result = converter.convert_to_brick(...)\n\n    # Clear for next iteration\n    converter.graph = converter.graph.__class__()\n</code></pre>"},{"location":"user-guide/conversion/single-building/#batch-vs-sequential","title":"Batch vs Sequential","text":"<p>For many buildings, use BatchConverter instead:</p> <pre><code># Instead of this:\nfor building_id in all_buildings:\n    converter.convert_to_brick(building_tag=building_id, ...)\n\n# Use this:\nfrom hhw_brick import BatchConverter\nbatch = BatchConverter()\nbatch.convert_all_buildings(...)\n</code></pre> <p>See Batch Conversion for details.</p>"},{"location":"user-guide/conversion/single-building/#next-steps","title":"Next Steps","text":"<ul> <li>Batch Conversion - Convert multiple buildings efficiently</li> <li>System Types - Understand different HVAC systems</li> <li>Sensor Mapping - Customize sensor mappings</li> <li>Examples - More code examples</li> </ul> <p>Continue to: Batch Conversion \u2192</p>"},{"location":"user-guide/conversion/system-types/","title":"System Types","text":"<p>Understanding the different HVAC system types supported by HHW Brick Application.</p>"},{"location":"user-guide/conversion/system-types/#overview","title":"Overview","text":"<p>HHW Brick Application supports five main system types for heating hot water systems. Each system type has different equipment configurations and Brick class mappings.</p>"},{"location":"user-guide/conversion/system-types/#supported-system-types","title":"Supported System Types","text":"System Type Description Common Use Equipment Created Boiler Generic boiler system Legacy/generic buildings Boiler, pumps Non-condensing Non-condensing boiler with heat exchanger Older buildings Boiler, HX, primary/secondary loops Condensing High-efficiency condensing boiler Modern buildings Condensing boiler, HX, loops District HW District hot water connection Campus settings District connection, HX, building loop District Steam District steam connection Dense urban areas Steam connection, HX, building loop"},{"location":"user-guide/conversion/system-types/#system-type-details","title":"System Type Details","text":""},{"location":"user-guide/conversion/system-types/#1-boiler-systems","title":"1. Boiler Systems","text":"<p>Generic boiler system without specific efficiency classification.</p>"},{"location":"user-guide/conversion/system-types/#equipment-hierarchy","title":"Equipment Hierarchy","text":"<pre><code>graph TD\n    B[Boiler] --&gt;|has point| SP[Supply Temp]\n    B --&gt;|has point| RP[Return Temp]\n    B --&gt;|has point| F[Flow]\n    B --&gt;|feeds| P[Pump]\n\n    style B fill:#ff9800\n    style P fill:#2196f3</code></pre>"},{"location":"user-guide/conversion/system-types/#created-equipment","title":"Created Equipment","text":"<ul> <li>Boiler (<code>brick:Boiler</code>)</li> <li>Supply temperature sensor</li> <li>Return temperature sensor</li> <li> <p>Flow sensor (if available)</p> </li> <li> <p>Pumps (<code>brick:Water_Pump</code>)</p> </li> <li>Primary pumps</li> <li>Variable frequency drives (if available)</li> </ul>"},{"location":"user-guide/conversion/system-types/#csv-example","title":"CSV Example","text":"<pre><code># metadata.csv\ntag,system,org\n105,Boiler,Organization A\n\n# vars_available_by_building.csv\ntag,hw_supply_temp,hw_return_temp,hw_flow\n105,1,1,1\n</code></pre>"},{"location":"user-guide/conversion/system-types/#2-non-condensing-systems","title":"2. Non-condensing Systems","text":"<p>Non-condensing boiler with heat exchanger separating primary and secondary loops.</p>"},{"location":"user-guide/conversion/system-types/#equipment-hierarchy_1","title":"Equipment Hierarchy","text":"<pre><code>graph LR\n    B[Boiler&lt;br/&gt;Primary] --&gt;|feeds| HX[Heat&lt;br/&gt;Exchanger]\n    HX --&gt;|feeds| SL[Secondary&lt;br/&gt;Loop]\n    B --&gt;|has| PP[Primary&lt;br/&gt;Pump]\n    SL --&gt;|has| SP[Secondary&lt;br/&gt;Pump]\n\n    style B fill:#ff9800\n    style HX fill:#2196f3\n    style SL fill:#4caf50</code></pre>"},{"location":"user-guide/conversion/system-types/#created-equipment_1","title":"Created Equipment","text":"<p>Primary Side: - Boiler (<code>brick:Boiler</code>)   - HW supply temperature   - HW return temperature   - Flow rate   - Firing rate (if available)</p> <ul> <li>Primary Pumps (<code>brick:Water_Pump</code>)</li> <li>Pump power</li> <li>Pump speed</li> <li>VFD status</li> </ul> <p>Heat Transfer: - Heat Exchanger (<code>brick:Heat_Exchanger</code>)   - Primary/secondary interface</p> <p>Secondary Side: - Secondary Loop Equipment   - Supply/return temperatures   - Flow rate   - Pumps with VFDs</p>"},{"location":"user-guide/conversion/system-types/#csv-example_1","title":"CSV Example","text":"<pre><code># metadata.csv\ntag,system,org,b_number\n105,Non-condensing,Org A,2\n\n# vars_available_by_building.csv\ntag,hw_supply_temp,hw_return_temp,hw_flow,secondary_supply_temp,secondary_return_temp,secondary_flow,sup1,ret1,sup2,ret2\n105,1,1,1,1,1,1,1,1,1,1\n</code></pre>"},{"location":"user-guide/conversion/system-types/#multiple-boilers","title":"Multiple Boilers","text":"<p>The system can model multiple boilers:</p> <pre><code># Building with 3 boilers\n# metadata.csv: b_number=3\n# Creates: Boiler_Primary_1, Boiler_Primary_2, Boiler_Primary_3\n</code></pre>"},{"location":"user-guide/conversion/system-types/#3-condensing-systems","title":"3. Condensing Systems","text":"<p>High-efficiency condensing boiler systems with same topology as non-condensing.</p>"},{"location":"user-guide/conversion/system-types/#key-differences","title":"Key Differences","text":"Feature Non-condensing Condensing Boiler Type <code>brick:Boiler</code> <code>brick:Condensing_Boiler</code> Efficiency ~80-85% ~90-98% Exhaust Temp High (&gt;140\u00b0C) Low (&lt;60\u00b0C) Return Temp &gt;60\u00b0C Can be &lt;60\u00b0C"},{"location":"user-guide/conversion/system-types/#equipment-hierarchy_2","title":"Equipment Hierarchy","text":"<p>Same as non-condensing, but uses <code>brick:Condensing_Boiler</code> class.</p>"},{"location":"user-guide/conversion/system-types/#csv-example_2","title":"CSV Example","text":"<pre><code># metadata.csv\ntag,system,org\n106,Condensing,Org A\n\n# vars_available_by_building.csv (same format as non-condensing)\ntag,hw_supply_temp,hw_return_temp,hw_flow\n106,1,1,1\n</code></pre>"},{"location":"user-guide/conversion/system-types/#4-district-hot-water-district-hw","title":"4. District Hot Water (District HW)","text":"<p>Building connected to a campus-wide hot water distribution system.</p>"},{"location":"user-guide/conversion/system-types/#equipment-hierarchy_3","title":"Equipment Hierarchy","text":"<pre><code>graph LR\n    DS[District&lt;br/&gt;Supply] --&gt;|feeds| HX[Heat&lt;br/&gt;Exchanger]\n    HX --&gt;|feeds| BL[Building&lt;br/&gt;Loop]\n    DS --&gt;|has| DM[District&lt;br/&gt;Meter]\n    BL --&gt;|has| BP[Building&lt;br/&gt;Pump]\n\n    style DS fill:#9c27b0\n    style HX fill:#2196f3\n    style BL fill:#4caf50</code></pre>"},{"location":"user-guide/conversion/system-types/#created-equipment_2","title":"Created Equipment","text":"<p>District Side: - District Connection (<code>brick:District_Hot_Water_System</code>)   - Supply temperature   - Return temperature   - Flow meter   - Energy meter</p> <p>Building Side: - Heat Exchanger (<code>brick:Heat_Exchanger</code>) - Building Loop   - Secondary supply/return temperatures   - Building circulation pumps   - Control valves</p>"},{"location":"user-guide/conversion/system-types/#csv-example_3","title":"CSV Example","text":"<pre><code># metadata.csv\ntag,system,org\n108,District HW,Org B\n\n# vars_available_by_building.csv\ntag,hw_supply_temp,hw_return_temp,hw_flow,secondary_supply_temp,secondary_return_temp\n108,1,1,1,1,1\n</code></pre>"},{"location":"user-guide/conversion/system-types/#no-boilers","title":"No Boilers","text":"<p>District systems do not create boiler entities, even if boiler-related data exists:</p> <pre><code># If b_number &gt; 0 in District HW system:\n# \u26a0 Warning logged: \"District system but found boiler data\"\n# \u2713 No boilers created (correct behavior)\n</code></pre>"},{"location":"user-guide/conversion/system-types/#5-district-steam","title":"5. District Steam","text":"<p>Building connected to campus steam distribution.</p>"},{"location":"user-guide/conversion/system-types/#equipment-hierarchy_4","title":"Equipment Hierarchy","text":"<pre><code>graph LR\n    DST[District&lt;br/&gt;Steam] --&gt;|feeds| SC[Steam&lt;br/&gt;Condenser/HX]\n    SC --&gt;|feeds| BL[Building&lt;br/&gt;HW Loop]\n    SC --&gt;|returns| CR[Condensate&lt;br/&gt;Return]\n\n    style DST fill:#9c27b0\n    style SC fill:#ff5722\n    style BL fill:#4caf50</code></pre>"},{"location":"user-guide/conversion/system-types/#created-equipment_3","title":"Created Equipment","text":"<p>Steam Side: - District Steam Connection (<code>brick:District_Steam_System</code>)   - Steam pressure   - Steam temperature   - Condensate return temperature</p> <p>Conversion: - Steam-to-Water Heat Exchanger   - Steam condensing   - Hot water generation</p> <p>Building Side: - Hot Water Loop   - Supply/return temperatures   - Pumps and controls</p>"},{"location":"user-guide/conversion/system-types/#csv-example_4","title":"CSV Example","text":"<pre><code># metadata.csv\ntag,system,org\n109,District Steam,Org B\n\n# vars_available_by_building.csv\ntag,steam_pressure,condensate_temp,hw_supply_temp,hw_return_temp\n109,1,1,1,1\n</code></pre>"},{"location":"user-guide/conversion/system-types/#system-type-selection","title":"System Type Selection","text":""},{"location":"user-guide/conversion/system-types/#auto-detection","title":"Auto-Detection","text":"<p>If you don't specify <code>system_type</code>, it's auto-detected from metadata:</p> <pre><code>converter = CSVToBrickConverter()\nresult = converter.convert_to_brick(\n    metadata_csv=\"metadata.csv\",\n    vars_csv=\"vars.csv\",\n    building_tag=\"105\"\n    # system_type not specified - auto-detected\n)\n</code></pre>"},{"location":"user-guide/conversion/system-types/#manual-specification","title":"Manual Specification","text":"<p>You can override the metadata:</p> <pre><code>result = converter.convert_to_brick(\n    metadata_csv=\"metadata.csv\",\n    vars_csv=\"vars.csv\",\n    building_tag=\"105\",\n    system_type=\"Condensing\"  # Force this type\n)\n</code></pre>"},{"location":"user-guide/conversion/system-types/#filtering","title":"Filtering","text":"<p>Convert only specific system types:</p> <pre><code># Convert only condensing systems\nresult = converter.convert_to_brick(\n    metadata_csv=\"metadata.csv\",\n    vars_csv=\"vars.csv\",\n    system_type=\"Condensing\"  # Filter\n)\n</code></pre>"},{"location":"user-guide/conversion/system-types/#equipment-numbering","title":"Equipment Numbering","text":""},{"location":"user-guide/conversion/system-types/#boiler-numbering","title":"Boiler Numbering","text":"<p>Boilers are numbered based on <code>b_number</code> in metadata and sensor patterns:</p> <pre><code># metadata.csv: b_number=3\n# Creates:\n#   Boiler_Primary_1\n#   Boiler_Primary_2\n#   Boiler_Primary_3\n</code></pre>"},{"location":"user-guide/conversion/system-types/#sensor-based-detection","title":"Sensor-Based Detection","text":"<p>If <code>b_number</code> is missing, the converter infers from sensors:</p> <pre><code># vars_available_by_building.csv\ntag,sup1,ret1,fire1,sup2,ret2,fire2,sup3,ret3,fire3\n105,1,1,1,1,1,1,1,1,1\n# Detects 3 boilers from sup1-3, ret1-3, fire1-3\n</code></pre>"},{"location":"user-guide/conversion/system-types/#pump-numbering","title":"Pump Numbering","text":"<p>Similar logic for pumps:</p> <pre><code># vars_available_by_building.csv\ntag,pmp1_pwr,pmp1_spd,pmp2_pwr,pmp2_spd\n105,1,1,1,1\n# Detects 2 pumps\n</code></pre>"},{"location":"user-guide/conversion/system-types/#point-mappings-by-system","title":"Point Mappings by System","text":""},{"location":"user-guide/conversion/system-types/#common-points-all-systems","title":"Common Points (All Systems)","text":"CSV Column Brick Class <code>hw_supply_temp</code> <code>Hot_Water_Supply_Temperature_Sensor</code> <code>hw_return_temp</code> <code>Hot_Water_Return_Temperature_Sensor</code> <code>hw_flow</code> <code>Water_Flow_Sensor</code> <code>outdoor_temp</code> <code>Outside_Air_Temperature_Sensor</code>"},{"location":"user-guide/conversion/system-types/#boiler-specific-points","title":"Boiler-Specific Points","text":"CSV Column Brick Class Systems <code>fire1</code>, <code>fire2</code>, ... <code>Firing_Rate_Sensor</code> Boiler, Non-condensing, Condensing <code>sup1</code>, <code>sup2</code>, ... <code>Hot_Water_Supply_Temperature_Sensor</code> Boiler, Non-condensing, Condensing <code>ret1</code>, <code>ret2</code>, ... <code>Hot_Water_Return_Temperature_Sensor</code> Boiler, Non-condensing, Condensing"},{"location":"user-guide/conversion/system-types/#secondary-loop-points","title":"Secondary Loop Points","text":"CSV Column Brick Class Systems <code>secondary_supply_temp</code> <code>Hot_Water_Supply_Temperature_Sensor</code> Non-condensing, Condensing, District <code>secondary_return_temp</code> <code>Hot_Water_Return_Temperature_Sensor</code> Non-condensing, Condensing, District <code>secondary_flow</code> <code>Water_Flow_Sensor</code> Non-condensing, Condensing, District"},{"location":"user-guide/conversion/system-types/#district-specific-points","title":"District-Specific Points","text":"CSV Column Brick Class Systems <code>steam_pressure</code> <code>Steam_Pressure_Sensor</code> District Steam <code>condensate_temp</code> <code>Condensate_Temperature_Sensor</code> District Steam"},{"location":"user-guide/conversion/system-types/#validation-and-warnings","title":"Validation and Warnings","text":""},{"location":"user-guide/conversion/system-types/#system-type-mismatch","title":"System Type Mismatch","text":"<pre><code># Building marked as \"District HW\" but has boiler data\n# \u26a0 Warning: \"District system but found boiler data\"\n# \u2713 Boilers not created (correct)\n</code></pre>"},{"location":"user-guide/conversion/system-types/#missing-equipment-count","title":"Missing Equipment Count","text":"<pre><code># Boiler system but b_number=0\n# \u26a0 Warning: \"Boiler system but b_number=0\"\n# \u2713 Falls back to sensor detection\n</code></pre>"},{"location":"user-guide/conversion/system-types/#inconsistent-data","title":"Inconsistent Data","text":"<pre><code># b_number=2 but sensors show 3 boilers\n# \u26a0 Warning: \"b_number=2 but sensors show 3, using max\"\n# \u2713 Creates 3 boilers\n</code></pre>"},{"location":"user-guide/conversion/system-types/#choosing-the-right-system-type","title":"Choosing the Right System Type","text":""},{"location":"user-guide/conversion/system-types/#when-to-use-each-type","title":"When to Use Each Type","text":"<p>Boiler: - Generic/legacy systems - Simple heating setups - When specific efficiency unknown</p> <p>Non-condensing: - Older buildings (pre-2000) - Systems with return temp &gt;60\u00b0C - Standard efficiency boilers</p> <p>Condensing: - Modern buildings (post-2000) - High-efficiency systems - Return temp can be &lt;60\u00b0C</p> <p>District HW: - Campus settings - Centralized hot water - No on-site boilers</p> <p>District Steam: - Dense urban areas - Legacy campus systems - Steam-to-hot-water conversion</p>"},{"location":"user-guide/conversion/system-types/#examples-by-system-type","title":"Examples by System Type","text":""},{"location":"user-guide/conversion/system-types/#convert-all-non-condensing","title":"Convert All Non-condensing","text":"<pre><code>from hhw_brick import BatchConverter\n\nbatch = BatchConverter()\nresults = batch.convert_all_buildings(\n    metadata_csv=\"metadata.csv\",\n    vars_csv=\"vars.csv\",\n    output_dir=\"non_condensing_models/\",\n    system_type=\"Non-condensing\"\n)\n</code></pre>"},{"location":"user-guide/conversion/system-types/#convert-district-systems","title":"Convert District Systems","text":"<pre><code># District HW\nresults_hw = batch.convert_all_buildings(\n    metadata_csv=\"metadata.csv\",\n    vars_csv=\"vars.csv\",\n    output_dir=\"district_hw/\",\n    system_type=\"District HW\"\n)\n\n# District Steam\nresults_steam = batch.convert_all_buildings(\n    metadata_csv=\"metadata.csv\",\n    vars_csv=\"vars.csv\",\n    output_dir=\"district_steam/\",\n    system_type=\"District Steam\"\n)\n</code></pre>"},{"location":"user-guide/conversion/system-types/#separate-by-type","title":"Separate by Type","text":"<pre><code>system_types = [\n    \"Non-condensing\",\n    \"Condensing\",\n    \"District HW\"\n]\n\nfor system in system_types:\n    results = batch.convert_all_buildings(\n        metadata_csv=\"metadata.csv\",\n        vars_csv=\"vars.csv\",\n        output_dir=f\"models/{system.lower().replace(' ', '_')}/\",\n        system_type=system,\n        show_progress=True\n    )\n\n    print(f\"{system}: {results['successful']} buildings\")\n</code></pre>"},{"location":"user-guide/conversion/system-types/#next-steps","title":"Next Steps","text":"<ul> <li>Sensor Mapping - Customize sensor mappings</li> <li>Validation - Validate system models</li> <li>Examples - Working examples</li> </ul> <p>Continue to: Sensor Mapping \u2192</p>"},{"location":"user-guide/validation/","title":"Model Validation","text":"<p>Ensure your Brick models are correct, complete, and follow schema rules.</p>"},{"location":"user-guide/validation/#overview","title":"Overview","text":"<p>After converting CSV data to Brick models, validation ensures:</p> <ul> <li>Ontology correctness - Models follow Brick Schema 1.4 rules (SHACL validation)</li> <li>Data completeness - All expected sensors and equipment exist</li> <li>Structural integrity - System topology matches expected patterns</li> </ul>"},{"location":"user-guide/validation/#why-validate","title":"Why Validate?","text":""},{"location":"user-guide/validation/#quality-assurance","title":"Quality Assurance","text":"<p>Catch errors early before running analytics:</p> <pre><code># Convert\nconverter = CSVToBrickConverter()\ngraph = converter.convert_to_brick(...)\n\n# Validate immediately\nvalidator = BrickModelValidator()\nresult = validator.validate_ontology(\"building_105.ttl\")\n\nif not result['valid']:\n    print(\"Fix these issues before proceeding:\")\n    for violation in result['violations']:\n        print(f\"  - {violation}\")\n</code></pre>"},{"location":"user-guide/validation/#production-readiness","title":"Production Readiness","text":"<p>Ensure models are ready for analytics applications:</p> <pre><code># Only use validated models in production\nif result['valid']:\n    app = apps.load_app(\"secondary_loop_temp_diff\")\n    results = app.analyze(\n        brick_model=\"building_105.ttl\",\n        timeseries_data=\"data.csv\"\n    )\n</code></pre>"},{"location":"user-guide/validation/#build-confidence","title":"Build Confidence","text":"<p>Validation provides confidence that your semantic models accurately represent your buildings.</p>"},{"location":"user-guide/validation/#four-validation-levels","title":"Four Validation Levels","text":"<p>HHW Brick provides comprehensive multi-level validation:</p>"},{"location":"user-guide/validation/#1-ontology-validation-shacl","title":"1. \ud83d\udd0d Ontology Validation (SHACL)","text":"<p>What it checks: Compliance with Brick Schema 1.4 rules</p> <pre><code>from hhw_brick import BrickModelValidator\n\nvalidator = BrickModelValidator(use_local_brick=True)\nresult = validator.validate_ontology(\"building_105.ttl\")\n\nif result['valid']:\n    print(\"\u2713 Model follows Brick Schema\")\nelse:\n    print(f\"\u2717 Found {len(result['violations'])} violations\")\n    for v in result['violations']:\n        print(f\"  - {v}\")\n</code></pre> <p>Validates: - \u2713 Valid Brick classes used (e.g., <code>brick:Boiler</code>, <code>brick:Temperature_Sensor</code>) - \u2713 Correct relationship types (e.g., <code>brick:hasPart</code>, <code>brick:feeds</code>) - \u2713 Proper namespaces and URIs - \u2713 RDF/OWL syntax correctness</p> <p>Learn more about ontology validation \u2192</p>"},{"location":"user-guide/validation/#2-point-count-validation","title":"2. \ud83d\udcca Point Count Validation","text":"<p>What it checks: All sensors from CSV were converted correctly</p> <pre><code>from hhw_brick import GroundTruthCalculator, BrickModelValidator\n\n# Step 1: Generate ground truth from CSV\ncalculator = GroundTruthCalculator()\nground_truth = calculator.calculate(\n    metadata_csv=\"metadata.csv\",\n    vars_csv=\"vars_available_by_building.csv\",\n    output_csv=\"ground_truth.csv\"\n)\n\n# Step 2: Validate point counts\nvalidator = BrickModelValidator(ground_truth_csv_path=\"ground_truth.csv\")\nresult = validator.validate_point_count(\"building_105.ttl\")\n\nprint(f\"Expected: {result['expected_points']} points\")\nprint(f\"Actual: {result['actual_points']} points\")\nprint(f\"Match: {result['match']} ({'\u2713' if result['match'] else '\u2717'})\")\nprint(f\"Accuracy: {result['accuracy_percentage']:.1f}%\")\n</code></pre> <p>Validates: - \u2713 Sensor count matches expected (from CSV) - \u2713 Handles <code>owl:sameAs</code> deduplication (shared sensors) - \u2713 Independent ground truth (calculated from source CSV, not Brick model)</p> <p>Learn more about point count validation \u2192</p>"},{"location":"user-guide/validation/#3-equipment-count-validation","title":"3. \u2699\ufe0f Equipment Count Validation","text":"<p>What it checks: Boilers, pumps, and weather stations</p> <pre><code>result = validator.validate_equipment_count(\"building_105.ttl\")\n\nprint(\"Equipment Counts:\")\nprint(f\"  Boilers: {result['boilers']['actual']}/{result['boilers']['expected']}\")\nprint(f\"  Pumps: {result['pumps']['actual']}/{result['pumps']['expected']}\")\nprint(f\"  Weather: {result['weather_stations']['actual']}/{result['weather_stations']['expected']}\")\n\nif result['all_match']:\n    print(\"\u2713 All equipment counts correct\")\n</code></pre> <p>Validates: - \u2713 Boiler count (with subclass support for condensing/non-condensing) - \u2713 Pump count (per loop) - \u2713 Weather station presence - \u2713 Supports equipment inheritance (e.g., <code>Condensing_Boiler</code> \u2192 <code>Boiler</code>)</p> <p>Learn more about equipment validation \u2192</p>"},{"location":"user-guide/validation/#4-structural-pattern-validation","title":"4. \ud83c\udfd7\ufe0f Structural Pattern Validation","text":"<p>What it checks: System topology and component relationships</p> <pre><code>from hhw_brick import SubgraphPatternValidator\n\nvalidator = SubgraphPatternValidator()\nresult = validator.validate_building_pattern(\"building_105.ttl\")\n\nif result['pattern_1']:\n    print(\"\u2713 Pattern 1: Boiler System\")\n    print(f\"  Boilers: {result['pattern_1']['boiler_count']}\")\n    print(f\"  Primary pumps: {result['pattern_1']['primary_pump_count']}\")\n    print(f\"  Secondary pumps: {result['pattern_1']['secondary_pump_count']}\")\nelif result['pattern_2']:\n    print(\"\u2713 Pattern 2: District System\")\n    print(f\"  Secondary pumps: {result['pattern_2']['secondary_pump_count']}\")\n</code></pre> <p>Validates: - \u2713 Pattern 1: Boiler system (primary loop + secondary loop + boilers) - \u2713 Pattern 2: District system (secondary loop only, no boilers) - \u2713 Correct loop structure using SPARQL queries - \u2713 Equipment placement in appropriate loops</p> <p>Learn more about pattern validation \u2192</p>"},{"location":"user-guide/validation/#validation-workflow","title":"Validation Workflow","text":"<pre><code>graph TD\n    A[CSV Files] --&gt; B[Convert to Brick]\n    B --&gt; C[Brick Model .ttl]\n    C --&gt; D[1. Ontology Validation]\n    D --&gt; E{Valid?}\n    E --&gt;|No| F[Fix Conversion Logic]\n    E --&gt;|Yes| G[2. Point Count Validation]\n    G --&gt; H{Match?}\n    H --&gt;|No| I[Check CSV &amp; Converter]\n    H --&gt;|Yes| J[3. Equipment Count Validation]\n    J --&gt; K{Match?}\n    K --&gt;|No| L[Check Equipment Logic]\n    K --&gt;|Yes| M[4. Pattern Validation]\n    M --&gt; N{Pattern Found?}\n    N --&gt;|No| O[Check System Structure]\n    N --&gt;|Yes| P[\u2713 Validated Model]\n    P --&gt; Q[Ready for Analytics]\n    F --&gt; B\n    I --&gt; B\n    L --&gt; B\n    O --&gt; B</code></pre>"},{"location":"user-guide/validation/#recommended-validation-order","title":"Recommended Validation Order","text":"<ol> <li>Ontology First - Catch schema violations early</li> <li>Point Counts - Verify completeness</li> <li>Equipment Counts - Check specific components</li> <li>Patterns Last - Validate overall structure</li> </ol>"},{"location":"user-guide/validation/#batch-validation-parallel-processing","title":"Batch Validation (Parallel Processing)","text":"<p>Validate multiple buildings efficiently using parallel workers:</p>"},{"location":"user-guide/validation/#batch-ontology-validation","title":"Batch Ontology Validation","text":"<pre><code>validator = BrickModelValidator(use_local_brick=True)\n\nresults = validator.batch_validate_ontology(\n    test_data_dir=\"output/\",\n    max_workers=4  # Parallel processing\n)\n\nprint(f\"Total: {results['total_files']}\")\nprint(f\"Passed: {results['passed_files']}\")\nprint(f\"Failed: {results['failed_files']}\")\nprint(f\"Accuracy: {results['overall_accuracy']:.1f}%\")\n</code></pre>"},{"location":"user-guide/validation/#batch-point-count-validation","title":"Batch Point Count Validation","text":"<pre><code>results = validator.batch_validate_point_count(\n    test_data_dir=\"output/\",\n    max_workers=4\n)\n\nfor detail in results['details']:\n    building = detail['filename']\n    match = detail['match']\n    print(f\"{building}: {'\u2713' if match else '\u2717'}\")\n</code></pre>"},{"location":"user-guide/validation/#batch-pattern-validation","title":"Batch Pattern Validation","text":"<pre><code>validator = SubgraphPatternValidator()\n\nresults = validator.batch_validate_patterns(\n    test_data_dir=\"output/\",\n    max_workers=4\n)\n\nprint(f\"Boiler Systems (Pattern 1): {results['pattern_1_count']}\")\nprint(f\"District Systems (Pattern 2): {results['pattern_2_count']}\")\nprint(f\"Success Rate: {results['success_rate']:.1f}%\")\n</code></pre> <p>Benefits of Batch Validation: - \u26a1 Faster (parallel processing) - \ud83d\udcca Summary statistics - \ud83c\udfaf Identify problematic buildings - \ud83d\udcc8 Track overall quality</p>"},{"location":"user-guide/validation/#ground-truth-the-key-concept","title":"Ground Truth: The Key Concept","text":"<p>What is Ground Truth?</p> <p>Ground truth values (expected counts) are calculated independently from the input CSV data, not from the generated Brick model. This ensures unbiased validation.</p>"},{"location":"user-guide/validation/#why-independent-ground-truth","title":"Why Independent Ground Truth?","text":"<p>Without Independent Ground Truth (circular validation): <pre><code>CSV \u2192 Converter \u2192 Brick Model\n                      \u2193\n                  Count Points \u2190 Compare with itself \u2717\n</code></pre></p> <p>With Independent Ground Truth (proper validation): <pre><code>CSV \u2192 Converter \u2192 Brick Model\n  \u2193                   \u2193\nCount Expected \u2192 Compare with Actual \u2713\n  (Ground Truth)\n</code></pre></p>"},{"location":"user-guide/validation/#how-ground-truth-is-calculated","title":"How Ground Truth is Calculated","text":"<pre><code>calculator = GroundTruthCalculator()\n\n# Reads metadata.csv and vars_available_by_building.csv\n# Counts sensors and equipment directly from source data\nground_truth = calculator.calculate(\n    metadata_csv=\"metadata.csv\",\n    vars_csv=\"vars_available_by_building.csv\",\n    output_csv=\"ground_truth.csv\"\n)\n\n# ground_truth.csv contains expected counts for each building\n# Independent of the conversion process\n</code></pre>"},{"location":"user-guide/validation/#quick-start-example","title":"Quick Start Example","text":"<p>Complete validation workflow:</p> <pre><code>from hhw_brick import (\n    CSVToBrickConverter,\n    BrickModelValidator,\n    GroundTruthCalculator,\n    SubgraphPatternValidator\n)\n\n# 1. Convert\nconverter = CSVToBrickConverter()\ngraph = converter.convert_to_brick(\n    metadata_csv=\"metadata.csv\",\n    vars_csv=\"vars_available_by_building.csv\",\n    building_tag=\"105\",\n    output_path=\"building_105.ttl\"\n)\nprint(f\"Converted: {len(graph)} triples\")\n\n# 2. Generate ground truth\ncalculator = GroundTruthCalculator()\ncalculator.calculate(\n    metadata_csv=\"metadata.csv\",\n    vars_csv=\"vars_available_by_building.csv\",\n    output_csv=\"ground_truth.csv\"\n)\n\n# 3. Validate ontology\nvalidator = BrickModelValidator(\n    use_local_brick=True,\n    ground_truth_csv_path=\"ground_truth.csv\"\n)\n\nontology_result = validator.validate_ontology(\"building_105.ttl\")\nprint(f\"Ontology valid: {ontology_result['valid']}\")\n\n# 4. Validate point counts\npoint_result = validator.validate_point_count(\"building_105.ttl\")\nprint(f\"Point count match: {point_result['match']}\")\n\n# 5. Validate equipment\nequip_result = validator.validate_equipment_count(\"building_105.ttl\")\nprint(f\"Equipment match: {equip_result['all_match']}\")\n\n# 6. Validate pattern\npattern_validator = SubgraphPatternValidator()\npattern_result = pattern_validator.validate_building_pattern(\"building_105.ttl\")\nprint(f\"Pattern found: {pattern_result['pattern_1'] is not None or pattern_result['pattern_2'] is not None}\")\n</code></pre>"},{"location":"user-guide/validation/#troubleshooting-validation-issues","title":"Troubleshooting Validation Issues","text":""},{"location":"user-guide/validation/#ontology-validation-failures","title":"Ontology Validation Failures","text":"<p>Issue: SHACL violations</p> <p>Solutions: - Check class names (e.g., use <code>brick:Boiler</code>, not <code>Boiler</code>) - Verify relationships (e.g., <code>brick:hasPart</code>, not <code>hasPart</code>) - Ensure URIs are properly formatted - Use <code>use_local_brick=True</code> for stable validation</p>"},{"location":"user-guide/validation/#point-count-mismatches","title":"Point Count Mismatches","text":"<p>Issue: Expected \u2260 Actual point counts</p> <p>Solutions: - Check CSV data for missing/extra sensors - Verify <code>owl:sameAs</code> is used for shared sensors - Review converter sensor mapping logic - Inspect ground_truth.csv for accuracy</p>"},{"location":"user-guide/validation/#equipment-count-mismatches","title":"Equipment Count Mismatches","text":"<p>Issue: Boiler/pump counts don't match</p> <p>Solutions: - Use <code>include_subclasses=True</code> for equipment inheritance - Check metadata.csv for correct <code>b_number</code> and <code>p_number</code> - Verify equipment placement in correct loops</p>"},{"location":"user-guide/validation/#pattern-validation-failures","title":"Pattern Validation Failures","text":"<p>Issue: No pattern matched</p> <p>Solutions: - Verify loop labels contain \"primary\" or \"secondary\" - Check <code>brick:feeds</code> relationship between loops - Ensure boilers are in primary loop (Pattern 1) - Validate equipment placement</p>"},{"location":"user-guide/validation/#best-practices","title":"Best Practices","text":"<p>Validation Best Practices</p> <ol> <li>Validate immediately after conversion - Catch errors early</li> <li>Use batch validation - Faster with <code>max_workers</code></li> <li>Save validation reports - Track quality over time</li> <li>Fix root causes - Don't just fix individual models</li> <li>Automate validation - Include in CI/CD pipeline</li> </ol>"},{"location":"user-guide/validation/#automation-example","title":"Automation Example","text":"<pre><code>def validate_pipeline(metadata_csv, vars_csv, output_dir):\n    \"\"\"Complete conversion and validation pipeline\"\"\"\n\n    # Convert\n    batch = BatchConverter()\n    conv_results = batch.convert_all_buildings(\n        metadata_csv=metadata_csv,\n        vars_csv=vars_csv,\n        output_dir=output_dir\n    )\n\n    # Generate ground truth\n    calculator = GroundTruthCalculator()\n    calculator.calculate(\n        metadata_csv=metadata_csv,\n        vars_csv=vars_csv,\n        output_csv=f\"{output_dir}/ground_truth.csv\"\n    )\n\n    # Validate all\n    validator = BrickModelValidator(\n        use_local_brick=True,\n        ground_truth_csv_path=f\"{output_dir}/ground_truth.csv\"\n    )\n\n    val_results = {\n        'ontology': validator.batch_validate_ontology(output_dir),\n        'points': validator.batch_validate_point_count(output_dir),\n        'equipment': validator.batch_validate_equipment_count(output_dir)\n    }\n\n    # Report\n    print(f\"\\n{'='*60}\")\n    print(\"Validation Report\")\n    print(f\"{'='*60}\")\n    print(f\"Converted: {conv_results['successful']}/{conv_results['total']} buildings\")\n    print(f\"Ontology: {val_results['ontology']['passed_files']}/{val_results['ontology']['total_files']} passed\")\n    print(f\"Points: {val_results['points']['passed_files']}/{val_results['points']['total_files']} matched\")\n    print(f\"Equipment: {val_results['equipment']['passed_files']}/{val_results['equipment']['total_files']} matched\")\n\n    return val_results\n</code></pre>"},{"location":"user-guide/validation/#next-steps","title":"Next Steps","text":"<ul> <li>Ontology Validation Guide - SHACL validation details</li> <li>Ground Truth Validation - Point and equipment count validation</li> <li>Subgraph Pattern Validation - Structural pattern validation</li> <li>Examples - Complete working examples</li> </ul>"},{"location":"user-guide/validation/#need-help","title":"Need Help?","text":"<ul> <li>Check the FAQ for common issues</li> <li>Review examples for working code</li> <li>Report issues on GitHub</li> </ul> <p>Verify system topology patterns.</p> <pre><code>from hhw_brick.validation import SubgraphPatternValidator\n\nvalidator = SubgraphPatternValidator()\nresult = validator.validate(\"building_105.ttl\")\n\nif result['all_patterns_found']:\n    print(\"\u2713 All expected patterns found\")\nelse:\n    print(f\"\u2717 Missing: {result['missing_patterns']}\")\n</code></pre> <p>Checks: - \u2713 Boiler \u2192 Heat Exchanger connection - \u2713 Equipment \u2192 Points relationships - \u2713 Primary \u2192 Secondary loop flow</p> <p>Learn more \u2192</p>"},{"location":"user-guide/validation/#quick-start","title":"Quick Start","text":""},{"location":"user-guide/validation/#validate-a-single-model","title":"Validate a Single Model","text":"<p>Complete validation workflow:</p> <pre><code>from hhw_brick import BrickModelValidator, GroundTruthCalculator\n\n# Step 1: Generate ground truth\ncalculator = GroundTruthCalculator()\ncalculator.calculate(\n    metadata_csv=\"metadata.csv\",\n    vars_csv=\"vars.csv\",\n    output_csv=\"ground_truth.csv\"\n)\n\n# Step 2: Create validator\nvalidator = BrickModelValidator(\n    ground_truth_csv_path=\"ground_truth.csv\",\n    use_local_brick=True\n)\n\n# Step 3: Validate ontology\nontology_result = validator.validate_ontology(\"building_105.ttl\")\nprint(f\"Ontology valid: {ontology_result['valid']}\")\n\n# Step 4: Validate point counts\npoint_result = validator.validate_point_count(\"building_105.ttl\")\nprint(f\"Point accuracy: {point_result['accuracy_percentage']:.1f}%\")\n\n# Step 5: Validate equipment counts\nequipment_result = validator.validate_equipment_count(\"building_105.ttl\")\nprint(f\"Equipment match: {equipment_result['overall_success']}\")\n</code></pre>"},{"location":"user-guide/validation/#batch-validate-multiple-models","title":"Batch Validate Multiple Models","text":"<p>Validate all models in a directory:</p> <pre><code>from hhw_brick import BrickModelValidator\n\nvalidator = BrickModelValidator(\n    ground_truth_csv_path=\"ground_truth.csv\",\n    use_local_brick=True\n)\n\n# Batch ontology validation (parallel processing)\nresults = validator.batch_validate_ontology(\n    test_data_dir=\"brick_models/\",\n    max_workers=8  # Parallel workers\n)\n\nprint(f\"Validated {results['total_files']} models\")\nprint(f\"Valid: {results['passed_files']}\")\nprint(f\"Invalid: {results['failed_files']}\")\nprint(f\"Accuracy: {results['overall_accuracy']:.1f}%\")\n\n# Batch point count validation\npoint_results = validator.batch_validate_point_count(\n    test_data_dir=\"brick_models/\"\n)\n\nprint(f\"Point count accuracy: {point_results['overall_accuracy']:.1f}%\")\n</code></pre>"},{"location":"user-guide/validation/#validation-workflow_1","title":"Validation Workflow","text":""},{"location":"user-guide/validation/#complete-production-workflow","title":"Complete Production Workflow","text":"<pre><code>graph TD\n    A[CSV Files] --&gt;|Convert| B[Brick Models]\n    A --&gt;|Calculate| C[Ground Truth]\n    B --&gt;|Validate Ontology| D{Valid?}\n    D --&gt;|No| E[Fix Conversion]\n    E --&gt; A\n    D --&gt;|Yes| F[Validate Counts]\n    C --&gt;|Compare| F\n    F --&gt;|Check| G{Match?}\n    G --&gt;|No| H[Review Data]\n    H --&gt; A\n    G --&gt;|Yes| I[\u2713 Validated Models]\n    I --&gt;|Use in| J[Analytics Apps]\n\n    style A fill:#e1f5ff\n    style I fill:#c8e6c9\n    style E fill:#ffcdd2\n    style H fill:#ffcdd2</code></pre>"},{"location":"user-guide/validation/#step-by-step-example","title":"Step-by-Step Example","text":"<p>Based on <code>examples/02_ontology_validation.py</code> and <code>examples/03_point_count_validation.py</code>:</p> <pre><code>\"\"\"\nComplete validation workflow\nBased on HHW Brick Application examples\n\"\"\"\n\nfrom pathlib import Path\nfrom hhw_brick import (\n    CSVToBrickConverter,\n    BatchConverter,\n    BrickModelValidator,\n    GroundTruthCalculator\n)\n\ndef complete_workflow():\n    # Paths\n    metadata_csv = \"metadata.csv\"\n    vars_csv = \"vars_available_by_building.csv\"\n    output_dir = Path(\"brick_models\")\n    ground_truth_csv = \"ground_truth.csv\"\n\n    # ===== Step 1: Convert CSV to Brick =====\n    print(\"Step 1: Converting CSV to Brick...\")\n    batch = BatchConverter()\n    conversion_results = batch.convert_all_buildings(\n        metadata_csv=metadata_csv,\n        vars_csv=vars_csv,\n        output_dir=str(output_dir),\n        show_progress=True\n    )\n    print(f\"\u2713 Converted {conversion_results['successful']} buildings\")\n\n    # ===== Step 2: Generate Ground Truth =====\n    print(\"\\nStep 2: Generating ground truth...\")\n    calculator = GroundTruthCalculator()\n    ground_truth_df = calculator.calculate(\n        metadata_csv=metadata_csv,\n        vars_csv=vars_csv,\n        output_csv=ground_truth_csv\n    )\n    print(f\"\u2713 Ground truth generated for {len(ground_truth_df)} buildings\")\n\n    # ===== Step 3: Validate Ontology (Batch) =====\n    print(\"\\nStep 3: Validating ontology...\")\n    validator = BrickModelValidator(\n        ground_truth_csv_path=ground_truth_csv,\n        use_local_brick=True\n    )\n\n    ontology_results = validator.batch_validate_ontology(\n        test_data_dir=str(output_dir),\n        max_workers=8\n    )\n\n    print(f\"\u2713 Ontology validation:\")\n    print(f\"  - Valid: {ontology_results['passed_files']}/{ontology_results['total_files']}\")\n    print(f\"  - Accuracy: {ontology_results['overall_accuracy']:.1f}%\")\n\n    # ===== Step 4: Validate Point Counts (Batch) =====\n    print(\"\\nStep 4: Validating point counts...\")\n    point_results = validator.batch_validate_point_count(\n        test_data_dir=str(output_dir)\n    )\n\n    print(f\"\u2713 Point count validation:\")\n    print(f\"  - Matched: {point_results['passed_files']}/{point_results['total_files']}\")\n    print(f\"  - Accuracy: {point_results['overall_accuracy']:.1f}%\")\n\n    # ===== Step 5: Validate Equipment Counts (Batch) =====\n    print(\"\\nStep 5: Validating equipment counts...\")\n    equipment_results = validator.batch_validate_equipment_count(\n        test_data_dir=str(output_dir)\n    )\n\n    print(f\"\u2713 Equipment count validation:\")\n    print(f\"  - Matched: {equipment_results['passed_files']}/{equipment_results['total_files']}\")\n    print(f\"  - Accuracy: {equipment_results['overall_accuracy']:.1f}%\")\n\n    # ===== Summary =====\n    print(\"\\n\" + \"=\"*60)\n    print(\"Validation Summary\")\n    print(\"=\"*60)\n    print(f\"Total models: {conversion_results['successful']}\")\n    print(f\"Ontology valid: {ontology_results['passed_files']}\")\n    print(f\"Point counts match: {point_results['passed_files']}\")\n    print(f\"Equipment counts match: {equipment_results['passed_files']}\")\n\n    # Overall success\n    all_valid = (\n        ontology_results['passed_files'] == conversion_results['successful'] and\n        point_results['passed_files'] == conversion_results['successful'] and\n        equipment_results['passed_files'] == conversion_results['successful']\n    )\n\n    if all_valid:\n        print(\"\\n\u2713 All models validated successfully!\")\n        print(\"  Models are ready for analytics applications.\")\n    else:\n        print(\"\\n\u26a0 Some models have validation issues\")\n        print(\"  Review failed models before using in production.\")\n\n    return {\n        'conversion': conversion_results,\n        'ontology': ontology_results,\n        'points': point_results,\n        'equipment': equipment_results\n    }\n\nif __name__ == \"__main__\":\n    results = complete_workflow()\n</code></pre>"},{"location":"user-guide/validation/#common-validation-patterns","title":"Common Validation Patterns","text":""},{"location":"user-guide/validation/#pattern-1-validate-after-conversion","title":"Pattern 1: Validate After Conversion","text":"<p>Always validate after converting:</p> <pre><code># Convert\nresult = converter.convert_to_brick(\n    metadata_csv=\"metadata.csv\",\n    vars_csv=\"vars.csv\",\n    building_tag=\"105\",\n    output_path=\"building_105.ttl\"\n)\n\n# Validate immediately\nvalidator = BrickModelValidator(use_local_brick=True)\nvalidation = validator.validate_ontology(\"building_105.ttl\")\n\nif validation['valid']:\n    print(\"\u2713 Conversion successful and valid\")\nelse:\n    print(\"\u2717 Model has errors - review conversion\")\n</code></pre>"},{"location":"user-guide/validation/#pattern-2-pre-production-check","title":"Pattern 2: Pre-Production Check","text":"<p>Before deploying to analytics:</p> <pre><code>def is_model_ready(model_path, ground_truth_path):\n    \"\"\"Check if model is ready for production use.\"\"\"\n\n    validator = BrickModelValidator(\n        ground_truth_csv_path=ground_truth_path,\n        use_local_brick=True\n    )\n\n    # Check ontology\n    ont_result = validator.validate_ontology(model_path)\n    if not ont_result['valid']:\n        return False, \"Ontology validation failed\"\n\n    # Check point counts\n    point_result = validator.validate_point_count(model_path)\n    if not point_result['success']:\n        return False, \"Point count mismatch\"\n\n    # Check equipment counts\n    equip_result = validator.validate_equipment_count(model_path)\n    if not equip_result['overall_success']:\n        return False, \"Equipment count mismatch\"\n\n    return True, \"Model ready\"\n\n# Use it\nready, message = is_model_ready(\"building_105.ttl\", \"ground_truth.csv\")\nif ready:\n    # Run analytics\n    app.analyze(model, data, config)\n</code></pre>"},{"location":"user-guide/validation/#pattern-3-continuous-validation","title":"Pattern 3: Continuous Validation","text":"<p>Validate on data updates:</p> <pre><code>import os\nfrom datetime import datetime\n\ndef validate_if_changed(model_path, ground_truth_path, cache_file=\".validation_cache\"):\n    \"\"\"Only validate if model changed since last check.\"\"\"\n\n    # Get model modification time\n    mod_time = os.path.getmtime(model_path)\n\n    # Check cache\n    if os.path.exists(cache_file):\n        with open(cache_file, 'r') as f:\n            last_validated = float(f.read().strip())\n\n        if mod_time &lt;= last_validated:\n            print(\"Model unchanged, using cached validation result\")\n            return True\n\n    # Validate\n    validator = BrickModelValidator(\n        ground_truth_csv_path=ground_truth_path\n    )\n\n    result = validator.validate_ontology(model_path)\n\n    # Update cache\n    if result['valid']:\n        with open(cache_file, 'w') as f:\n            f.write(str(datetime.now().timestamp()))\n\n    return result['valid']\n</code></pre>"},{"location":"user-guide/validation/#validation-results","title":"Validation Results","text":""},{"location":"user-guide/validation/#understanding-results","title":"Understanding Results","text":"<p>All validation methods return dictionaries with results:</p> <pre><code># Ontology validation\n{\n    'valid': True,\n    'violations': [],\n    'ttl_file_path': 'building_105.ttl'\n}\n\n# Point count validation\n{\n    'success': True,\n    'match': True,\n    'expected_point_count': 23,\n    'actual_point_count': 23,\n    'accuracy_percentage': 100.0\n}\n\n# Equipment count validation\n{\n    'overall_success': True,\n    'boiler': {'expected': 2, 'actual': 2, 'match': True},\n    'pump': {'expected': 3, 'actual': 3, 'match': True},\n    'weather_station': {'expected': 1, 'actual': 1, 'match': True}\n}\n</code></pre>"},{"location":"user-guide/validation/#troubleshooting","title":"Troubleshooting","text":""},{"location":"user-guide/validation/#issue-brickschema-not-available","title":"Issue: \"brickschema not available\"","text":"<p>Solution: <pre><code>pip install brickschema\n</code></pre></p>"},{"location":"user-guide/validation/#issue-ground-truth-file-not-found","title":"Issue: \"Ground truth file not found\"","text":"<p>Solution: Generate it first: <pre><code>calculator = GroundTruthCalculator()\ncalculator.calculate(\n    metadata_csv=\"metadata.csv\",\n    vars_csv=\"vars.csv\",\n    output_csv=\"ground_truth.csv\"\n)\n</code></pre></p>"},{"location":"user-guide/validation/#issue-point-count-mismatch","title":"Issue: Point count mismatch","text":"<p>Possible causes: 1. Sensor mapping incorrect 2. Missing sensors in vars.csv 3. Conversion issues</p> <p>Solution: Review conversion warnings: <pre><code>converter = CSVToBrickConverter()\nresult = converter.convert_to_brick(...)\n\nif converter.validation_warnings:\n    for warning in converter.validation_warnings:\n        print(warning)\n</code></pre></p>"},{"location":"user-guide/validation/#performance","title":"Performance","text":""},{"location":"user-guide/validation/#batch-validation-speed","title":"Batch Validation Speed","text":"<p>Parallel processing significantly improves performance:</p> <pre><code># Serial (slow for many files)\nfor file in ttl_files:\n    validator.validate_ontology(file)\n\n# Parallel (much faster)\nresults = validator.batch_validate_ontology(\n    test_data_dir=\"brick_models/\",\n    max_workers=8  # Use 8 parallel workers\n)\n</code></pre> <p>Typical performance: - 10 models: ~5 seconds (parallel) vs ~30 seconds (serial) - 100 models: ~45 seconds (parallel) vs ~5 minutes (serial)</p>"},{"location":"user-guide/validation/#next-steps_1","title":"Next Steps","text":"<p>Learn about each validation type in detail:</p> <ul> <li>Ontology Validation - Check Brick schema compliance</li> <li>Ground Truth Validation - Verify counts and completeness</li> <li>Subgraph Patterns - Validate system topology</li> </ul> <p>Or explore related topics:</p> <ul> <li>Conversion Guide - How to generate models</li> <li>Applications Guide - Use validated models</li> <li>Examples - Working code samples</li> </ul> <p>Continue to: Ontology Validation \u2192</p>"},{"location":"user-guide/validation/ground-truth/","title":"Ground Truth Validation","text":"<p>Validate Brick models against expected counts calculated from source CSV data.</p>"},{"location":"user-guide/validation/ground-truth/#overview","title":"Overview","text":"<p>Ground truth validation compares your Brick model against expected values derived from the original CSV data:</p> <ul> <li>Point counts - Number of sensors/points</li> <li>Boiler counts - Number of boilers</li> <li>Pump counts - Number of pumps  </li> <li>Weather stations - Presence of weather data</li> </ul> <p>This ensures your conversion was complete and accurate.</p>"},{"location":"user-guide/validation/ground-truth/#why-ground-truth-validation","title":"Why Ground Truth Validation?","text":""},{"location":"user-guide/validation/ground-truth/#verify-completeness","title":"Verify Completeness","text":"<p>Ensure no data was lost during conversion:</p> <pre><code># Expected: 23 points (from CSV)\n# Actual: 18 points (in Brick model)\n# \u2717 5 points missing - conversion issue!\n</code></pre>"},{"location":"user-guide/validation/ground-truth/#catch-conversion-errors","title":"Catch Conversion Errors","text":"<p>Find problems early:</p> <pre><code># Expected: 2 boilers\n# Actual: 1 boiler\n# \u2717 Check b_number or sensor detection logic\n</code></pre>"},{"location":"user-guide/validation/ground-truth/#production-quality","title":"Production Quality","text":"<p>Only use complete models:</p> <pre><code>if point_validation['match']:\n    # Model is complete, safe to use\n    app.analyze(model, data, config)\n</code></pre>"},{"location":"user-guide/validation/ground-truth/#ground-truth-calculator","title":"Ground Truth Calculator","text":""},{"location":"user-guide/validation/ground-truth/#generate-ground-truth","title":"Generate Ground Truth","text":"<p>From <code>examples/03_point_count_validation.py</code>:</p> <pre><code>from hhw_brick.validation import GroundTruthCalculator\n\n# Create calculator\ncalculator = GroundTruthCalculator()\n\n# Calculate expected counts from CSV\nground_truth_df = calculator.calculate(\n    metadata_csv=\"metadata.csv\",\n    vars_csv=\"vars_available_by_building.csv\",\n    output_csv=\"ground_truth.csv\"\n)\n\nprint(f\"Generated ground truth for {len(ground_truth_df)} buildings\")\n</code></pre>"},{"location":"user-guide/validation/ground-truth/#ground-truth-format","title":"Ground Truth Format","text":"<p>The generated <code>ground_truth.csv</code> contains:</p> <pre><code>tag,system,point_count,boiler_count,pump_count,weather_station_count\n105,Non-condensing,23,2,3,1\n106,Condensing,18,1,2,0\n107,District HW,15,0,2,1\n</code></pre> <p>Columns: - <code>tag</code> - Building ID - <code>system</code> - System type - <code>point_count</code> - Expected total points - <code>boiler_count</code> - Expected boilers - <code>pump_count</code> - Expected pumps - <code>weather_station_count</code> - Expected weather stations (0 or 1)</p>"},{"location":"user-guide/validation/ground-truth/#how-counts-are-calculated","title":"How Counts Are Calculated","text":""},{"location":"user-guide/validation/ground-truth/#point-count","title":"Point Count","text":"<p>Counts all sensors marked as available (value=1) in <code>vars_available_by_building.csv</code>:</p> <pre><code># vars.csv\ntag,hw_supply_temp,hw_return_temp,hw_flow,outdoor_temp\n105,1,1,1,1  # 4 sensors available\n\n# ground_truth.csv\ntag,point_count\n105,4  # Calculated from available sensors\n</code></pre>"},{"location":"user-guide/validation/ground-truth/#boiler-count","title":"Boiler Count","text":"<p>From <code>b_number</code> in metadata.csv or inferred from sensor patterns:</p> <pre><code># metadata.csv\ntag,b_number\n105,2  # Explicitly set\n\n# OR inferred from sensors\n# vars.csv: sup1, ret1, fire1, sup2, ret2, fire2\n# Infers: 2 boilers\n\n# ground_truth.csv\ntag,boiler_count\n105,2\n</code></pre>"},{"location":"user-guide/validation/ground-truth/#pump-count","title":"Pump Count","text":"<p>Inferred from pump sensor patterns (<code>pmp1_*</code>, <code>pmp2_*</code>, etc.):</p> <pre><code># vars.csv\ntag,pmp1_pwr,pmp1_spd,pmp2_pwr,pmp2_spd,pmp3_pwr\n105,1,1,1,1,1  # Pump 1, 2, 3 detected\n\n# ground_truth.csv\ntag,pump_count\n105,3\n</code></pre>"},{"location":"user-guide/validation/ground-truth/#weather-station","title":"Weather Station","text":"<p>From <code>oper</code> column or outdoor sensors:</p> <pre><code># Has outdoor_temp sensor or oper != 0\n# weather_station_count = 1\n</code></pre>"},{"location":"user-guide/validation/ground-truth/#point-count-validation","title":"Point Count Validation","text":""},{"location":"user-guide/validation/ground-truth/#validate-single-building","title":"Validate Single Building","text":"<p>From <code>examples/03_point_count_validation.py</code>:</p> <pre><code>from hhw_brick import BrickModelValidator\n\n# Create validator with ground truth\nvalidator = BrickModelValidator(\n    ground_truth_csv_path=\"ground_truth.csv\"\n)\n\n# Validate point count\nresult = validator.validate_point_count(\"building_105.ttl\")\n\n# Check result\nif result['success'] and result['match']:\n    print(\"\u2713 Point count matches!\")\nelse:\n    print(f\"\u2717 Point count mismatch\")\n    print(f\"  Expected: {result['expected_point_count']}\")\n    print(f\"  Actual: {result['actual_point_count']}\")\n    print(f\"  Accuracy: {result['accuracy_percentage']:.1f}%\")\n</code></pre>"},{"location":"user-guide/validation/ground-truth/#validate_point_count","title":"validate_point_count()","text":"<p>Signature: <pre><code>def validate_point_count(ttl_file_path: str) -&gt; Dict\n</code></pre></p> <p>Returns: <pre><code>{\n    'success': bool,                # Overall success\n    'match': bool,                  # Counts match exactly\n    'expected_point_count': int,    # From ground truth\n    'actual_point_count': int,      # From Brick model\n    'accuracy_percentage': float,   # Match percentage\n    'ttl_file_path': str,          # Model file path\n    'building_tag': str             # Extracted building ID\n}\n</code></pre></p> <p>Example: <pre><code>result = validator.validate_point_count(\"building_105.ttl\")\n\nprint(f\"Expected: {result['expected_point_count']}\")\nprint(f\"Actual: {result['actual_point_count']}\")\nprint(f\"Match: {result['match']}\")\nprint(f\"Accuracy: {result['accuracy_percentage']:.1f}%\")\n</code></pre></p>"},{"location":"user-guide/validation/ground-truth/#equipment-count-validation","title":"Equipment Count Validation","text":""},{"location":"user-guide/validation/ground-truth/#validate-equipment-counts","title":"Validate Equipment Counts","text":"<p>From <code>examples/04_equipment_count_validation.py</code>:</p> <pre><code>from hhw_brick import BrickModelValidator\n\nvalidator = BrickModelValidator(\n    ground_truth_csv_path=\"ground_truth.csv\",\n    use_local_brick=True\n)\n\n# Validate equipment counts\nresult = validator.validate_equipment_count(\"building_105.ttl\")\n\n# Check overall result\nif result['overall_success']:\n    print(\"\u2713 All equipment counts match!\")\nelse:\n    print(\"\u2717 Equipment count mismatch detected\")\n\n# Check individual equipment\nprint(f\"Boilers: {result['boiler']['actual']}/{result['boiler']['expected']}\")\nprint(f\"Pumps: {result['pump']['actual']}/{result['pump']['expected']}\")\nprint(f\"Weather: {result['weather_station']['actual']}/{result['weather_station']['expected']}\")\n</code></pre>"},{"location":"user-guide/validation/ground-truth/#validate_equipment_count","title":"validate_equipment_count()","text":"<p>Signature: <pre><code>def validate_equipment_count(ttl_file_path: str) -&gt; Dict\n</code></pre></p> <p>Returns: <pre><code>{\n    'overall_success': bool,        # All equipment matches\n    'boiler': {\n        'expected': int,\n        'actual': int,\n        'match': bool\n    },\n    'pump': {\n        'expected': int,\n        'actual': int,\n        'match': bool\n    },\n    'weather_station': {\n        'expected': int,\n        'actual': int,\n        'match': bool\n    },\n    'ttl_file_path': str,\n    'building_tag': str\n}\n</code></pre></p> <p>Example: <pre><code>result = validator.validate_equipment_count(\"building_105.ttl\")\n\nfor equip_type in ['boiler', 'pump', 'weather_station']:\n    equip = result[equip_type]\n    status = \"\u2713\" if equip['match'] else \"\u2717\"\n    print(f\"{status} {equip_type}: {equip['actual']}/{equip['expected']}\")\n</code></pre></p>"},{"location":"user-guide/validation/ground-truth/#batch-validation","title":"Batch Validation","text":""},{"location":"user-guide/validation/ground-truth/#batch-point-count-validation","title":"Batch Point Count Validation","text":"<p>Validate multiple models:</p> <pre><code>from hhw_brick import BrickModelValidator\n\nvalidator = BrickModelValidator(\n    ground_truth_csv_path=\"ground_truth.csv\"\n)\n\n# Batch validate point counts\nresults = validator.batch_validate_point_count(\n    test_data_dir=\"brick_models/\"\n)\n\nprint(f\"Total files: {results['total_files']}\")\nprint(f\"Matched: {results['passed_files']}\")\nprint(f\"Mismatched: {results['failed_files']}\")\nprint(f\"Accuracy: {results['overall_accuracy']:.1f}%\")\n</code></pre>"},{"location":"user-guide/validation/ground-truth/#batch-equipment-count-validation","title":"Batch Equipment Count Validation","text":"<pre><code># Batch validate equipment counts\nresults = validator.batch_validate_equipment_count(\n    test_data_dir=\"brick_models/\"\n)\n\nprint(f\"Total files: {results['total_files']}\")\nprint(f\"All matched: {results['passed_files']}\")\nprint(f\"Accuracy: {results['overall_accuracy']:.1f}%\")\n</code></pre>"},{"location":"user-guide/validation/ground-truth/#batch_validate_point_count","title":"batch_validate_point_count()","text":"<p>Signature: <pre><code>def batch_validate_point_count(test_data_dir: str) -&gt; Dict\n</code></pre></p> <p>Returns: <pre><code>{\n    'total_files': int,\n    'passed_files': int,            # Exact matches\n    'failed_files': int,            # Mismatches\n    'overall_accuracy': float,      # Average accuracy %\n    'individual_results': [...]     # List of individual results\n}\n</code></pre></p>"},{"location":"user-guide/validation/ground-truth/#complete-validation-workflow","title":"Complete Validation Workflow","text":"<p>From examples:</p> <pre><code>\"\"\"\nComplete ground truth validation workflow\nBased on examples/03 and 04\n\"\"\"\n\nfrom pathlib import Path\nfrom hhw_brick import BatchConverter, BrickModelValidator\nfrom hhw_brick.validation import GroundTruthCalculator\n\ndef complete_ground_truth_workflow():\n    # Paths\n    metadata_csv = \"metadata.csv\"\n    vars_csv = \"vars_available_by_building.csv\"\n    output_dir = Path(\"brick_models\")\n    ground_truth_csv = \"ground_truth.csv\"\n\n    # ===== Step 1: Convert CSV to Brick =====\n    print(\"Step 1: Converting CSV to Brick...\")\n    batch = BatchConverter()\n    conversion_results = batch.convert_all_buildings(\n        metadata_csv=metadata_csv,\n        vars_csv=vars_csv,\n        output_dir=str(output_dir),\n        show_progress=True\n    )\n    print(f\"\u2713 Converted {conversion_results['successful']} buildings\")\n\n    # ===== Step 2: Generate Ground Truth =====\n    print(\"\\nStep 2: Generating ground truth...\")\n    calculator = GroundTruthCalculator()\n    ground_truth_df = calculator.calculate(\n        metadata_csv=metadata_csv,\n        vars_csv=vars_csv,\n        output_csv=ground_truth_csv\n    )\n    print(f\"\u2713 Ground truth for {len(ground_truth_df)} buildings\")\n\n    # Show sample\n    print(\"\\n  Sample (first 3 buildings):\")\n    for _, row in ground_truth_df.head(3).iterrows():\n        print(f\"    Building {row['tag']}: \"\n              f\"{int(row['point_count'])} points, \"\n              f\"{int(row['boiler_count'])} boilers, \"\n              f\"{int(row['pump_count'])} pumps\")\n\n    # ===== Step 3: Create Validator =====\n    validator = BrickModelValidator(\n        ground_truth_csv_path=ground_truth_csv,\n        use_local_brick=True\n    )\n\n    # ===== Step 4: Validate Point Counts =====\n    print(\"\\nStep 3: Validating point counts...\")\n    point_results = validator.batch_validate_point_count(\n        test_data_dir=str(output_dir)\n    )\n\n    print(f\"\u2713 Point count validation:\")\n    print(f\"  - Matched: {point_results['passed_files']}/{point_results['total_files']}\")\n    print(f\"  - Accuracy: {point_results['overall_accuracy']:.1f}%\")\n\n    # ===== Step 5: Validate Equipment Counts =====\n    print(\"\\nStep 4: Validating equipment counts...\")\n    equipment_results = validator.batch_validate_equipment_count(\n        test_data_dir=str(output_dir)\n    )\n\n    print(f\"\u2713 Equipment count validation:\")\n    print(f\"  - Matched: {equipment_results['passed_files']}/{equipment_results['total_files']}\")\n    print(f\"  - Accuracy: {equipment_results['overall_accuracy']:.1f}%\")\n\n    # ===== Step 6: Detailed Report for Failures =====\n    if point_results['failed_files'] &gt; 0:\n        print(\"\\nPoint count mismatches:\")\n        for result in point_results['individual_results']:\n            if not result['match']:\n                file_name = Path(result['ttl_file_path']).name\n                print(f\"  \u2717 {file_name}\")\n                print(f\"      Expected: {result['expected_point_count']}\")\n                print(f\"      Actual: {result['actual_point_count']}\")\n                print(f\"      Accuracy: {result['accuracy_percentage']:.1f}%\")\n\n    # ===== Summary =====\n    print(\"\\n\" + \"=\"*60)\n    print(\"Ground Truth Validation Summary\")\n    print(\"=\"*60)\n    print(f\"Total buildings: {conversion_results['successful']}\")\n    print(f\"Point counts matched: {point_results['passed_files']}\")\n    print(f\"Equipment counts matched: {equipment_results['passed_files']}\")\n\n    all_valid = (\n        point_results['passed_files'] == conversion_results['successful'] and\n        equipment_results['passed_files'] == conversion_results['successful']\n    )\n\n    if all_valid:\n        print(\"\\n\u2713 All models complete and accurate!\")\n        print(\"  Ready for production use.\")\n    else:\n        print(\"\\n\u26a0 Some models have count mismatches\")\n        print(\"  Review conversion or source data.\")\n\n    return {\n        'conversion': conversion_results,\n        'ground_truth': ground_truth_df,\n        'points': point_results,\n        'equipment': equipment_results\n    }\n\nif __name__ == \"__main__\":\n    results = complete_ground_truth_workflow()\n</code></pre>"},{"location":"user-guide/validation/ground-truth/#understanding-results","title":"Understanding Results","text":""},{"location":"user-guide/validation/ground-truth/#point-count-match","title":"Point Count Match","text":"<pre><code># Perfect match\n{\n    'success': True,\n    'match': True,\n    'expected_point_count': 23,\n    'actual_point_count': 23,\n    'accuracy_percentage': 100.0\n}\n\n# Partial match\n{\n    'success': True,\n    'match': False,\n    'expected_point_count': 23,\n    'actual_point_count': 20,\n    'accuracy_percentage': 86.96  # 20/23 * 100\n}\n</code></pre>"},{"location":"user-guide/validation/ground-truth/#equipment-count-results","title":"Equipment Count Results","text":"<pre><code># All match\n{\n    'overall_success': True,\n    'boiler': {'expected': 2, 'actual': 2, 'match': True},\n    'pump': {'expected': 3, 'actual': 3, 'match': True},\n    'weather_station': {'expected': 1, 'actual': 1, 'match': True}\n}\n\n# Mismatch detected\n{\n    'overall_success': False,\n    'boiler': {'expected': 2, 'actual': 1, 'match': False},  # Missing 1\n    'pump': {'expected': 3, 'actual': 3, 'match': True},\n    'weather_station': {'expected': 1, 'actual': 1, 'match': True}\n}\n</code></pre>"},{"location":"user-guide/validation/ground-truth/#common-patterns","title":"Common Patterns","text":""},{"location":"user-guide/validation/ground-truth/#pattern-1-validate-during-conversion","title":"Pattern 1: Validate During Conversion","text":"<pre><code>from hhw_brick import CSVToBrickConverter, BrickModelValidator\nfrom hhw_brick.validation import GroundTruthCalculator\n\n# Generate ground truth once\ncalculator = GroundTruthCalculator()\ncalculator.calculate(\"metadata.csv\", \"vars.csv\", \"ground_truth.csv\")\n\n# Create validator\nvalidator = BrickModelValidator(ground_truth_csv_path=\"ground_truth.csv\")\n\n# Convert and validate each building\nconverter = CSVToBrickConverter()\nfor building_id in [\"105\", \"106\", \"107\"]:\n    # Convert\n    converter.convert_to_brick(\n        metadata_csv=\"metadata.csv\",\n        vars_csv=\"vars.csv\",\n        building_tag=building_id,\n        output_path=f\"building_{building_id}.ttl\"\n    )\n\n    # Validate immediately\n    result = validator.validate_point_count(f\"building_{building_id}.ttl\")\n\n    if result['match']:\n        print(f\"\u2713 Building {building_id}: Complete\")\n    else:\n        print(f\"\u2717 Building {building_id}: {result['accuracy_percentage']:.1f}% complete\")\n</code></pre>"},{"location":"user-guide/validation/ground-truth/#pattern-2-only-use-complete-models","title":"Pattern 2: Only Use Complete Models","text":"<pre><code>def get_complete_models(model_dir, ground_truth_path):\n    \"\"\"Return list of models with 100% point count match.\"\"\"\n\n    validator = BrickModelValidator(\n        ground_truth_csv_path=ground_truth_path\n    )\n\n    results = validator.batch_validate_point_count(test_data_dir=model_dir)\n\n    complete_models = []\n    for result in results['individual_results']:\n        if result['match']:  # 100% match\n            complete_models.append(result['ttl_file_path'])\n\n    return complete_models\n\n# Use only complete models\ncomplete = get_complete_models(\"brick_models/\", \"ground_truth.csv\")\nprint(f\"Found {len(complete)} complete models\")\n\nfor model_path in complete:\n    # Safe to use in analytics\n    app.analyze(model_path, data, config)\n</code></pre>"},{"location":"user-guide/validation/ground-truth/#pattern-3-threshold-based-acceptance","title":"Pattern 3: Threshold-Based Acceptance","text":"<p>Accept models above a certain accuracy threshold:</p> <pre><code>def get_acceptable_models(model_dir, ground_truth_path, threshold=95.0):\n    \"\"\"Return models with accuracy &gt;= threshold.\"\"\"\n\n    validator = BrickModelValidator(\n        ground_truth_csv_path=ground_truth_path\n    )\n\n    results = validator.batch_validate_point_count(test_data_dir=model_dir)\n\n    acceptable = []\n    for result in results['individual_results']:\n        if result['accuracy_percentage'] &gt;= threshold:\n            acceptable.append({\n                'path': result['ttl_file_path'],\n                'accuracy': result['accuracy_percentage']\n            })\n\n    return acceptable\n\n# Use models with 95%+ accuracy\nacceptable = get_acceptable_models(\"brick_models/\", \"ground_truth.csv\", 95.0)\nprint(f\"Found {len(acceptable)} acceptable models (\u226595% accurate)\")\n</code></pre>"},{"location":"user-guide/validation/ground-truth/#troubleshooting","title":"Troubleshooting","text":""},{"location":"user-guide/validation/ground-truth/#issue-ground-truth-file-not-found","title":"Issue: \"Ground truth file not found\"","text":"<p>Solution: Generate it first: <pre><code>calculator = GroundTruthCalculator()\ncalculator.calculate(\n    metadata_csv=\"metadata.csv\",\n    vars_csv=\"vars.csv\",\n    output_csv=\"ground_truth.csv\"\n)\n</code></pre></p>"},{"location":"user-guide/validation/ground-truth/#issue-point-count-always-0","title":"Issue: Point count always 0","text":"<p>Cause: Building tag not found in ground truth</p> <p>Solution: Check building ID format: <pre><code>import pandas as pd\n\n# Check ground truth\ngt = pd.read_csv(\"ground_truth.csv\")\nprint(\"Buildings in ground truth:\")\nprint(gt['tag'].tolist())\n\n# Ensure building ID matches\n# File: building_105.ttl -&gt; tag should be \"105\" in ground_truth.csv\n</code></pre></p>"},{"location":"user-guide/validation/ground-truth/#issue-all-equipment-counts-mismatch","title":"Issue: All equipment counts mismatch","text":"<p>Cause: Ground truth calculation issue</p> <p>Solution: Regenerate ground truth: <pre><code># Delete old file\nimport os\nif os.exists(\"ground_truth.csv\"):\n    os.remove(\"ground_truth.csv\")\n\n# Regenerate\ncalculator = GroundTruthCalculator()\ncalculator.calculate(\n    metadata_csv=\"metadata.csv\",\n    vars_csv=\"vars.csv\",\n    output_csv=\"ground_truth.csv\"\n)\n</code></pre></p>"},{"location":"user-guide/validation/ground-truth/#issue-point-count-slightly-off","title":"Issue: Point count slightly off","text":"<p>Possible causes: 1. Sensor mapping differences 2. Optional sensors not counted 3. Generated points (e.g., virtual points)</p> <p>Investigation: <pre><code># Check what's in the model\nfrom rdflib import Graph\n\ng = Graph()\ng.parse(\"building_105.ttl\", format=\"turtle\")\n\n# Count points manually\nquery = \"\"\"\nPREFIX brick: &lt;https://brickschema.org/schema/Brick#&gt;\nSELECT (COUNT(?point) as ?count) WHERE {\n    ?point a ?type .\n    ?type rdfs:subClassOf* brick:Point .\n}\n\"\"\"\n\nfor row in g.query(query):\n    print(f\"Actual points in model: {row.count}\")\n</code></pre></p>"},{"location":"user-guide/validation/ground-truth/#best-practices","title":"Best Practices","text":""},{"location":"user-guide/validation/ground-truth/#1-generate-ground-truth-first","title":"1. Generate Ground Truth First","text":"<pre><code># Good \u2713\ncalculator.calculate(\"metadata.csv\", \"vars.csv\", \"ground_truth.csv\")\nvalidator = BrickModelValidator(ground_truth_csv_path=\"ground_truth.csv\")\n\n# Bad \u2717\n# Try to validate without ground truth\n</code></pre>"},{"location":"user-guide/validation/ground-truth/#2-regenerate-after-data-changes","title":"2. Regenerate After Data Changes","text":"<pre><code># If CSV data changes, regenerate ground truth\ncalculator.calculate(\"updated_metadata.csv\", \"updated_vars.csv\", \"ground_truth.csv\")\n</code></pre>"},{"location":"user-guide/validation/ground-truth/#3-check-both-points-and-equipment","title":"3. Check Both Points and Equipment","text":"<pre><code># Good \u2713\npoint_result = validator.validate_point_count(model)\nequip_result = validator.validate_equipment_count(model)\n\n# Bad \u2717\n# Only check one type\n</code></pre>"},{"location":"user-guide/validation/ground-truth/#4-handle-partial-matches","title":"4. Handle Partial Matches","text":"<pre><code># Good \u2713\nif result['accuracy_percentage'] &gt;= 95.0:\n    # Use model with warning\n    logging.warning(f\"Model {model} is {result['accuracy_percentage']:.1f}% complete\")\n    use_model(model)\n\n# Bad \u2717\nif result['match']:  # Only accept 100% matches\n    use_model(model)\n# Might reject many usable models\n</code></pre>"},{"location":"user-guide/validation/ground-truth/#next-steps","title":"Next Steps","text":"<ul> <li>Subgraph Patterns - Validate system topology</li> <li>Applications - Use validated models</li> <li>Examples - Working code</li> </ul> <p>Continue to: Subgraph Patterns \u2192</p>"},{"location":"user-guide/validation/ontology/","title":"Ontology Validation","text":"<p>Verify that Brick models follow the Brick Schema 1.4 rules and RDF/OWL standards using SHACL validation.</p>"},{"location":"user-guide/validation/ontology/#overview","title":"Overview","text":"<p>Ontology validation ensures your Brick model:</p> <ul> <li>\u2713 Uses valid Brick classes (e.g., <code>brick:Boiler</code>, <code>brick:Temperature_Sensor</code>)</li> <li>\u2713 Has correct relationships (e.g., <code>brick:hasPart</code>, <code>brick:feeds</code>, <code>brick:isPointOf</code>)</li> <li>\u2713 Follows RDF/OWL syntax rules</li> <li>\u2713 Uses proper namespaces and URIs</li> <li>\u2713 Conforms to SHACL constraints defined in Brick Schema 1.4</li> </ul>"},{"location":"user-guide/validation/ontology/#why-ontology-validation","title":"Why Ontology Validation?","text":""},{"location":"user-guide/validation/ontology/#1-ensure-interoperability","title":"1. Ensure Interoperability","text":"<p>Valid models work seamlessly with all Brick-compatible tools:</p> <pre><code># If model is valid, it works with:\n# \u2713 Other Brick applications\n# \u2713 SPARQL query engines\n# \u2713 Visualization tools (e.g., Brick Viewer)\n# \u2713 Analytics frameworks\n# \u2713 Integration platforms\n</code></pre>"},{"location":"user-guide/validation/ontology/#2-catch-errors-early","title":"2. Catch Errors Early","text":"<p>Find schema violations before using models in production:</p> <pre><code># Invalid models might cause:\n# \u2717 Analytics application failures\n# \u2717 SPARQL query errors\n# \u2717 Integration problems\n# \u2717 Incorrect inference results\n\n# Always validate first:\nvalidator = BrickModelValidator(use_local_brick=True)\nresult = validator.validate_ontology(\"building_105.ttl\")\n\nif result['valid']:\n    # Safe to use in production\n    app.analyze(\"building_105.ttl\", data, config)\nelse:\n    print(\"Fix violations before proceeding\")\n</code></pre>"},{"location":"user-guide/validation/ontology/#3-quality-assurance","title":"3. Quality Assurance","text":"<p>Ontology validation is the first level of quality assurance in the validation pipeline.</p>"},{"location":"user-guide/validation/ontology/#what-is-shacl","title":"What is SHACL?","text":"<p>SHACL (Shapes Constraint Language) is a W3C standard for validating RDF graphs.</p>"},{"location":"user-guide/validation/ontology/#how-shacl-works","title":"How SHACL Works","text":"<pre><code>Brick Model (RDF)  +  SHACL Shapes  \u2192  Validation Report\n    (Your data)      (Schema rules)     (Conformance check)\n</code></pre> <p>Example SHACL Shape (from Brick Schema): <pre><code># A Temperature_Sensor must have a unit\nbrick:TemperatureSensorShape\n    a sh:NodeShape ;\n    sh:targetClass brick:Temperature_Sensor ;\n    sh:property [\n        sh:path brick:hasUnit ;\n        sh:minCount 1 ;\n        sh:message \"Temperature sensor must have a unit\" ;\n    ] .\n</code></pre></p>"},{"location":"user-guide/validation/ontology/#shacl-in-hhw-brick","title":"SHACL in HHW Brick","text":"<p>HHW Brick uses Brick Schema 1.4's official SHACL shapes to validate models:</p> <ul> <li>\u2713 Class constraints</li> <li>\u2713 Property constraints</li> <li>\u2713 Relationship constraints</li> <li>\u2713 Data type constraints</li> </ul>"},{"location":"user-guide/validation/ontology/#basic-usage","title":"Basic Usage","text":""},{"location":"user-guide/validation/ontology/#validate-single-model","title":"Validate Single Model","text":"<p>Complete example from <code>examples/02_ontology_validation.py</code>:</p> <pre><code>from hhw_brick import BrickModelValidator\n\n# Create validator with local Brick schema\nvalidator = BrickModelValidator(use_local_brick=True)\n\n# Validate a model\nresult = validator.validate_ontology(\"building_105.ttl\")\n\n# Check result\nif result['valid']:\n    print(\"\u2713 Model is valid!\")\n    print(f\"  Conforms to Brick Schema 1.4\")\nelse:\n    print(f\"\u2717 Model has {len(result['violations'])} violations:\")\n    for i, violation in enumerate(result['violations'], 1):\n        print(f\"  {i}. {violation}\")\n</code></pre>"},{"location":"user-guide/validation/ontology/#result-structure","title":"Result Structure","text":"<pre><code>{\n    'valid': True,              # or False\n    'conforms': True,           # SHACL conformance\n    'violations': [],           # List of violation messages\n    'validation_report': {...}  # Detailed SHACL report (if violations exist)\n}\n</code></pre>"},{"location":"user-guide/validation/ontology/#expected-output","title":"Expected Output","text":"<p>\u2713 Valid model: <pre><code>\u2713 Model is valid!\n  Conforms to Brick Schema 1.4\n</code></pre></p> <p>\u2717 Invalid model: <pre><code>\u2717 Model has 3 violations:\n  1. Value does not have class brick:Equipment\n  2. Less than 1 values on building105:boiler1-&gt;brick:hasPoint\n  3. Invalid namespace: http://wrong.namespace.org#sensor1\n</code></pre></p>"},{"location":"user-guide/validation/ontology/#batch-validation-with-parallel-processing","title":"Batch Validation with Parallel Processing","text":"<p>Validate multiple buildings efficiently:</p>"},{"location":"user-guide/validation/ontology/#basic-batch-validation","title":"Basic Batch Validation","text":"<pre><code>from hhw_brick import BrickModelValidator\n\nvalidator = BrickModelValidator(use_local_brick=True)\n\n# Validate all TTL files in directory\nresults = validator.batch_validate_ontology(\n    test_data_dir=\"output/\",\n    max_workers=4  # Parallel workers (default: CPU count - 1)\n)\n\n# Display summary\nprint(f\"\\n{'='*60}\")\nprint(\"Batch Validation Results\")\nprint(f\"{'='*60}\")\nprint(f\"Total models: {results['total_files']}\")\nprint(f\"Valid: {results['passed_files']} \u2713\")\nprint(f\"Invalid: {results['failed_files']} \u2717\")\nprint(f\"Overall accuracy: {results['overall_accuracy']:.1f}%\")\n</code></pre>"},{"location":"user-guide/validation/ontology/#detailed-results","title":"Detailed Results","text":"<pre><code># Access individual results\nfor detail in results['details']:\n    filename = detail['filename']\n    valid = detail['valid']\n    status = '\u2713' if valid else '\u2717'\n\n    print(f\"{status} {filename}\")\n\n    if not valid and 'violations' in detail:\n        for violation in detail['violations']:\n            print(f\"    - {violation}\")\n</code></pre>"},{"location":"user-guide/validation/ontology/#results-structure","title":"Results Structure","text":"<pre><code>{\n    'total_files': 10,\n    'passed_files': 9,\n    'failed_files': 1,\n    'overall_accuracy': 90.0,\n    'details': [\n        {\n            'filename': 'building_105.ttl',\n            'valid': True,\n            'conforms': True,\n            'violations': []\n        },\n        {\n            'filename': 'building_110.ttl',\n            'valid': False,\n            'conforms': False,\n            'violations': ['Invalid class: brick:WrongBoiler']\n        },\n        # ... more results\n    ]\n}\n</code></pre>"},{"location":"user-guide/validation/ontology/#performance-with-parallel-processing","title":"Performance with Parallel Processing","text":"<pre><code># Single-threaded (slow for many files)\nresults = validator.batch_validate_ontology(\n    test_data_dir=\"output/\",\n    max_workers=1  # Sequential\n)\n# 10 files \u00d7 10s each = 100 seconds\n\n# Multi-threaded (faster)\nresults = validator.batch_validate_ontology(\n    test_data_dir=\"output/\",\n    max_workers=4  # 4 parallel workers\n)\n# 10 files / 4 workers \u00d7 10s = ~25 seconds\n</code></pre> <p>Choosing max_workers</p> <ul> <li>Default: <code>cpu_count() - 1</code> (leaves one core free)</li> <li>Small datasets: <code>max_workers=2</code> or <code>3</code></li> <li>Large datasets: <code>max_workers=8</code> or more</li> <li>Don't exceed available CPU cores</li> </ul>"},{"location":"user-guide/validation/ontology/#local-vs-nightly-brick-schema","title":"Local vs Nightly Brick Schema","text":""},{"location":"user-guide/validation/ontology/#use-local-brick-recommended","title":"Use Local Brick (Recommended)","text":"<pre><code>validator = BrickModelValidator(use_local_brick=True)\n</code></pre> <p>Advantages: - \u2713 Works offline - \u2713 Faster (no network download) - \u2713 Stable (specific Brick version) - \u2713 Reproducible results</p> <p>When to use: - Production environments - CI/CD pipelines - Offline validation - Consistent testing</p>"},{"location":"user-guide/validation/ontology/#use-nightly-brick-latest","title":"Use Nightly Brick (Latest)","text":"<pre><code>validator = BrickModelValidator(load_brick_nightly=True)\n</code></pre> <p>Advantages: - \u2713 Latest Brick Schema features - \u2713 Newest SHACL shapes - \u2713 Cutting-edge updates</p> <p>Disadvantages: - \u2717 Requires internet connection - \u2717 Slower (downloads from GitHub) - \u2717 Results may change over time</p> <p>When to use: - Development/testing - Exploring new Brick features - Checking compatibility with latest schema</p> <p>Don't mix in production</p> <p>Choose one approach and stick with it for consistency. Use <code>use_local_brick=True</code> for production to ensure reproducible validation results.</p>"},{"location":"user-guide/validation/ontology/#common-violations-and-fixes","title":"Common Violations and Fixes","text":""},{"location":"user-guide/validation/ontology/#1-invalid-brick-class","title":"1. Invalid Brick Class","text":"<p>Violation: <pre><code>Value does not have class brick:Equipment\n</code></pre></p> <p>Cause: Using non-existent or misspelled Brick class</p> <p>Fix: <pre><code># \u2717 Wrong\ng.add((building_ns.boiler1, RDF.type, BRICK.InvalidBoiler))\n\n# \u2713 Correct\ng.add((building_ns.boiler1, RDF.type, BRICK.Boiler))\n</code></pre></p>"},{"location":"user-guide/validation/ontology/#2-missing-required-relationship","title":"2. Missing Required Relationship","text":"<p>Violation: <pre><code>Less than 1 values on building105:boiler1-&gt;brick:hasPoint\n</code></pre></p> <p>Cause: Equipment missing required sensors/points</p> <p>Fix: <pre><code># \u2717 Missing hasPoint relationship\ng.add((building_ns.boiler1, RDF.type, BRICK.Boiler))\n\n# \u2713 Add required sensor\ng.add((building_ns.boiler1, RDF.type, BRICK.Boiler))\ng.add((building_ns.boiler1, BRICK.hasPoint, building_ns.boiler1_temp))\ng.add((building_ns.boiler1_temp, RDF.type, BRICK.Temperature_Sensor))\n</code></pre></p>"},{"location":"user-guide/validation/ontology/#3-invalid-namespace","title":"3. Invalid Namespace","text":"<p>Violation: <pre><code>Invalid namespace: http://example.org#sensor1\n</code></pre></p> <p>Cause: Using non-standard namespace without proper declaration</p> <p>Fix: <pre><code># \u2717 Wrong - undefined namespace\nsensor_uri = URIRef(\"http://example.org#sensor1\")\n\n# \u2713 Correct - use building-specific namespace\nfrom rdflib import Namespace\nBUILDING = Namespace(\"https://buildings.example.org#\")\nsensor_uri = BUILDING.building105_sensor1\n</code></pre></p>"},{"location":"user-guide/validation/ontology/#4-incorrect-relationship-direction","title":"4. Incorrect Relationship Direction","text":"<p>Violation: <pre><code>Unexpected relationship direction\n</code></pre></p> <p>Cause: Using inverse relationships incorrectly</p> <p>Fix: <pre><code># \u2717 Wrong direction\ng.add((sensor, BRICK.isPointOf, equipment))\n\n# \u2713 Correct direction\ng.add((equipment, BRICK.hasPoint, sensor))\n# OR use inverse\ng.add((sensor, BRICK.isPointOf, equipment))\n</code></pre></p>"},{"location":"user-guide/validation/ontology/#5-missing-type-declaration","title":"5. Missing Type Declaration","text":"<p>Violation: <pre><code>Node has no rdf:type\n</code></pre></p> <p>Cause: Entity missing <code>rdf:type</code> declaration</p> <p>Fix: <pre><code># \u2717 Missing type\ng.add((building_ns.loop1, BRICK.hasPart, building_ns.pump1))\n\n# \u2713 Add types\ng.add((building_ns.loop1, RDF.type, BRICK.Hot_Water_Loop))\ng.add((building_ns.pump1, RDF.type, BRICK.Pump))\ng.add((building_ns.loop1, BRICK.hasPart, building_ns.pump1))\n</code></pre></p>"},{"location":"user-guide/validation/ontology/#advanced-usage","title":"Advanced Usage","text":""},{"location":"user-guide/validation/ontology/#custom-validation-with-additional-shapes","title":"Custom Validation with Additional Shapes","text":"<pre><code>from hhw_brick import BrickModelValidator\n\n# Validate with custom SHACL shapes\nvalidator = BrickModelValidator(use_local_brick=True)\n\n# Load additional shapes\ncustom_shapes = \"\"\"\n@prefix sh: &lt;http://www.w3.org/ns/shacl#&gt; .\n@prefix brick: &lt;https://brickschema.org/schema/Brick#&gt; .\n\n# Custom shape: All boilers must have a manufacturer\nbrick:CustomBoilerShape\n    a sh:NodeShape ;\n    sh:targetClass brick:Boiler ;\n    sh:property [\n        sh:path brick:hasManufacturer ;\n        sh:minCount 1 ;\n        sh:message \"Boiler must have a manufacturer\" ;\n    ] .\n\"\"\"\n\n# Note: HHW Brick currently validates against standard Brick shapes\n# Custom shapes require extending the validator\n</code></pre>"},{"location":"user-guide/validation/ontology/#programmatic-access-to-violations","title":"Programmatic Access to Violations","text":"<pre><code>result = validator.validate_ontology(\"building_105.ttl\")\n\nif not result['valid']:\n    violations = result['violations']\n\n    # Categorize violations\n    class_violations = [v for v in violations if 'class' in v.lower()]\n    property_violations = [v for v in violations if 'property' in v.lower()]\n\n    print(f\"Class violations: {len(class_violations)}\")\n    print(f\"Property violations: {len(property_violations)}\")\n\n    # Log for debugging\n    with open('validation_report.txt', 'w') as f:\n        for v in violations:\n            f.write(f\"{v}\\n\")\n</code></pre>"},{"location":"user-guide/validation/ontology/#integration-with-conversion-pipeline","title":"Integration with Conversion Pipeline","text":"<p>Validate immediately after conversion:</p> <pre><code>from hhw_brick import CSVToBrickConverter, BrickModelValidator\n\n# Convert\nconverter = CSVToBrickConverter()\ngraph = converter.convert_to_brick(\n    metadata_csv=\"metadata.csv\",\n    vars_csv=\"vars_available_by_building.csv\",\n    building_tag=\"105\",\n    output_path=\"building_105.ttl\"\n)\n\n# Validate immediately\nvalidator = BrickModelValidator(use_local_brick=True)\nresult = validator.validate_ontology(\"building_105.ttl\")\n\nif result['valid']:\n    print(f\"\u2713 Conversion successful: {len(graph)} triples\")\n    print(\"\u2713 Model validated\")\nelse:\n    print(\"\u2717 Conversion produced invalid model\")\n    print(\"Violations:\")\n    for v in result['violations']:\n        print(f\"  - {v}\")\n    # Fix converter logic\n</code></pre>"},{"location":"user-guide/validation/ontology/#troubleshooting","title":"Troubleshooting","text":""},{"location":"user-guide/validation/ontology/#validation-takes-too-long","title":"Validation Takes Too Long","text":"<p>Problem: Validation is slow for large models</p> <p>Solutions: 1. Use batch validation with parallel processing 2. Reduce <code>max_workers</code> if memory is limited 3. Validate incrementally during development</p> <pre><code># Fast batch validation\nresults = validator.batch_validate_ontology(\n    test_data_dir=\"output/\",\n    max_workers=8  # Adjust based on CPU\n)\n</code></pre>"},{"location":"user-guide/validation/ontology/#no-data-to-validate-error","title":"\"No data to validate\" Error","text":"<p>Problem: Validator can't read the TTL file</p> <p>Solutions: 1. Check file path is correct 2. Verify TTL file is valid RDF syntax 3. Ensure file has <code>.ttl</code> extension</p> <pre><code>from pathlib import Path\n\nttl_file = Path(\"building_105.ttl\")\nif not ttl_file.exists():\n    print(f\"File not found: {ttl_file}\")\nelif not ttl_file.suffix == '.ttl':\n    print(f\"Wrong extension: {ttl_file.suffix}\")\n</code></pre>"},{"location":"user-guide/validation/ontology/#inconsistent-validation-results","title":"Inconsistent Validation Results","text":"<p>Problem: Results differ between runs</p> <p>Solution: Use <code>use_local_brick=True</code> for consistent results</p> <pre><code># \u2717 Inconsistent (downloads latest schema each time)\nvalidator = BrickModelValidator(load_brick_nightly=True)\n\n# \u2713 Consistent (uses fixed local schema)\nvalidator = BrickModelValidator(use_local_brick=True)\n</code></pre>"},{"location":"user-guide/validation/ontology/#violations-but-model-looks-correct","title":"Violations but Model Looks Correct","text":"<p>Problem: SHACL reports violations but model seems valid</p> <p>Solutions: 1. Check Brick Schema version compatibility 2. Verify namespace URIs are exact 3. Review SHACL shape definitions 4. Check relationship directions</p> <pre><code># Debug: Inspect model manually\nfrom rdflib import Graph\n\ng = Graph()\ng.parse(\"building_105.ttl\", format=\"turtle\")\n\n# Check all types used\ntypes = set()\nfor s, p, o in g.triples((None, RDF.type, None)):\n    types.add(str(o))\n\nprint(\"Classes used:\")\nfor t in sorted(types):\n    print(f\"  - {t}\")\n</code></pre>"},{"location":"user-guide/validation/ontology/#best-practices","title":"Best Practices","text":"<p>Ontology Validation Best Practices</p> <ol> <li>Validate early and often - After each conversion</li> <li>Use local Brick - For consistent results (<code>use_local_brick=True</code>)</li> <li>Batch validate - Faster with <code>max_workers</code></li> <li>Log violations - Save reports for debugging</li> <li>Fix root causes - Update converter, not individual models</li> <li>Automate - Include in CI/CD pipeline</li> </ol>"},{"location":"user-guide/validation/ontology/#example-cicd-integration","title":"Example CI/CD Integration","text":"<pre><code>def ci_validation_check(output_dir):\n    \"\"\"CI/CD validation check - fails build if invalid models\"\"\"\n    validator = BrickModelValidator(use_local_brick=True)\n\n    results = validator.batch_validate_ontology(\n        test_data_dir=output_dir,\n        max_workers=4\n    )\n\n    if results['overall_accuracy'] &lt; 100.0:\n        print(f\"\u2717 Validation failed: {results['failed_files']} invalid models\")\n        for detail in results['details']:\n            if not detail['valid']:\n                print(f\"\\n{detail['filename']}:\")\n                for v in detail.get('violations', []):\n                    print(f\"  - {v}\")\n        return False  # Fail CI build\n    else:\n        print(f\"\u2713 All {results['total_files']} models valid\")\n        return True  # Pass CI build\n\n# In CI pipeline\nif not ci_validation_check(\"output/\"):\n    exit(1)  # Fail build\n</code></pre>"},{"location":"user-guide/validation/ontology/#next-steps","title":"Next Steps","text":"<ul> <li>Ground Truth Validation - Validate point and equipment counts</li> <li>Subgraph Pattern Validation - Validate system structure</li> <li>Examples - Working validation examples</li> <li>Back to Validation Overview</li> </ul>"},{"location":"user-guide/validation/ontology/#references","title":"References","text":"<ul> <li>Brick Schema Documentation</li> <li>SHACL W3C Specification</li> <li>RDF 1.1 Primer</li> <li>brickschema Python Package</li> </ul>"},{"location":"user-guide/validation/ontology/#validation-methods","title":"Validation Methods","text":""},{"location":"user-guide/validation/ontology/#validate_ontology","title":"validate_ontology()","text":"<p>Main ontology validation method.</p> <p>Signature: <pre><code>def validate_ontology(ttl_file_path: str) -&gt; Dict\n</code></pre></p> <p>Parameters: - <code>ttl_file_path</code> (str): Path to TTL file to validate</p> <p>Returns: <pre><code>{\n    'valid': bool,              # True if valid\n    'violations': list,         # List of violation messages\n    'ttl_file_path': str,       # Path to validated file\n    'success': bool,            # Same as 'valid'\n    'is_valid': bool,           # Same as 'valid'\n    'validation_report': str    # Text report\n}\n</code></pre></p> <p>Example: <pre><code>result = validator.validate_ontology(\"building_105.ttl\")\n\nprint(f\"Valid: {result['valid']}\")\nprint(f\"File: {result['ttl_file_path']}\")\n\nif not result['valid']:\n    print(\"Violations:\")\n    for v in result['violations']:\n        print(f\"  - {v}\")\n</code></pre></p>"},{"location":"user-guide/validation/ontology/#batch-validation","title":"Batch Validation","text":""},{"location":"user-guide/validation/ontology/#validate-multiple-models-parallel","title":"Validate Multiple Models (Parallel)","text":"<p>From <code>examples/02_ontology_validation.py</code>:</p> <pre><code>from hhw_brick import BrickModelValidator\n\nvalidator = BrickModelValidator(use_local_brick=True)\n\n# Batch validate with parallel processing\nresults = validator.batch_validate_ontology(\n    test_data_dir=\"brick_models/\",\n    max_workers=8  # Number of parallel workers\n)\n\n# Results\nprint(f\"Total files: {results['total_files']}\")\nprint(f\"Valid: {results['passed_files']}\")\nprint(f\"Invalid: {results['failed_files']}\")\nprint(f\"Accuracy: {results['overall_accuracy']:.1f}%\")\n</code></pre>"},{"location":"user-guide/validation/ontology/#batch_validate_ontology","title":"batch_validate_ontology()","text":"<p>Signature: <pre><code>def batch_validate_ontology(\n    test_data_dir: str,\n    max_workers: int = None\n) -&gt; Dict\n</code></pre></p> <p>Parameters: - <code>test_data_dir</code> (str): Directory containing TTL files - <code>max_workers</code> (int, optional): Number of parallel workers (default: CPU count - 1)</p> <p>Returns: <pre><code>{\n    'total_files': int,           # Total TTL files found\n    'passed_files': int,          # Valid models\n    'failed_files': int,          # Invalid models\n    'overall_accuracy': float,    # Percentage valid\n    'individual_results': [...]   # List of individual results\n}\n</code></pre></p> <p>Example: <pre><code># Auto-detect worker count\nresults = validator.batch_validate_ontology(\n    test_data_dir=\"brick_models/\"\n)\n\n# Custom worker count for better performance\nresults = validator.batch_validate_ontology(\n    test_data_dir=\"brick_models/\",\n    max_workers=16  # Use 16 workers\n)\n\n# Show detailed results\nfor result in results['individual_results']:\n    file_name = result['ttl_file_path'].split('/')[-1]\n    status = \"\u2713\" if result['valid'] else \"\u2717\"\n    print(f\"{status} {file_name}\")\n</code></pre></p>"},{"location":"user-guide/validation/ontology/#local-vs-remote-brick-schema","title":"Local vs Remote Brick Schema","text":""},{"location":"user-guide/validation/ontology/#using-local-brick-schema-recommended","title":"Using Local Brick Schema (Recommended)","text":"<p>Faster and works offline:</p> <pre><code>validator = BrickModelValidator(use_local_brick=True)\nresult = validator.validate_ontology(\"building_105.ttl\")\n</code></pre> <p>Advantages: - \u2713 Faster validation - \u2713 Works offline - \u2713 Consistent results - \u2713 No network dependency</p> <p>Uses: <code>hhw_brick/validation/Brick_Self.ttl</code></p>"},{"location":"user-guide/validation/ontology/#using-remote-brick-schema","title":"Using Remote Brick Schema","text":"<p>Latest Brick schema from GitHub:</p> <pre><code>validator = BrickModelValidator(use_local_brick=False)\nresult = validator.validate_ontology(\"building_105.ttl\")\n</code></pre> <p>Advantages: - \u2713 Always latest Brick version - \u2713 Latest class definitions</p> <p>Disadvantages: - \u2717 Requires internet - \u2717 Slower validation - \u2717 May change over time</p>"},{"location":"user-guide/validation/ontology/#common-validation-patterns","title":"Common Validation Patterns","text":""},{"location":"user-guide/validation/ontology/#pattern-1-validate-after-conversion","title":"Pattern 1: Validate After Conversion","text":"<pre><code>from hhw_brick import CSVToBrickConverter, BrickModelValidator\n\n# Convert\nconverter = CSVToBrickConverter()\nresult = converter.convert_to_brick(\n    metadata_csv=\"metadata.csv\",\n    vars_csv=\"vars.csv\",\n    building_tag=\"105\",\n    output_path=\"building_105.ttl\"\n)\n\n# Validate immediately\nvalidator = BrickModelValidator(use_local_brick=True)\nvalidation = validator.validate_ontology(\"building_105.ttl\")\n\nif validation['valid']:\n    print(\"\u2713 Conversion successful and valid\")\nelse:\n    print(\"\u2717 Conversion produced invalid model\")\n    print(\"Review these issues:\")\n    for v in validation['violations']:\n        print(f\"  - {v}\")\n</code></pre>"},{"location":"user-guide/validation/ontology/#pattern-2-production-batch-validation","title":"Pattern 2: Production Batch Validation","text":"<pre><code>\"\"\"\nProduction validation workflow\n\"\"\"\nfrom pathlib import Path\nfrom hhw_brick import BatchConverter, BrickModelValidator\n\ndef production_validation():\n    \"\"\"Convert and validate all buildings.\"\"\"\n\n    # Step 1: Batch convert\n    print(\"Converting buildings...\")\n    batch = BatchConverter()\n    conversion_results = batch.convert_all_buildings(\n        metadata_csv=\"metadata.csv\",\n        vars_csv=\"vars.csv\",\n        output_dir=\"brick_models/\",\n        show_progress=True\n    )\n\n    print(f\"Converted {conversion_results['successful']} buildings\")\n\n    # Step 2: Batch validate\n    print(\"\\nValidating models...\")\n    validator = BrickModelValidator(use_local_brick=True)\n    validation_results = validator.batch_validate_ontology(\n        test_data_dir=\"brick_models/\",\n        max_workers=8\n    )\n\n    # Step 3: Report\n    print(f\"\\nValidation Results:\")\n    print(f\"  Total: {validation_results['total_files']}\")\n    print(f\"  Valid: {validation_results['passed_files']}\")\n    print(f\"  Invalid: {validation_results['failed_files']}\")\n    print(f\"  Accuracy: {validation_results['overall_accuracy']:.1f}%\")\n\n    # Step 4: Handle failures\n    if validation_results['failed_files'] &gt; 0:\n        print(\"\\nFailed models:\")\n        for result in validation_results['individual_results']:\n            if not result['valid']:\n                print(f\"  \u2717 {Path(result['ttl_file_path']).name}\")\n                for v in result.get('violations', [])[:3]:  # First 3\n                    print(f\"      - {v}\")\n\n    return validation_results\n\nif __name__ == \"__main__\":\n    results = production_validation()\n</code></pre>"},{"location":"user-guide/validation/ontology/#pattern-3-selective-validation","title":"Pattern 3: Selective Validation","text":"<p>Only validate new or changed models:</p> <pre><code>import os\nfrom pathlib import Path\n\ndef validate_new_models(model_dir, cache_file=\".validation_cache\"):\n    \"\"\"Validate only new/changed models.\"\"\"\n\n    # Load validation cache\n    validated = set()\n    if os.path.exists(cache_file):\n        with open(cache_file, 'r') as f:\n            validated = set(line.strip() for line in f)\n\n    # Find new models\n    all_models = set(str(p) for p in Path(model_dir).glob(\"*.ttl\"))\n    new_models = all_models - validated\n\n    if not new_models:\n        print(\"No new models to validate\")\n        return\n\n    print(f\"Validating {len(new_models)} new models...\")\n\n    validator = BrickModelValidator(use_local_brick=True)\n\n    # Validate new models\n    newly_validated = []\n    for model_path in new_models:\n        result = validator.validate_ontology(model_path)\n\n        if result['valid']:\n            newly_validated.append(model_path)\n            print(f\"\u2713 {Path(model_path).name}\")\n        else:\n            print(f\"\u2717 {Path(model_path).name}\")\n\n    # Update cache\n    with open(cache_file, 'a') as f:\n        for model in newly_validated:\n            f.write(f\"{model}\\n\")\n\n    print(f\"\\nValidated {len(newly_validated)}/{len(new_models)} new models\")\n\n# Use it\nvalidate_new_models(\"brick_models/\")\n</code></pre>"},{"location":"user-guide/validation/ontology/#what-gets-validated","title":"What Gets Validated","text":""},{"location":"user-guide/validation/ontology/#brick-class-names","title":"Brick Class Names","text":"<p>Checks if classes exist in Brick schema:</p> <pre><code># Valid \u2713\nbrick:Boiler\nbrick:Hot_Water_Supply_Temperature_Sensor\nbrick:Heat_Exchanger\n\n# Invalid \u2717\nbrick:InvalidBoiler  # No such class\nbrick:TemperatureSensor  # Wrong name (should be Temperature_Sensor)\nmyprefix:CustomClass  # Not in Brick namespace\n</code></pre>"},{"location":"user-guide/validation/ontology/#relationship-types","title":"Relationship Types","text":"<p>Checks if relationships are valid:</p> <pre><code># Valid \u2713\nbrick:hasPoint\nbrick:feeds\nbrick:isPartOf\n\n# Invalid \u2717\nbrick:hasInvalidRelation  # No such relation\ncustom:feeds  # Wrong namespace\n</code></pre>"},{"location":"user-guide/validation/ontology/#rdf-syntax","title":"RDF Syntax","text":"<p>Checks RDF/Turtle syntax:</p> <pre><code># Valid \u2713\n:Boiler_01 a brick:Boiler .\n:Boiler_01 brick:hasPoint :Temp_Sensor .\n\n# Invalid \u2717\n:Boiler_01 a brick:Boiler  # Missing period\n:Boiler_01 brick:hasPoint  # Incomplete triple\n</code></pre>"},{"location":"user-guide/validation/ontology/#namespace-declarations","title":"Namespace Declarations","text":"<p>Checks proper namespace usage:</p> <pre><code># Valid \u2713\n@prefix brick: &lt;https://brickschema.org/schema/Brick#&gt; .\n@prefix hhws: &lt;https://hhws.example.org#&gt; .\n\n# Invalid \u2717\n@prefix brick: &lt;http://wrong.url.org#&gt; .  # Wrong URL\n# Missing namespace declarations\n</code></pre>"},{"location":"user-guide/validation/ontology/#understanding-validation-results","title":"Understanding Validation Results","text":""},{"location":"user-guide/validation/ontology/#valid-result","title":"Valid Result","text":"<pre><code>{\n    'valid': True,\n    'violations': [],\n    'ttl_file_path': 'building_105.ttl',\n    'success': True,\n    'is_valid': True,\n    'validation_report': 'Model is valid'\n}\n</code></pre>"},{"location":"user-guide/validation/ontology/#invalid-result","title":"Invalid Result","text":"<pre><code>{\n    'valid': False,\n    'violations': [\n        'sh:Violation on brick:hasPoint',\n        'Invalid class: brick:WrongClass',\n        'Missing required property'\n    ],\n    'ttl_file_path': 'building_105.ttl',\n    'success': False,\n    'is_valid': False,\n    'validation_report': 'Model has 3 violations'\n}\n</code></pre>"},{"location":"user-guide/validation/ontology/#performance","title":"Performance","text":""},{"location":"user-guide/validation/ontology/#single-model","title":"Single Model","text":"<p>Typical validation time: - Local Brick: 0.5-2 seconds per model - Remote Brick: 3-5 seconds per model (first time)</p>"},{"location":"user-guide/validation/ontology/#batch-validation_1","title":"Batch Validation","text":"<p>Parallel processing dramatically improves speed:</p> <pre><code># Serial (slow)\nfor file in ttl_files:\n    validator.validate_ontology(file)  # ~2 sec each\n# 100 files = ~200 seconds\n\n# Parallel (fast)\nresults = validator.batch_validate_ontology(\n    test_data_dir=\"models/\",\n    max_workers=8\n)\n# 100 files = ~30 seconds (8x speedup)\n</code></pre> <p>Performance table:</p> Models Serial Parallel (8 workers) Speedup 10 ~20s ~5s 4x 50 ~100s ~15s 6.7x 100 ~200s ~30s 6.7x 500 ~1000s ~150s 6.7x"},{"location":"user-guide/validation/ontology/#optimization-tips","title":"Optimization Tips","text":"<ol> <li>Use local Brick for faster validation</li> <li>Increase workers for more parallelism (up to CPU count)</li> <li>Validate in batches rather than one-by-one</li> <li>Cache results for unchanged models</li> </ol>"},{"location":"user-guide/validation/ontology/#troubleshooting_1","title":"Troubleshooting","text":""},{"location":"user-guide/validation/ontology/#issue-brickschema-not-available","title":"Issue: \"brickschema not available\"","text":"<p>Cause: Missing dependency</p> <p>Solution: <pre><code>pip install brickschema\n</code></pre></p>"},{"location":"user-guide/validation/ontology/#issue-local-brick-file-not-found","title":"Issue: \"Local Brick file not found\"","text":"<p>Cause: Package not properly installed</p> <p>Solution: <pre><code># Reinstall package\npip install --force-reinstall hhw-brick\n</code></pre></p> <p>Or use remote Brick: <pre><code>validator = BrickModelValidator(use_local_brick=False)\n</code></pre></p>"},{"location":"user-guide/validation/ontology/#issue-all-models-failing-validation","title":"Issue: All models failing validation","text":"<p>Possible causes: 1. Conversion issues 2. Wrong Brick version 3. Corrupted TTL files</p> <p>Solution: <pre><code># Check single model manually\nfrom rdflib import Graph\n\ng = Graph()\ntry:\n    g.parse(\"building_105.ttl\", format=\"turtle\")\n    print(f\"\u2713 File parses correctly: {len(g)} triples\")\nexcept Exception as e:\n    print(f\"\u2717 Parse error: {e}\")\n</code></pre></p>"},{"location":"user-guide/validation/ontology/#issue-validation-too-slow","title":"Issue: Validation too slow","text":"<p>Solution 1: Use local Brick <pre><code>validator = BrickModelValidator(use_local_brick=True)\n</code></pre></p> <p>Solution 2: Increase workers <pre><code>results = validator.batch_validate_ontology(\n    test_data_dir=\"models/\",\n    max_workers=16  # More workers\n)\n</code></pre></p> <p>Solution 3: Validate only changed files <pre><code># See \"Pattern 3: Selective Validation\" above\n</code></pre></p>"},{"location":"user-guide/validation/ontology/#best-practices_1","title":"Best Practices","text":""},{"location":"user-guide/validation/ontology/#1-always-validate-after-conversion","title":"1. Always Validate After Conversion","text":"<pre><code># Good \u2713\nresult = converter.convert_to_brick(...)\nvalidation = validator.validate_ontology(output_file)\n\n# Bad \u2717\nresult = converter.convert_to_brick(...)\n# Skip validation - might have invalid models\n</code></pre>"},{"location":"user-guide/validation/ontology/#2-use-local-brick-for-production","title":"2. Use Local Brick for Production","text":"<pre><code># Production \u2713\nvalidator = BrickModelValidator(use_local_brick=True)\n\n# Development (occasional use)\nvalidator = BrickModelValidator(use_local_brick=False)\n</code></pre>"},{"location":"user-guide/validation/ontology/#3-handle-validation-failures","title":"3. Handle Validation Failures","text":"<pre><code># Good \u2713\nresult = validator.validate_ontology(\"model.ttl\")\nif not result['valid']:\n    log_error(result['violations'])\n    notify_admin()\n    skip_model()\n\n# Bad \u2717\nresult = validator.validate_ontology(\"model.ttl\")\n# Ignore failures - use invalid model anyway\n</code></pre>"},{"location":"user-guide/validation/ontology/#4-log-validation-results","title":"4. Log Validation Results","text":"<pre><code>import logging\n\nlogging.basicConfig(level=logging.INFO)\n\nresult = validator.validate_ontology(\"model.ttl\")\nif result['valid']:\n    logging.info(f\"\u2713 Valid: {result['ttl_file_path']}\")\nelse:\n    logging.error(f\"\u2717 Invalid: {result['ttl_file_path']}\")\n    for v in result['violations']:\n        logging.error(f\"  - {v}\")\n</code></pre>"},{"location":"user-guide/validation/ontology/#next-steps_1","title":"Next Steps","text":"<ul> <li>Ground Truth Validation - Validate counts and completeness</li> <li>Subgraph Patterns - Validate system topology</li> <li>Examples - Working code samples</li> </ul> <p>Continue to: Ground Truth Validation \u2192</p>"},{"location":"user-guide/validation/subgraph-patterns/","title":"Subgraph Pattern Validation","text":"<p>Validate system topology and architectural patterns in Brick models.</p>"},{"location":"user-guide/validation/subgraph-patterns/#overview","title":"Overview","text":"<p>Subgraph pattern validation checks if your Brick model follows expected system architecture patterns:</p> <ul> <li>Pattern 1 (Boiler System): Has boilers, primary loop, heat exchanger, secondary loop</li> <li>Pattern 2 (District System): Has district connection, secondary loop, no boilers</li> </ul> <p>This ensures system topology is correct.</p>"},{"location":"user-guide/validation/subgraph-patterns/#why-validate-patterns","title":"Why Validate Patterns?","text":""},{"location":"user-guide/validation/subgraph-patterns/#verify-system-architecture","title":"Verify System Architecture","text":"<p>Ensure model represents the actual system:</p> <pre><code># Pattern 2: District System\n# Expected: District connection \u2192 HX \u2192 Secondary loop\n# Should NOT have: Boilers, primary loop\n\nresult = validator.check_pattern_2_district_system(\"building_108.ttl\")\nif result['matched']:\n    print(\"\u2713 District system architecture correct\")\n</code></pre>"},{"location":"user-guide/validation/subgraph-patterns/#catch-modeling-errors","title":"Catch Modeling Errors","text":"<p>Find structural issues:</p> <pre><code># District system but has boilers? Error!\nif result['has_boiler']:\n    print(\"\u2717 District system should not have boilers\")\n</code></pre>"},{"location":"user-guide/validation/subgraph-patterns/#prepare-for-analytics","title":"Prepare for Analytics","text":"<p>Some analytics require specific patterns:</p> <pre><code># This app requires boiler system (Pattern 1)\nif not has_boilers(model):\n    print(\"Skip: Model doesn't match required pattern\")\n</code></pre>"},{"location":"user-guide/validation/subgraph-patterns/#subgraphpatternvalidator","title":"SubgraphPatternValidator","text":""},{"location":"user-guide/validation/subgraph-patterns/#basic-usage","title":"Basic Usage","text":"<p>From <code>examples/05_subgraph_pattern_matching.py</code>:</p> <pre><code>from hhw_brick.validation import SubgraphPatternValidator\n\n# Create validator\nvalidator = SubgraphPatternValidator()\n\n# Check if model matches Pattern 2 (District System)\nresult = validator.check_pattern_2_district_system(\"building_108.ttl\")\n\nif result['matched']:\n    print(\"\u2713 This is a District System\")\n    print(f\"  - Has building: {result['details']['has_building']}\")\n    print(f\"  - Has HW system: {result['details']['has_hot_water_system']}\")\n    print(f\"  - Has secondary loop: {result['details']['has_secondary_loop']}\")\n    print(f\"  - No boilers: {not result['details']['has_boiler']}\")\nelse:\n    print(\"\u2717 Not a District System\")\n</code></pre>"},{"location":"user-guide/validation/subgraph-patterns/#pattern-definitions","title":"Pattern Definitions","text":""},{"location":"user-guide/validation/subgraph-patterns/#pattern-1-boiler-system","title":"Pattern 1: Boiler System","text":"<p>Architecture: <pre><code>graph LR\n    B[Boiler] --&gt;|feeds| HX[Heat Exchanger]\n    HX --&gt;|feeds| SL[Secondary Loop]\n    B --&gt;|has| PP[Primary Pump]\n    SL --&gt;|has| SP[Secondary Pump]\n\n    style B fill:#ff9800\n    style HX fill:#2196f3\n    style SL fill:#4caf50</code></pre></p> <p>Components: - \u2713 One or more boilers - \u2713 Primary loop - \u2713 Heat exchanger - \u2713 Secondary loop - \u2713 Primary and secondary pumps</p> <p>System Types: Non-condensing, Condensing, Boiler</p>"},{"location":"user-guide/validation/subgraph-patterns/#pattern-2-district-system","title":"Pattern 2: District System","text":"<p>Architecture: <pre><code>graph LR\n    DS[District&lt;br/&gt;Supply] --&gt;|feeds| HX[Heat&lt;br/&gt;Exchanger]\n    HX --&gt;|feeds| BL[Building&lt;br/&gt;Loop]\n    DS --&gt;|has| DM[District&lt;br/&gt;Meter]\n    BL --&gt;|has| BP[Building&lt;br/&gt;Pump]\n\n    style DS fill:#9c27b0\n    style HX fill:#2196f3\n    style BL fill:#4caf50</code></pre></p> <p>Components: - \u2713 District hot water/steam connection - \u2713 Heat exchanger - \u2713 Secondary loop (building side) - \u2713 Building pumps - \u2717 NO boilers - \u2717 NO primary loop</p> <p>System Types: District HW, District Steam</p>"},{"location":"user-guide/validation/subgraph-patterns/#validation-methods","title":"Validation Methods","text":""},{"location":"user-guide/validation/subgraph-patterns/#check_pattern_2_district_system","title":"check_pattern_2_district_system()","text":"<p>Check if model matches District System pattern.</p> <p>Signature: <pre><code>def check_pattern_2_district_system(ttl_file_path: str) -&gt; Dict\n</code></pre></p> <p>Returns: <pre><code>{\n    'matched': bool,                    # True if matches Pattern 2\n    'details': {\n        'has_building': bool,           # Building entity exists\n        'has_hot_water_system': bool,   # HW system exists\n        'has_secondary_loop': bool,     # Secondary loop exists\n        'has_pump': bool,               # Pumps exist\n        'has_weather_station': bool,    # Weather station exists\n        'has_boiler': bool,             # Should be False for Pattern 2\n        'has_primary_loop': bool,       # Should be False for Pattern 2\n        'pump_count': int               # Number of pumps\n    },\n    'ttl_file_path': str,\n    'error': str or None                # Error message if failed\n}\n</code></pre></p> <p>Example: <pre><code>result = validator.check_pattern_2_district_system(\"building_108.ttl\")\n\nprint(f\"Matched Pattern 2: {result['matched']}\")\n\ndetails = result['details']\nprint(f\"\\nComponents:\")\nprint(f\"  Building: {details['has_building']}\")\nprint(f\"  HW System: {details['has_hot_water_system']}\")\nprint(f\"  Secondary Loop: {details['has_secondary_loop']}\")\nprint(f\"  Pump Count: {details['pump_count']}\")\n\n# Verify no boiler components\nprint(f\"\\nNo Boiler Components (should be False):\")\nprint(f\"  Has Boiler: {details['has_boiler']}\")\nprint(f\"  Has Primary Loop: {details['has_primary_loop']}\")\n</code></pre></p>"},{"location":"user-guide/validation/subgraph-patterns/#batch-pattern-validation","title":"Batch Pattern Validation","text":"<p>From <code>examples/05_subgraph_pattern_matching.py</code>:</p> <pre><code>from hhw_brick.validation import SubgraphPatternValidator\n\nvalidator = SubgraphPatternValidator()\n\n# Batch validate all buildings\nbatch_results = validator.batch_validate_all_buildings(\n    ttl_directory=\"brick_models/\",\n    max_workers=4  # Parallel workers\n)\n\n# Summary\ntotal = len(batch_results)\npattern_2 = sum(1 for r in batch_results if r.get('matched'))\npattern_1 = total - pattern_2\n\nprint(f\"Total buildings: {total}\")\nprint(f\"Pattern 1 (Boiler Systems): {pattern_1}\")\nprint(f\"Pattern 2 (District Systems): {pattern_2}\")\n</code></pre>"},{"location":"user-guide/validation/subgraph-patterns/#batch_validate_all_buildings","title":"batch_validate_all_buildings()","text":"<p>Signature: <pre><code>def batch_validate_all_buildings(\n    ttl_directory: str,\n    max_workers: int = None\n) -&gt; List[Dict]\n</code></pre></p> <p>Parameters: - <code>ttl_directory</code> (str): Directory containing TTL files - <code>max_workers</code> (int, optional): Number of parallel workers</p> <p>Returns: <pre><code>[\n    {\n        'matched': bool,\n        'details': {...},\n        'ttl_file_path': str,\n        'error': str or None\n    },\n    # ... one dict per file\n]\n</code></pre></p> <p>Example: <pre><code>results = validator.batch_validate_all_buildings(\n    ttl_directory=\"brick_models/\",\n    max_workers=8\n)\n\n# Group by pattern\npattern_1_models = []\npattern_2_models = []\n\nfor result in results:\n    file_name = Path(result['ttl_file_path']).name\n\n    if result['matched']:\n        pattern_2_models.append(file_name)\n    else:\n        pattern_1_models.append(file_name)\n\nprint(f\"Pattern 1 (Boiler): {len(pattern_1_models)} models\")\nprint(f\"Pattern 2 (District): {len(pattern_2_models)} models\")\n</code></pre></p>"},{"location":"user-guide/validation/subgraph-patterns/#complete-validation-example","title":"Complete Validation Example","text":"<p>Based on <code>examples/05_subgraph_pattern_matching.py</code>:</p> <pre><code>\"\"\"\nComplete subgraph pattern validation\n\"\"\"\n\nfrom pathlib import Path\nfrom hhw_brick.validation import SubgraphPatternValidator\n\ndef validate_system_patterns():\n    # Create validator\n    validator = SubgraphPatternValidator()\n\n    # ===== Single Building Validation =====\n    print(\"Single Building Pattern Validation\")\n    print(\"=\"*60)\n\n    building_file = \"building_108_district_hw_aa.ttl\"\n\n    # Check Pattern 2\n    result = validator.check_pattern_2_district_system(building_file)\n\n    if result['matched']:\n        print(f\"\u2713 {building_file} matches Pattern 2 (District System)\")\n\n        details = result['details']\n        print(\"\\nSystem Components:\")\n        print(f\"  \u2713 Building: {details['has_building']}\")\n        print(f\"  \u2713 HW System: {details['has_hot_water_system']}\")\n        print(f\"  \u2713 Secondary Loop: {details['has_secondary_loop']}\")\n        print(f\"  \u2713 Pumps: {details['pump_count']}\")\n        print(f\"  \u2713 Weather Station: {details['has_weather_station']}\")\n\n        print(\"\\nNo Boiler Components (correct for District):\")\n        print(f\"  \u2713 No Boiler: {not details['has_boiler']}\")\n        print(f\"  \u2713 No Primary Loop: {not details['has_primary_loop']}\")\n    else:\n        print(f\"\u2717 {building_file} does NOT match Pattern 2\")\n        print(f\"  This is likely a Pattern 1 (Boiler System)\")\n\n    # ===== Batch Validation =====\n    print(\"\\n\" + \"=\"*60)\n    print(\"Batch Pattern Validation\")\n    print(\"=\"*60)\n\n    batch_results = validator.batch_validate_all_buildings(\n        ttl_directory=\"brick_models/\",\n        max_workers=8\n    )\n\n    # Analyze results\n    total = len(batch_results)\n    pattern_2_count = 0\n    pattern_1_count = 0\n    errors = 0\n\n    pattern_2_files = []\n    pattern_1_files = []\n\n    for result in batch_results:\n        file_name = Path(result['ttl_file_path']).name\n\n        if result.get('error'):\n            errors += 1\n        elif result['matched']:\n            pattern_2_count += 1\n            pattern_2_files.append(file_name)\n        else:\n            pattern_1_count += 1\n            pattern_1_files.append(file_name)\n\n    # Summary\n    print(f\"\\nPattern Validation Summary:\")\n    print(f\"  Total files: {total}\")\n    print(f\"  Pattern 1 (Boiler Systems): {pattern_1_count}\")\n    print(f\"  Pattern 2 (District Systems): {pattern_2_count}\")\n    print(f\"  Errors: {errors}\")\n\n    # Show samples\n    if pattern_1_files:\n        print(f\"\\nPattern 1 (Boiler) sample:\")\n        for file in pattern_1_files[:3]:\n            print(f\"  - {file}\")\n\n    if pattern_2_files:\n        print(f\"\\nPattern 2 (District) sample:\")\n        for file in pattern_2_files[:3]:\n            print(f\"  - {file}\")\n\n    return batch_results\n\nif __name__ == \"__main__\":\n    results = validate_system_patterns()\n</code></pre>"},{"location":"user-guide/validation/subgraph-patterns/#common-use-cases","title":"Common Use Cases","text":""},{"location":"user-guide/validation/subgraph-patterns/#use-case-1-separate-by-pattern","title":"Use Case 1: Separate by Pattern","text":"<p>Group models by their pattern:</p> <pre><code>def separate_by_pattern(model_dir):\n    \"\"\"Separate models into Pattern 1 and Pattern 2 directories.\"\"\"\n\n    from pathlib import Path\n    import shutil\n\n    validator = SubgraphPatternValidator()\n\n    # Create output directories\n    pattern_1_dir = Path(\"pattern_1_boiler\")\n    pattern_2_dir = Path(\"pattern_2_district\")\n    pattern_1_dir.mkdir(exist_ok=True)\n    pattern_2_dir.mkdir(exist_ok=True)\n\n    # Validate all\n    results = validator.batch_validate_all_buildings(\n        ttl_directory=model_dir,\n        max_workers=8\n    )\n\n    # Copy to appropriate directories\n    for result in results:\n        src = Path(result['ttl_file_path'])\n\n        if result['matched']:\n            dst = pattern_2_dir / src.name\n        else:\n            dst = pattern_1_dir / src.name\n\n        shutil.copy(src, dst)\n\n    print(f\"Pattern 1 (Boiler): {len(list(pattern_1_dir.glob('*.ttl')))} files\")\n    print(f\"Pattern 2 (District): {len(list(pattern_2_dir.glob('*.ttl')))} files\")\n\n# Use it\nseparate_by_pattern(\"brick_models/\")\n</code></pre>"},{"location":"user-guide/validation/subgraph-patterns/#use-case-2-validate-before-analytics","title":"Use Case 2: Validate Before Analytics","text":"<p>Only run certain analytics on matching patterns:</p> <pre><code>def run_pattern_specific_analytics(model_path, data, config):\n    \"\"\"Run analytics based on system pattern.\"\"\"\n\n    validator = SubgraphPatternValidator()\n    result = validator.check_pattern_2_district_system(model_path)\n\n    if result['matched']:\n        # Pattern 2: District System\n        print(\"Running district system analytics...\")\n        app = apps.load_app(\"district_efficiency\")\n    else:\n        # Pattern 1: Boiler System\n        print(\"Running boiler system analytics...\")\n        app = apps.load_app(\"boiler_efficiency\")\n\n    # Run appropriate analytics\n    qualified, details = app.qualify(model_path)\n    if qualified:\n        results = app.analyze(model_path, data, config)\n        return results\n    else:\n        print(\"Building doesn't qualify for this analysis\")\n        return None\n</code></pre>"},{"location":"user-guide/validation/subgraph-patterns/#use-case-3-validation-report","title":"Use Case 3: Validation Report","text":"<p>Generate detailed pattern validation report:</p> <pre><code>def generate_pattern_report(model_dir, output_file=\"pattern_report.csv\"):\n    \"\"\"Generate CSV report of pattern validation.\"\"\"\n\n    import pandas as pd\n\n    validator = SubgraphPatternValidator()\n    results = validator.batch_validate_all_buildings(\n        ttl_directory=model_dir,\n        max_workers=8\n    )\n\n    # Create report data\n    report_data = []\n    for result in results:\n        file_name = Path(result['ttl_file_path']).name\n        building_id = file_name.split('_')[1]  # Extract from filename\n\n        details = result.get('details', {})\n\n        report_data.append({\n            'building_id': building_id,\n            'file_name': file_name,\n            'pattern': 'Pattern 2 (District)' if result['matched'] else 'Pattern 1 (Boiler)',\n            'has_building': details.get('has_building', False),\n            'has_hw_system': details.get('has_hot_water_system', False),\n            'has_secondary_loop': details.get('has_secondary_loop', False),\n            'has_boiler': details.get('has_boiler', False),\n            'pump_count': details.get('pump_count', 0),\n            'has_weather_station': details.get('has_weather_station', False)\n        })\n\n    # Create DataFrame and save\n    df = pd.DataFrame(report_data)\n    df.to_csv(output_file, index=False)\n\n    print(f\"Pattern report saved to: {output_file}\")\n    print(f\"Total buildings: {len(df)}\")\n    print(df['pattern'].value_counts())\n\n    return df\n\n# Use it\nreport = generate_pattern_report(\"brick_models/\")\n</code></pre>"},{"location":"user-guide/validation/subgraph-patterns/#understanding-results","title":"Understanding Results","text":""},{"location":"user-guide/validation/subgraph-patterns/#pattern-2-match-district-system","title":"Pattern 2 Match (District System)","text":"<pre><code>{\n    'matched': True,\n    'details': {\n        'has_building': True,\n        'has_hot_water_system': True,\n        'has_secondary_loop': True,\n        'has_pump': True,\n        'has_weather_station': True,\n        'has_boiler': False,          # Correct: No boiler\n        'has_primary_loop': False,    # Correct: No primary loop\n        'pump_count': 2\n    },\n    'ttl_file_path': 'building_108.ttl',\n    'error': None\n}\n</code></pre>"},{"location":"user-guide/validation/subgraph-patterns/#pattern-1-not-pattern-2","title":"Pattern 1 (Not Pattern 2)","text":"<pre><code>{\n    'matched': False,  # Not Pattern 2\n    'details': {\n        'has_building': True,\n        'has_hot_water_system': True,\n        'has_secondary_loop': True,\n        'has_pump': True,\n        'has_weather_station': True,\n        'has_boiler': True,           # Has boiler -&gt; Pattern 1\n        'has_primary_loop': True,     # Has primary loop -&gt; Pattern 1\n        'pump_count': 4\n    },\n    'ttl_file_path': 'building_105.ttl',\n    'error': None\n}\n</code></pre>"},{"location":"user-guide/validation/subgraph-patterns/#troubleshooting","title":"Troubleshooting","text":""},{"location":"user-guide/validation/subgraph-patterns/#issue-all-models-show-matchedfalse","title":"Issue: All models show matched=False","text":"<p>Cause: Models are Pattern 1 (Boiler systems)</p> <p>Solution: This is correct if you have boiler systems. Pattern 2 is specifically for district systems.</p>"},{"location":"user-guide/validation/subgraph-patterns/#issue-pattern-validation-fails","title":"Issue: Pattern validation fails","text":"<p>Cause: Model parsing error</p> <p>Solution: <pre><code>result = validator.check_pattern_2_district_system(\"model.ttl\")\n\nif result.get('error'):\n    print(f\"Validation error: {result['error']}\")\n    # Check if file is valid\n    from rdflib import Graph\n    g = Graph()\n    g.parse(\"model.ttl\", format=\"turtle\")\n</code></pre></p>"},{"location":"user-guide/validation/subgraph-patterns/#issue-district-system-not-matching-pattern-2","title":"Issue: District system not matching Pattern 2","text":"<p>Possible causes: 1. Model has boiler entities (shouldn't) 2. Missing secondary loop components 3. Conversion issue</p> <p>Investigation: <pre><code>result = validator.check_pattern_2_district_system(\"district_model.ttl\")\n\ndetails = result['details']\nprint(f\"Has boiler (should be False): {details['has_boiler']}\")\nprint(f\"Has primary loop (should be False): {details['has_primary_loop']}\")\nprint(f\"Has secondary loop (should be True): {details['has_secondary_loop']}\")\n</code></pre></p>"},{"location":"user-guide/validation/subgraph-patterns/#best-practices","title":"Best Practices","text":""},{"location":"user-guide/validation/subgraph-patterns/#1-use-pattern-validation-for-filtering","title":"1. Use Pattern Validation for Filtering","text":"<pre><code># Separate district systems for specific analytics\nvalidator = SubgraphPatternValidator()\nresults = validator.batch_validate_all_buildings(\"brick_models/\")\n\ndistrict_models = [\n    r['ttl_file_path'] for r in results if r['matched']\n]\n\nfor model in district_models:\n    # Run district-specific analytics\n    run_district_analysis(model)\n</code></pre>"},{"location":"user-guide/validation/subgraph-patterns/#2-combine-with-other-validation","title":"2. Combine with Other Validation","text":"<pre><code># Complete validation pipeline\nontology_valid = validator.validate_ontology(model)['valid']\npattern_matched = pattern_validator.check_pattern_2_district_system(model)['matched']\ncounts_match = validator.validate_point_count(model)['match']\n\nif ontology_valid and counts_match:\n    # Model is valid, check pattern for analytics selection\n    if pattern_matched:\n        run_district_analytics(model)\n    else:\n        run_boiler_analytics(model)\n</code></pre>"},{"location":"user-guide/validation/subgraph-patterns/#3-document-pattern-in-metadata","title":"3. Document Pattern in Metadata","text":"<pre><code># Add pattern info to model metadata\nresults = validator.batch_validate_all_buildings(\"brick_models/\")\n\nfor result in results:\n    pattern = \"District\" if result['matched'] else \"Boiler\"\n    file_path = result['ttl_file_path']\n\n    # Store in database or metadata file\n    save_metadata(file_path, pattern=pattern)\n</code></pre>"},{"location":"user-guide/validation/subgraph-patterns/#next-steps","title":"Next Steps","text":"<ul> <li>Applications - Use validated models in analytics</li> <li>Examples - More pattern examples</li> <li>API Reference - Complete API</li> </ul> <p>Validation documentation complete! \ud83c\udf89</p> <p>Continue to Applications Guide \u2192</p>"}]}