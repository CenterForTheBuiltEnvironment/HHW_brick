{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"HHW Brick Application <p> Semantic Modeling &amp; Analytics Toolkit for Hot Water Systems </p> <p> Transform building hot water system data into standardized Brick models with automated conversion, validation, and portable analytics </p> <p> </p> <p> Get Started Installation </p>"},{"location":"#why-hhw-brick-application","title":"Why HHW Brick Application?","text":"<p>A complete toolkit for hot water system analytics with portable applications and one-click deployment based on Brick ontology</p> <p>HHW Brick Application provides a specialized portable application framework designed specifically for building heating hot water systems. Built on Brick semantic standards, it enables automated data conversion, quality validation, and seamless deployment of analytics applications across different buildings.</p> Component Description Brick-Based Modeling Standardized semantic models for 5 hot water system types (Boiler, Non-condensing, Condensing, District HW, District Steam) Portable App Framework Pre-built analytics applications that automatically adapt to different building configurations One-Click Deployment Automated conversion \u2192 validation \u2192 deployment workflow with built-in quality assurance Batch Processing Process hundreds of buildings in parallel with consistent quality across the portfolio"},{"location":"#three-step-workflow","title":"Three-Step Workflow","text":"1. Convert - CSV to Brick Models <p>Transform equipment metadata and sensor data into standardized Brick semantic models with automatic system type detection and flexible sensor mapping</p> 2. Validate - Triple Quality Assurance <p>Ensure model correctness through Brick Schema compliance, point/equipment count verification, and system topology pattern matching</p> 3. Analyze - Deploy Portable Applications <p>Run pre-built analytics applications (temperature difference, performance benchmarking) or deploy custom applications across buildings</p>"},{"location":"#quick-start-example","title":"Quick Start Example","text":"<p>Get from raw data to validated models in under 5 minutes:</p> <pre><code>from hhw_brick import CSVToBrickConverter\nfrom hhw_brick.validation import (\n    BrickModelValidator,\n    GroundTruthCalculator,\n    SubgraphPatternValidator\n)\nfrom hhw_brick import apps\n\n# Step 1: Convert your CSV data to Brick\nconverter = CSVToBrickConverter()\nconverter.convert_to_brick(\n    metadata_csv=\"metadata.csv\",\n    vars_csv=\"vars_available_by_building.csv\",\n    building_tag=\"105\",\n    output_path=\"building_105.ttl\"\n)\n\n# Step 2: Validate the generated model\n\n# 2.1 Ontology validation - Brick Schema compliance\nvalidator = BrickModelValidator(use_local_brick=True)\nontology_result = validator.validate_ontology(\"building_105.ttl\")\nprint(f\"Ontology valid: {ontology_result['valid']}\")\n\n# 2.2 Generate ground truth for count validation\ncalculator = GroundTruthCalculator()\nground_truth_df = calculator.calculate(\n    metadata_csv=\"metadata.csv\",\n    vars_csv=\"vars_available_by_building.csv\",\n    output_csv=\"ground_truth.csv\"\n)\n\n# 2.3 Validate point and equipment counts\nvalidator_with_gt = BrickModelValidator(\n    ground_truth_csv_path=\"ground_truth.csv\",\n    use_local_brick=True\n)\npoint_result = validator_with_gt.validate_point_count(\"building_105.ttl\", building_tag=\"105\")\nequipment_result = validator_with_gt.validate_equipment_count(\"building_105.ttl\", building_tag=\"105\")\nprint(f\"Point count valid: {point_result['valid']}\")\nprint(f\"Equipment count valid: {equipment_result['valid']}\")\n\n# 2.4 Validate system topology pattern\npattern_validator = SubgraphPatternValidator()\npattern_result = pattern_validator.validate_building(\"building_105.ttl\")\nprint(f\"Pattern matched: {pattern_result['primary_pattern']}\")\n\n# Step 3: Run analytics on validated models\nif ontology_result['valid'] and pattern_result['valid']:\n    # Load and qualify application\n    app = apps.load_app(\"secondary_loop_temp_diff\")\n    qualified, details = app.qualify(\"building_105.ttl\")\n\n    if qualified:\n        # Run analysis\n        config = apps.get_default_config(\"secondary_loop_temp_diff\")\n        results = app.analyze(\"building_105.ttl\", \"105_data.csv\", config)\n\n        # Results are automatically saved to output directory\n        print(f\"\u2713 Analysis complete!\")\n        print(f\"\u2713 Results saved to: {config['output']['output_dir']}\")\n</code></pre> <p>That's it! From CSV to insights in 3 simple steps.</p> <p>\ud83d\udcd6 See Full Tutorial \u2192</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install hhw-brick\n</code></pre> <p>Requirements: Python 3.8 or higher</p> <p>\ud83d\udcd8 Detailed Installation Guide \u2192</p>"},{"location":"#key-features","title":"Key Features","text":"Batch Processing at Scale <p>Convert 100+ buildings in minutes with parallel processing. Built-in progress tracking and error handling.</p> 5 Hot Water System Types <p>Comprehensive support for Boiler, Non-condensing, Condensing, District HW, and District Steam heating systems.</p> Triple Validation <p>Ontology schema + ground truth comparison + topology pattern matching ensure model quality.</p> Portable Applications <p>Pre-built analytics apps with a framework for creating custom applications that work across buildings.</p> Flexible Sensor Mapping <p>YAML-based configuration with intelligent matching. Customize mappings to fit your data structure.</p> Comprehensive Reporting <p>Detailed validation reports with accuracy statistics, violation details, and actionable recommendations.</p>"},{"location":"#documentation","title":"Documentation","text":"\ud83d\ude80 Getting Started <p>Installation, 5-minute quick start, understanding Brick ontology, and CSV data format requirements.</p> Read Guide \u2192 \ud83d\udd04 Conversion Guide <p>Single building conversion, batch processing, system type configuration, and sensor mapping customization.</p> Read Guide \u2192 \u2705 Validation Guide <p>Ontology validation, ground truth comparison, topology pattern matching, and batch validation workflows.</p> Read Guide \u2192 \ud83d\udcca Applications Guide <p>Apps manager, temperature difference analysis, running applications, and custom app development.</p> Read Guide \u2192"},{"location":"#resources","title":"ResourcesReady to Get Started?","text":"\ud83d\udcd6 Documentation <p> Getting Started User Guide FAQ </p> \ud83d\udce6 Package Info <p> PyPI Package Changelog MIT License </p> \ud83d\udd27 Source Code <p> GitHub Repository View Examples Report Issues </p> <p> Transform your hot water system data into standardized Brick models </p> <p>      Get Started Now \u2192    </p> <p>Developed by Mingchen Li</p> <p>Making building hot water system data standardized and analyzable</p>"},{"location":"APP_DEVELOPER_GUIDE/","title":"App Developer Guide - HHW Brick Application","text":"<p>Version: 1.0.0 Last Updated: October 22, 2025 Audience: Developers who want to create custom analytics applications</p>"},{"location":"APP_DEVELOPER_GUIDE/#table-of-contents","title":"\ud83d\udcda Table of Contents","text":"<ol> <li>Introduction</li> <li>Framework Overview</li> <li>Quick Start</li> <li>BaseApp API Reference</li> <li>SPARQL Query Patterns</li> <li>Best Practices</li> <li>Common Patterns</li> <li>Troubleshooting</li> </ol>"},{"location":"APP_DEVELOPER_GUIDE/#introduction","title":"\ud83c\udfaf Introduction","text":"<p>The HHW Brick Application framework allows you to create custom analytics applications that analyze Brick models of hot water systems. This guide will teach you how to:</p> <ul> <li>Create custom apps using the <code>BaseApp</code> class</li> <li>Query Brick models using SPARQL</li> <li>Process and export results</li> <li>Integrate with the CLI</li> </ul>"},{"location":"APP_DEVELOPER_GUIDE/#what-is-an-app","title":"What is an App?","text":"<p>An App is a Python class that: 1. Inherits from <code>BaseApp</code> 2. Implements an <code>analyze()</code> method 3. Queries Brick models using SPARQL 4. Returns structured results</p>"},{"location":"APP_DEVELOPER_GUIDE/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.8+</li> <li>Basic understanding of Brick Schema</li> <li>Familiarity with SPARQL (helpful but not required)</li> <li>HHW Brick Application installed</li> </ul>"},{"location":"APP_DEVELOPER_GUIDE/#framework-overview","title":"\ud83c\udfd7\ufe0f Framework Overview","text":""},{"location":"APP_DEVELOPER_GUIDE/#architecture","title":"Architecture","text":"<pre><code>User runs CLI \u2192 AppRunner \u2192 Your App \u2192 SPARQL Query \u2192 Brick Model\n                                    \u2193\n                              Results \u2192 Export (CSV/JSON)\n</code></pre>"},{"location":"APP_DEVELOPER_GUIDE/#key-components","title":"Key Components","text":"<p>BaseApp - Base class for all apps - Provides common functionality - Handles Brick model loading - Manages namespaces - Provides helper methods</p> <p>AppRegistry - Manages app registration - Discovers available apps - Provides app metadata - Handles app instantiation</p> <p>AppRunner - Executes apps - Loads Brick models - Runs apps - Handles output</p>"},{"location":"APP_DEVELOPER_GUIDE/#app-lifecycle","title":"App Lifecycle","text":"<pre><code>1. App is registered (via @register_app decorator or manual registration)\n2. User runs app via CLI: hhw-brick apps run &lt;app_name&gt; &lt;model.ttl&gt;\n3. AppRunner loads the Brick model\n4. AppRunner instantiates your app\n5. Your analyze() method is called\n6. Results are returned and optionally exported\n</code></pre>"},{"location":"APP_DEVELOPER_GUIDE/#quick-start","title":"\ud83d\ude80 Quick Start","text":""},{"location":"APP_DEVELOPER_GUIDE/#step-1-create-your-first-app","title":"Step 1: Create Your First App","text":"<p>Create a new file <code>my_first_app.py</code>:</p> <pre><code>from hhw_brick.analytics.core.base_app import BaseApp, register_app\nfrom rdflib import Namespace\n\n@register_app(\n    name=\"my_first_app\",\n    description=\"My first Brick analytics app\",\n    version=\"1.0.0\"\n)\nclass MyFirstApp(BaseApp):\n    \"\"\"A simple app that counts buildings in the model.\"\"\"\n\n    def analyze(self, graph, building_name=None, **kwargs):\n        \"\"\"\n        Analyze the Brick model.\n\n        Args:\n            graph: rdflib.Graph - The loaded Brick model\n            building_name: str - Optional building name filter\n            **kwargs: Additional arguments\n\n        Returns:\n            dict: Analysis results\n        \"\"\"\n        # Define SPARQL query\n        query = \"\"\"\n        PREFIX brick: &lt;https://brickschema.org/schema/Brick#&gt;\n\n        SELECT ?building\n        WHERE {\n            ?building a brick:Building .\n        }\n        \"\"\"\n\n        # Execute query\n        results = graph.query(query)\n\n        # Process results\n        buildings = [str(row.building) for row in results]\n\n        # Return structured results\n        return {\n            'building_count': len(buildings),\n            'buildings': buildings\n        }\n</code></pre>"},{"location":"APP_DEVELOPER_GUIDE/#step-2-run-your-app","title":"Step 2: Run Your App","text":"<pre><code># Run via CLI\nhhw-brick apps run my_first_app building_105.ttl\n\n# Run with output file\nhhw-brick apps run my_first_app building_105.ttl -o results.json\n</code></pre>"},{"location":"APP_DEVELOPER_GUIDE/#step-3-use-in-python","title":"Step 3: Use in Python","text":"<pre><code>from my_first_app import MyFirstApp\nfrom rdflib import Graph\n\n# Load Brick model\ngraph = Graph()\ngraph.parse(\"building_105.ttl\", format=\"turtle\")\n\n# Create app instance\napp = MyFirstApp()\n\n# Run analysis\nresults = app.analyze(graph)\n\nprint(f\"Found {results['building_count']} buildings\")\n</code></pre>"},{"location":"APP_DEVELOPER_GUIDE/#baseapp-api-reference","title":"\ud83d\udcd6 BaseApp API Reference","text":""},{"location":"APP_DEVELOPER_GUIDE/#class-baseapp","title":"Class: BaseApp","text":"<p>Location: <code>hhw_brick.analytics.core.base_app</code></p>"},{"location":"APP_DEVELOPER_GUIDE/#constructor","title":"Constructor","text":"<pre><code>def __init__(self, config=None):\n    \"\"\"\n    Initialize the app.\n\n    Args:\n        config (dict, optional): Configuration dictionary\n    \"\"\"\n</code></pre>"},{"location":"APP_DEVELOPER_GUIDE/#methods","title":"Methods","text":""},{"location":"APP_DEVELOPER_GUIDE/#analyze","title":"analyze()","text":"<p>Abstract method - MUST be implemented by your app</p> <pre><code>def analyze(self, graph, building_name=None, **kwargs):\n    \"\"\"\n    Analyze the Brick model.\n\n    Args:\n        graph (rdflib.Graph): The loaded Brick model\n        building_name (str, optional): Building name filter\n        **kwargs: Additional arguments\n\n    Returns:\n        dict: Analysis results\n\n    Raises:\n        NotImplementedError: If not implemented by subclass\n    \"\"\"\n</code></pre>"},{"location":"APP_DEVELOPER_GUIDE/#get_buildings","title":"get_buildings()","text":"<pre><code>def get_buildings(self, graph):\n    \"\"\"\n    Get all buildings in the model.\n\n    Args:\n        graph (rdflib.Graph): The Brick model\n\n    Returns:\n        list: List of building URIs\n    \"\"\"\n</code></pre>"},{"location":"APP_DEVELOPER_GUIDE/#get_points","title":"get_points()","text":"<pre><code>def get_points(self, graph, point_class=None):\n    \"\"\"\n    Get all points in the model.\n\n    Args:\n        graph (rdflib.Graph): The Brick model\n        point_class (str, optional): Filter by point class\n\n    Returns:\n        list: List of point URIs\n    \"\"\"\n</code></pre>"},{"location":"APP_DEVELOPER_GUIDE/#get_equipment","title":"get_equipment()","text":"<pre><code>def get_equipment(self, graph, equipment_class=None):\n    \"\"\"\n    Get all equipment in the model.\n\n    Args:\n        graph (rdflib.Graph): The Brick model\n        equipment_class (str, optional): Filter by equipment class\n\n    Returns:\n        list: List of equipment URIs\n    \"\"\"\n</code></pre>"},{"location":"APP_DEVELOPER_GUIDE/#properties","title":"Properties","text":""},{"location":"APP_DEVELOPER_GUIDE/#brick-namespace","title":"brick (Namespace)","text":"<pre><code>@property\ndef brick(self):\n    \"\"\"Brick Schema namespace.\"\"\"\n    return Namespace(\"https://brickschema.org/schema/Brick#\")\n</code></pre>"},{"location":"APP_DEVELOPER_GUIDE/#rdfs-namespace","title":"rdfs (Namespace)","text":"<pre><code>@property\ndef rdfs(self):\n    \"\"\"RDFS namespace.\"\"\"\n    return RDFS\n</code></pre>"},{"location":"APP_DEVELOPER_GUIDE/#rdf-namespace","title":"rdf (Namespace)","text":"<pre><code>@property\ndef rdf(self):\n    \"\"\"RDF namespace.\"\"\"\n    return RDF\n</code></pre>"},{"location":"APP_DEVELOPER_GUIDE/#sparql-query-patterns","title":"\ud83d\udd0d SPARQL Query Patterns","text":""},{"location":"APP_DEVELOPER_GUIDE/#common-query-patterns-for-brick-models","title":"Common Query Patterns for Brick Models","text":""},{"location":"APP_DEVELOPER_GUIDE/#pattern-1-get-all-points","title":"Pattern 1: Get All Points","text":"<pre><code>query = \"\"\"\nPREFIX brick: &lt;https://brickschema.org/schema/Brick#&gt;\n\nSELECT ?point ?pointType\nWHERE {\n    ?point a/rdfs:subClassOf* brick:Point .\n    ?point a ?pointType .\n}\n\"\"\"\n</code></pre>"},{"location":"APP_DEVELOPER_GUIDE/#pattern-2-get-equipment-with-points","title":"Pattern 2: Get Equipment with Points","text":"<pre><code>query = \"\"\"\nPREFIX brick: &lt;https://brickschema.org/schema/Brick#&gt;\n\nSELECT ?equipment ?point ?pointType\nWHERE {\n    ?equipment brick:hasPoint ?point .\n    ?point a ?pointType .\n}\n\"\"\"\n</code></pre>"},{"location":"APP_DEVELOPER_GUIDE/#pattern-3-get-system-topology","title":"Pattern 3: Get System Topology","text":"<pre><code>query = \"\"\"\nPREFIX brick: &lt;https://brickschema.org/schema/Brick#&gt;\n\nSELECT ?system ?equipment\nWHERE {\n    ?system brick:hasPart ?equipment .\n    ?equipment a/rdfs:subClassOf* brick:Equipment .\n}\n\"\"\"\n</code></pre>"},{"location":"APP_DEVELOPER_GUIDE/#pattern-4-get-relationships","title":"Pattern 4: Get Relationships","text":"<pre><code>query = \"\"\"\nPREFIX brick: &lt;https://brickschema.org/schema/Brick#&gt;\n\nSELECT ?source ?target\nWHERE {\n    ?source brick:feeds ?target .\n}\n\"\"\"\n</code></pre>"},{"location":"APP_DEVELOPER_GUIDE/#pattern-5-filter-by-building","title":"Pattern 5: Filter by Building","text":"<pre><code>query = \"\"\"\nPREFIX brick: &lt;https://brickschema.org/schema/Brick#&gt;\nPREFIX hhws: &lt;https://example.org/hhws#&gt;\n\nSELECT ?point\nWHERE {\n    hhws:building105 brick:hasPart* ?point .\n    ?point a/rdfs:subClassOf* brick:Point .\n}\n\"\"\"\n</code></pre>"},{"location":"APP_DEVELOPER_GUIDE/#best-practices","title":"\u2705 Best Practices","text":""},{"location":"APP_DEVELOPER_GUIDE/#1-return-structured-data","title":"1. Return Structured Data","text":"<p>Good: <pre><code>def analyze(self, graph, **kwargs):\n    return {\n        'summary': {'total_points': 42, 'total_equipment': 5},\n        'points': [...],\n        'equipment': [...]\n    }\n</code></pre></p> <p>Bad: <pre><code>def analyze(self, graph, **kwargs):\n    return \"Found 42 points and 5 equipment\"  # Hard to process!\n</code></pre></p>"},{"location":"APP_DEVELOPER_GUIDE/#2-handle-errors-gracefully","title":"2. Handle Errors Gracefully","text":"<pre><code>def analyze(self, graph, **kwargs):\n    try:\n        results = graph.query(query)\n        return self._process_results(results)\n    except Exception as e:\n        return {\n            'error': str(e),\n            'success': False\n        }\n</code></pre>"},{"location":"APP_DEVELOPER_GUIDE/#3-use-efficient-queries","title":"3. Use Efficient Queries","text":"<p>Good: <pre><code># Get everything in one query\nquery = \"\"\"\nSELECT ?equipment ?point ?pointType\nWHERE {\n    ?equipment brick:hasPoint ?point .\n    ?point a ?pointType .\n}\n\"\"\"\n</code></pre></p> <p>Bad: <pre><code># Multiple queries (slow!)\nfor equipment in get_equipment():\n    for point in get_points_for_equipment(equipment):\n        ...  # Inefficient!\n</code></pre></p>"},{"location":"APP_DEVELOPER_GUIDE/#4-document-your-app","title":"4. Document Your App","text":"<pre><code>@register_app(\n    name=\"my_app\",\n    description=\"Clear description of what this app does\",\n    version=\"1.0.0\",\n    author=\"Your Name\",\n    requires=[\"pandas\", \"matplotlib\"]  # Optional dependencies\n)\nclass MyApp(BaseApp):\n    \"\"\"\n    Detailed docstring explaining:\n    - What the app analyzes\n    - What results it returns\n    - Example usage\n    \"\"\"\n\n    def analyze(self, graph, **kwargs):\n        \"\"\"\n        Clear docstring for analyze method.\n\n        Args:\n            graph: The Brick model\n            param1: What this parameter does\n\n        Returns:\n            dict with keys:\n            - 'key1': Description\n            - 'key2': Description\n        \"\"\"\n</code></pre>"},{"location":"APP_DEVELOPER_GUIDE/#5-make-results-exportable","title":"5. Make Results Exportable","text":"<p>Return data that can be easily converted to CSV/JSON:</p> <pre><code># Pandas DataFrame (auto-converts to CSV)\nimport pandas as pd\n\ndef analyze(self, graph, **kwargs):\n    data = [...]\n    df = pd.DataFrame(data)\n    return {\n        'dataframe': df,\n        'summary': {...}\n    }\n</code></pre>"},{"location":"APP_DEVELOPER_GUIDE/#common-patterns","title":"\ud83c\udfa8 Common Patterns","text":""},{"location":"APP_DEVELOPER_GUIDE/#pattern-data-extraction-app","title":"Pattern: Data Extraction App","text":"<pre><code>@register_app(name=\"data_extractor\")\nclass DataExtractorApp(BaseApp):\n    \"\"\"Extract specific data from Brick model.\"\"\"\n\n    def analyze(self, graph, **kwargs):\n        # Query\n        results = self._query_data(graph)\n\n        # Transform\n        data = self._transform_results(results)\n\n        # Export-ready format\n        return {\n            'data': data,\n            'count': len(data)\n        }\n</code></pre>"},{"location":"APP_DEVELOPER_GUIDE/#pattern-analytics-app","title":"Pattern: Analytics App","text":"<pre><code>@register_app(name=\"performance_analyzer\")\nclass PerformanceAnalyzerApp(BaseApp):\n    \"\"\"Calculate performance metrics.\"\"\"\n\n    def analyze(self, graph, **kwargs):\n        # Get data\n        equipment = self._get_equipment(graph)\n        points = self._get_points(graph)\n\n        # Calculate metrics\n        metrics = self._calculate_metrics(equipment, points)\n\n        # Return analysis\n        return {\n            'metrics': metrics,\n            'recommendations': self._generate_recommendations(metrics)\n        }\n</code></pre>"},{"location":"APP_DEVELOPER_GUIDE/#pattern-validation-app","title":"Pattern: Validation App","text":"<pre><code>@register_app(name=\"topology_validator\")\nclass TopologyValidatorApp(BaseApp):\n    \"\"\"Validate system topology.\"\"\"\n\n    def analyze(self, graph, **kwargs):\n        # Run checks\n        checks = [\n            self._check_required_equipment(graph),\n            self._check_relationships(graph),\n            self._check_completeness(graph)\n        ]\n\n        # Aggregate results\n        return {\n            'valid': all(c['passed'] for c in checks),\n            'checks': checks\n        }\n</code></pre>"},{"location":"APP_DEVELOPER_GUIDE/#troubleshooting","title":"\ud83d\udc1b Troubleshooting","text":""},{"location":"APP_DEVELOPER_GUIDE/#issue-query-returns-no-results","title":"Issue: Query Returns No Results","text":"<p>Problem: Your SPARQL query returns empty results</p> <p>Solutions: 1. Check namespace prefixes 2. Verify the data exists in the model 3. Test query in SPARQL editor 4. Check for typos in class names</p>"},{"location":"APP_DEVELOPER_GUIDE/#issue-import-errors","title":"Issue: Import Errors","text":"<p>Problem: Cannot import BaseApp or other components</p> <p>Solutions: <pre><code># Reinstall package\npip install -e .\n\n# Check installation\npython -c \"from hhw_brick.analytics.core.base_app import BaseApp\"\n</code></pre></p>"},{"location":"APP_DEVELOPER_GUIDE/#issue-app-not-discovered","title":"Issue: App Not Discovered","text":"<p>Problem: Your app doesn't appear in <code>hhw-brick apps list</code></p> <p>Solutions: 1. Ensure you used <code>@register_app</code> decorator 2. Check app is in correct location 3. Verify no syntax errors in file</p>"},{"location":"APP_DEVELOPER_GUIDE/#next-steps","title":"\ud83d\udcda Next Steps","text":"<ol> <li>Read the Tutorials - Step-by-step examples</li> <li><code>tutorials/01_hello_world_app.md</code></li> <li><code>tutorials/02_point_extraction_app.md</code></li> <li> <p><code>tutorials/03_equipment_analysis_app.md</code></p> </li> <li> <p>Study Demo Apps - Real working examples</p> </li> <li><code>analytics/apps/available_points.py</code></li> <li> <p><code>analytics/apps/equipment_analysis.py</code></p> </li> <li> <p>Review Examples - Additional code samples</p> </li> <li> <p><code>examples/custom_apps/</code></p> </li> <li> <p>Check API Reference - Complete API documentation</p> </li> <li><code>docs/API_REFERENCE.md</code></li> </ol>"},{"location":"APP_DEVELOPER_GUIDE/#contributing","title":"\ud83e\udd1d Contributing","text":"<p>Want to contribute your app to the project?</p> <ol> <li>Create your app following these guidelines</li> <li>Add tests</li> <li>Document thoroughly</li> <li>Submit a pull request</li> </ol> <p>Questions? Open an issue on GitHub or check the documentation.</p> <p>Happy coding! \ud83d\ude80</p>"},{"location":"CONVERSION_COMPLETE/","title":"\ud83c\udf89 Conversion Documentation Complete!","text":""},{"location":"CONVERSION_COMPLETE/#all-pages-created-successfully","title":"\u2705 All Pages Created Successfully","text":"<p>I've completed 10 comprehensive pages covering Getting Started and CSV to Brick Conversion.</p>"},{"location":"CONVERSION_COMPLETE/#getting-started-55","title":"Getting Started (5/5) \u2705","text":"Page Status Description index.md \u2705 Complete Getting Started overview and navigation installation.md \u2705 Complete Installation guide with troubleshooting quick-start.md \u2705 Complete 5-minute tutorial with working code understanding-brick.md \u2705 Complete Brick ontology explained with examples csv-format.md \u2705 Complete CSV format requirements and validation"},{"location":"CONVERSION_COMPLETE/#conversion-guide-55","title":"Conversion Guide (5/5) \u2705","text":"Page Status Description index.md \u2705 Complete Conversion overview and workflows single-building.md \u2705 Complete Single building conversion details batch-conversion.md \u2705 Complete Batch processing guide system-types.md \u2705 Complete HVAC system types explained sensor-mapping.md \u2705 Complete Custom sensor mapping guide"},{"location":"CONVERSION_COMPLETE/#documentation-statistics","title":"\ud83d\udcca Documentation Statistics","text":"<ul> <li>Total Pages: 10</li> <li>Estimated Words: 40,000+</li> <li>Code Examples: 100+</li> <li>Mermaid Diagrams: 15+</li> <li>Tables: 50+</li> <li>Admonitions: 30+</li> </ul>"},{"location":"CONVERSION_COMPLETE/#file-structure","title":"\ud83d\udcc1 File Structure","text":"<pre><code>docs/\n\u251c\u2500\u2500 getting-started/\n\u2502   \u251c\u2500\u2500 index.md                    (1,500 words)\n\u2502   \u251c\u2500\u2500 installation.md             (2,500 words)\n\u2502   \u251c\u2500\u2500 quick-start.md              (3,000 words)\n\u2502   \u251c\u2500\u2500 understanding-brick.md      (5,500 words)\n\u2502   \u2514\u2500\u2500 csv-format.md               (5,000 words)\n\u2514\u2500\u2500 user-guide/\n    \u2514\u2500\u2500 conversion/\n        \u251c\u2500\u2500 index.md                (4,000 words)\n        \u251c\u2500\u2500 single-building.md      (6,000 words)\n        \u251c\u2500\u2500 batch-conversion.md     (5,500 words)\n        \u251c\u2500\u2500 system-types.md         (4,500 words)\n        \u2514\u2500\u2500 sensor-mapping.md       (4,500 words)\n</code></pre>"},{"location":"CONVERSION_COMPLETE/#whats-documented","title":"\ud83d\udcda What's Documented","text":""},{"location":"CONVERSION_COMPLETE/#getting-started-coverage","title":"Getting Started Coverage","text":"<p>\u2705 Installation - PyPI installation - Virtual environments - Dependencies - Troubleshooting</p> <p>\u2705 Quick Start - Complete 5-minute tutorial - Working code example - Output inspection - Validation</p> <p>\u2705 Understanding Brick - What is Brick? - Why use it? - Schema components - Querying examples - HHWS mappings</p> <p>\u2705 CSV Format - Two required files - Column specifications - Supported system types - Data quality guidelines - Validation scripts</p>"},{"location":"CONVERSION_COMPLETE/#conversion-coverage","title":"Conversion Coverage","text":"<p>\u2705 Overview - Conversion process - Three conversion methods - Common workflows - Output formats - Error handling</p> <p>\u2705 Single Building - API parameters explained - Return values - Step-by-step workflow - Common patterns - Advanced usage</p> <p>\u2705 Batch Conversion - Multi-building processing - Progress tracking - Result statistics - Filtering options - Production workflows</p> <p>\u2705 System Types - 5 supported types - Equipment hierarchies - Point mappings - Auto-detection - Validation</p> <p>\u2705 Sensor Mapping - YAML format - Default mappings - Customization - Brick class reference - Complete examples</p>"},{"location":"CONVERSION_COMPLETE/#key-features","title":"\ud83c\udfaf Key Features","text":""},{"location":"CONVERSION_COMPLETE/#code-examples","title":"Code Examples","text":"<p>Every page includes: - \u2705 Working code snippets - \u2705 Complete scripts - \u2705 Common patterns - \u2705 Production examples - \u2705 Error handling</p>"},{"location":"CONVERSION_COMPLETE/#visual-aids","title":"Visual Aids","text":"<ul> <li>\u2705 15+ Mermaid diagrams</li> <li>\u2705 System architecture diagrams</li> <li>\u2705 Workflow diagrams</li> <li>\u2705 Equipment hierarchies</li> </ul>"},{"location":"CONVERSION_COMPLETE/#user-experience","title":"User Experience","text":"<ul> <li>\u2705 Clear navigation</li> <li>\u2705 Progressive disclosure</li> <li>\u2705 Cross-references</li> <li>\u2705 Search-optimized</li> <li>\u2705 Mobile-responsive</li> </ul>"},{"location":"CONVERSION_COMPLETE/#how-to-view","title":"\ud83d\ude80 How to View","text":"<pre><code>cd \"D:\\Git_project\\Hot Water System\\HHW_brick\"\nmkdocs serve\n</code></pre> <p>Then open: http://127.0.0.1:8000</p>"},{"location":"CONVERSION_COMPLETE/#documentation-quality","title":"\ud83d\udcd6 Documentation Quality","text":""},{"location":"CONVERSION_COMPLETE/#comprehensiveness","title":"Comprehensiveness","text":"<ul> <li>Beginner-friendly: Clear explanations for newcomers</li> <li>Advanced topics: Deep dives for power users</li> <li>Code-heavy: Practical examples throughout</li> <li>Well-structured: Logical progression</li> </ul>"},{"location":"CONVERSION_COMPLETE/#writing-style","title":"Writing Style","text":"<ul> <li>Clear and concise: No jargon without explanation</li> <li>Example-driven: Learn by doing</li> <li>Troubleshooting: Common issues addressed</li> <li>Best practices: Professional guidance</li> </ul>"},{"location":"CONVERSION_COMPLETE/#whats-next","title":"\ud83c\udf8a What's Next?","text":"<p>The conversion documentation is 100% complete. Next sections to document:</p>"},{"location":"CONVERSION_COMPLETE/#user-guide-validation","title":"User Guide - Validation","text":"<ul> <li>Ontology validation</li> <li>Ground truth comparison</li> <li>Subgraph patterns</li> </ul>"},{"location":"CONVERSION_COMPLETE/#user-guide-applications","title":"User Guide - Applications","text":"<ul> <li>Apps manager</li> <li>Secondary loop temp diff</li> <li>Primary loop temp diff</li> <li>Running applications</li> </ul>"},{"location":"CONVERSION_COMPLETE/#developer-guide","title":"Developer Guide","text":"<ul> <li>Package architecture</li> <li>Creating applications</li> <li>Contributing</li> </ul>"},{"location":"CONVERSION_COMPLETE/#api-reference","title":"API Reference","text":"<ul> <li>Complete API documentation</li> <li>All classes and methods</li> </ul>"},{"location":"CONVERSION_COMPLETE/#examples","title":"Examples","text":"<ul> <li>Working code examples</li> <li>Real-world scenarios</li> </ul>"},{"location":"CONVERSION_COMPLETE/#summary","title":"\ud83d\udca1 Summary","text":"<p>Conversion module is now fully documented!</p> <p>Users can: - \u2705 Install the package - \u2705 Understand Brick ontology - \u2705 Prepare CSV data - \u2705 Convert single buildings - \u2705 Batch convert multiple buildings - \u2705 Understand system types - \u2705 Customize sensor mappings</p> <p>All with working code examples and detailed explanations.</p> <p>Great work! The conversion documentation is production-ready. \ud83c\udf89</p> <p>Ready to continue with Validation or Applications documentation? Let me know!</p>"},{"location":"DOCUMENTATION_PROGRESS/","title":"\ud83d\udcda Documentation Progress - Conversion Module","text":""},{"location":"DOCUMENTATION_PROGRESS/#completed-pages","title":"\u2705 Completed Pages","text":"<p>I've successfully created comprehensive documentation for the Getting Started and Conversion sections.</p>"},{"location":"DOCUMENTATION_PROGRESS/#getting-started-section-55-complete","title":"Getting Started Section (5/5 Complete) \u2705","text":"<ol> <li>\u2705 index.md - Getting Started overview</li> <li>\u2705 installation.md - Complete installation guide</li> <li>\u2705 quick-start.md - 5-minute tutorial with working code</li> <li>\u2705 understanding-brick.md - Brick ontology explained</li> <li>\u2705 csv-format.md - Detailed CSV format requirements</li> </ol>"},{"location":"DOCUMENTATION_PROGRESS/#conversion-section-34-complete","title":"Conversion Section (\u00be Complete) \ud83d\udd04","text":"<ol> <li>\u2705 index.md - Conversion overview with workflows</li> <li>\u2705 single-building.md - Detailed single building conversion (COMPLETE)</li> <li>\u2705 batch-conversion.md - Batch processing guide (COMPLETE)</li> <li>\u23f3 system-types.md - HVAC system types explained (IN PROGRESS)</li> <li>\u23f3 sensor-mapping.md - Custom sensor mapping (IN PROGRESS)</li> </ol>"},{"location":"DOCUMENTATION_PROGRESS/#content-summary","title":"\ud83d\udcca Content Summary","text":""},{"location":"DOCUMENTATION_PROGRESS/#whats-been-documented","title":"What's Been Documented","text":"<p>\u2705 Installation - PyPI installation - Virtual environment setup - Dependency management - Troubleshooting</p> <p>\u2705 Quick Start - 5-minute tutorial - Complete working example - Output inspection - Validation</p> <p>\u2705 Understanding Brick - What is Brick? - Why use it? - Schema components - Querying Brick models - HHWS-specific mapping</p> <p>\u2705 CSV Format - Required files (metadata.csv, vars.csv) - Column specifications - Supported system types - Sensor mappings - Validation script - Complete examples</p> <p>\u2705 Conversion Overview - Conversion process diagram - Three conversion methods - Common workflows - Output format - Error handling</p>"},{"location":"DOCUMENTATION_PROGRESS/#next-steps","title":"\ud83c\udfaf Next Steps","text":"<p>To complete the conversion documentation, create:</p> <ol> <li>single-building.md - Focus on CSVToBrickConverter API</li> <li>batch-conversion.md - BatchConverter with examples</li> <li>system-types.md - Detail each HVAC system type</li> <li>sensor-mapping.md - Customization guide</li> </ol> <p>Would you like me to continue creating these pages?</p>"},{"location":"DOCUMENTATION_PROGRESS/#documentation-quality","title":"\ud83d\udcdd Documentation Quality","text":"<p>All created pages include: - \u2705 Clear explanations - \u2705 Working code examples - \u2705 Mermaid diagrams - \u2705 Best practices - \u2705 Troubleshooting - \u2705 Cross-references - \u2705 Admonition boxes (tips, warnings, notes)</p>"},{"location":"DOCUMENTATION_PROGRESS/#how-to-view","title":"\ud83d\ude80 How to View","text":"<p>Start the documentation server:</p> <pre><code>cd \"D:\\Git_project\\Hot Water System\\HHW_brick\"\nmkdocs serve\n</code></pre> <p>Then visit: http://127.0.0.1:8000</p> <p>The completed pages are fully navigable with: - Top navigation tabs - Left sidebar navigation - Right table of contents - Search functionality - Dark/light mode toggle</p>"},{"location":"DOCUMENTATION_PROGRESS/#files-created-so-far","title":"\ud83d\udccb Files Created So Far","text":"<pre><code>docs/\n\u251c\u2500\u2500 getting-started/\n\u2502   \u251c\u2500\u2500 index.md \u2705\n\u2502   \u251c\u2500\u2500 installation.md \u2705\n\u2502   \u251c\u2500\u2500 quick-start.md \u2705\n\u2502   \u251c\u2500\u2500 understanding-brick.md \u2705\n\u2502   \u2514\u2500\u2500 csv-format.md \u2705\n\u2514\u2500\u2500 user-guide/\n    \u2514\u2500\u2500 conversion/\n        \u2514\u2500\u2500 index.md \u2705\n</code></pre> <p>Ready to continue with the remaining conversion pages!         \u251c\u2500\u2500 index.md \u2705         \u251c\u2500\u2500 single-building.md \u2705         \u251c\u2500\u2500 batch-conversion.md \u2705         \u251c\u2500\u2500 system-types.md \u23f3         \u2514\u2500\u2500 sensor-mapping.md \u23f3</p>"},{"location":"PARALLEL_PROCESSING/","title":"Parallel Processing in Validation Methods","text":""},{"location":"PARALLEL_PROCESSING/#summary","title":"Summary","text":"<p>All batch validation methods now support parallel processing with an optional <code>max_workers</code> parameter.</p>"},{"location":"PARALLEL_PROCESSING/#methods-with-parallel-processing","title":"Methods with Parallel Processing","text":""},{"location":"PARALLEL_PROCESSING/#1-ontology-validation-example-02","title":"1. Ontology Validation (Example 02)","text":"<pre><code>validator.batch_validate_ontology(\n    test_data_dir=str(brick_model_dir),\n    max_workers=4  # Optional: default is CPU count - 1\n)\n</code></pre>"},{"location":"PARALLEL_PROCESSING/#2-point-count-validation-example-03","title":"2. Point Count Validation (Example 03)","text":"<pre><code>validator.batch_validate_point_count(\n    test_data_dir=str(brick_model_dir),\n    max_workers=4  # Optional: default is CPU count - 1\n)\n</code></pre>"},{"location":"PARALLEL_PROCESSING/#3-equipment-count-validation-example-04","title":"3. Equipment Count Validation (Example 04)","text":"<pre><code>validator.batch_validate_equipment_count(\n    test_data_dir=str(brick_model_dir),\n    max_workers=4  # Optional: default is CPU count - 1\n)\n</code></pre>"},{"location":"PARALLEL_PROCESSING/#4-subgraph-pattern-matching-example-05","title":"4. Subgraph Pattern Matching (Example 05)","text":"<pre><code>validator.batch_validate_all_buildings(\n    ttl_directory=str(brick_model_dir),\n    max_workers=4  # Optional: default is CPU count - 1\n)\n</code></pre>"},{"location":"PARALLEL_PROCESSING/#parameter-details","title":"Parameter Details","text":""},{"location":"PARALLEL_PROCESSING/#max_workers-optional","title":"<code>max_workers</code> (optional)","text":"<ul> <li>Type: <code>int</code> or <code>None</code></li> <li>Default: <code>None</code> (uses <code>CPU count - 1</code> workers)</li> <li>Description: Number of parallel workers for processing</li> <li>Example Values:</li> <li><code>None</code>: Auto-detect (CPU count - 1)</li> <li><code>1</code>: Sequential processing (no parallelism)</li> <li><code>4</code>: Use 4 parallel workers</li> <li><code>8</code>: Use 8 parallel workers</li> </ul>"},{"location":"PARALLEL_PROCESSING/#performance-benefits","title":"Performance Benefits","text":"<ul> <li>Without Parallel Processing: ~1-2 seconds per file</li> <li>With Parallel Processing (4 workers): ~0.3-0.5 seconds per file</li> <li>Speed Up: ~4-5x faster with 4 workers</li> </ul>"},{"location":"PARALLEL_PROCESSING/#usage-examples","title":"Usage Examples","text":""},{"location":"PARALLEL_PROCESSING/#default-auto-detect-workers","title":"Default (Auto-detect workers)","text":"<pre><code># Uses CPU count - 1 workers automatically\nresults = validator.batch_validate_ontology(test_data_dir)\n</code></pre>"},{"location":"PARALLEL_PROCESSING/#custom-number-of-workers","title":"Custom Number of Workers","text":"<pre><code># Use exactly 4 workers\nresults = validator.batch_validate_ontology(test_data_dir, max_workers=4)\n</code></pre>"},{"location":"PARALLEL_PROCESSING/#sequential-processing-no-parallelism","title":"Sequential Processing (No Parallelism)","text":"<pre><code># Process files one by one\nresults = validator.batch_validate_ontology(test_data_dir, max_workers=1)\n</code></pre>"},{"location":"PARALLEL_PROCESSING/#maximum-parallelism","title":"Maximum Parallelism","text":"<pre><code>import multiprocessing\n\n# Use all available CPU cores\nresults = validator.batch_validate_ontology(\n    test_data_dir,\n    max_workers=multiprocessing.cpu_count()\n)\n</code></pre>"},{"location":"PARALLEL_PROCESSING/#notes","title":"Notes","text":"<ol> <li>Thread Safety: Uses <code>ProcessPoolExecutor</code> instead of threads to avoid RDFLib thread-safety issues</li> <li>Memory: Each worker loads models independently, so high <code>max_workers</code> values may use significant memory</li> <li>Optimal Value: Generally, <code>CPU count - 1</code> or <code>CPU count / 2</code> works well</li> <li>Progress Bar: All methods show a <code>tqdm</code> progress bar during processing</li> </ol>"},{"location":"SIMPLIFIED_ROADMAP/","title":"\ud83c\udfaf Simplified Development Roadmap - HHW Brick Application","text":"<p>Date: October 22, 2025 Philosophy: Core framework + Demo app + Developer docs \u2192 Community extends</p>"},{"location":"SIMPLIFIED_ROADMAP/#development-scope-division","title":"\ud83d\udcca Development Scope Division","text":""},{"location":"SIMPLIFIED_ROADMAP/#your-scope-core-developer","title":"\ud83d\udd27 Your Scope (Core Developer)","text":"<p>What YOU will develop:</p> <ol> <li>\u2705 Core Infrastructure (DONE)</li> <li>CSV to Brick conversion</li> <li>Validation framework</li> <li>Python package &amp; CLI</li> <li> <p>Documentation</p> </li> <li> <p>\ud83d\udd04 Advanced Validation (IN PROGRESS)</p> </li> <li>Subgraph pattern validation refinement</li> <li> <p>Basic validation suite completion</p> </li> <li> <p>\ud83d\udea7 Demo Analytics App (NEXT)</p> </li> <li>1-2 reference apps as examples</li> <li>Show how to use the framework</li> <li> <p>Demonstrate best practices</p> </li> <li> <p>\ud83d\udcdd Developer Documentation (NEXT)</p> </li> <li>App development guide</li> <li>API reference</li> <li>Tutorial series</li> <li>Code examples</li> </ol>"},{"location":"SIMPLIFIED_ROADMAP/#others-scope-future-developers","title":"\ud83d\udc65 Others' Scope (Future Developers)","text":"<p>What OTHERS will develop using your framework:</p> <ol> <li>Analytics Applications</li> <li>Performance analysis apps</li> <li>Fault detection apps</li> <li>Optimization apps</li> <li> <p>Custom reporting tools</p> </li> <li> <p>Web Frontend</p> </li> <li>Interactive UI</li> <li>Visualization tools</li> <li> <p>Dashboards</p> </li> <li> <p>Advanced Features</p> </li> <li>Timeseries integration</li> <li>Cloud deployment</li> <li>Additional integrations</li> </ol>"},{"location":"SIMPLIFIED_ROADMAP/#your-simplified-todo","title":"\ud83c\udfaf Your Simplified TODO","text":""},{"location":"SIMPLIFIED_ROADMAP/#phase-1-core-complete","title":"Phase 1: Core (\u2705 COMPLETE)","text":"<p>Everything done! No more work needed.</p>"},{"location":"SIMPLIFIED_ROADMAP/#phase-2-validation-in-progress","title":"Phase 2: Validation (\ud83d\udd04 IN PROGRESS)","text":"<p>Subgraph Pattern Validation - [ ] Refine pattern matching algorithms - [ ] Improve validation accuracy - [ ] Add comprehensive test cases - [ ] Performance optimization - [ ] Documentation</p> <p>Estimated Time: 2-4 weeks</p>"},{"location":"SIMPLIFIED_ROADMAP/#phase-3-demo-app-next-priority","title":"Phase 3: Demo App (\ud83d\udea7 NEXT PRIORITY)","text":"<p>Goal: Create 1-2 reference apps that demonstrate the framework</p> <p>Demo App 1: Available Points Analyzer (Already partially done) - [ ] Refine existing <code>AvailablePointsApp</code> - [ ] Add more SPARQL query examples - [ ] Show CSV export functionality - [ ] Document code thoroughly</p> <p>Demo App 2: Equipment Analysis (Already partially done) - [ ] Refine existing <code>EquipmentAnalysisApp</code> - [ ] Analyze equipment relationships - [ ] Show graph traversal patterns - [ ] Document best practices</p> <p>Demo App 3: Performance Metrics (Optional - Simple Example) - [ ] Create basic performance calculation - [ ] Demonstrate timeseries reference handling - [ ] Show aggregation patterns - [ ] Keep it simple but complete</p> <p>What the demo should show: - \u2705 How to inherit from <code>BaseApp</code> - \u2705 How to use SPARQL queries - \u2705 How to process results - \u2705 How to export data - \u2705 Error handling patterns - \u2705 CLI integration</p> <p>Estimated Time: 1-2 weeks</p>"},{"location":"SIMPLIFIED_ROADMAP/#phase-4-developer-documentation-critical","title":"Phase 4: Developer Documentation (\ud83d\udcdd CRITICAL)","text":"<p>Goal: Enable others to create their own apps</p> <p>Developer Guide Document (<code>docs/APP_DEVELOPER_GUIDE.md</code>) - [ ] Framework overview - [ ] BaseApp API reference - [ ] AppRegistry usage - [ ] SPARQL query patterns for Brick - [ ] Best practices and conventions - [ ] Common pitfalls and solutions</p> <p>Tutorial Series (<code>docs/tutorials/</code>) - [ ] Tutorial 1: Hello World App (15 min)   - Minimal app that queries building info   - Shows basic structure</p> <ul> <li> Tutorial 2: Point Extraction App (30 min)</li> <li>Extract all points from a building</li> <li>Filter by type</li> <li> <p>Export to CSV</p> </li> <li> <p> Tutorial 3: Equipment Relationship App (45 min)</p> </li> <li>Query equipment hierarchies</li> <li>Analyze feeds relationships</li> <li> <p>Generate topology report</p> </li> <li> <p> Tutorial 4: Custom Analytics App (60 min)</p> </li> <li>Calculate custom metrics</li> <li>Handle timeseries references</li> <li>Generate visualizations</li> </ul> <p>API Reference (<code>docs/API_REFERENCE.md</code>) - [ ] BaseApp class documentation - [ ] AppRegistry documentation - [ ] BrickQuery helper methods - [ ] Common utility functions - [ ] CLI integration guide</p> <p>Code Examples (<code>examples/custom_apps/</code>) - [ ] Simple query app - [ ] Data extraction app - [ ] Analysis app - [ ] Reporting app</p> <p>Estimated Time: 2-3 weeks</p>"},{"location":"SIMPLIFIED_ROADMAP/#realistic-timeline","title":"\ud83d\udcc5 Realistic Timeline","text":""},{"location":"SIMPLIFIED_ROADMAP/#month-1-weeks-1-4","title":"Month 1 (Weeks 1-4)","text":"<ul> <li>Weeks 1-2: Complete subgraph validation refinement</li> <li>Weeks 3-4: Polish 2-3 demo apps</li> </ul>"},{"location":"SIMPLIFIED_ROADMAP/#month-2-weeks-5-8","title":"Month 2 (Weeks 5-8)","text":"<ul> <li>Weeks 5-6: Write developer guide</li> <li>Weeks 7-8: Create tutorial series</li> </ul>"},{"location":"SIMPLIFIED_ROADMAP/#month-3-weeks-9-12","title":"Month 3 (Weeks 9-12)","text":"<ul> <li>Weeks 9-10: Complete API reference</li> <li>Weeks 11-12: Final polish, testing, documentation review</li> </ul> <p>Total Time: ~3 months for complete handoff package</p>"},{"location":"SIMPLIFIED_ROADMAP/#deliverables","title":"\ud83d\udce6 Deliverables","text":""},{"location":"SIMPLIFIED_ROADMAP/#what-youll-provide","title":"What You'll Provide","text":"<ol> <li>Working Framework \u2705</li> <li>Core library</li> <li>CLI tools</li> <li> <p>Validation suite</p> </li> <li> <p>Demo Applications \ud83d\udea7</p> </li> <li>2-3 reference apps</li> <li>Well-documented code</li> <li> <p>Example outputs</p> </li> <li> <p>Developer Documentation \ud83d\udcdd</p> </li> <li>Comprehensive guide</li> <li>Step-by-step tutorials</li> <li>API reference</li> <li> <p>Code examples</p> </li> <li> <p>Handoff Package \ud83d\udce6</p> </li> <li>Installation guide</li> <li>Quick start</li> <li>Architecture overview</li> <li>Contribution guidelines</li> </ol>"},{"location":"SIMPLIFIED_ROADMAP/#what-others-can-build","title":"\ud83c\udf93 What Others Can Build","text":"<p>After your work, other developers can easily create:</p>"},{"location":"SIMPLIFIED_ROADMAP/#analytics-apps","title":"Analytics Apps","text":"<ul> <li>Performance Analysis</li> <li>Energy efficiency metrics</li> <li>System performance KPIs</li> <li> <p>Comparative analysis</p> </li> <li> <p>Fault Detection</p> </li> <li>Anomaly detection</li> <li>Equipment diagnostics</li> <li> <p>Predictive maintenance</p> </li> <li> <p>Optimization</p> </li> <li>Control strategies</li> <li>Load balancing</li> <li>Cost optimization</li> </ul>"},{"location":"SIMPLIFIED_ROADMAP/#integrations","title":"Integrations","text":"<ul> <li>Timeseries Databases</li> <li>InfluxDB connector</li> <li>Prometheus integration</li> <li> <p>Custom data sources</p> </li> <li> <p>External Systems</p> </li> <li>BMS integration</li> <li>Cloud platforms</li> <li>IoT platforms</li> </ul>"},{"location":"SIMPLIFIED_ROADMAP/#frontendui","title":"Frontend/UI","text":"<ul> <li>Web Dashboard</li> <li>React/Vue app</li> <li>Interactive visualizations</li> <li> <p>Real-time monitoring</p> </li> <li> <p>Mobile Apps</p> </li> <li>iOS/Android</li> <li>Field inspection tools</li> <li>Alert notifications</li> </ul>"},{"location":"SIMPLIFIED_ROADMAP/#documentation-structure","title":"\ud83d\udcdd Documentation Structure","text":"<pre><code>HHW_brick/\n\u251c\u2500\u2500 docs/\n\u2502   \u251c\u2500\u2500 APP_DEVELOPER_GUIDE.md          # Main developer guide\n\u2502   \u251c\u2500\u2500 API_REFERENCE.md                 # Complete API docs\n\u2502   \u251c\u2500\u2500 ARCHITECTURE.md                  # System architecture\n\u2502   \u251c\u2500\u2500 CONTRIBUTING.md                  # How to contribute\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 tutorials/                       # Step-by-step tutorials\n\u2502   \u2502   \u251c\u2500\u2500 01_hello_world_app.md\n\u2502   \u2502   \u251c\u2500\u2500 02_point_extraction_app.md\n\u2502   \u2502   \u251c\u2500\u2500 03_equipment_analysis_app.md\n\u2502   \u2502   \u2514\u2500\u2500 04_custom_analytics_app.md\n\u2502   \u2502\n\u2502   \u2514\u2500\u2500 examples/                        # Code examples\n\u2502       \u251c\u2500\u2500 simple_query_app.py\n\u2502       \u251c\u2500\u2500 data_extraction_app.py\n\u2502       \u251c\u2500\u2500 analysis_app.py\n\u2502       \u2514\u2500\u2500 reporting_app.py\n\u2502\n\u2514\u2500\u2500 hhw_brick/\n    \u2514\u2500\u2500 analytics/\n        \u2514\u2500\u2500 apps/\n            \u251c\u2500\u2500 available_points.py      # Demo app 1\n            \u251c\u2500\u2500 equipment_analysis.py    # Demo app 2\n            \u2514\u2500\u2500 performance_demo.py      # Demo app 3 (optional)\n</code></pre>"},{"location":"SIMPLIFIED_ROADMAP/#success-criteria","title":"\u2705 Success Criteria","text":"<p>Your work is complete when:</p> <ol> <li>\u2705 Core framework is stable and tested</li> <li>\u2705 Subgraph validation is refined</li> <li>\u2705 2-3 demo apps are working and documented</li> <li>\u2705 Developer guide is comprehensive and clear</li> <li>\u2705 Tutorials are easy to follow</li> <li>\u2705 API reference is complete</li> <li>\u2705 Code examples compile and run</li> <li>\u2705 Another developer can create an app in &lt; 1 hour</li> </ol>"},{"location":"SIMPLIFIED_ROADMAP/#summary","title":"\ud83c\udf89 Summary","text":"<p>Your Focus: - \u2705 Build solid foundation - \ud83d\udd04 Refine validation - \ud83d\udea7 Create demo apps - \ud83d\udcdd Write excellent docs</p> <p>Their Focus: - \ud83d\udc65 Build specific apps - \ud83d\udc65 Create frontends - \ud83d\udc65 Add integrations - \ud83d\udc65 Extend functionality</p> <p>Philosophy:</p> <p>Provide the tools and knowledge, let the community build the applications.</p> <p>Estimated Total Effort: 3 months Outcome: Production-ready framework + Developer enablement Impact: Enable unlimited app development by others</p>"},{"location":"changelog/","title":"Changelog","text":"<p>All notable changes to HHW Brick Application will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p>"},{"location":"changelog/#unreleased","title":"[Unreleased]","text":""},{"location":"changelog/#planned","title":"Planned","text":"<ul> <li>Web interface for visualization</li> <li>Additional analytics applications</li> <li>Performance optimizations</li> <li>Multi-language documentation</li> </ul>"},{"location":"changelog/#020-2024-10-29","title":"[0.2.0] - 2024-10-29","text":""},{"location":"changelog/#added","title":"Added","text":"<ul> <li>Comprehensive validation module</li> <li>Ontology validation using brickschema</li> <li>Subgraph pattern matching</li> <li>Point and equipment count validation</li> <li>Ground truth calculator</li> <li>Unified workflow module (HHWSWorkflow)</li> <li>Command-line interface (CLI) with Click</li> <li>Batch conversion support</li> <li>Configuration management utilities</li> <li>Deployment management module</li> <li>Application framework with apps_manager</li> <li>Auto-discovery of applications</li> <li>Pluggable analytics system</li> <li>Secondary loop temperature difference application</li> <li>Primary loop temperature difference application</li> </ul>"},{"location":"changelog/#changed","title":"Changed","text":"<ul> <li>Migrated to modern pyproject.toml configuration</li> <li>Reorganized package structure with clear module separation</li> <li>Improved CSV to Brick conversion with better error handling</li> <li>Enhanced logging throughout the package</li> <li>Updated documentation structure</li> </ul>"},{"location":"changelog/#fixed","title":"Fixed","text":"<ul> <li>CSV conversion edge cases</li> <li>Memory leaks in batch processing</li> <li>Type hints in core modules</li> </ul>"},{"location":"changelog/#deprecated","title":"Deprecated","text":"<ul> <li>Legacy validation methods (replaced with new validation module)</li> </ul>"},{"location":"changelog/#0181-previous-release","title":"[0.1.8.1] - Previous Release","text":""},{"location":"changelog/#added_1","title":"Added","text":"<ul> <li>Basic CSV to Brick conversion functionality</li> <li>Initial validation features</li> <li>Core utilities for Brick query</li> </ul>"},{"location":"changelog/#changed_1","title":"Changed","text":"<ul> <li>Various bug fixes and improvements</li> </ul>"},{"location":"changelog/#010-initial-release","title":"[0.1.0] - Initial Release","text":""},{"location":"changelog/#added_2","title":"Added","text":"<ul> <li>Initial release of HHW Brick Application</li> <li>CSV to Brick ontology conversion</li> <li>Basic Brick model support</li> <li>Preliminary validation tools</li> </ul>"},{"location":"changelog/#version-numbering","title":"Version Numbering","text":"<p>We use Semantic Versioning:</p> <ul> <li>MAJOR version for incompatible API changes</li> <li>MINOR version for new functionality in a backwards compatible manner</li> <li>PATCH version for backwards compatible bug fixes</li> </ul> <p>Example: <code>0.2.1</code> - <code>0</code> - Major version (pre-1.0 is development) - <code>2</code> - Minor version (new features) - <code>1</code> - Patch version (bug fixes)</p>"},{"location":"changelog/#links","title":"Links","text":"<ul> <li>PyPI Package</li> <li>GitHub Repository</li> <li>Issue Tracker</li> <li>Documentation</li> </ul>"},{"location":"changelog/#how-to-contribute","title":"How to Contribute","text":"<p>See our Contributing Guide for:</p> <ul> <li>Reporting bugs</li> <li>Suggesting features</li> <li>Submitting pull requests</li> <li>Writing documentation</li> </ul> <p>Back to Home</p>"},{"location":"license/","title":"License","text":""},{"location":"license/#mit-license","title":"MIT License","text":"<p>Copyright \u00a9 2024 Mingchen Li</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"license/#what-this-means","title":"What This Means","text":"<p>The MIT License is a permissive free software license. In simple terms:</p>"},{"location":"license/#you-can","title":"\u2705 You CAN","text":"<ul> <li>Use the software for any purpose (commercial or personal)</li> <li>Modify the source code</li> <li>Distribute the software</li> <li>Sublicense the software</li> <li>Use it in proprietary software</li> </ul>"},{"location":"license/#you-must","title":"\u26a0\ufe0f You MUST","text":"<ul> <li>Include the original copyright notice</li> <li>Include the license text</li> </ul>"},{"location":"license/#you-cannot","title":"\u274c You CANNOT","text":"<ul> <li>Hold the authors liable for any damages</li> <li>Use the authors' names for promotion without permission</li> </ul>"},{"location":"license/#dependencies","title":"Dependencies","text":"<p>This project uses several open-source libraries, each with their own licenses:</p> Library License Purpose RDFLib BSD-3-Clause RDF processing pandas BSD-3-Clause Data manipulation Click BSD-3-Clause CLI framework brickschema BSD-3-Clause Brick ontology PyYAML MIT YAML parsing <p>All dependencies are compatible with the MIT License.</p>"},{"location":"license/#contributing","title":"Contributing","text":"<p>By contributing to this project, you agree that your contributions will be licensed under the MIT License.</p> <p>See the Contributing Guide for more information.</p>"},{"location":"license/#third-party-content","title":"Third-Party Content","text":""},{"location":"license/#brick-schema","title":"Brick Schema","text":"<p>This package uses Brick Schema, which is licensed under BSD-3-Clause.</p>"},{"location":"license/#documentation-theme","title":"Documentation Theme","text":"<p>Documentation is built with Material for MkDocs, licensed under MIT.</p>"},{"location":"license/#questions","title":"Questions?","text":"<p>If you have questions about licensing, please:</p> <ol> <li>Check the FAQ</li> <li>Review the full license text above</li> <li>Open an issue on GitHub</li> </ol> <p>Back to Home</p>"},{"location":"license/#frequently-asked-questions","title":"Frequently Asked Questions","text":"<p>Common questions and answers about HHW Brick Application.</p>"},{"location":"license/#general-questions","title":"General Questions","text":""},{"location":"license/#what-is-hhw-brick-application","title":"What is HHW Brick Application?","text":"<p>HHW Brick Application is a Python package for working with Brick ontology in heating hot water systems. It provides tools for converting CSV data to Brick models, validating models, and running analytics applications.</p>"},{"location":"license/#what-is-brick","title":"What is Brick?","text":"<p>Brick is a standardized semantic vocabulary for describing building systems and their data. It enables interoperability between different building management systems and analytics tools.</p>"},{"location":"license/#do-i-need-to-know-rdfontologies-to-use-this-package","title":"Do I need to know RDF/ontologies to use this package?","text":"<p>No! The package handles all the RDF and ontology complexity for you. You can work with familiar formats like CSV and Python dictionaries.</p>"},{"location":"license/#what-python-versions-are-supported","title":"What Python versions are supported?","text":"<p>Python 3.8 and higher are supported.</p>"},{"location":"license/#installation-setup","title":"Installation &amp; Setup","text":""},{"location":"license/#how-do-i-install-the-package","title":"How do I install the package?","text":"<pre><code>pip install hhw-brick\n</code></pre> <p>See the Installation Guide for more details.</p>"},{"location":"license/#can-i-use-this-package-offline","title":"Can I use this package offline?","text":"<p>Yes, once installed, the core functionality works offline. However, some validation features may require internet access to download Brick schema files.</p>"},{"location":"license/#what-are-the-dependencies","title":"What are the dependencies?","text":"<p>Main dependencies include: - <code>rdflib</code> - RDF processing - <code>pandas</code> - Data manipulation - <code>pyyaml</code> - Configuration - <code>click</code> - CLI - <code>brickschema</code> - Brick schema support</p> <p>All dependencies are automatically installed via pip.</p>"},{"location":"license/#usage-questions","title":"Usage Questions","text":""},{"location":"license/#how-do-i-convert-a-csv-file-to-brick","title":"How do I convert a CSV file to Brick?","text":"<pre><code>from hhw_brick import CSVToBrickConverter\n\nconverter = CSVToBrickConverter()\nconverter.convert_csv_to_brick(\"input.csv\", \"output.ttl\")\n</code></pre> <p>See Basic Usage for more examples.</p>"},{"location":"license/#what-csv-format-is-required","title":"What CSV format is required?","text":"<p>The CSV should contain columns for: - Equipment type - Equipment name - Points (sensors/actuators) - Relationships</p> <p>See the Configuration Guide for details.</p>"},{"location":"license/#can-i-validate-a-model-without-ground-truth-data","title":"Can I validate a model without ground truth data?","text":"<p>Yes! You can perform ontology validation without ground truth:</p> <pre><code>validator = BrickModelValidator()\nis_valid, report = validator.validate_ontology(\"model.ttl\")\n</code></pre>"},{"location":"license/#how-do-i-list-available-applications","title":"How do I list available applications?","text":"<pre><code>from hhw_brick import apps\n\navailable = apps.list_apps()\nprint(available)\n</code></pre>"},{"location":"license/#application-development","title":"Application Development","text":""},{"location":"license/#how-do-i-create-a-custom-application","title":"How do I create a custom application?","text":"<p>See the Developer Guide for a complete tutorial.</p> <p>Basic structure:</p> <pre><code># my_app/__init__.py\n__all__ = ['qualify', 'analyze', 'load_config']\n\ndef qualify(brick_model):\n    return True, {}\n\ndef analyze(brick_model, timeseries_data, config):\n    return {\"results\": \"data\"}\n\ndef load_config(config_path=None):\n    return {}\n</code></pre>"},{"location":"license/#where-do-i-place-my-custom-application","title":"Where do I place my custom application?","text":"<p>Place it in the <code>hhw_brick/applications/</code> directory:</p> <pre><code>hhw_brick/\n\u2514\u2500\u2500 applications/\n    \u251c\u2500\u2500 my_custom_app/\n    \u2502   \u2514\u2500\u2500 __init__.py\n    \u2514\u2500\u2500 apps_manager.py\n</code></pre>"},{"location":"license/#how-does-the-app-discovery-work","title":"How does the app discovery work?","text":"<p>The <code>apps_manager</code> automatically discovers all packages in the <code>applications/</code> directory that have the required interface (<code>qualify</code>, <code>analyze</code>, <code>load_config</code>).</p>"},{"location":"license/#troubleshooting","title":"Troubleshooting","text":""},{"location":"license/#module-not-found-error","title":"\"Module not found\" error","text":"<p>Make sure the package is installed:</p> <pre><code>pip install hhw-brick\n</code></pre>"},{"location":"license/#command-not-found-hhw-brick","title":"\"Command not found: hhw-brick\"","text":"<p>The CLI might not be in your PATH. Try:</p> <pre><code>python -m hhw_brick.cli.main --help\n</code></pre> <p>Or reinstall the package:</p> <pre><code>pip install --force-reinstall hhw-brick\n</code></pre>"},{"location":"license/#validation-fails-for-a-valid-model","title":"Validation fails for a valid model","text":"<p>Ensure you have the latest Brick schema:</p> <pre><code>from brickschema import Graph\ng = Graph().load_file(\"model.ttl\")\nvalid, _, report = g.validate()\nprint(report)\n</code></pre>"},{"location":"license/#performance-is-slow-for-large-files","title":"Performance is slow for large files","text":"<p>For large CSV files, consider: - Using batch processing with smaller chunks - Enabling parallel processing (if available) - Upgrading to a machine with more RAM</p>"},{"location":"license/#best-practices","title":"Best Practices","text":""},{"location":"license/#should-i-validate-every-time-i-convert","title":"Should I validate every time I convert?","text":"<p>Yes! Validation ensures your Brick model is correct:</p> <pre><code># Convert\nconverter.convert_csv_to_brick(\"input.csv\", \"output.ttl\")\n\n# Validate\nvalidator = BrickModelValidator()\nis_valid, report = validator.validate_model(\"output.ttl\")\n\nif not is_valid:\n    print(\"Validation errors:\", report)\n</code></pre>"},{"location":"license/#how-often-should-i-update-the-package","title":"How often should I update the package?","text":"<p>Check for updates monthly:</p> <pre><code>pip install --upgrade hhw-brick\n</code></pre>"},{"location":"license/#whats-the-recommended-workflow","title":"What's the recommended workflow?","text":"<ol> <li>Convert CSV to Brick</li> <li>Validate the model</li> <li>Qualify buildings for analysis</li> <li>Run applications</li> <li>Export results</li> </ol> <p>See User Guide for detailed workflows.</p>"},{"location":"license/#contributing_1","title":"Contributing","text":""},{"location":"license/#how-can-i-contribute","title":"How can I contribute?","text":"<p>See the Contributing Guide for: - Reporting bugs - Suggesting features - Submitting pull requests - Writing documentation</p>"},{"location":"license/#where-do-i-report-bugs","title":"Where do I report bugs?","text":"<p>GitHub Issues</p>"},{"location":"license/#can-i-add-my-application-to-the-package","title":"Can I add my application to the package?","text":"<p>Yes! We welcome contributions of new analytics applications. See the Pull Request Guide.</p>"},{"location":"license/#still-have-questions","title":"Still Have Questions?","text":"<ul> <li>Check the documentation: Browse the User Guide or Developer Guide</li> <li>Search GitHub: Look for similar issues</li> <li>Ask the community: Open a discussion</li> </ul> <p>Didn't find your answer? Open an issue on GitHub.</p>"},{"location":"port_configuration_guide/","title":"Port Configuration Guide","text":""},{"location":"port_configuration_guide/#port-configuration-overview","title":"\ud83d\udccb Port Configuration Overview","text":""},{"location":"port_configuration_guide/#basic-port-configuration","title":"\ud83d\udd0c Basic Port Configuration","text":"<pre><code>port: 8080  # Application listening port number\n</code></pre>"},{"location":"port_configuration_guide/#port-usage-details","title":"\ud83c\udfaf Port Usage Details","text":""},{"location":"port_configuration_guide/#1-web-interface-access","title":"1. Web Interface Access","text":"<ul> <li>Purpose: Provides browser-based user interface</li> <li>Features:</li> <li>CSV data upload and conversion</li> <li>Brick model visualization</li> <li>System status monitoring</li> <li>Configuration management</li> <li>Access: <code>http://localhost:8080</code></li> </ul>"},{"location":"port_configuration_guide/#2-api-services","title":"2. API Services","text":"<pre><code># Example API endpoints\nGET  /status          # Get system status\nPOST /convert         # Convert CSV data\nGET  /config          # Get configuration info\nPOST /deploy          # Deploy application\n</code></pre>"},{"location":"port_configuration_guide/#3-docker-container-deployment","title":"3. Docker Container Deployment","text":"<p><pre><code>docker:\n  ports:\n    - \"8080:8080\"     # host_port:container_port\n</code></pre> - Host Port (8080): External access port - Container Port (8080): Application port inside container - Port Mapping: Allows external access to container service via host_ip:8080</p>"},{"location":"port_configuration_guide/#4-kubernetes-cluster-deployment","title":"4. Kubernetes Cluster Deployment","text":"<p><pre><code>kubernetes:\n  service_type: \"LoadBalancer\"\n  # Automatically creates Service using port configuration\n</code></pre> - Pod Port: Application listening port inside container - Service Port: Cluster-internal service communication port - LoadBalancer: External service exposure port</p>"},{"location":"port_configuration_guide/#port-usage-in-different-deployment-modes","title":"\ud83d\udd27 Port Usage in Different Deployment Modes","text":""},{"location":"port_configuration_guide/#local-development-mode","title":"Local Development Mode","text":"<pre><code># Start application\npython examples/web_app_example.py --port 8080\n\n# Access URL\nhttp://localhost:8080\n</code></pre>"},{"location":"port_configuration_guide/#docker-container-mode","title":"Docker Container Mode","text":"<pre><code># Build and run\ndocker build -t hhw-brick-app .\ndocker run -p 8080:8080 hhw-brick-app\n\n# Access URL\nhttp://localhost:8080\n</code></pre>"},{"location":"port_configuration_guide/#kubernetes-cluster-mode","title":"Kubernetes Cluster Mode","text":"<pre><code># Deploy to cluster\nkubectl apply -f k8s/\n\n# Access via Service\nkubectl port-forward service/hhws-app-service 8080:8080\n</code></pre>"},{"location":"port_configuration_guide/#real-world-application-scenarios","title":"\ud83c\udf10 Real-World Application Scenarios","text":""},{"location":"port_configuration_guide/#scenario-1-data-center-monitoring","title":"Scenario 1: Data Center Monitoring","text":"<ul> <li>Port: 8080</li> <li>Function: Real-time HHWS system status display</li> <li>Users: Operations staff monitoring via browser</li> </ul>"},{"location":"port_configuration_guide/#scenario-2-data-conversion-service","title":"Scenario 2: Data Conversion Service","text":"<ul> <li>Port: 8080</li> <li>Function: Receives CSV files, returns Brick format data</li> <li>Users: Other systems calling via API</li> </ul>"},{"location":"port_configuration_guide/#scenario-3-multi-tenant-deployment","title":"Scenario 3: Multi-Tenant Deployment","text":"<ul> <li>Ports: 8080, 8081, 8082...</li> <li>Function: Deploy separate instances for different buildings</li> <li>Users: Each building has its own management interface</li> </ul>"},{"location":"port_configuration_guide/#port-configuration-best-practices","title":"\u2699\ufe0f Port Configuration Best Practices","text":""},{"location":"port_configuration_guide/#1-port-selection-principles","title":"1. Port Selection Principles","text":"<ul> <li>Avoid Conflicts: Do not use system reserved ports (0-1023)</li> <li>Enterprise Standards: Follow company port allocation standards</li> <li>Firewall: Ensure selected port is open in firewall</li> </ul>"},{"location":"port_configuration_guide/#2-security-considerations","title":"2. Security Considerations","text":"<ul> <li>Internal Network: Recommend exposing only on internal network in production</li> <li>HTTPS: Use SSL/TLS encryption in production</li> <li>Authentication: Add user authentication and access control</li> </ul>"},{"location":"port_configuration_guide/#3-monitoring-and-logging","title":"3. Monitoring and Logging","text":"<ul> <li>Health Checks: Configure port health checks</li> <li>Access Logs: Record all access requests</li> <li>Performance Monitoring: Monitor port response times</li> </ul>"},{"location":"port_configuration_guide/#quick-port-configuration-testing","title":"\ud83d\ude80 Quick Port Configuration Testing","text":""},{"location":"port_configuration_guide/#test-web-interface","title":"Test Web Interface","text":"<pre><code># Start test server\npython examples/web_app_example.py --port 8080 --debug\n\n# Open in browser\nhttp://localhost:8080\n</code></pre>"},{"location":"port_configuration_guide/#test-api-endpoints","title":"Test API Endpoints","text":"<pre><code># Check service status\ncurl http://localhost:8080/status\n\n# Get configuration info\ncurl http://localhost:8080/config\n</code></pre>"},{"location":"api-reference/","title":"API Reference","text":"<p>Complete API documentation for HHW Brick Application.</p>"},{"location":"api-reference/#overview","title":"Overview","text":"<p>This section provides detailed documentation for all public APIs in the package.</p>"},{"location":"api-reference/#modules","title":"Modules","text":""},{"location":"api-reference/#conversion","title":"Conversion","text":"<p>Transform CSV data to Brick ontology models.</p> <ul> <li>CSVToBrickConverter - Main converter class</li> <li>BatchConverter - Batch processing</li> </ul>"},{"location":"api-reference/#validation","title":"Validation","text":"<p>Validate Brick models against schemas and ground truth.</p> <ul> <li>BrickModelValidator - Main validator</li> <li>SubgraphPatternValidator - Pattern matching</li> <li>GroundTruthCalculator - Ground truth comparison</li> </ul>"},{"location":"api-reference/#applications","title":"Applications","text":"<p>Analytics application framework.</p> <ul> <li>AppsManager - Application management</li> <li>BaseApp - Base application interface</li> </ul>"},{"location":"api-reference/#cli","title":"CLI","text":"<p>Command-line interface.</p> <ul> <li>Main CLI - Command-line entry points</li> </ul>"},{"location":"api-reference/#utils","title":"Utils","text":"<p>Utility functions and helpers.</p> <ul> <li>BrickQuery - Query Brick models</li> <li>ConfigLoader - Load configurations</li> </ul>"},{"location":"api-reference/#quick-reference","title":"Quick Reference","text":""},{"location":"api-reference/#import-statements","title":"Import Statements","text":"<pre><code># Main classes\nfrom hhw_brick import (\n    CSVToBrickConverter,\n    BatchConverter,\n    BrickModelValidator,\n    GroundTruthCalculator,\n    apps\n)\n\n# Utilities\nfrom hhw_brick.utils import (\n    BrickQuery,\n    ConfigLoader\n)\n\n# Validation\nfrom hhw_brick.validation import (\n    SubgraphPatternValidator\n)\n</code></pre>"},{"location":"api-reference/#common-methods","title":"Common Methods","text":""},{"location":"api-reference/#conversion_1","title":"Conversion","text":"<pre><code>converter = CSVToBrickConverter()\n\n# Convert single file\nconverter.convert_csv_to_brick(input_file, output_file)\n\n# Batch convert\nbatch = BatchConverter()\nbatch.convert_batch(input_dir, output_dir)\n</code></pre>"},{"location":"api-reference/#validation_1","title":"Validation","text":"<pre><code>validator = BrickModelValidator()\n\n# Validate model\nis_valid, report = validator.validate_model(model_path)\n\n# Check ontology\nis_valid, errors = validator.validate_ontology(model_path)\n</code></pre>"},{"location":"api-reference/#applications_1","title":"Applications","text":"<pre><code># List apps\navailable = apps.list_apps()\n\n# Load app\napp = apps.load_app(\"app_name\")\n\n# Qualify building\nqualified, details = app.qualify(brick_model)\n\n# Run analysis\nresults = app.analyze(brick_model, data, config)\n</code></pre>"},{"location":"api-reference/#type-hints","title":"Type Hints","text":"<p>All public APIs include type hints for better IDE support:</p> <pre><code>from typing import Dict, Tuple, Optional\nfrom rdflib import Graph\nimport pandas as pd\n\ndef qualify(brick_model: Graph) -&gt; Tuple[bool, Dict]:\n    ...\n\ndef analyze(\n    brick_model: Graph,\n    timeseries_data: pd.DataFrame,\n    config: Optional[Dict] = None\n) -&gt; Dict:\n    ...\n</code></pre>"},{"location":"api-reference/#return-values","title":"Return Values","text":""},{"location":"api-reference/#successfailure-pattern","title":"Success/Failure Pattern","text":"<p>Most methods return success status with details:</p> <pre><code># Pattern 1: Boolean + Details\nis_valid, report = validator.validate_model(path)\n# is_valid: bool\n# report: Dict[str, Any]\n\n# Pattern 2: Result Dictionary\nresult = {\n    \"success\": True,\n    \"data\": {...},\n    \"errors\": []\n}\n</code></pre>"},{"location":"api-reference/#error-handling","title":"Error Handling","text":"<p>APIs raise specific exceptions:</p> <pre><code>from hhw_brick.exceptions import (\n    ValidationError,\n    ConversionError,\n    ConfigurationError\n)\n</code></pre>"},{"location":"api-reference/#next-steps","title":"Next Steps","text":"<ul> <li>Browse module documentation in the sidebar</li> <li>Check Examples for practical usage</li> <li>Read User Guide for workflows</li> </ul> <p>Need details? Select a module from the navigation \u2192</p>"},{"location":"developer-guide/","title":"Developer Guide","text":"<p>Welcome to the HHW Brick Application Developer Guide! This guide is for developers who want to extend the package or contribute to its development.</p>"},{"location":"developer-guide/#overview","title":"Overview","text":"<p>This guide covers:</p>"},{"location":"developer-guide/#package-architecture","title":"Package Architecture","text":"<p>Understand the internal structure and design of the package.</p> <ul> <li>Core Modules - Overview of all modules</li> <li>Application Framework - How the app system works</li> <li>Design Patterns - Architectural decisions</li> </ul>"},{"location":"developer-guide/#developing-applications","title":"Developing Applications","text":"<p>Learn how to create your own analytics applications.</p> <ul> <li>Getting Started - Your first application</li> <li>Application Structure - Required components</li> <li>Qualify Function - Check building eligibility</li> <li>Analyze Function - Implement analysis logic</li> <li>Configuration - Handle app settings</li> <li>Testing - Test your application</li> <li>Best Practices - Tips and guidelines</li> </ul>"},{"location":"developer-guide/#contributing","title":"Contributing","text":"<p>Contribute to the HHW Brick Application project.</p> <ul> <li>Development Setup - Set up your environment</li> <li>Code Style - Coding standards</li> <li>Testing Guide - Write and run tests</li> <li>Documentation - Update docs</li> <li>Pull Requests - Submit changes</li> </ul>"},{"location":"developer-guide/#quick-start-for-developers","title":"Quick Start for Developers","text":""},{"location":"developer-guide/#create-your-first-application","title":"Create Your First Application","text":"<pre><code># my_app/__init__.py\n\"\"\"\nCustom Analytics Application\n\"\"\"\nfrom typing import Dict, Tuple\nimport pandas as pd\nfrom rdflib import Graph\n\n__all__ = ['qualify', 'analyze', 'load_config']\n\ndef qualify(brick_model: Graph) -&gt; Tuple[bool, Dict]:\n    \"\"\"Check if building has required sensors\"\"\"\n    # Implementation here\n    return True, {\"status\": \"qualified\"}\n\ndef analyze(brick_model: Graph,\n           timeseries_data: pd.DataFrame,\n           config: Dict) -&gt; Dict:\n    \"\"\"Run analysis on the building\"\"\"\n    # Implementation here\n    return {\"results\": \"analysis complete\"}\n\ndef load_config(config_path: str = None) -&gt; Dict:\n    \"\"\"Load application configuration\"\"\"\n    return {\"default\": \"config\"}\n</code></pre> <p>Learn more about developing apps \u2192</p>"},{"location":"developer-guide/#application-development-workflow","title":"Application Development Workflow","text":"<pre><code>graph TD\n    A[Define App Idea] --&gt; B[Create App Structure]\n    B --&gt; C[Implement qualify]\n    C --&gt; D[Implement analyze]\n    D --&gt; E[Add Configuration]\n    E --&gt; F[Write Tests]\n    F --&gt; G[Document App]\n    G --&gt; H{Tests Pass?}\n    H --&gt;|Yes| I[Deploy App]\n    H --&gt;|No| F\n\n    style A fill:#e1f5ff\n    style I fill:#c8e6c9</code></pre>"},{"location":"developer-guide/#package-structure","title":"Package Structure","text":"<pre><code>hhw_brick/\n\u251c\u2500\u2500 conversion/              # CSV to Brick conversion\n\u2502   \u251c\u2500\u2500 csv_to_brick.py\n\u2502   \u2514\u2500\u2500 batch_converter.py\n\u251c\u2500\u2500 validation/              # Model validation\n\u2502   \u251c\u2500\u2500 validator.py\n\u2502   \u2514\u2500\u2500 subgraph_matcher.py\n\u251c\u2500\u2500 applications/            # Analytics applications\n\u2502   \u251c\u2500\u2500 apps_manager.py     # Application framework\n\u2502   \u251c\u2500\u2500 secondary_loop_temp_diff/\n\u2502   \u2514\u2500\u2500 primary_loop_temp_diff/\n\u251c\u2500\u2500 cli/                     # Command-line interface\n\u2502   \u2514\u2500\u2500 main.py\n\u2514\u2500\u2500 utils/                   # Utility functions\n    \u251c\u2500\u2500 brick_query.py\n    \u2514\u2500\u2500 config_loader.py\n</code></pre> <p>Explore architecture \u2192</p>"},{"location":"developer-guide/#development-tools","title":"Development Tools","text":""},{"location":"developer-guide/#required-tools","title":"Required Tools","text":"<ul> <li>Python 3.8+</li> <li>Git - Version control</li> <li>pytest - Testing framework</li> <li>black - Code formatting</li> <li>mypy - Type checking</li> </ul>"},{"location":"developer-guide/#recommended-tools","title":"Recommended Tools","text":"<ul> <li>VS Code or PyCharm - IDE</li> <li>pytest-cov - Coverage reporting</li> <li>pre-commit - Git hooks</li> </ul> <p>Setup guide \u2192</p>"},{"location":"developer-guide/#api-design-principles","title":"API Design Principles","text":""},{"location":"developer-guide/#consistency","title":"Consistency","text":"<p>All applications follow the same interface:</p> <pre><code>__all__ = ['qualify', 'analyze', 'load_config']\n\ndef qualify(brick_model: Graph) -&gt; Tuple[bool, Dict]:\n    \"\"\"Standard signature for all apps\"\"\"\n    pass\n\ndef analyze(brick_model: Graph,\n           timeseries_data: pd.DataFrame,\n           config: Dict) -&gt; Dict:\n    \"\"\"Standard signature for all apps\"\"\"\n    pass\n</code></pre>"},{"location":"developer-guide/#modularity","title":"Modularity","text":"<p>Each component is self-contained and can be used independently:</p> <pre><code># Use conversion alone\nfrom hhw_brick import CSVToBrickConverter\n\n# Use validation alone\nfrom hhw_brick import BrickModelValidator\n\n# Use apps alone\nfrom hhw_brick import apps\n</code></pre>"},{"location":"developer-guide/#extensibility","title":"Extensibility","text":"<p>The application framework allows easy addition of new analytics:</p> <pre><code># Your custom app is automatically discovered\nfrom hhw_brick import apps\n\n# Just place it in applications/ directory\napps.list_apps()  # Will include your app\n</code></pre>"},{"location":"developer-guide/#quick-navigation","title":"Quick Navigation","text":"<ul> <li> <p>:material-architecture: Architecture</p> <p>Understand the package design</p> </li> <li> <p> Build Apps</p> <p>Create analytics applications</p> </li> <li> <p> Contribute</p> <p>Join the development</p> </li> <li> <p> API Reference</p> <p>Detailed API docs</p> </li> </ul>"},{"location":"developer-guide/#resources","title":"Resources","text":"<ul> <li>Source Code: GitHub Repository</li> <li>Issue Tracker: GitHub Issues</li> <li>PyPI Package: hhw-brick</li> </ul> <p>Ready to build? Start with Package Architecture or jump to Developing Applications \u2192</p>"},{"location":"developer-guide/#getting-started","title":"Getting Started","text":"<p>Welcome to HHW Brick Application! This guide will help you get up and running quickly.</p>"},{"location":"developer-guide/#what-youll-learn","title":"What You'll Learn","text":"<p>In this section, you'll learn:</p> <ul> <li>How to install the package</li> <li>How to perform your first conversion</li> <li>Understanding core concepts of the package</li> </ul>"},{"location":"developer-guide/#prerequisites","title":"Prerequisites","text":"<p>Before you begin, make sure you have:</p> <ul> <li>Python 3.8 or higher installed</li> <li>Basic knowledge of Python programming</li> <li>Familiarity with CSV files (optional but helpful)</li> <li>Understanding of building systems (optional but helpful)</li> </ul>"},{"location":"developer-guide/#installation-overview","title":"Installation Overview","text":"<p>The easiest way to install HHW Brick Application is using pip:</p> <pre><code>pip install hhw-brick\n</code></pre> <p>For detailed installation instructions, including development setup, see the Installation Guide.</p>"},{"location":"developer-guide/#quick-example","title":"Quick Example","text":"<p>Here's a simple example to get you started:</p> <pre><code>from hhw_brick import CSVToBrickConverter\n\n# Create a converter\nconverter = CSVToBrickConverter()\n\n# Convert CSV to Brick\nconverter.convert_csv_to_brick(\n    input_file=\"your_building.csv\",\n    output_file=\"your_building.ttl\"\n)\n</code></pre>"},{"location":"developer-guide/#next-steps","title":"Next Steps","text":"<p>Ready to dive in? Choose your path:</p> <ul> <li> <p> Install the Package</p> <p>Get HHW Brick Application installed on your system</p> </li> <li> <p> Quick Start Guide</p> <p>Follow a step-by-step tutorial</p> </li> <li> <p> Learn Core Concepts</p> <p>Understand the fundamentals</p> </li> <li> <p> Explore User Guide</p> <p>Dive deeper into features</p> </li> </ul>"},{"location":"developer-guide/#need-help","title":"Need Help?","text":"<ul> <li>Check the FAQ for common questions</li> <li>Browse Examples for code samples</li> <li>Visit our GitHub repository for issues and discussions</li> </ul> <p>Let's get started! Head over to the Installation Guide \u2192</p>"},{"location":"examples/","title":"Examples","text":"<p>Practical code examples for using HHW Brick Application.</p>"},{"location":"examples/#overview","title":"Overview","text":"<p>This section contains working code examples demonstrating how to use the HHW Brick Application package. All examples use test data from <code>tests/fixtures/</code> to ensure they work out of the box.</p>"},{"location":"examples/#available-examples","title":"Available Examples","text":""},{"location":"examples/#getting-started","title":"Getting Started","text":"<ul> <li>Installation and Setup - Quick Start Guide</li> <li>First Conversion - Convert your first building to Brick format</li> </ul>"},{"location":"examples/#conversion-examples","title":"Conversion Examples","text":"<ul> <li>Single Building Conversion - Convert one building at a time</li> <li>Batch Conversion - Convert multiple buildings at once</li> <li>Custom Sensor Mapping - Customize sensor mappings</li> </ul>"},{"location":"examples/#validation-examples","title":"Validation Examples","text":"<ul> <li>Ontology Validation - Validate Brick schema compliance</li> <li>Ground Truth Validation - Check point and equipment counts</li> <li>Pattern Validation - Verify system topology</li> </ul>"},{"location":"examples/#application-examples","title":"Application Examples","text":"<ul> <li>Apps Manager - Discover and manage apps</li> <li>Secondary Loop Analysis - Temperature difference analysis</li> <li>Running Apps - Complete application workflow</li> </ul>"},{"location":"examples/#example-code-repository","title":"Example Code Repository","text":"<p>The package includes complete example scripts in the <code>examples/</code> directory:</p> <pre><code>examples/\n\u251c\u2500\u2500 01_convert_csv_to_brick.py\n\u251c\u2500\u2500 02_ontology_validation.py\n\u251c\u2500\u2500 03_point_count_validation.py\n\u251c\u2500\u2500 04_equipment_count_validation.py\n\u251c\u2500\u2500 05_subgraph_pattern_matching.py\n\u251c\u2500\u2500 06_application_management.py\n\u251c\u2500\u2500 07_run_application.py\n\u251c\u2500\u2500 08_batch_run_application.py\n\u2514\u2500\u2500 README.md\n</code></pre>"},{"location":"examples/#running-examples","title":"Running Examples","text":"<p>All examples can be run directly from the package installation:</p> <pre><code>cd path/to/hhw-brick\npython examples/01_convert_csv_to_brick.py\n</code></pre>"},{"location":"examples/#common-workflows","title":"Common Workflows","text":""},{"location":"examples/#complete-end-to-end-workflow","title":"Complete End-to-End Workflow","text":"<pre><code>\"\"\"\nComplete workflow: Convert \u2192 Validate \u2192 Analyze\n\"\"\"\nfrom hhw_brick import (\n    CSVToBrickConverter,\n    BrickModelValidator,\n    apps\n)\n\n# Step 1: Convert\nconverter = CSVToBrickConverter()\nconverter.convert_to_brick(\n    metadata_csv=\"metadata.csv\",\n    vars_csv=\"vars.csv\",\n    building_tag=\"105\",\n    output_path=\"building_105.ttl\"\n)\n\n# Step 2: Validate\nvalidator = BrickModelValidator(use_local_brick=True)\nis_valid = validator.validate_ontology(\"building_105.ttl\")['valid']\n\nif is_valid:\n    # Step 3: Analyze\n    app = apps.load_app(\"secondary_loop_temp_diff\")\n    qualified, details = app.qualify(\"building_105.ttl\")\n\n    if qualified:\n        config = apps.get_default_config(\"secondary_loop_temp_diff\")\n        results = app.analyze(\n            \"building_105.ttl\",\n            \"105_data.csv\",\n            config\n        )\n        print(f\"Analysis complete: {results['summary']}\")\n</code></pre>"},{"location":"examples/#interactive-tutorials","title":"Interactive Tutorials","text":"<p>For step-by-step learning, see:</p> <ul> <li>Quick Start Tutorial</li> <li>Conversion Guide</li> <li>Validation Guide</li> <li>Applications Guide</li> </ul>"},{"location":"examples/#need-help","title":"Need Help?","text":"<ul> <li>Check the FAQ for common questions</li> <li>Browse the User Guide for detailed documentation</li> <li>Visit the GitHub repository for issues and discussions</li> </ul>"},{"location":"getting-started/","title":"Getting Started","text":"<p>Welcome to HHW Brick Application! This guide will help you get up and running with converting heating hot water system data to Brick ontology format.</p>"},{"location":"getting-started/#what-youll-learn","title":"What You'll Learn","text":"<p>In this section, you'll learn:</p> <ul> <li>How to install the package</li> <li>How to perform your first conversion </li> <li>Understanding Brick ontology</li> <li>CSV data format requirements</li> </ul>"},{"location":"getting-started/#what-is-hhw-brick-application","title":"What is HHW Brick Application?","text":"<p>HHW Brick Application is a Python package that converts heating hot water system (HHWS) equipment data from CSV format into standardized Brick ontology models. It supports:</p> <ul> <li>Multiple System Types: Boiler, Condensing, Non-condensing, District HW, District Steam</li> <li>Batch Processing: Convert hundreds of buildings at once</li> <li>Validation: Ensure model correctness</li> <li>Analytics: Run analysis applications on converted models</li> </ul>"},{"location":"getting-started/#prerequisites","title":"Prerequisites","text":"<p>Before you begin, you should have:</p> <ul> <li>Python 3.8+ installed on your system</li> <li>Basic Python knowledge (variables, functions, modules)</li> <li>CSV data files with building equipment information (we provide test data to get started)</li> </ul>"},{"location":"getting-started/#quick-example","title":"Quick Example","text":"<p>Here's the simplest possible example:</p> <pre><code>from hhw_brick import CSVToBrickConverter\n\n# Create converter\nconverter = CSVToBrickConverter()\n\n# Convert a building\nconverter.convert_to_brick(\n    metadata_csv=\"metadata.csv\",\n    vars_csv=\"vars_available_by_building.csv\",\n    building_tag=\"105\",\n    output_path=\"building_105.ttl\"\n)\n</code></pre> <p>That's it! You now have a Brick ontology model in <code>building_105.ttl</code>.</p>"},{"location":"getting-started/#package-components","title":"Package Components","text":"<p>The package consists of three main components:</p>"},{"location":"getting-started/#1-conversion-module","title":"1. Conversion Module","text":"<p>Convert CSV data to Brick models:</p> <pre><code>from hhw_brick import CSVToBrickConverter, BatchConverter\n</code></pre> <ul> <li><code>CSVToBrickConverter</code> - Single building conversion</li> <li><code>BatchConverter</code> - Multiple buildings at once</li> </ul>"},{"location":"getting-started/#2-validation-module","title":"2. Validation Module","text":"<p>Validate your Brick models:</p> <pre><code>from hhw_brick import BrickModelValidator, GroundTruthCalculator\n</code></pre> <ul> <li><code>BrickModelValidator</code> - Check ontology correctness</li> <li><code>GroundTruthCalculator</code> - Compare against expected values</li> </ul>"},{"location":"getting-started/#3-applications-module","title":"3. Applications Module","text":"<p>Run analytics on your models:</p> <pre><code>from hhw_brick import apps\n\n# List available applications\napps.list_apps()\n\n# Load an application\napp = apps.load_app(\"secondary_loop_temp_diff\")\n</code></pre>"},{"location":"getting-started/#next-steps","title":"Next Steps","text":"<p>Ready to get started? Choose your path:</p> <ul> <li> <p>\ud83d\udce5 Install the Package - Install HHW Brick Application on your system</p> </li> <li> <p>\u26a1 Quick Start Guide - Convert your first building in 5 minutes</p> </li> <li> <p>\ud83d\udcda Understanding Brick - Learn what Brick ontology is</p> </li> <li> <p>\ud83d\udccb CSV Format Guide - Prepare your data files</p> </li> </ul>"},{"location":"getting-started/#need-help","title":"Need Help?","text":"<ul> <li>Check the FAQ for common questions</li> <li>See User Guide for detailed documentation</li> </ul> <p>Let's begin! Head over to Installation \u2192</p>"},{"location":"getting-started/csv-format/","title":"CSV Data Format","text":"<p>Understanding the CSV file format for converting to Brick models.</p>"},{"location":"getting-started/csv-format/#two-required-files","title":"Two Required Files","text":"<ol> <li>metadata.csv - Building information</li> <li>vars_available_by_building.csv - Sensor availability</li> </ol>"},{"location":"getting-started/csv-format/#metadatacsv","title":"metadata.csv","text":""},{"location":"getting-started/csv-format/#minimum-required","title":"Minimum Required","text":"<pre><code>tag,system,org\n105,Non-condensing,Organization A\n106,Condensing,Organization B\n107,District HW,Organization C\n</code></pre>"},{"location":"getting-started/csv-format/#real-world-example-with-optional-columns","title":"Real-World Example (with optional columns)","text":"<pre><code>tag,org,area,bldg_type,year,system,b_number,design_supply,design_return\n29,Z,13000,Other/EventSpace,1960,District HW,NA,NA,NA\n53,X,7700,Other/Museum,2020,Condensing,2,71.1,54.4\n105,H,46000,Office,1980,Non-condensing,3,87.8,NA\n127,M,26000,Other,2020,Condensing,2,60,37.8\n</code></pre>"},{"location":"getting-started/csv-format/#column-descriptions","title":"Column Descriptions","text":"<p>Required: - <code>tag</code> - Building ID (integer, unique) - <code>system</code> - System type (see below) - <code>org</code> - Organization name</p> <p>Optional but useful: - <code>area</code> - Building area (sq ft) - <code>bldg_type</code> - Building type (Office, Lab, etc.) - <code>year</code> - Year built - <code>b_number</code> - Number of boilers - <code>design_supply</code> - Design supply temperature (\u00b0C) - <code>design_return</code> - Design return temperature (\u00b0C)</p>"},{"location":"getting-started/csv-format/#system-types","title":"System Types","text":"<p>Must be one of these 5 types (case-insensitive):</p> System Type Description <code>Boiler</code> Generic boiler system <code>Non-condensing</code> Standard efficiency boiler <code>Condensing</code> High efficiency boiler <code>District HW</code> Campus hot water <code>District Steam</code> District steam"},{"location":"getting-started/csv-format/#vars_available_by_buildingcsv","title":"vars_available_by_building.csv","text":""},{"location":"getting-started/csv-format/#purpose","title":"Purpose","text":"<p>Shows which sensors each building has. - <code>1</code> = sensor exists - <code>0</code> or empty = no sensor</p>"},{"location":"getting-started/csv-format/#minimum-example","title":"Minimum Example","text":"<pre><code>tag,ret,sup,hw,flow,t_out\n105,1,1,1,1,1\n106,1,1,1,0,0\n107,1,1,0,0,1\n</code></pre>"},{"location":"getting-started/csv-format/#real-world-example-many-sensors","title":"Real-World Example (many sensors)","text":"<pre><code>tag,ret,sup,sup1,ret1,fire1,sup2,ret2,fire2,hw,flow,pmp1_pwr,pmp2_pwr,t_out,enab\n29,1,1,,,,,,,1,1,,,1,\n53,1,1,1,,,,,,1,1,,,1,1\n105,1,1,1,1,1,1,1,1,1,1,1,1,1,1\n</code></pre>"},{"location":"getting-started/csv-format/#common-sensor-columns","title":"Common Sensor Columns","text":"<p>Temperature: <pre><code>sup, ret          # Primary supply/return\nsup1-4, ret1-4    # Individual boiler temps\n</code></pre></p> <p>Pumps: <pre><code>pmp1_pwr, pmp1_spd, pmp1_vfd    # Pump 1\npmp2_pwr, pmp2_spd, pmp2_vfd    # Pump 2\n</code></pre></p> <p>Other: <pre><code>hw          # Hot water sensor\nflow        # Flow rate\ndp          # Differential pressure\nfire1-4     # Boiler firing rates\nt_out       # Outdoor temperature\nenab        # Enable signal\n</code></pre></p> <p>You can have 5 columns or 50 columns - the converter automatically handles all available sensors!</p>"},{"location":"getting-started/csv-format/#quick-validation","title":"Quick Validation","text":"<pre><code>import pandas as pd\n\n# Load files\nmeta = pd.read_csv(\"metadata.csv\")\nvars_df = pd.read_csv(\"vars_available_by_building.csv\")\n\n# Check basics\nprint(\"Buildings in metadata:\", len(meta))\nprint(\"Buildings in vars:\", len(vars_df))\nprint(\"Tags match:\", set(meta['tag']) == set(vars_df['tag']))\nprint(\"Sensor types:\", len(vars_df.columns) - 1)\n</code></pre>"},{"location":"getting-started/csv-format/#common-issues-solutions","title":"Common Issues &amp; Solutions","text":""},{"location":"getting-started/csv-format/#issue-missing-required-column","title":"\u274c Issue: Missing required column","text":"<pre><code>tag,system\n105,Non-condensing\n# Missing 'org' column!\n</code></pre> <p>\u2705 Fix: Add the <code>org</code> column <pre><code>tag,system,org\n105,Non-condensing,Organization A\n</code></pre></p>"},{"location":"getting-started/csv-format/#issue-invalid-system-type","title":"\u274c Issue: Invalid system type","text":"<pre><code>tag,system,org\n105,InvalidType,Org A\n</code></pre> <p>\u2705 Fix: Use one of the 5 supported types <pre><code>tag,system,org\n105,Non-condensing,Org A\n</code></pre></p>"},{"location":"getting-started/csv-format/#issue-tags-dont-match","title":"\u274c Issue: Tags don't match","text":"<pre><code># metadata.csv: has building 105\n# vars.csv: has building 106\n</code></pre> <p>\u2705 Fix: Ensure tags match exactly in both files</p>"},{"location":"getting-started/csv-format/#next-steps","title":"Next Steps","text":"<p>Ready to convert? See:</p> <ul> <li>Quick Start - Convert your first building</li> <li>Conversion Guide - Detailed guide</li> <li>Sensor Mapping - Customize mappings</li> </ul>"},{"location":"getting-started/installation/","title":"Installation","text":"<p>Get HHW Brick Application installed and ready to use.</p>"},{"location":"getting-started/installation/#requirements","title":"Requirements","text":""},{"location":"getting-started/installation/#python-version","title":"Python Version","text":"<ul> <li>Python 3.8 or higher is required</li> <li>Python 3.10 is recommended for best performance</li> </ul> <p>Check your Python version:</p> <pre><code>python --version\n</code></pre>"},{"location":"getting-started/installation/#operating-systems","title":"Operating Systems","text":"<p>HHW Brick Application works on:</p> <ul> <li>\u2705 Windows 10/11</li> <li>\u2705 macOS 10.15+</li> <li>\u2705 Linux (Ubuntu 20.04+, Debian, CentOS, etc.)</li> </ul>"},{"location":"getting-started/installation/#installation-methods","title":"Installation Methods","text":""},{"location":"getting-started/installation/#method-1-install-from-pypi-recommended","title":"Method 1: Install from PyPI (Recommended)","text":"<p>The easiest way to install:</p> <pre><code>pip install hhw-brick\n</code></pre> <p>This installs the latest stable version.</p>"},{"location":"getting-started/installation/#method-2-install-from-source","title":"Method 2: Install from Source","text":"<p>For the latest development version:</p> <pre><code># Clone the repository\ngit clone https://github.com/CenterForTheBuiltEnvironment/HHW_brick.git\ncd hhw-brick\n\n# Install in editable mode\npip install -e .\n</code></pre>"},{"location":"getting-started/installation/#method-3-install-specific-version","title":"Method 3: Install Specific Version","text":"<pre><code># Install specific version\npip install hhw-brick==0.2.0\n\n# Upgrade to latest\npip install --upgrade hhw-brick\n</code></pre>"},{"location":"getting-started/installation/#verify-installation","title":"Verify Installation","text":"<p>Check that the package is installed correctly:</p> <pre><code>import hhw_brick\nprint(hhw_brick.__version__)\n</code></pre> <p>Expected output: <pre><code>0.2.0\n</code></pre></p> <p>Test the main components:</p> <pre><code>from hhw_brick import CSVToBrickConverter, BatchConverter, apps\n\nprint(\"\u2713 Conversion module loaded\")\nprint(f\"\u2713 Available apps: {apps.list_apps()}\")\n</code></pre>"},{"location":"getting-started/installation/#dependencies","title":"Dependencies","text":"<p>HHW Brick Application automatically installs these dependencies:</p>"},{"location":"getting-started/installation/#core-dependencies","title":"Core Dependencies","text":"Package Version Purpose rdflib \u22657.2.0 RDF graph processing pandas \u22651.3.0 Data manipulation pyyaml \u22655.4.0 Configuration files brickschema \u22650.7.0 Brick ontology support"},{"location":"getting-started/installation/#optional-dependencies","title":"Optional Dependencies","text":"Package Version Purpose click \u22658.0.0 Command-line interface matplotlib \u22653.5.0 Visualization tqdm \u22654.0.0 Progress bars"},{"location":"getting-started/installation/#virtual-environment-recommended","title":"Virtual Environment (Recommended)","text":"<p>It's recommended to use a virtual environment:</p>"},{"location":"getting-started/installation/#using-venv","title":"Using venv","text":"<pre><code># Create virtual environment\npython -m venv venv\n\n# Activate (Windows)\nvenv\\Scripts\\activate\n\n# Activate (Linux/Mac)\nsource venv/bin/activate\n\n# Install package\npip install hhw-brick\n</code></pre>"},{"location":"getting-started/installation/#using-conda","title":"Using conda","text":"<pre><code># Create environment\nconda create -n hhws python=3.10\n\n# Activate\nconda activate hhws\n\n# Install package\npip install hhw-brick\n</code></pre>"},{"location":"getting-started/installation/#troubleshooting","title":"Troubleshooting","text":""},{"location":"getting-started/installation/#issue-pip-command-not-found","title":"Issue: \"pip: command not found\"","text":"<p>Solution: Install pip or use <code>python -m pip</code> instead:</p> <pre><code>python -m pip install hhw-brick\n</code></pre>"},{"location":"getting-started/installation/#issue-permission-denied","title":"Issue: \"Permission denied\"","text":"<p>Solution: Use <code>--user</code> flag:</p> <pre><code>pip install --user hhw-brick\n</code></pre> <p>Or use a virtual environment (recommended).</p>"},{"location":"getting-started/installation/#issue-no-matching-distribution-found","title":"Issue: \"No matching distribution found\"","text":"<p>Solution: Upgrade pip:</p> <pre><code>python -m pip install --upgrade pip\npip install hhw-brick\n</code></pre>"},{"location":"getting-started/installation/#issue-dependency-conflicts","title":"Issue: Dependency conflicts","text":"<p>Solution: Install in a clean virtual environment:</p> <pre><code>python -m venv fresh_env\nfresh_env\\Scripts\\activate  # Windows\npip install hhw-brick\n</code></pre>"},{"location":"getting-started/installation/#development-installation","title":"Development Installation","text":"<p>For contributors and developers:</p> <pre><code># Clone repository\ngit clone https://github.com/CenterForTheBuiltEnvironment/HHW_brick.git\ncd hhw-brick\n\n# Install development dependencies\npip install -r requirements.txt\npip install -r requirements-dev.txt\n\n# Install in editable mode\npip install -e .\n\n# Run tests to verify\npytest\n</code></pre> <p>See Development Setup for more details.</p>"},{"location":"getting-started/installation/#uninstallation","title":"Uninstallation","text":"<p>To remove the package:</p> <pre><code>pip uninstall hhw-brick\n</code></pre>"},{"location":"getting-started/installation/#next-steps","title":"Next Steps","text":"<p>Now that you have the package installed:</p> <ul> <li>Quick Start - Convert your first building</li> <li>Understanding Brick - Learn about Brick ontology</li> <li>CSV Format - Prepare your data files</li> </ul> <p>Installation complete! Continue to Quick Start \u2192</p>"},{"location":"getting-started/quick-start/","title":"Quick Start","text":"<p>Convert your first building to Brick format in just 5 minutes!</p>"},{"location":"getting-started/quick-start/#what-youll-build","title":"What You'll Build","text":"<p>By the end of this guide, you'll have:</p> <ul> <li>\u2705 Converted a building from CSV to Brick format</li> <li>\u2705 Validated the resulting model</li> <li>\u2705 Understood the basic workflow</li> </ul>"},{"location":"getting-started/quick-start/#step-1-install-the-package","title":"Step 1: Install the Package","text":"<p>If you haven't already:</p> <pre><code>pip install hhw-brick\n</code></pre>"},{"location":"getting-started/quick-start/#step-2-prepare-your-data","title":"Step 2: Prepare Your Data","text":"<p>You need two CSV files:</p> <ol> <li>metadata.csv - Building information (system type, organization, etc.)</li> <li>vars_available_by_building.csv - Sensor/point data for each building</li> </ol> <p>For this tutorial, we'll use the included test data.</p>"},{"location":"getting-started/quick-start/#download-test-data","title":"Download Test Data","text":"<p>The package includes test data. You can find it at:</p> <pre><code>tests/fixtures/metadata.csv\ntests/fixtures/vars_available_by_building.csv\n</code></pre> <p>Or create a simple example:</p> <pre><code>import pandas as pd\n\n# Create metadata.csv\nmetadata = pd.DataFrame({\n    'tag': [105],\n    'system': ['Non-condensing'],\n    'org': ['Organization A']\n})\nmetadata.to_csv('metadata.csv', index=False)\n\n# Create vars_available_by_building.csv  \nvars_data = pd.DataFrame({\n    'tag': [105],\n    'hw_supply_temp': [1],\n    'hw_return_temp': [1],\n    'hw_flow': [1]\n})\nvars_data.to_csv('vars_available_by_building.csv', index=False)\n</code></pre>"},{"location":"getting-started/quick-start/#step-3-convert-your-first-building","title":"Step 3: Convert Your First Building","text":"<p>Create a Python script (<code>my_first_conversion.py</code>):</p> <pre><code>from hhw_brick import CSVToBrickConverter\n\n# Create the converter\nconverter = CSVToBrickConverter()\n\n# Convert building #105\nresult = converter.convert_to_brick(\n    metadata_csv=\"metadata.csv\",\n    vars_csv=\"vars_available_by_building.csv\",\n    building_tag=\"105\",  # Building ID to convert\n    output_path=\"building_105.ttl\"\n)\n\nprint(f\"\u2713 Conversion complete!\")\nprint(f\"\u2713 Created {len(result)} RDF triples\")\nprint(f\"\u2713 Output: building_105.ttl\")\n</code></pre> <p>Run it:</p> <pre><code>python my_first_conversion.py\n</code></pre> <p>Expected output:</p> <pre><code>\u2713 Conversion complete!\n\u2713 Created 156 RDF triples\n\u2713 Output: building_105.ttl\n</code></pre>"},{"location":"getting-started/quick-start/#step-4-inspect-the-output","title":"Step 4: Inspect the Output","text":"<p>Your <code>building_105.ttl</code> file now contains a Brick model. Let's peek inside:</p> <pre><code>from rdflib import Graph\n\n# Load the Brick model\ng = Graph()\ng.parse(\"building_105.ttl\", format=\"turtle\")\n\n# Count elements\nprint(f\"Total statements: {len(g)}\")\n\n# Query for equipment\nquery = \"\"\"\nSELECT ?equip ?type WHERE {\n    ?equip a ?type .\n    FILTER(STRSTARTS(STR(?type), \"https://brickschema.org/schema/Brick#\"))\n}\n\"\"\"\nfor row in g.query(query):\n    print(f\"  - {row.equip.split('#')[-1]}: {row.type.split('#')[-1]}\")\n</code></pre>"},{"location":"getting-started/quick-start/#step-5-validate-the-model-optional","title":"Step 5: Validate the Model (Optional)","text":"<p>Ensure your model is correct:</p> <pre><code>from hhw_brick import BrickModelValidator\n\nvalidator = BrickModelValidator()\nis_valid, report = validator.validate_model(\"building_105.ttl\")\n\nif is_valid:\n    print(\"\u2713 Model is valid!\")\nelse:\n    print(\"\u26a0 Validation warnings:\")\n    for warning in report.get('warnings', []):\n        print(f\"  - {warning}\")\n</code></pre>"},{"location":"getting-started/quick-start/#what-just-happened","title":"What Just Happened?","text":"<p>Let's break down what the converter did:</p> <pre><code>graph LR\n    A[CSV Files] --&gt;|Read| B[Converter]\n    B --&gt;|Parse| C[Equipment Data]\n    C --&gt;|Map| D[Brick Classes]\n    D --&gt;|Generate| E[RDF Triples]\n    E --&gt;|Write| F[TTL File]\n\n    style A fill:#e1f5ff\n    style F fill:#c8e6c9</code></pre> <ol> <li>Read CSV files - Loaded metadata and sensor data</li> <li>Identified system type - \"Non-condensing\" system</li> <li>Created Brick entities - Equipment, points, relationships</li> <li>Generated RDF - Standard semantic format</li> <li>Saved TTL file - Turtle format output</li> </ol>"},{"location":"getting-started/quick-start/#next-steps","title":"Next Steps","text":"<p>Now that you've converted your first building:</p>"},{"location":"getting-started/quick-start/#learn-more-about-conversion","title":"Learn More About Conversion","text":"<ul> <li>Single Building Conversion - Detailed guide</li> <li>Batch Conversion - Convert multiple buildings</li> <li>System Types - Supported HVAC systems</li> </ul>"},{"location":"getting-started/quick-start/#explore-other-features","title":"Explore Other Features","text":"<ul> <li>Model Validation - Ensure quality</li> <li>Analytics Applications - Run analysis</li> <li>Examples - More code samples</li> </ul>"},{"location":"getting-started/quick-start/#understand-the-data","title":"Understand the Data","text":"<ul> <li>Understanding Brick - What is Brick ontology?</li> <li>CSV Format - Data file requirements</li> </ul>"},{"location":"getting-started/quick-start/#common-next-tasks","title":"Common Next Tasks","text":""},{"location":"getting-started/quick-start/#convert-multiple-buildings","title":"Convert Multiple Buildings","text":"<pre><code>from hhw_brick import BatchConverter\n\nbatch = BatchConverter()\nresults = batch.convert_all_buildings(\n    metadata_csv=\"metadata.csv\",\n    vars_csv=\"vars_available_by_building.csv\",\n    output_dir=\"brick_models/\",\n    show_progress=True\n)\n\nprint(f\"Converted {results['successful']} buildings\")\n</code></pre>"},{"location":"getting-started/quick-start/#filter-by-system-type","title":"Filter by System Type","text":"<pre><code># Convert only condensing systems\nresult = converter.convert_to_brick(\n    metadata_csv=\"metadata.csv\",\n    vars_csv=\"vars_available_by_building.csv\",\n    system_type=\"Condensing\",  # Filter\n    output_path=\"condensing_buildings.ttl\"\n)\n</code></pre>"},{"location":"getting-started/quick-start/#run-an-analytics-application","title":"Run an Analytics Application","text":"<pre><code>from hhw_brick import apps\n\n# Load temperature difference analysis app\napp = apps.load_app(\"secondary_loop_temp_diff\")\n\n# Check if building qualifies\nqualified, details = app.qualify(\"building_105.ttl\")\n\nif qualified:\n    # Run analysis (need timeseries data)\n    results = app.analyze(model, timeseries_data, config)\n</code></pre>"},{"location":"getting-started/quick-start/#troubleshooting","title":"Troubleshooting","text":""},{"location":"getting-started/quick-start/#error-filenotfounderror","title":"Error: \"FileNotFoundError\"","text":"<p>Make sure your CSV files exist:</p> <pre><code>import os\nprint(os.path.exists(\"metadata.csv\"))  # Should be True\n</code></pre>"},{"location":"getting-started/quick-start/#error-no-data-found-for-building-tag","title":"Error: \"No data found for building tag\"","text":"<p>Check that the building ID exists in your CSV:</p> <pre><code>import pandas as pd\ndf = pd.read_csv(\"metadata.csv\")\nprint(df['tag'].unique())  # List all building IDs\n</code></pre>"},{"location":"getting-started/quick-start/#warning-could-not-convert-value-to-float","title":"Warning: \"Could not convert value to float\"","text":"<p>Some sensor values might be missing (NA). This is normal and the converter handles it automatically.</p>"},{"location":"getting-started/quick-start/#complete-example-script","title":"Complete Example Script","text":"<p>Here's a complete script you can copy and run:</p> <pre><code>\"\"\"\nComplete Quick Start Example\nThis script demonstrates the basic workflow.\n\"\"\"\n\nfrom hhw_brick import CSVToBrickConverter, BrickModelValidator\nfrom pathlib import Path\n\ndef main():\n    print(\"HHW Brick Application - Quick Start\")\n    print(\"=\" * 50)\n\n    # Step 1: Set up paths\n    metadata_csv = \"metadata.csv\"\n    vars_csv = \"vars_available_by_building.csv\"\n    output_file = \"building_105.ttl\"\n\n    # Step 2: Convert\n    print(\"\\n1. Converting building #105...\")\n    converter = CSVToBrickConverter()\n    result = converter.convert_to_brick(\n        metadata_csv=metadata_csv,\n        vars_csv=vars_csv,\n        building_tag=\"105\",\n        output_path=output_file\n    )\n    print(f\"   \u2713 Created {len(result)} RDF triples\")\n\n    # Step 3: Validate\n    print(\"\\n2. Validating model...\")\n    validator = BrickModelValidator()\n    is_valid, report = validator.validate_model(output_file)\n\n    if is_valid:\n        print(\"   \u2713 Model is valid!\")\n    else:\n        print(\"   \u26a0 Validation warnings (this is normal):\")\n        for w in report.get('warnings', [])[:3]:  # Show first 3\n            print(f\"     - {w}\")\n\n    # Step 4: Summary\n    print(\"\\n3. Summary:\")\n    print(f\"   - Input: {metadata_csv}, {vars_csv}\")\n    print(f\"   - Output: {output_file}\")\n    print(f\"   - Size: {Path(output_file).stat().st_size / 1024:.1f} KB\")\n\n    print(\"\\n\u2713 Quick start complete!\")\n    print(\"\\nNext steps:\")\n    print(\"  - View the TTL file in a text editor\")\n    print(\"  - Try batch conversion\")\n    print(\"  - Explore the User Guide\")\n\nif __name__ == \"__main__\":\n    main()\n</code></pre> <p>Congratulations! \ud83c\udf89 You've completed the quick start.</p> <p>Continue to Understanding Brick or jump to User Guide \u2192</p>"},{"location":"getting-started/understanding-brick/","title":"Understanding Brick","text":"<p>Learn about Brick ontology and why it matters for building data.</p>"},{"location":"getting-started/understanding-brick/#what-is-brick","title":"What is Brick?","text":"<p>Brick is a standardized semantic vocabulary for describing buildings and their systems. Think of it as a common language that allows different building management systems, analytics tools, and applications to understand each other.</p>"},{"location":"getting-started/understanding-brick/#the-problem-brick-solves","title":"The Problem Brick Solves","text":"<p>Building systems use different naming conventions:</p> <pre><code>Building A: \"AHU_01_Supply_Temp\"\nBuilding B: \"SupplyAirTemp_AHU1\"\nBuilding C: \"SAT-AHU-001\"\n</code></pre> <p>All three mean the same thing, but software can't automatically understand that!</p>"},{"location":"getting-started/understanding-brick/#bricks-solution","title":"Brick's Solution","text":"<p>Brick provides standardized classes:</p> <pre><code># In Brick, they're all:\n:AHU_01 a brick:AHU ;\n    brick:hasPoint :Supply_Temp .\n\n:Supply_Temp a brick:Supply_Air_Temperature_Sensor .\n</code></pre> <p>Now software can automatically understand the data!</p>"},{"location":"getting-started/understanding-brick/#why-use-brick","title":"Why Use Brick?","text":""},{"location":"getting-started/understanding-brick/#1-interoperability","title":"1. Interoperability","text":"<p>Share data between different systems:</p> <pre><code>graph LR\n    A[Building A&lt;br/&gt;Brick Model] --&gt;|Standard Format| C[Analytics Tool]\n    B[Building B&lt;br/&gt;Brick Model] --&gt;|Standard Format| C\n    C --&gt;|Insights| D[Results]\n\n    style A fill:#e1f5ff\n    style B fill:#e1f5ff\n    style C fill:#fff9c4\n    style D fill:#c8e6c9</code></pre>"},{"location":"getting-started/understanding-brick/#2-portability","title":"2. Portability","text":"<p>Move analytics between buildings:</p> <pre><code># Same code works on any Brick model!\ndef analyze_hvac_efficiency(brick_model):\n    # Query for AHUs and their points\n    query = \"\"\"\n    SELECT ?ahu ?temp WHERE {\n        ?ahu a brick:AHU .\n        ?ahu brick:hasPoint ?temp .\n        ?temp a brick:Supply_Air_Temperature_Sensor .\n    }\n    \"\"\"\n    # Analysis logic...\n</code></pre>"},{"location":"getting-started/understanding-brick/#3-automatic-discovery","title":"3. Automatic Discovery","text":"<p>Find equipment and points programmatically:</p> <pre><code># Find all temperature sensors\nsensors = model.query(\"\"\"\n    SELECT ?sensor WHERE {\n        ?sensor a brick:Temperature_Sensor .\n    }\n\"\"\")\n</code></pre>"},{"location":"getting-started/understanding-brick/#brick-schema-components","title":"Brick Schema Components","text":"<p>Brick has three main types of entities:</p>"},{"location":"getting-started/understanding-brick/#equipment","title":"Equipment","text":"<p>Physical devices in buildings:</p> <pre><code>:Boiler_01 a brick:Boiler .\n:HX_01 a brick:Heat_Exchanger .\n:Pump_Primary_01 a brick:Water_Pump .\n</code></pre> <p>Common equipment classes: - <code>brick:Boiler</code> - <code>brick:Heat_Exchanger</code> - <code>brick:Pump</code> - <code>brick:Valve</code></p>"},{"location":"getting-started/understanding-brick/#points","title":"Points","text":"<p>Sensors, actuators, setpoints:</p> <pre><code>:HW_Supply_Temp a brick:Hot_Water_Supply_Temperature_Sensor .\n:HW_Return_Temp a brick:Hot_Water_Return_Temperature_Sensor .\n:HW_Flow a brick:Water_Flow_Sensor .\n</code></pre> <p>Common point classes: - <code>brick:Temperature_Sensor</code> - <code>brick:Flow_Sensor</code> - <code>brick:Valve_Command</code> - <code>brick:Temperature_Setpoint</code></p>"},{"location":"getting-started/understanding-brick/#relationships","title":"Relationships","text":"<p>How things connect:</p> <pre><code>:Boiler_01 brick:hasPoint :HW_Supply_Temp .\n:Boiler_01 brick:feeds :HX_01 .\n:HX_01 brick:hasPoint :Secondary_Supply_Temp .\n</code></pre> <p>Common relationships: - <code>brick:hasPoint</code> - Equipment has a point - <code>brick:feeds</code> - Flow direction - <code>brick:isPartOf</code> - Component hierarchy</p>"},{"location":"getting-started/understanding-brick/#brick-in-hhws-application","title":"Brick in HHWS Application","text":""},{"location":"getting-started/understanding-brick/#what-we-convert","title":"What We Convert","text":"<p>The HHW Brick Application converts:</p> <pre><code>CSV Data              \u2192    Brick Model\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500     \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nBuilding metadata     \u2192    Building entity\nSystem type           \u2192    Equipment types\nSensor availability   \u2192    Point entities  \n                           Relationships\n</code></pre>"},{"location":"getting-started/understanding-brick/#example-conversion","title":"Example Conversion","text":"<p>Input CSV:</p> tag system org hw_supply_temp hw_return_temp 105 Non-condensing Org A 1 1 <p>Output Brick:</p> <pre><code>:Building_105 a rec:Building ;\n    brick:hasLocation :Building_105_location .\n\n:Boiler_Primary a brick:Boiler ;\n    brick:hasPoint :HW_Supply_Temp_Sensor,\n                   :HW_Return_Temp_Sensor .\n\n:HW_Supply_Temp_Sensor a brick:Hot_Water_Supply_Temperature_Sensor .\n:HW_Return_Temp_Sensor a brick:Hot_Water_Return_Temperature_Sensor .\n</code></pre>"},{"location":"getting-started/understanding-brick/#system-type-mapping","title":"System Type Mapping","text":"<p>HHWS Application supports these system types:</p>"},{"location":"getting-started/understanding-brick/#non-condensing-systems","title":"Non-condensing Systems","text":"<pre><code>graph LR\n    B[Boiler] --&gt;|feeds| HX[Heat Exchanger]\n    HX --&gt;|feeds| SL[Secondary Loop]\n\n    style B fill:#ff9800\n    style HX fill:#2196f3\n    style SL fill:#4caf50</code></pre> <p>Equipment created: - Primary boiler - Heat exchanger - Primary/secondary pumps</p>"},{"location":"getting-started/understanding-brick/#condensing-systems","title":"Condensing Systems","text":"<p>Similar to non-condensing but with: - Condensing boiler type - Different control strategies</p>"},{"location":"getting-started/understanding-brick/#district-hwsteam","title":"District HW/Steam","text":"<pre><code>graph LR\n    DS[District Supply] --&gt;|feeds| HX[Heat Exchanger]\n    HX --&gt;|feeds| BL[Building Loop]\n\n    style DS fill:#9c27b0\n    style HX fill:#2196f3\n    style BL fill:#4caf50</code></pre> <p>Equipment created: - District connection - Heat exchanger - Building-side equipment</p>"},{"location":"getting-started/understanding-brick/#querying-brick-models","title":"Querying Brick Models","text":"<p>Once you have a Brick model, you can query it:</p>"},{"location":"getting-started/understanding-brick/#find-all-equipment","title":"Find All Equipment","text":"<pre><code>from rdflib import Graph\n\ng = Graph()\ng.parse(\"building_105.ttl\")\n\nquery = \"\"\"\nPREFIX brick: &lt;https://brickschema.org/schema/Brick#&gt;\n\nSELECT ?equipment ?type WHERE {\n    ?equipment a ?type .\n    FILTER(STRSTARTS(STR(?type), STR(brick:)))\n}\n\"\"\"\n\nfor row in g.query(query):\n    print(f\"{row.equipment}: {row.type}\")\n</code></pre>"},{"location":"getting-started/understanding-brick/#find-temperature-sensors","title":"Find Temperature Sensors","text":"<pre><code>query = \"\"\"\nPREFIX brick: &lt;https://brickschema.org/schema/Brick#&gt;\n\nSELECT ?sensor WHERE {\n    ?sensor a brick:Temperature_Sensor .\n}\n\"\"\"\n</code></pre>"},{"location":"getting-started/understanding-brick/#find-equipment-relationships","title":"Find Equipment Relationships","text":"<pre><code>query = \"\"\"\nPREFIX brick: &lt;https://brickschema.org/schema/Brick#&gt;\n\nSELECT ?equip1 ?rel ?equip2 WHERE {\n    ?equip1 ?rel ?equip2 .\n    FILTER(?rel = brick:feeds || ?rel = brick:hasPoint)\n}\n\"\"\"\n</code></pre>"},{"location":"getting-started/understanding-brick/#brick-versions","title":"Brick Versions","text":""},{"location":"getting-started/understanding-brick/#brick-13-current","title":"Brick 1.3 (Current)","text":"<p>HHWS Application uses Brick 1.3, which includes:</p> <ul> <li>Comprehensive HVAC classes</li> <li>Better relationship definitions</li> <li>Hot water system support</li> </ul> <p>Import statement in generated models:</p> <pre><code>@prefix brick: &lt;https://brickschema.org/schema/Brick#&gt; .\n\n&lt;ontology_uri&gt; a owl:Ontology ;\n    owl:imports &lt;https://brickschema.org/schema/1.3/Brick&gt; .\n</code></pre>"},{"location":"getting-started/understanding-brick/#advantages-for-hvac-analysis","title":"Advantages for HVAC Analysis","text":""},{"location":"getting-started/understanding-brick/#1-standard-queries","title":"1. Standard Queries","text":"<p>Write once, run anywhere:</p> <pre><code># Works on ANY Brick model\ndef get_loop_temperature_diff(model):\n    query = \"\"\"\n    SELECT ?supply ?return WHERE {\n        ?supply a brick:Hot_Water_Supply_Temperature_Sensor .\n        ?return a brick:Hot_Water_Return_Temperature_Sensor .\n    }\n    \"\"\"\n    return model.query(query)\n</code></pre>"},{"location":"getting-started/understanding-brick/#2-automatic-validation","title":"2. Automatic Validation","text":"<p>Check if building has required sensors:</p> <pre><code>def check_for_analysis(model):\n    required = [\n        \"brick:Hot_Water_Supply_Temperature_Sensor\",\n        \"brick:Hot_Water_Return_Temperature_Sensor\",\n        \"brick:Water_Flow_Sensor\"\n    ]\n\n    for sensor_type in required:\n        if not has_sensor(model, sensor_type):\n            return False, f\"Missing {sensor_type}\"\n    return True, \"Qualified\"\n</code></pre>"},{"location":"getting-started/understanding-brick/#3-relationship-traversal","title":"3. Relationship Traversal","text":"<p>Follow system connections:</p> <pre><code># Find all equipment fed by the boiler\nquery = \"\"\"\nSELECT ?equipment WHERE {\n    :Boiler_01 brick:feeds+ ?equipment .\n}\n\"\"\"\n</code></pre> <p>The <code>+</code> means \"one or more steps\" - it follows the chain!</p>"},{"location":"getting-started/understanding-brick/#learn-more","title":"Learn More","text":""},{"location":"getting-started/understanding-brick/#official-resources","title":"Official Resources","text":"<ul> <li>Brick Schema Website - Official site</li> <li>Brick Schema Viewer - Browse classes</li> <li>Brick GitHub - Source code</li> </ul>"},{"location":"getting-started/understanding-brick/#in-this-documentation","title":"In This Documentation","text":"<ul> <li>CSV Format - Data requirements</li> <li>System Types - Supported systems</li> <li>Examples - Working code</li> </ul>"},{"location":"getting-started/understanding-brick/#tools","title":"Tools","text":"<ul> <li>brickschema - Python library</li> <li>Brick Studio - Visual editor</li> <li>RDFLib - RDF processing</li> </ul>"},{"location":"getting-started/understanding-brick/#key-takeaways","title":"Key Takeaways","text":"<p>Remember</p> <ul> <li>Brick provides standard vocabulary for buildings</li> <li>Enables interoperability between systems</li> <li>Makes portable analytics possible</li> <li>Based on semantic web standards (RDF/OWL)</li> </ul> <p>For HHWS Users</p> <ul> <li>HHWS Application automatically creates Brick models</li> <li>You don't need to know RDF/OWL to use it</li> <li>Focus on your CSV data, we handle Brick complexity</li> </ul> <p>Next: Learn about CSV format requirements \u2192</p>"},{"location":"tutorials/","title":"Tutorials","text":"<p>Step-by-step tutorials to master HHW Brick Application.</p>"},{"location":"tutorials/#overview","title":"Overview","text":"<p>These tutorials provide in-depth, hands-on learning experiences. Each tutorial builds on previous knowledge and includes:</p> <ul> <li>Clear learning objectives</li> <li>Step-by-step instructions</li> <li>Complete code examples</li> <li>Exercises and challenges</li> <li>Summary and next steps</li> </ul>"},{"location":"tutorials/#available-tutorials","title":"Available Tutorials","text":""},{"location":"tutorials/#building-your-first-application","title":"Building Your First Application","text":"<p>Duration: 30-45 minutes Level: Beginner</p> <p>Learn how to create a custom analytics application from scratch.</p> <p>What you'll learn: - Application structure and requirements - Implementing qualify and analyze functions - Testing your application - Deploying to the package</p> <p>Start tutorial \u2192</p>"},{"location":"tutorials/#data-pipeline-workflow","title":"Data Pipeline Workflow","text":"<p>Duration: 45-60 minutes Level: Intermediate</p> <p>Build a complete data processing pipeline.</p> <p>What you'll learn: - Batch CSV conversion - Automated validation - Application qualification - Batch analytics execution - Results aggregation</p> <p>Start tutorial \u2192</p>"},{"location":"tutorials/#performance-optimization","title":"Performance Optimization","text":"<p>Duration: 30-45 minutes Level: Advanced</p> <p>Optimize your workflows for production use.</p> <p>What you'll learn: - Profiling bottlenecks - Parallel processing - Memory management - Caching strategies - Best practices</p> <p>Start tutorial \u2192</p>"},{"location":"tutorials/#tutorial-path","title":"Tutorial Path","text":"<pre><code>graph LR\n    A[First App] --&gt;|Build on| B[Data Pipeline]\n    B --&gt;|Optimize| C[Performance]\n\n    style A fill:#c8e6c9\n    style B fill:#fff9c4\n    style C fill:#f8bbd0</code></pre> <p>We recommend following the tutorials in order for the best learning experience.</p>"},{"location":"tutorials/#prerequisites","title":"Prerequisites","text":"<p>Before starting the tutorials, make sure you have:</p> <ul> <li> Installed HHW Brick Application</li> <li> Basic Python knowledge</li> <li> Completed the Quick Start Guide</li> <li> Familiarity with Core Concepts</li> </ul>"},{"location":"tutorials/#learning-resources","title":"Learning Resources","text":""},{"location":"tutorials/#complementary-materials","title":"Complementary Materials","text":"<ul> <li>Examples - Quick code snippets</li> <li>User Guide - Feature documentation</li> <li>Developer Guide - Advanced topics</li> <li>API Reference - Detailed API docs</li> </ul>"},{"location":"tutorials/#external-resources","title":"External Resources","text":"<ul> <li>Brick Schema Documentation</li> <li>RDFLib Tutorial</li> <li>Python Packaging Guide</li> </ul>"},{"location":"tutorials/#getting-help","title":"Getting Help","text":"<p>If you get stuck during a tutorial:</p> <ol> <li>Check the code - All tutorials include complete working examples</li> <li>Review the FAQ - Common issues are documented in the FAQ</li> <li>Search issues - Look for similar problems on GitHub</li> <li>Ask for help - Open a discussion</li> </ol>"},{"location":"tutorials/#contributing-tutorials","title":"Contributing Tutorials","text":"<p>Have an idea for a tutorial? We'd love to hear from you!</p> <p>See the Contributing Guide to learn how to contribute tutorials.</p> <p>Ready to learn? Start with Building Your First Application \u2192</p>"},{"location":"tutorials/#examples","title":"Examples","text":"<p>Practical examples to help you get started with HHW Brick Application.</p>"},{"location":"tutorials/#overview_1","title":"Overview","text":"<p>This section contains code examples ranging from basic to advanced usage. Each example includes:</p> <ul> <li>Complete working code</li> <li>Explanation of key concepts</li> <li>Expected output</li> <li>Common variations</li> </ul>"},{"location":"tutorials/#quick-examples","title":"Quick Examples","text":""},{"location":"tutorials/#simple-csv-conversion","title":"Simple CSV Conversion","text":"<pre><code>from hhw_brick import CSVToBrickConverter\n\nconverter = CSVToBrickConverter()\nresult = converter.convert_csv_to_brick(\n    input_file=\"building_105.csv\",\n    output_file=\"building_105.ttl\"\n)\n</code></pre>"},{"location":"tutorials/#validate-a-model","title":"Validate a Model","text":"<pre><code>from hhw_brick import BrickModelValidator\n\nvalidator = BrickModelValidator()\nis_valid, report = validator.validate_model(\"building_105.ttl\")\nprint(f\"Valid: {is_valid}\")\n</code></pre>"},{"location":"tutorials/#run-an-application","title":"Run an Application","text":"<pre><code>from hhw_brick import apps\n\napp = apps.load_app(\"secondary_loop_temp_diff\")\nqualified, details = app.qualify(brick_model)\nif qualified:\n    results = app.analyze(brick_model, timeseries_data, config)\n</code></pre>"},{"location":"tutorials/#example-categories","title":"Example Categories","text":""},{"location":"tutorials/#basic-examples","title":"Basic Examples","text":"<p>Simple examples for beginners:</p> <ul> <li>CSV to Brick Conversion</li> <li>Model Validation</li> <li>Running Applications</li> </ul>"},{"location":"tutorials/#advanced-examples","title":"Advanced Examples","text":"<p>Complex workflows for advanced users:</p> <ul> <li>Batch Processing</li> <li>Custom Applications</li> <li>System Integration</li> </ul>"},{"location":"tutorials/#example-data","title":"Example Data","text":"<p>All examples use sample data available in the <code>Example_Input_Data/</code> directory:</p> <pre><code>Example_Input_Data/\n\u251c\u2500\u2500 building_105.csv\n\u251c\u2500\u2500 building_127.csv\n\u251c\u2500\u2500 building_304.csv\n\u2514\u2500\u2500 timeseries/\n    \u251c\u2500\u2500 building_105_data.csv\n    \u2514\u2500\u2500 building_127_data.csv\n</code></pre>"},{"location":"tutorials/#running-examples","title":"Running Examples","text":""},{"location":"tutorials/#option-1-python-script","title":"Option 1: Python Script","text":"<p>Save the example code to a <code>.py</code> file and run:</p> <pre><code>python my_example.py\n</code></pre>"},{"location":"tutorials/#option-2-interactive-python","title":"Option 2: Interactive Python","text":"<p>Run in Python interactive mode:</p> <pre><code>python\n&gt;&gt;&gt; from hhw_brick import CSVToBrickConverter\n&gt;&gt;&gt; # ... rest of code\n</code></pre>"},{"location":"tutorials/#option-3-jupyter-notebook","title":"Option 3: Jupyter Notebook","text":"<p>Use examples in Jupyter notebooks for interactive exploration.</p>"},{"location":"tutorials/#common-patterns","title":"Common Patterns","text":""},{"location":"tutorials/#pattern-1-complete-workflow","title":"Pattern 1: Complete Workflow","text":"<pre><code>from hhw_brick import (\n    CSVToBrickConverter,\n    BrickModelValidator,\n    apps\n)\n\n# Convert\nconverter = CSVToBrickConverter()\nconverter.convert_csv_to_brick(\"input.csv\", \"model.ttl\")\n\n# Validate\nvalidator = BrickModelValidator()\nis_valid, report = validator.validate_model(\"model.ttl\")\n\nif is_valid:\n    # Run app\n    app = apps.load_app(\"secondary_loop_temp_diff\")\n    results = app.analyze(model, data, config)\n    print(\"Analysis complete!\")\n</code></pre>"},{"location":"tutorials/#pattern-2-batch-processing","title":"Pattern 2: Batch Processing","text":"<pre><code>from hhw_brick import BatchConverter\n\nconverter = BatchConverter()\nresults = converter.convert_batch(\n    input_dir=\"csv_files/\",\n    output_dir=\"brick_models/\"\n)\n</code></pre>"},{"location":"tutorials/#pattern-3-error-handling","title":"Pattern 3: Error Handling","text":"<pre><code>try:\n    converter.convert_csv_to_brick(\"input.csv\", \"output.ttl\")\nexcept FileNotFoundError:\n    print(\"Input file not found!\")\nexcept Exception as e:\n    print(f\"Conversion failed: {e}\")\n</code></pre>"},{"location":"tutorials/#next-steps","title":"Next Steps","text":"<ul> <li>Browse Basic Examples to get started</li> <li>Explore Advanced Examples for complex workflows</li> <li>Check Tutorials for step-by-step guides</li> <li>Read User Guide for detailed documentation</li> </ul> <p>Ready to try? Start with CSV Conversion \u2192</p>"},{"location":"tutorials/01_hello_world_app/","title":"Tutorial 1: Hello World App","text":"<p>Duration: 15 minutes Difficulty: Beginner Goal: Create your first Brick analytics app</p>"},{"location":"tutorials/01_hello_world_app/#what-youll-build","title":"What You'll Build","text":"<p>A simple app that: - Counts buildings in a Brick model - Lists all building names - Exports results to JSON</p>"},{"location":"tutorials/01_hello_world_app/#prerequisites","title":"Prerequisites","text":"<ul> <li>HHW Brick Application installed</li> <li>A Brick model file (e.g., <code>building_105.ttl</code>)</li> <li>Basic Python knowledge</li> </ul>"},{"location":"tutorials/01_hello_world_app/#step-1-create-app-file","title":"Step 1: Create App File","text":"<p>Create a new file called <code>hello_world_app.py</code>:</p> <pre><code>\"\"\"\nHello World App - Tutorial 1\nA simple app that counts and lists buildings.\n\"\"\"\n\nfrom hhw_brick.analytics.core.base_app import BaseApp, register_app\nfrom rdflib import Namespace\n\n# Register your app\n@register_app(\n    name=\"hello_world\",\n    description=\"Counts and lists all buildings in the model\",\n    version=\"1.0.0\"\n)\nclass HelloWorldApp(BaseApp):\n    \"\"\"My first Brick analytics app!\"\"\"\n\n    def analyze(self, graph, building_name=None, **kwargs):\n        \"\"\"\n        Count and list all buildings.\n\n        Args:\n            graph: The Brick model (rdflib.Graph)\n            building_name: Optional filter (not used in this example)\n\n        Returns:\n            dict: Contains building count and list\n        \"\"\"\n        # Step 1: Define SPARQL query\n        query = \"\"\"\n        PREFIX brick: &lt;https://brickschema.org/schema/Brick#&gt;\n        PREFIX rdfs: &lt;http://www.w3.org/2000/01/rdf-schema#&gt;\n\n        SELECT ?building ?label\n        WHERE {\n            ?building a brick:Building .\n            OPTIONAL { ?building rdfs:label ?label }\n        }\n        \"\"\"\n\n        # Step 2: Execute query\n        results = graph.query(query)\n\n        # Step 3: Process results\n        buildings = []\n        for row in results:\n            building_uri = str(row.building)\n            building_label = str(row.label) if row.label else building_uri\n\n            buildings.append({\n                'uri': building_uri,\n                'name': building_label\n            })\n\n        # Step 4: Return structured results\n        return {\n            'building_count': len(buildings),\n            'buildings': buildings,\n            'summary': f\"Found {len(buildings)} building(s) in the model\"\n        }\n</code></pre>"},{"location":"tutorials/01_hello_world_app/#step-2-test-your-app","title":"Step 2: Test Your App","text":""},{"location":"tutorials/01_hello_world_app/#option-a-run-via-cli","title":"Option A: Run via CLI","text":"<pre><code># List all apps (should show your new app)\nhhw-brick apps list\n\n# Run your app\nhhw-brick apps run hello_world building_105.ttl\n\n# Run with JSON output\nhhw-brick apps run hello_world building_105.ttl -o results.json\n</code></pre>"},{"location":"tutorials/01_hello_world_app/#option-b-run-in-python","title":"Option B: Run in Python","text":"<p>Create a test script <code>test_hello_world.py</code>:</p> <pre><code>from hello_world_app import HelloWorldApp\nfrom rdflib import Graph\n\n# Load Brick model\nprint(\"Loading Brick model...\")\ngraph = Graph()\ngraph.parse(\"building_105.ttl\", format=\"turtle\")\nprint(f\"Loaded {len(graph)} triples\")\n\n# Create and run app\nprint(\"\\nRunning Hello World app...\")\napp = HelloWorldApp()\nresults = app.analyze(graph)\n\n# Display results\nprint(f\"\\n{results['summary']}\")\nprint(f\"\\nBuildings:\")\nfor building in results['buildings']:\n    print(f\"  - {building['name']}\")\n</code></pre> <p>Run it:</p> <pre><code>python test_hello_world.py\n</code></pre>"},{"location":"tutorials/01_hello_world_app/#expected-output","title":"Expected Output","text":"<pre><code>Loading Brick model...\nLoaded 1,234 triples\n\nRunning Hello World app...\n\nFound 1 building(s) in the model\n\nBuildings:\n  - building105\n</code></pre>"},{"location":"tutorials/01_hello_world_app/#step-3-understand-the-code","title":"Step 3: Understand the Code","text":""},{"location":"tutorials/01_hello_world_app/#the-register_app-decorator","title":"The @register_app Decorator","text":"<pre><code>@register_app(\n    name=\"hello_world\",           # CLI command name\n    description=\"...\",             # Shows in help\n    version=\"1.0.0\"               # Your app version\n)\n</code></pre> <p>This makes your app discoverable by the framework.</p>"},{"location":"tutorials/01_hello_world_app/#the-analyze-method","title":"The analyze() Method","text":"<p>This is the core method that does the work:</p> <pre><code>def analyze(self, graph, building_name=None, **kwargs):\n    # Your analysis code here\n    return {...}  # Must return a dict\n</code></pre> <p>Parameters: - <code>graph</code>: The loaded Brick model (rdflib.Graph object) - <code>building_name</code>: Optional building filter - <code>**kwargs</code>: Additional parameters</p> <p>Returns: - Must return a dictionary - Can contain any structure - Will be converted to JSON/CSV automatically</p>"},{"location":"tutorials/01_hello_world_app/#the-sparql-query","title":"The SPARQL Query","text":"<pre><code>query = \"\"\"\nPREFIX brick: &lt;https://brickschema.org/schema/Brick#&gt;\n\nSELECT ?building ?label\nWHERE {\n    ?building a brick:Building .\n    OPTIONAL { ?building rdfs:label ?label }\n}\n\"\"\"\n</code></pre> <p>Breakdown: - <code>PREFIX</code>: Define namespaces - <code>SELECT</code>: Variables to return - <code>WHERE</code>: Pattern to match - <code>OPTIONAL</code>: Make label optional (building might not have one)</p>"},{"location":"tutorials/01_hello_world_app/#step-4-enhance-your-app","title":"Step 4: Enhance Your App","text":""},{"location":"tutorials/01_hello_world_app/#add-error-handling","title":"Add Error Handling","text":"<pre><code>def analyze(self, graph, building_name=None, **kwargs):\n    try:\n        query = \"...\"\n        results = graph.query(query)\n        # ... process results\n        return {...}\n    except Exception as e:\n        return {\n            'error': str(e),\n            'success': False\n        }\n</code></pre>"},{"location":"tutorials/01_hello_world_app/#add-filtering","title":"Add Filtering","text":"<pre><code>def analyze(self, graph, building_name=None, **kwargs):\n    # Filter by building name if provided\n    if building_name:\n        query = f\"\"\"\n        PREFIX brick: &lt;https://brickschema.org/schema/Brick#&gt;\n        PREFIX hhws: &lt;https://example.org/hhws#&gt;\n\n        SELECT ?building\n        WHERE {{\n            ?building a brick:Building .\n            FILTER(CONTAINS(STR(?building), \"{building_name}\"))\n        }}\n        \"\"\"\n    else:\n        query = \"...\"  # Original query\n</code></pre>"},{"location":"tutorials/01_hello_world_app/#add-logging","title":"Add Logging","text":"<pre><code>def analyze(self, graph, building_name=None, **kwargs):\n    print(f\"Analyzing {len(graph)} triples...\")\n\n    query = \"...\"\n    results = graph.query(query)\n\n    print(f\"Found {len(list(results))} buildings\")\n\n    return {...}\n</code></pre>"},{"location":"tutorials/01_hello_world_app/#step-5-export-results","title":"Step 5: Export Results","text":""},{"location":"tutorials/01_hello_world_app/#to-json","title":"To JSON","text":"<pre><code>hhw-brick apps run hello_world building_105.ttl -o results.json\n</code></pre> <p>Creates <code>results.json</code>:</p> <pre><code>{\n  \"building_count\": 1,\n  \"buildings\": [\n    {\n      \"uri\": \"https://example.org/hhws#building105\",\n      \"name\": \"building105\"\n    }\n  ],\n  \"summary\": \"Found 1 building(s) in the model\"\n}\n</code></pre>"},{"location":"tutorials/01_hello_world_app/#to-csv-with-pandas","title":"To CSV (with pandas)","text":"<p>Modify your app to return a DataFrame:</p> <pre><code>import pandas as pd\n\ndef analyze(self, graph, **kwargs):\n    # ... query and process ...\n\n    # Create DataFrame\n    df = pd.DataFrame(buildings)\n\n    return {\n        'dataframe': df,  # Auto-converts to CSV\n        'summary': {...}\n    }\n</code></pre>"},{"location":"tutorials/01_hello_world_app/#common-issues","title":"Common Issues","text":""},{"location":"tutorials/01_hello_world_app/#issue-1-no-results","title":"Issue 1: No Results","text":"<p>Problem: Query returns empty results</p> <p>Solution: Check that the Brick model actually contains buildings:</p> <pre><code># Debug: print all classes\nfor s, p, o in graph.triples((None, RDF.type, None)):\n    print(f\"{s} is a {o}\")\n</code></pre>"},{"location":"tutorials/01_hello_world_app/#issue-2-import-error","title":"Issue 2: Import Error","text":"<p>Problem: Cannot import BaseApp</p> <p>Solution: <pre><code>pip install -e .\n</code></pre></p>"},{"location":"tutorials/01_hello_world_app/#issue-3-app-not-listed","title":"Issue 3: App Not Listed","text":"<p>Problem: <code>hhw-brick apps list</code> doesn't show your app</p> <p>Solution: Ensure @register_app decorator is used and file is in correct location.</p>"},{"location":"tutorials/01_hello_world_app/#congratulations","title":"\ud83c\udf89 Congratulations!","text":"<p>You've created your first Brick analytics app!</p>"},{"location":"tutorials/01_hello_world_app/#what-you-learned","title":"What You Learned","text":"<p>\u2705 How to create an app class \u2705 How to use the @register_app decorator \u2705 How to write SPARQL queries \u2705 How to process and return results \u2705 How to run apps via CLI</p>"},{"location":"tutorials/01_hello_world_app/#next-steps","title":"Next Steps","text":"<ul> <li>Tutorial 2: Point Extraction App (extract all points from a building)</li> <li>Tutorial 3: Equipment Analysis App (analyze equipment relationships)</li> <li>Tutorial 4: Custom Analytics App (calculate performance metrics)</li> </ul>"},{"location":"tutorials/01_hello_world_app/#full-code","title":"Full Code","text":"<pre><code>\"\"\"Hello World App - Complete Code\"\"\"\n\nfrom hhw_brick.analytics.core.base_app import BaseApp, register_app\n\n@register_app(\n    name=\"hello_world\",\n    description=\"Counts and lists all buildings in the model\",\n    version=\"1.0.0\"\n)\nclass HelloWorldApp(BaseApp):\n    \"\"\"My first Brick analytics app!\"\"\"\n\n    def analyze(self, graph, building_name=None, **kwargs):\n        \"\"\"Count and list all buildings.\"\"\"\n\n        query = \"\"\"\n        PREFIX brick: &lt;https://brickschema.org/schema/Brick#&gt;\n        PREFIX rdfs: &lt;http://www.w3.org/2000/01/rdf-schema#&gt;\n\n        SELECT ?building ?label\n        WHERE {\n            ?building a brick:Building .\n            OPTIONAL { ?building rdfs:label ?label }\n        }\n        \"\"\"\n\n        results = graph.query(query)\n\n        buildings = []\n        for row in results:\n            buildings.append({\n                'uri': str(row.building),\n                'name': str(row.label) if row.label else str(row.building)\n            })\n\n        return {\n            'building_count': len(buildings),\n            'buildings': buildings,\n            'summary': f\"Found {len(buildings)} building(s) in the model\"\n        }\n</code></pre> <p>Happy coding! \ud83d\ude80</p>"},{"location":"user-guide/","title":"User Guide","text":"<p>Welcome to the HHW Brick Application User Guide! This comprehensive guide covers all features and functionalities of the package.</p>"},{"location":"user-guide/#overview","title":"Overview","text":"<p>The User Guide is organized into the following sections:</p>"},{"location":"user-guide/#csv-to-brick-conversion","title":"CSV to Brick Conversion","text":"<p>Learn how to convert your building equipment data from CSV format to Brick ontology models.</p> <ul> <li>Basic Usage - Simple conversion examples</li> <li>Batch Processing - Convert multiple files</li> <li>Configuration - Customize conversion settings</li> </ul>"},{"location":"user-guide/#model-validation","title":"Model Validation","text":"<p>Ensure your Brick models meet quality standards and specifications.</p> <ul> <li>Ontology Validation - Validate against Brick schema</li> <li>Subgraph Matching - Pattern-based validation</li> <li>Point Count Validation - Verify data completeness</li> </ul>"},{"location":"user-guide/#analytics-applications","title":"Analytics Applications","text":"<p>Use pre-built or custom analytics applications to analyze building systems.</p> <ul> <li>Available Apps - Browse built-in applications</li> <li>Running Applications - Execute analysis workflows</li> <li>Batch Analysis - Process multiple buildings</li> </ul>"},{"location":"user-guide/#command-line-interface","title":"Command Line Interface","text":"<p>Use the powerful CLI for quick operations and automation.</p> <ul> <li>Commands Reference - Complete command documentation</li> <li>Examples - Practical CLI usage examples</li> </ul>"},{"location":"user-guide/#common-workflows","title":"Common Workflows","text":""},{"location":"user-guide/#basic-workflow","title":"Basic Workflow","text":"<pre><code>graph LR\n    A[CSV Data] --&gt;|convert| B[Brick Model]\n    B --&gt;|validate| C[Validated Model]\n    C --&gt;|analyze| D[Results]\n\n    style A fill:#e1f5ff\n    style B fill:#fff9c4\n    style C fill:#c8e6c9\n    style D fill:#f8bbd0</code></pre> <ol> <li>Convert CSV data to Brick model</li> <li>Validate the generated model</li> <li>Analyze using applications</li> <li>Export results</li> </ol>"},{"location":"user-guide/#advanced-workflow","title":"Advanced Workflow","text":"<pre><code>graph TD\n    A[Multiple CSV Files] --&gt;|Batch Convert| B[Multiple Brick Models]\n    B --&gt;|Batch Validate| C[Valid Models]\n    C --&gt;|Qualify Buildings| D{Meet Criteria?}\n    D --&gt;|Yes| E[Run Analytics]\n    D --&gt;|No| F[Skip]\n    E --&gt;|Batch Process| G[Analysis Results]\n\n    style A fill:#e1f5ff\n    style C fill:#c8e6c9\n    style G fill:#f8bbd0</code></pre> <ol> <li>Batch convert multiple CSV files</li> <li>Batch validate all models</li> <li>Qualify buildings for analysis</li> <li>Run analytics on qualified buildings</li> <li>Aggregate results</li> </ol>"},{"location":"user-guide/#quick-navigation","title":"Quick Navigation","text":"<ul> <li> <p> Conversion</p> <p>Transform CSV to Brick models</p> </li> <li> <p> Validation</p> <p>Verify model quality</p> </li> <li> <p> Applications</p> <p>Analyze building systems</p> </li> <li> <p>:material-terminal: CLI</p> <p>Use command-line tools</p> </li> </ul>"},{"location":"user-guide/#need-more-help","title":"Need More Help?","text":"<ul> <li>New to Brick? Check out Core Concepts</li> <li>Looking for code examples? Browse Examples</li> <li>Want to build your own apps? See Developer Guide</li> <li>Have questions? Visit the FAQ</li> </ul> <p>Ready to start? Pick a topic above or continue to CSV to Brick Conversion \u2192</p>"},{"location":"user-guide/applications/","title":"Analytics Applications","text":"<p>Run analytics on validated Brick models to extract insights from building data.</p>"},{"location":"user-guide/applications/#overview","title":"Overview","text":"<p>HHW Brick Application provides a pluggable application framework for running analytics on building systems. Applications are self-contained modules that:</p> <ul> <li>Qualify buildings - Check if building has required sensors</li> <li>Analyze data - Perform calculations and generate insights</li> <li>Generate outputs - Create reports, plots, and metrics</li> </ul>"},{"location":"user-guide/applications/#available-applications","title":"Available Applications","text":""},{"location":"user-guide/applications/#current-applications","title":"Current Applications","text":"<p>The package includes two built-in applications:</p> Application Purpose Required Sensors secondary_loop_temp_diff Analyze secondary loop temperature difference Secondary supply, return temps primary_loop_temp_diff Analyze primary loop temperature difference Primary supply, return temps <p>More applications can be added by developers. See Developer Guide.</p>"},{"location":"user-guide/applications/#quick-start","title":"Quick Start","text":""},{"location":"user-guide/applications/#4-step-workflow","title":"4-Step Workflow","text":"<p>From <code>examples/07_run_application.py</code>:</p> <pre><code>from hhw_brick import apps\n\n# Step 1: Load application\napp = apps.load_app(\"secondary_loop_temp_diff\")\n\n# Step 2: Qualify building (check if it has required sensors)\nqualified, details = app.qualify(\"building_105.ttl\")\n\nif qualified:\n    # Step 3: Load configuration\n    config = apps.get_default_config(\"secondary_loop_temp_diff\")\n\n    # Step 4: Run analysis\n    results = app.analyze(\n        brick_model_path=\"building_105.ttl\",\n        timeseries_data_path=\"building_105_data.csv\",\n        config=config\n    )\n\n    print(f\"Analysis complete: {results['summary']}\")\n</code></pre>"},{"location":"user-guide/applications/#apps-manager","title":"Apps Manager","text":""},{"location":"user-guide/applications/#discover-applications","title":"Discover Applications","text":"<p>From <code>examples/06_application_management.py</code>:</p> <pre><code>from hhw_brick import apps\n\n# List all available applications\navailable_apps = apps.list_apps()\n\nprint(f\"Found {len(available_apps)} applications:\")\nfor app_info in available_apps:\n    print(f\"  \u2022 {app_info['name']}\")\n    print(f\"    {app_info['description']}\")\n</code></pre> <p>Expected output: <pre><code>Found 2 applications:\n  \u2022 secondary_loop_temp_diff\n    Analyzes temperature difference in secondary hot water loop\n  \u2022 primary_loop_temp_diff\n    Analyzes temperature difference in primary hot water loop\n</code></pre></p>"},{"location":"user-guide/applications/#load-application","title":"Load Application","text":"<pre><code># Load by name\napp = apps.load_app(\"secondary_loop_temp_diff\")\n\n# Now you can use app.qualify() and app.analyze()\n</code></pre>"},{"location":"user-guide/applications/#get-application-info","title":"Get Application Info","text":"<pre><code># Get detailed information\ninfo = apps.get_app_info(\"secondary_loop_temp_diff\")\n\nprint(f\"Name: {info['name']}\")\nprint(f\"Description: {info['description']}\")\nprint(f\"Functions: {[f['name'] for f in info['functions']]}\")\n</code></pre>"},{"location":"user-guide/applications/#get-default-configuration","title":"Get Default Configuration","text":"<pre><code># Get default config template\nconfig = apps.get_default_config(\"secondary_loop_temp_diff\")\n\n# Customize\nconfig['output']['output_dir'] = './my_results'\nconfig['output']['generate_plots'] = True\n\n# Save for later use\nimport yaml\nwith open('my_config.yaml', 'w') as f:\n    yaml.dump(config, f)\n</code></pre>"},{"location":"user-guide/applications/#application-lifecycle","title":"Application Lifecycle","text":""},{"location":"user-guide/applications/#complete-workflow","title":"Complete Workflow","text":"<pre><code>graph TD\n    A[Load App] --&gt;|apps.load_app| B[Qualify Building]\n    B --&gt;|app.qualify| C{Has Required&lt;br/&gt;Sensors?}\n    C --&gt;|No| D[Skip Building]\n    C --&gt;|Yes| E[Load Config]\n    E --&gt;|apps.get_default_config| F[Run Analysis]\n    F --&gt;|app.analyze| G[Generate Results]\n    G --&gt; H[Save Outputs]\n\n    style A fill:#e1f5ff\n    style C fill:#fff9c4\n    style G fill:#c8e6c9\n    style D fill:#ffcdd2</code></pre>"},{"location":"user-guide/applications/#step-by-step-example","title":"Step-by-Step Example","text":"<pre><code>\"\"\"\nComplete application workflow\nBased on examples/07_run_application.py\n\"\"\"\n\nfrom pathlib import Path\nfrom hhw_brick import apps\nimport yaml\n\ndef run_application_workflow(building_id, app_name):\n    \"\"\"Complete workflow for running an application.\"\"\"\n\n    # Paths\n    model_file = f\"brick_models/building_{building_id}.ttl\"\n    data_file = f\"timeseries_data/{building_id}_data.csv\"\n\n    print(f\"Running {app_name} on building {building_id}\")\n    print(\"=\"*60)\n\n    # ===== Step 1: Load Application =====\n    print(\"\\nStep 1: Load Application\")\n    app = apps.load_app(app_name)\n    print(f\"\u2713 Loaded {app_name}\")\n\n    # ===== Step 2: Qualify Building =====\n    print(\"\\nStep 2: Qualify Building\")\n    qualified, details = app.qualify(model_file)\n\n    if not qualified:\n        print(f\"\u2717 Building {building_id} not qualified\")\n        print(f\"  Reason: {details.get('reason', 'Missing required sensors')}\")\n        return None\n\n    print(f\"\u2713 Building {building_id} qualified\")\n    print(f\"  Found sensors:\")\n    for sensor_type, sensor_uri in details.items():\n        if sensor_uri and 'http' in str(sensor_uri):\n            sensor_name = str(sensor_uri).split('#')[-1]\n            print(f\"    - {sensor_type}: {sensor_name}\")\n\n    # ===== Step 3: Load Configuration =====\n    print(\"\\nStep 3: Load Configuration\")\n    config = apps.get_default_config(app_name)\n\n    # Customize config\n    config['output']['output_dir'] = f\"./results/{app_name}\"\n    config['output']['generate_plots'] = True\n\n    # Save config (optional)\n    config_file = f\"{app_name}_config.yaml\"\n    with open(config_file, 'w') as f:\n        yaml.dump(config, f)\n    print(f\"\u2713 Configuration ready\")\n    print(f\"  Output: {config['output']['output_dir']}\")\n\n    # ===== Step 4: Run Analysis =====\n    print(\"\\nStep 4: Run Analysis\")\n    print(f\"  Model: {model_file}\")\n    print(f\"  Data: {data_file}\")\n\n    results = app.analyze(\n        brick_model_path=model_file,\n        timeseries_data_path=data_file,\n        config=config\n    )\n\n    # ===== Display Results =====\n    print(\"\\n\" + \"=\"*60)\n    print(\"Analysis Results\")\n    print(\"=\"*60)\n\n    if 'summary' in results:\n        print(\"\\nSummary:\")\n        for key, value in results['summary'].items():\n            print(f\"  {key}: {value}\")\n\n    if 'outputs' in results:\n        print(\"\\nGenerated Files:\")\n        for output in results['outputs']:\n            print(f\"  \u2713 {output}\")\n\n    return results\n\n# Run it\nif __name__ == \"__main__\":\n    results = run_application_workflow(\n        building_id=\"105\",\n        app_name=\"secondary_loop_temp_diff\"\n    )\n</code></pre>"},{"location":"user-guide/applications/#batch-application","title":"Batch Application","text":""},{"location":"user-guide/applications/#qualify-multiple-buildings","title":"Qualify Multiple Buildings","text":"<p>From <code>examples/06_application_management.py</code>:</p> <pre><code>from hhw_brick import apps\n\n# Check all buildings in a directory\nbatch_results = apps.qualify_buildings(\"brick_models/\")\n\n# Analyze results\nfor building in batch_results:\n    building_name = Path(building['model']).stem\n    print(f\"\\nBuilding: {building_name}\")\n\n    for result in building['results']:\n        app_name = result['app']\n        qualified = result['qualified']\n\n        status = \"\u2713\" if qualified else \"\u2717\"\n        print(f\"  {status} {app_name}\")\n</code></pre>"},{"location":"user-guide/applications/#build-qualification-matrix","title":"Build Qualification Matrix","text":"<pre><code>\"\"\"\nCreate a matrix showing which buildings qualify for which apps\n\"\"\"\n\nfrom pathlib import Path\nfrom hhw_brick import apps\n\n# Batch qualify\nbatch_results = apps.qualify_buildings(\"brick_models/\")\n\n# Build matrix\napp_matrix = {}  # app -&gt; list of qualified buildings\nbuilding_matrix = {}  # building -&gt; list of qualified apps\n\nfor building in batch_results:\n    building_name = Path(building['model']).stem\n    building_matrix[building_name] = []\n\n    for r in building['results']:\n        app_name = r['app']\n\n        if app_name not in app_matrix:\n            app_matrix[app_name] = []\n\n        if r['qualified']:\n            app_matrix[app_name].append(building_name)\n            building_matrix[building_name].append(app_name)\n\n# Display by application\nprint(\"By Application:\")\nfor app_name, buildings in app_matrix.items():\n    print(f\"  {app_name}:\")\n    print(f\"    Qualified: {len(buildings)}/{len(batch_results)} buildings\")\n    for b in buildings[:5]:  # Show first 5\n        print(f\"      \u2713 {b}\")\n\n# Display by building\nprint(\"\\nBy Building:\")\nfor building_name, apps_list in building_matrix.items():\n    if apps_list:\n        print(f\"  {building_name}: {', '.join(apps_list)}\")\n</code></pre>"},{"location":"user-guide/applications/#batch-run-applications","title":"Batch Run Applications","text":"<pre><code>\"\"\"\nRun applications on all qualified buildings\n\"\"\"\n\nfrom hhw_brick import apps\nfrom pathlib import Path\nimport yaml\n\ndef batch_run_application(app_name, model_dir, data_dir, output_dir):\n    \"\"\"Run application on all qualified buildings.\"\"\"\n\n    # Load app\n    app = apps.load_app(app_name)\n    config = apps.get_default_config(app_name)\n\n    # Find all models\n    model_files = list(Path(model_dir).glob(\"*.ttl\"))\n\n    results_summary = {\n        'total': len(model_files),\n        'qualified': 0,\n        'analyzed': 0,\n        'failed': 0,\n        'results': []\n    }\n\n    for model_file in model_files:\n        building_id = model_file.stem.split('_')[1]  # Extract ID\n\n        # Qualify\n        qualified, details = app.qualify(str(model_file))\n\n        if not qualified:\n            continue\n\n        results_summary['qualified'] += 1\n\n        # Find corresponding data file\n        data_file = Path(data_dir) / f\"{building_id}_data.csv\"\n\n        if not data_file.exists():\n            print(f\"\u26a0 Data file not found for building {building_id}\")\n            results_summary['failed'] += 1\n            continue\n\n        try:\n            # Run analysis\n            result = app.analyze(\n                brick_model_path=str(model_file),\n                timeseries_data_path=str(data_file),\n                config=config\n            )\n\n            results_summary['analyzed'] += 1\n            results_summary['results'].append({\n                'building_id': building_id,\n                'status': 'success',\n                'summary': result.get('summary', {})\n            })\n\n            print(f\"\u2713 Building {building_id}\")\n\n        except Exception as e:\n            results_summary['failed'] += 1\n            results_summary['results'].append({\n                'building_id': building_id,\n                'status': 'failed',\n                'error': str(e)\n            })\n\n            print(f\"\u2717 Building {building_id}: {e}\")\n\n    # Summary\n    print(f\"\\n{'='*60}\")\n    print(f\"Batch Analysis Summary - {app_name}\")\n    print(f\"{'='*60}\")\n    print(f\"Total buildings: {results_summary['total']}\")\n    print(f\"Qualified: {results_summary['qualified']}\")\n    print(f\"Analyzed: {results_summary['analyzed']}\")\n    print(f\"Failed: {results_summary['failed']}\")\n\n    return results_summary\n\n# Use it\nresults = batch_run_application(\n    app_name=\"secondary_loop_temp_diff\",\n    model_dir=\"brick_models/\",\n    data_dir=\"timeseries_data/\",\n    output_dir=\"analysis_results/\"\n)\n</code></pre>"},{"location":"user-guide/applications/#application-interface","title":"Application Interface","text":""},{"location":"user-guide/applications/#standard-interface","title":"Standard Interface","text":"<p>All applications follow the same interface:</p> <pre><code># All apps have these three functions:\n\n__all__ = ['qualify', 'analyze', 'load_config']\n\ndef qualify(brick_model_path: str) -&gt; Tuple[bool, Dict]:\n    \"\"\"\n    Check if building has required sensors.\n\n    Returns:\n        (qualified, details) tuple\n        - qualified: True if building can use this app\n        - details: Dict with sensor URIs or qualification info\n    \"\"\"\n    pass\n\ndef analyze(brick_model_path: str,\n           timeseries_data_path: str,\n           config: Dict) -&gt; Dict:\n    \"\"\"\n    Run analysis on building data.\n\n    Returns:\n        Dict with analysis results, including:\n        - summary: Key metrics\n        - outputs: List of generated files\n        - data: Detailed results\n    \"\"\"\n    pass\n\ndef load_config(config_path: str = None) -&gt; Dict:\n    \"\"\"\n    Load application configuration.\n\n    Returns:\n        Configuration dictionary\n    \"\"\"\n    pass\n</code></pre>"},{"location":"user-guide/applications/#common-patterns","title":"Common Patterns","text":""},{"location":"user-guide/applications/#pattern-1-single-building-analysis","title":"Pattern 1: Single Building Analysis","text":"<pre><code># Load app\napp = apps.load_app(\"secondary_loop_temp_diff\")\n\n# Qualify\nqualified, details = app.qualify(\"building_105.ttl\")\n\nif qualified:\n    # Load config\n    config = apps.get_default_config(\"secondary_loop_temp_diff\")\n\n    # Run\n    results = app.analyze(\n        \"building_105.ttl\",\n        \"building_105_data.csv\",\n        config\n    )\n</code></pre>"},{"location":"user-guide/applications/#pattern-2-try-multiple-apps","title":"Pattern 2: Try Multiple Apps","text":"<pre><code># Try all apps on one building\navailable_apps = apps.list_apps()\nmodel_path = \"building_105.ttl\"\n\nfor app_info in available_apps:\n    app = apps.load_app(app_info['name'])\n    qualified, details = app.qualify(model_path)\n\n    if qualified:\n        print(f\"\u2713 Can run: {app_info['name']}\")\n        # Run it...\n    else:\n        print(f\"\u2717 Cannot run: {app_info['name']}\")\n</code></pre>"},{"location":"user-guide/applications/#pattern-3-conditional-analysis","title":"Pattern 3: Conditional Analysis","text":"<pre><code># Run different apps based on system type\nfrom hhw_brick.validation import SubgraphPatternValidator\n\npattern_validator = SubgraphPatternValidator()\nresult = pattern_validator.check_pattern_2_district_system(model_path)\n\nif result['matched']:\n    # District system - use district-specific apps\n    app = apps.load_app(\"district_efficiency\")\nelse:\n    # Boiler system - use boiler-specific apps  \n    app = apps.load_app(\"boiler_efficiency\")\n\n# Then qualify and analyze...\n</code></pre>"},{"location":"user-guide/applications/#configuration-management","title":"Configuration Management","text":""},{"location":"user-guide/applications/#default-configuration","title":"Default Configuration","text":"<pre><code># Get default config\nconfig = apps.get_default_config(\"secondary_loop_temp_diff\")\n\n# Typical structure:\n{\n    'analysis': {\n        'time_window': '1D',\n        'aggregation': 'mean'\n    },\n    'output': {\n        'save_results': True,\n        'output_dir': './results',\n        'generate_plots': True\n    }\n}\n</code></pre>"},{"location":"user-guide/applications/#custom-configuration","title":"Custom Configuration","text":"<pre><code>import yaml\n\n# Load and customize\nconfig = apps.get_default_config(\"secondary_loop_temp_diff\")\nconfig['output']['output_dir'] = './custom_results'\nconfig['output']['generate_plots'] = False\nconfig['analysis']['time_window'] = '6H'\n\n# Save\nwith open('custom_config.yaml', 'w') as f:\n    yaml.dump(config, f)\n\n# Load later\nwith open('custom_config.yaml', 'r') as f:\n    config = yaml.safe_load(f)\n\n# Use it\nresults = app.analyze(model_path, data_path, config)\n</code></pre>"},{"location":"user-guide/applications/#output-management","title":"Output Management","text":""},{"location":"user-guide/applications/#typical-outputs","title":"Typical Outputs","text":"<p>Applications generate various outputs:</p> <pre><code>results = app.analyze(model_path, data_path, config)\n\n# Results structure\n{\n    'summary': {\n        'mean_temp_diff': 5.2,\n        'max_temp_diff': 12.1,\n        'data_points': 8760\n    },\n    'outputs': [\n        'results/temp_diff_plot.png',\n        'results/statistics.csv',\n        'results/hourly_data.csv'\n    ],\n    'data': {\n        # Detailed results...\n    }\n}\n</code></pre>"},{"location":"user-guide/applications/#handling-outputs","title":"Handling Outputs","text":"<pre><code># Check generated files\nif 'outputs' in results:\n    print(\"Generated files:\")\n    for output_file in results['outputs']:\n        if Path(output_file).exists():\n            print(f\"  \u2713 {output_file}\")\n        else:\n            print(f\"  \u2717 {output_file} (not found)\")\n\n# Access summary metrics\nif 'summary' in results:\n    for metric, value in results['summary'].items():\n        print(f\"{metric}: {value}\")\n</code></pre>"},{"location":"user-guide/applications/#troubleshooting","title":"Troubleshooting","text":""},{"location":"user-guide/applications/#issue-app-not-found","title":"Issue: \"App not found\"","text":"<p>Solution: <pre><code># List available apps\nprint(apps.list_apps())\n\n# Use exact name\napp = apps.load_app(\"secondary_loop_temp_diff\")  # Correct\n# app = apps.load_app(\"secondary_loop\")  # Wrong\n</code></pre></p>"},{"location":"user-guide/applications/#issue-building-not-qualified","title":"Issue: Building not qualified","text":"<p>Investigation: <pre><code>qualified, details = app.qualify(\"building_105.ttl\")\n\nif not qualified:\n    print(\"Qualification failed:\")\n    print(f\"  Reason: {details.get('reason', 'Unknown')}\")\n    print(f\"  Missing: {details.get('missing', [])}\")\n</code></pre></p>"},{"location":"user-guide/applications/#issue-analysis-fails","title":"Issue: Analysis fails","text":"<p>Check: 1. Data file exists and is readable 2. Data format matches expected format 3. Configuration is valid</p> <pre><code># Debug\ntry:\n    results = app.analyze(model_path, data_path, config)\nexcept FileNotFoundError as e:\n    print(f\"File not found: {e}\")\nexcept Exception as e:\n    print(f\"Analysis failed: {e}\")\n    import traceback\n    traceback.print_exc()\n</code></pre>"},{"location":"user-guide/applications/#best-practices","title":"Best Practices","text":""},{"location":"user-guide/applications/#1-always-qualify-first","title":"1. Always Qualify First","text":"<pre><code># Good \u2713\nqualified, details = app.qualify(model_path)\nif qualified:\n    results = app.analyze(model_path, data_path, config)\n\n# Bad \u2717\n# Skip qualification - might fail\nresults = app.analyze(model_path, data_path, config)\n</code></pre>"},{"location":"user-guide/applications/#2-use-configuration-files","title":"2. Use Configuration Files","text":"<pre><code># Good \u2713 - Reusable configuration\nconfig = yaml.safe_load(open('config.yaml'))\nresults = app.analyze(model_path, data_path, config)\n\n# Bad \u2717 - Hard-coded config\nconfig = {'output': {'output_dir': './results'}}\n</code></pre>"},{"location":"user-guide/applications/#3-handle-failures-gracefully","title":"3. Handle Failures Gracefully","text":"<pre><code># Good \u2713\ntry:\n    results = app.analyze(model_path, data_path, config)\n    save_results(results)\nexcept Exception as e:\n    log_error(f\"Analysis failed: {e}\")\n    notify_admin()\n\n# Bad \u2717\nresults = app.analyze(model_path, data_path, config)\n# No error handling\n</code></pre>"},{"location":"user-guide/applications/#next-steps","title":"Next Steps","text":"<p>Learn about specific applications:</p> <ul> <li>Apps Manager - Detailed apps manager API</li> <li>Secondary Loop Temp Diff - Temperature difference analysis</li> <li>Primary Loop Temp Diff - Primary loop analysis</li> <li>Running Apps - Complete guide to running applications</li> </ul> <p>Or explore related topics:</p> <ul> <li>Developer Guide - Create your own applications</li> <li>Examples - Working code samples</li> </ul> <p>Continue to: Apps Manager Details \u2192</p>"},{"location":"user-guide/applications/apps-manager/","title":"Apps Manager","text":"<p>Detailed guide to the Apps Manager API for discovering and managing analytics applications.</p>"},{"location":"user-guide/applications/apps-manager/#overview","title":"Overview","text":"<p>The Apps Manager (<code>apps</code>) provides a simple interface to:</p> <ul> <li>Discover available applications</li> <li>Load applications dynamically</li> <li>Get information about applications</li> <li>Manage configurations</li> <li>Batch qualify buildings</li> </ul>"},{"location":"user-guide/applications/apps-manager/#importing-apps-manager","title":"Importing Apps Manager","text":"<pre><code>from hhw_brick import apps\n</code></pre> <p>The <code>apps</code> object is a singleton instance of <code>AppsManager</code> that provides all functionality.</p>"},{"location":"user-guide/applications/apps-manager/#core-functions","title":"Core Functions","text":""},{"location":"user-guide/applications/apps-manager/#list_apps","title":"list_apps()","text":"<p>List all available analytics applications.</p> <p>Signature: <pre><code>def list_apps() -&gt; List[Dict[str, str]]\n</code></pre></p> <p>Returns: <pre><code>[\n    {\n        'name': 'secondary_loop_temp_diff',\n        'description': 'Analyzes temperature difference in secondary hot water loop',\n        'path': '/path/to/app'\n    },\n    # ... more apps\n]\n</code></pre></p> <p>Example: <pre><code>from hhw_brick import apps\n\n# List all apps\navailable = apps.list_apps()\n\nprint(f\"Found {len(available)} applications:\")\nfor app in available:\n    print(f\"  \u2022 {app['name']}\")\n    print(f\"    {app['description']}\")\n</code></pre></p> <p>Output: <pre><code>Found 2 applications:\n  \u2022 secondary_loop_temp_diff\n    Analyzes temperature difference in secondary hot water loop\n  \u2022 primary_loop_temp_diff\n    Analyzes temperature difference in primary hot water loop\n</code></pre></p>"},{"location":"user-guide/applications/apps-manager/#load_app","title":"load_app()","text":"<p>Load an application by name.</p> <p>Signature: <pre><code>def load_app(app_name: str) -&gt; Module\n</code></pre></p> <p>Parameters: - <code>app_name</code> (str): Name of the application (e.g., \"secondary_loop_temp_diff\")</p> <p>Returns: - App module with <code>qualify()</code>, <code>analyze()</code>, and <code>load_config()</code> functions</p> <p>Example: <pre><code># Load application\napp = apps.load_app(\"secondary_loop_temp_diff\")\n\n# Now you can use app functions\nqualified, details = app.qualify(\"building_105.ttl\")\n</code></pre></p> <p>Raises: - <code>ImportError</code>: If app not found or cannot be loaded</p> <pre><code>try:\n    app = apps.load_app(\"non_existent_app\")\nexcept ImportError as e:\n    print(f\"Error: {e}\")\n</code></pre>"},{"location":"user-guide/applications/apps-manager/#get_app_info","title":"get_app_info()","text":"<p>Get detailed information about an application.</p> <p>Signature: <pre><code>def get_app_info(app_name: str) -&gt; Dict[str, Any]\n</code></pre></p> <p>Returns: <pre><code>{\n    'name': 'secondary_loop_temp_diff',\n    'description': 'Analyzes temperature difference in secondary hot water loop',\n    'functions': [\n        {'name': 'qualify', 'signature': '...'},\n        {'name': 'analyze', 'signature': '...'},\n        {'name': 'load_config', 'signature': '...'}\n    ]\n}\n</code></pre></p> <p>Example: <pre><code>info = apps.get_app_info(\"secondary_loop_temp_diff\")\n\nprint(f\"App: {info['name']}\")\nprint(f\"Description: {info['description']}\")\nprint(f\"Functions:\")\nfor func in info['functions']:\n    print(f\"  - {func['name']}\")\n</code></pre></p>"},{"location":"user-guide/applications/apps-manager/#get_default_config","title":"get_default_config()","text":"<p>Get default configuration template for an application.</p> <p>Signature: <pre><code>def get_default_config(app_name: str) -&gt; Dict[str, Any]\n</code></pre></p> <p>Returns: <pre><code>{\n    'analysis': {\n        'threshold_min_delta': 0.5,\n        'threshold_max_delta': 10.0\n    },\n    'output': {\n        'save_results': True,\n        'output_dir': './results',\n        'generate_plots': True\n    }\n}\n</code></pre></p> <p>Example: <pre><code># Get default config\nconfig = apps.get_default_config(\"secondary_loop_temp_diff\")\n\n# Customize\nconfig['output']['output_dir'] = './my_results'\nconfig['analysis']['threshold_min_delta'] = 1.0\n\n# Use it\nresults = app.analyze(model_path, data_path, config)\n</code></pre></p>"},{"location":"user-guide/applications/apps-manager/#batch-operations","title":"Batch Operations","text":""},{"location":"user-guide/applications/apps-manager/#qualify_building","title":"qualify_building()","text":"<p>Qualify a single building against all available applications.</p> <p>Signature: <pre><code>def qualify_building(model_path: str, verbose: bool = True) -&gt; Dict\n</code></pre></p> <p>Parameters: - <code>model_path</code> (str): Path to Brick model file - <code>verbose</code> (bool): Print detailed output (default: True)</p> <p>Returns: <pre><code>{\n    'model': 'building_105.ttl',\n    'results': [\n        {\n            'app': 'secondary_loop_temp_diff',\n            'qualified': True,\n            'details': {...}\n        },\n        {\n            'app': 'primary_loop_temp_diff',\n            'qualified': False,\n            'details': {...}\n        }\n    ]\n}\n</code></pre></p> <p>Example: <pre><code>from hhw_brick import apps\n\n# Qualify one building\nresult = apps.qualify_building(\"building_105.ttl\")\n\nprint(f\"Building: {result['model']}\")\nfor r in result['results']:\n    status = \"\u2713\" if r['qualified'] else \"\u2717\"\n    print(f\"  {status} {r['app']}\")\n</code></pre></p> <p>With verbose=False: <pre><code># Silent qualification (no print output)\nresult = apps.qualify_building(\"building_105.ttl\", verbose=False)\n\n# Process results programmatically\nqualified_apps = [\n    r['app'] for r in result['results'] if r['qualified']\n]\nprint(f\"Qualified for: {', '.join(qualified_apps)}\")\n</code></pre></p>"},{"location":"user-guide/applications/apps-manager/#qualify_buildings","title":"qualify_buildings()","text":"<p>Qualify multiple buildings against all applications.</p> <p>Signature: <pre><code>def qualify_buildings(model_dir: str, verbose: bool = False) -&gt; List[Dict]\n</code></pre></p> <p>Parameters: - <code>model_dir</code> (str): Directory containing Brick model files - <code>verbose</code> (bool): Print progress (default: False)</p> <p>Returns: <pre><code>[\n    {\n        'model': 'building_105.ttl',\n        'results': [\n            {'app': 'secondary_loop_temp_diff', 'qualified': True, 'details': {...}},\n            {'app': 'primary_loop_temp_diff', 'qualified': False, 'details': {...}}\n        ]\n    },\n    # ... more buildings\n]\n</code></pre></p> <p>Example: <pre><code>from hhw_brick import apps\nfrom pathlib import Path\n\n# Batch qualify\nbatch_results = apps.qualify_buildings(\"brick_models/\")\n\n# Analyze results\nfor building in batch_results:\n    building_name = Path(building['model']).stem\n    qualified_apps = [\n        r['app'] for r in building['results'] if r['qualified']\n    ]\n\n    if qualified_apps:\n        print(f\"{building_name}: {', '.join(qualified_apps)}\")\n    else:\n        print(f\"{building_name}: No apps available\")\n</code></pre></p>"},{"location":"user-guide/applications/apps-manager/#advanced-usage","title":"Advanced Usage","text":""},{"location":"user-guide/applications/apps-manager/#building-qualification-matrix","title":"Building Qualification Matrix","text":"<p>Create a comprehensive view of which buildings qualify for which apps:</p> <pre><code>\"\"\"\nBuild a qualification matrix\n\"\"\"\nfrom hhw_brick import apps\nfrom pathlib import Path\n\ndef build_qualification_matrix(model_dir):\n    \"\"\"Build matrix of buildings vs applications.\"\"\"\n\n    # Batch qualify\n    batch_results = apps.qualify_buildings(model_dir)\n\n    # Initialize matrices\n    app_to_buildings = {}  # app -&gt; [buildings]\n    building_to_apps = {}  # building -&gt; [apps]\n\n    # Process results\n    for building in batch_results:\n        building_name = Path(building['model']).stem\n        building_to_apps[building_name] = []\n\n        for result in building['results']:\n            app_name = result['app']\n\n            # Initialize app entry\n            if app_name not in app_to_buildings:\n                app_to_buildings[app_name] = []\n\n            # Record qualification\n            if result['qualified']:\n                app_to_buildings[app_name].append(building_name)\n                building_to_apps[building_name].append(app_name)\n\n    return {\n        'by_app': app_to_buildings,\n        'by_building': building_to_apps,\n        'total_buildings': len(batch_results)\n    }\n\n# Use it\nmatrix = build_qualification_matrix(\"brick_models/\")\n\n# Display by application\nprint(\"Qualification by Application:\")\nfor app_name, buildings in matrix['by_app'].items():\n    pct = len(buildings) / matrix['total_buildings'] * 100\n    print(f\"  {app_name}:\")\n    print(f\"    {len(buildings)}/{matrix['total_buildings']} ({pct:.1f}%)\")\n\n# Display by building\nprint(\"\\nQualification by Building:\")\nfor building, apps_list in matrix['by_building'].items():\n    if apps_list:\n        print(f\"  {building}: {', '.join(apps_list)}\")\n</code></pre>"},{"location":"user-guide/applications/apps-manager/#export-qualification-results","title":"Export Qualification Results","text":"<p>Save qualification results to CSV:</p> <pre><code>\"\"\"\nExport qualification matrix to CSV\n\"\"\"\nimport pandas as pd\nfrom hhw_brick import apps\n\ndef export_qualification_matrix(model_dir, output_csv):\n    \"\"\"Export qualification results to CSV.\"\"\"\n\n    batch_results = apps.qualify_buildings(model_dir)\n\n    # Flatten results for CSV\n    rows = []\n    for building in batch_results:\n        building_name = Path(building['model']).stem\n\n        for result in building['results']:\n            rows.append({\n                'building': building_name,\n                'application': result['app'],\n                'qualified': result['qualified']\n            })\n\n    # Create DataFrame\n    df = pd.DataFrame(rows)\n\n    # Pivot for matrix view\n    matrix = df.pivot(\n        index='building',\n        columns='application',\n        values='qualified'\n    )\n\n    # Save\n    matrix.to_csv(output_csv)\n    print(f\"Saved qualification matrix to: {output_csv}\")\n\n    # Summary\n    print(f\"\\nSummary:\")\n    for app in matrix.columns:\n        qualified_count = matrix[app].sum()\n        total = len(matrix)\n        print(f\"  {app}: {qualified_count}/{total} buildings\")\n\n    return matrix\n\n# Use it\nmatrix = export_qualification_matrix(\n    \"brick_models/\",\n    \"qualification_matrix.csv\"\n)\n</code></pre>"},{"location":"user-guide/applications/apps-manager/#dynamic-app-loading","title":"Dynamic App Loading","text":"<p>Load apps dynamically based on conditions:</p> <pre><code>\"\"\"\nDynamically select and load apps\n\"\"\"\nfrom hhw_brick import apps\n\ndef select_app_for_building(model_path, preferred_apps=None):\n    \"\"\"\n    Select best app for a building.\n\n    Args:\n        model_path: Path to Brick model\n        preferred_apps: List of preferred app names (in priority order)\n\n    Returns:\n        Tuple of (app_module, app_name) or (None, None)\n    \"\"\"\n    # Get all available apps\n    available = apps.list_apps()\n\n    # Set default preference\n    if preferred_apps is None:\n        preferred_apps = [a['name'] for a in available]\n\n    # Try apps in order of preference\n    for app_name in preferred_apps:\n        try:\n            app = apps.load_app(app_name)\n            qualified, details = app.qualify(model_path)\n\n            if qualified:\n                return app, app_name\n        except Exception as e:\n            print(f\"Error loading {app_name}: {e}\")\n            continue\n\n    return None, None\n\n# Use it\nmodel_path = \"building_105.ttl\"\npreferred = [\"secondary_loop_temp_diff\", \"primary_loop_temp_diff\"]\n\napp, app_name = select_app_for_building(model_path, preferred)\n\nif app:\n    print(f\"Selected: {app_name}\")\n    # Run analysis\n    config = apps.get_default_config(app_name)\n    results = app.analyze(model_path, data_path, config)\nelse:\n    print(\"No suitable app found\")\n</code></pre>"},{"location":"user-guide/applications/apps-manager/#configuration-management","title":"Configuration Management","text":""},{"location":"user-guide/applications/apps-manager/#load-configuration-from-file","title":"Load Configuration from File","text":"<pre><code>import yaml\n\n# Create config file\nconfig = apps.get_default_config(\"secondary_loop_temp_diff\")\nwith open('my_config.yaml', 'w') as f:\n    yaml.dump(config, f)\n\n# Load and use\nwith open('my_config.yaml', 'r') as f:\n    config = yaml.safe_load(f)\n\nresults = app.analyze(model_path, data_path, config)\n</code></pre>"},{"location":"user-guide/applications/apps-manager/#configuration-templates","title":"Configuration Templates","text":"<pre><code>\"\"\"\nCreate configuration templates for all apps\n\"\"\"\nfrom hhw_brick import apps\nimport yaml\nfrom pathlib import Path\n\ndef create_config_templates(output_dir):\n    \"\"\"Create config templates for all apps.\"\"\"\n\n    output_path = Path(output_dir)\n    output_path.mkdir(exist_ok=True)\n\n    available = apps.list_apps()\n\n    for app_info in available:\n        app_name = app_info['name']\n        config = apps.get_default_config(app_name)\n\n        config_file = output_path / f\"{app_name}_config.yaml\"\n        with open(config_file, 'w') as f:\n            yaml.dump(config, f, default_flow_style=False)\n\n        print(f\"Created: {config_file}\")\n\n# Use it\ncreate_config_templates(\"config_templates/\")\n</code></pre>"},{"location":"user-guide/applications/apps-manager/#error-handling","title":"Error Handling","text":""},{"location":"user-guide/applications/apps-manager/#handle-missing-apps","title":"Handle Missing Apps","text":"<pre><code>from hhw_brick import apps\n\napp_name = \"my_custom_app\"\n\ntry:\n    app = apps.load_app(app_name)\nexcept ImportError:\n    print(f\"App '{app_name}' not found\")\n    print(\"Available apps:\")\n    for a in apps.list_apps():\n        print(f\"  - {a['name']}\")\n</code></pre>"},{"location":"user-guide/applications/apps-manager/#handle-qualification-failures","title":"Handle Qualification Failures","text":"<pre><code>app = apps.load_app(\"secondary_loop_temp_diff\")\nqualified, details = app.qualify(\"building_105.ttl\")\n\nif not qualified:\n    print(\"Building not qualified\")\n\n    # Check details for reason\n    if 'reason' in details:\n        print(f\"Reason: {details['reason']}\")\n\n    if 'missing' in details:\n        print(f\"Missing: {details['missing']}\")\n</code></pre>"},{"location":"user-guide/applications/apps-manager/#best-practices","title":"Best Practices","text":""},{"location":"user-guide/applications/apps-manager/#1-check-available-apps-first","title":"1. Check Available Apps First","text":"<pre><code># Good \u2713\navailable = apps.list_apps()\nif available:\n    app = apps.load_app(available[0]['name'])\n\n# Bad \u2717\napp = apps.load_app(\"some_app\")  # Might not exist\n</code></pre>"},{"location":"user-guide/applications/apps-manager/#2-always-qualify-before-analyzing","title":"2. Always Qualify Before Analyzing","text":"<pre><code># Good \u2713\nqualified, details = app.qualify(model_path)\nif qualified:\n    results = app.analyze(model_path, data_path, config)\n\n# Bad \u2717\nresults = app.analyze(model_path, data_path, config)  # Might fail\n</code></pre>"},{"location":"user-guide/applications/apps-manager/#3-use-configuration-files","title":"3. Use Configuration Files","text":"<pre><code># Good \u2713 - Maintainable\nconfig = yaml.safe_load(open('config.yaml'))\n\n# Bad \u2717 - Hard-coded\nconfig = {'output': {'output_dir': './results'}}\n</code></pre>"},{"location":"user-guide/applications/apps-manager/#4-handle-errors-gracefully","title":"4. Handle Errors Gracefully","text":"<pre><code># Good \u2713\ntry:\n    app = apps.load_app(app_name)\n    qualified, details = app.qualify(model_path)\n    if qualified:\n        results = app.analyze(model_path, data_path, config)\nexcept ImportError:\n    print(f\"App not found: {app_name}\")\nexcept FileNotFoundError:\n    print(f\"File not found\")\nexcept Exception as e:\n    print(f\"Error: {e}\")\n</code></pre>"},{"location":"user-guide/applications/apps-manager/#api-reference-summary","title":"API Reference Summary","text":"Function Purpose Returns <code>list_apps()</code> List all applications List of app info dicts <code>load_app(name)</code> Load an application App module <code>get_app_info(name)</code> Get app details Info dict <code>get_default_config(name)</code> Get default config Config dict <code>qualify_building(path)</code> Qualify one building Qualification result <code>qualify_buildings(dir)</code> Qualify multiple buildings List of results"},{"location":"user-guide/applications/apps-manager/#next-steps","title":"Next Steps","text":"<ul> <li>Secondary Loop App - Learn about temperature difference analysis</li> <li>Running Apps - Complete guide to running applications</li> <li>Developer Guide - Create your own apps</li> </ul> <p>Continue to: Secondary Loop Temperature Difference \u2192</p>"},{"location":"user-guide/applications/running-apps/","title":"Running Applications","text":"<p>Complete guide to running analytics applications on building data.</p>"},{"location":"user-guide/applications/running-apps/#overview","title":"Overview","text":"<p>This guide covers the complete workflow for running applications, including:</p> <ul> <li>Preparation - Setting up data and models</li> <li>Qualification - Checking building compatibility</li> <li>Configuration - Customizing analysis parameters</li> <li>Execution - Running the analysis</li> <li>Results - Understanding and using outputs</li> </ul>"},{"location":"user-guide/applications/running-apps/#complete-workflow","title":"Complete Workflow","text":""},{"location":"user-guide/applications/running-apps/#end-to-end-example","title":"End-to-End Example","text":"<p>Based on <code>examples/07_run_application.py</code>:</p> <pre><code>\"\"\"\nComplete workflow: Convert \u2192 Validate \u2192 Analyze\n\"\"\"\n\nfrom pathlib import Path\nfrom hhw_brick import (\n    CSVToBrickConverter,\n    BrickModelValidator,\n    apps\n)\nimport yaml\n\ndef complete_workflow(building_id):\n    \"\"\"Complete workflow from CSV to analysis results.\"\"\"\n\n    # ===== Step 1: Convert CSV to Brick =====\n    print(\"Step 1: Convert CSV to Brick\")\n    print(\"=\"*60)\n\n    converter = CSVToBrickConverter()\n    model_file = f\"building_{building_id}.ttl\"\n\n    converter.convert_to_brick(\n        metadata_csv=\"metadata.csv\",\n        vars_csv=\"vars.csv\",\n        building_tag=building_id,\n        output_path=model_file\n    )\n    print(f\"\u2713 Created Brick model: {model_file}\\n\")\n\n    # ===== Step 2: Validate Model =====\n    print(\"Step 2: Validate Model\")\n    print(\"=\"*60)\n\n    validator = BrickModelValidator(use_local_brick=True)\n    is_valid = validator.validate_ontology(model_file)['valid']\n\n    if not is_valid:\n        print(\"\u2717 Model validation failed\\n\")\n        return None\n\n    print(f\"\u2713 Model is valid\\n\")\n\n    # ===== Step 3: Discover Available Apps =====\n    print(\"Step 3: Discover Available Apps\")\n    print(\"=\"*60)\n\n    available_apps = apps.list_apps()\n    print(f\"Found {len(available_apps)} applications:\")\n    for app_info in available_apps:\n        print(f\"  \u2022 {app_info['name']}\")\n    print()\n\n    # ===== Step 4: Qualify Building =====\n    print(\"Step 4: Qualify Building\")\n    print(\"=\"*60)\n\n    result = apps.qualify_building(model_file, verbose=False)\n\n    qualified_apps = [\n        r['app'] for r in result['results'] if r['qualified']\n    ]\n\n    if not qualified_apps:\n        print(f\"\u2717 Building {building_id} not qualified for any apps\\n\")\n        return None\n\n    print(f\"\u2713 Qualified for: {', '.join(qualified_apps)}\\n\")\n\n    # ===== Step 5: Run Analysis =====\n    print(\"Step 5: Run Analysis\")\n    print(\"=\"*60)\n\n    app_name = qualified_apps[0]  # Use first qualified app\n    app = apps.load_app(app_name)\n\n    # Load config\n    config = apps.get_default_config(app_name)\n    config['output']['output_dir'] = f\"./results/building_{building_id}\"\n\n    # Run analysis\n    data_file = f\"{building_id}_data.csv\"\n    results = app.analyze(model_file, data_file, config)\n\n    print(f\"\u2713 Analysis complete: {app_name}\")\n    print(f\"\\nSummary:\")\n    for key, value in results['summary'].items():\n        print(f\"  {key}: {value}\")\n\n    print(f\"\\nOutputs:\")\n    for output in results['outputs']:\n        print(f\"  - {output}\")\n\n    return results\n\n# Run it\nif __name__ == \"__main__\":\n    results = complete_workflow(\"105\")\n</code></pre>"},{"location":"user-guide/applications/running-apps/#preparation","title":"Preparation","text":""},{"location":"user-guide/applications/running-apps/#required-files","title":"Required Files","text":"<p>Before running an application, prepare:</p> File Description Example Brick Model TTL file with building model <code>building_105.ttl</code> Timeseries Data CSV with sensor data <code>105_data.csv</code> Configuration (optional) YAML with analysis settings <code>config.yaml</code>"},{"location":"user-guide/applications/running-apps/#data-file-requirements","title":"Data File Requirements","text":"<p>Timeseries CSV format:</p> <pre><code>datetime,secondary_supply_temp,secondary_return_temp,flow_rate\n2024-01-01 00:00:00,70.5,65.3,150.2\n2024-01-01 01:00:00,71.2,66.1,155.8\n2024-01-01 02:00:00,69.8,64.7,148.3\n...\n</code></pre> <p>Requirements: - \u2713 <code>datetime</code> column (timestamp) - \u2713 Sensor data columns (names can vary) - \u2713 Numeric values - \u2713 No missing critical timestamps</p>"},{"location":"user-guide/applications/running-apps/#verify-data-quality","title":"Verify Data Quality","text":"<pre><code>import pandas as pd\n\n# Load data\ndf = pd.read_csv(\"105_data.csv\", parse_dates=['datetime'])\n\n# Check quality\nprint(f\"Data points: {len(df)}\")\nprint(f\"Date range: {df['datetime'].min()} to {df['datetime'].max()}\")\nprint(f\"Columns: {df.columns.tolist()}\")\n\n# Check for missing values\nmissing = df.isnull().sum()\nif missing.any():\n    print(\"\\nMissing values:\")\n    print(missing[missing &gt; 0])\n</code></pre>"},{"location":"user-guide/applications/running-apps/#application-types","title":"Application Types","text":""},{"location":"user-guide/applications/running-apps/#primary-loop-temperature-difference","title":"Primary Loop Temperature Difference","text":"<p>Analyzes primary loop (boiler-side) temperature difference.</p> <p>Required Sensors: - Primary supply temperature - Primary return temperature</p> <p>Use Cases: - Boiler efficiency monitoring - Primary loop performance - Heat exchanger effectiveness</p> <p>Quick Example: <pre><code>app = apps.load_app(\"primary_loop_temp_diff\")\n\n# Qualify\nqualified, details = app.qualify(\"building_105.ttl\")\n\nif qualified:\n    # Get config\n    config = apps.get_default_config(\"primary_loop_temp_diff\")\n\n    # Run\n    results = app.analyze(\n        \"building_105.ttl\",\n        \"105_data.csv\",\n        config\n    )\n\n    print(f\"Primary loop temp diff: {results['summary']['mean_temp_diff']:.2f}\u00b0C\")\n</code></pre></p> <p>Similar to Secondary Loop:</p> <p>The primary loop app works identically to the secondary loop app, but: - Looks for primary loop sensors (not secondary) - Analyzes boiler-side temperatures - Useful for boiler systems (not district systems)</p> <p>See Secondary Loop for detailed documentation - the workflow is the same.</p>"},{"location":"user-guide/applications/running-apps/#secondary-loop-temperature-difference","title":"Secondary Loop Temperature Difference","text":"<p>See Secondary Loop App for complete documentation.</p>"},{"location":"user-guide/applications/running-apps/#batch-processing","title":"Batch Processing","text":""},{"location":"user-guide/applications/running-apps/#run-on-multiple-buildings","title":"Run on Multiple Buildings","text":"<pre><code>\"\"\"\nBatch process multiple buildings\n\"\"\"\nfrom pathlib import Path\nfrom hhw_brick import apps\n\ndef batch_run_app(app_name, model_dir, data_dir, output_base):\n    \"\"\"Run app on all qualified buildings.\"\"\"\n\n    # Load app\n    app = apps.load_app(app_name)\n    base_config = apps.get_default_config(app_name)\n\n    # Find models\n    model_files = list(Path(model_dir).glob(\"*.ttl\"))\n\n    results_summary = []\n\n    for model_file in model_files:\n        building_id = model_file.stem.split('_')[1]\n\n        # Qualify\n        qualified, details = app.qualify(str(model_file))\n        if not qualified:\n            print(f\"\u2298 Building {building_id}: Not qualified\")\n            continue\n\n        # Find data\n        data_file = Path(data_dir) / f\"{building_id}_data.csv\"\n        if not data_file.exists():\n            print(f\"\u2298 Building {building_id}: Data file not found\")\n            continue\n\n        # Configure\n        config = base_config.copy()\n        config['output']['output_dir'] = f\"{output_base}/building_{building_id}\"\n\n        # Run\n        try:\n            results = app.analyze(str(model_file), str(data_file), config)\n\n            results_summary.append({\n                'building_id': building_id,\n                'status': 'success',\n                'mean_temp_diff': results['summary']['mean_temp_diff'],\n                'data_points': results['summary']['data_points']\n            })\n\n            print(f\"\u2713 Building {building_id}: {results['summary']['mean_temp_diff']:.2f}\u00b0C\")\n\n        except Exception as e:\n            results_summary.append({\n                'building_id': building_id,\n                'status': 'failed',\n                'error': str(e)\n            })\n            print(f\"\u2717 Building {building_id}: {e}\")\n\n    # Summary\n    print(f\"\\n{'='*60}\")\n    print(f\"Batch Analysis Summary - {app_name}\")\n    print(f\"{'='*60}\")\n\n    successful = [r for r in results_summary if r['status'] == 'success']\n    failed = [r for r in results_summary if r['status'] == 'failed']\n\n    print(f\"Total: {len(model_files)}\")\n    print(f\"Analyzed: {len(successful)}\")\n    print(f\"Failed: {len(failed)}\")\n\n    if successful:\n        avg_temp_diff = sum(r['mean_temp_diff'] for r in successful) / len(successful)\n        print(f\"\\nAverage temp diff: {avg_temp_diff:.2f}\u00b0C\")\n\n    return results_summary\n\n# Use it\nresults = batch_run_app(\n    app_name=\"secondary_loop_temp_diff\",\n    model_dir=\"brick_models/\",\n    data_dir=\"timeseries_data/\",\n    output_base=\"./results\"\n)\n</code></pre>"},{"location":"user-guide/applications/running-apps/#parallel-batch-processing","title":"Parallel Batch Processing","text":"<pre><code>\"\"\"\nRun apps in parallel for faster processing\n\"\"\"\nfrom concurrent.futures import ProcessPoolExecutor, as_completed\nfrom hhw_brick import apps\n\ndef analyze_one_building(args):\n    \"\"\"Analyze one building (for parallel processing).\"\"\"\n    model_file, data_file, app_name, config = args\n\n    try:\n        app = apps.load_app(app_name)\n        results = app.analyze(str(model_file), str(data_file), config)\n        return {\n            'building': model_file.stem,\n            'status': 'success',\n            'summary': results['summary']\n        }\n    except Exception as e:\n        return {\n            'building': model_file.stem,\n            'status': 'failed',\n            'error': str(e)\n        }\n\ndef parallel_batch_run(app_name, model_dir, data_dir, max_workers=4):\n    \"\"\"Run app in parallel.\"\"\"\n\n    from pathlib import Path\n\n    app = apps.load_app(app_name)\n    config = apps.get_default_config(app_name)\n\n    # Prepare tasks\n    tasks = []\n    for model_file in Path(model_dir).glob(\"*.ttl\"):\n        building_id = model_file.stem.split('_')[1]\n\n        # Qualify\n        qualified, _ = app.qualify(str(model_file))\n        if not qualified:\n            continue\n\n        # Find data\n        data_file = Path(data_dir) / f\"{building_id}_data.csv\"\n        if not data_file.exists():\n            continue\n\n        # Configure\n        bldg_config = config.copy()\n        bldg_config['output']['output_dir'] = f\"./results/building_{building_id}\"\n\n        tasks.append((model_file, data_file, app_name, bldg_config))\n\n    # Execute in parallel\n    results = []\n    with ProcessPoolExecutor(max_workers=max_workers) as executor:\n        futures = {\n            executor.submit(analyze_one_building, task): task[0]\n            for task in tasks\n        }\n\n        for future in as_completed(futures):\n            result = future.result()\n            results.append(result)\n\n            status = \"\u2713\" if result['status'] == 'success' else \"\u2717\"\n            print(f\"{status} {result['building']}\")\n\n    return results\n\n# Use it\nresults = parallel_batch_run(\n    \"secondary_loop_temp_diff\",\n    \"brick_models/\",\n    \"timeseries_data/\",\n    max_workers=8\n)\n</code></pre>"},{"location":"user-guide/applications/running-apps/#configuration-management","title":"Configuration Management","text":""},{"location":"user-guide/applications/running-apps/#configuration-file-structure","title":"Configuration File Structure","text":"<pre><code># app_config.yaml\n\nanalysis:\n  # Analysis-specific parameters\n  threshold_min_delta: 0.5\n  threshold_max_delta: 10.0\n\noutput:\n  # Output settings\n  save_results: true\n  output_dir: ./results\n  export_format: csv\n  generate_plots: true\n  plot_format: png\n\ntime_range:\n  # Optional time filtering\n  start_time: \"2024-01-01 00:00:00\"\n  end_time: \"2024-12-31 23:59:59\"\n</code></pre>"},{"location":"user-guide/applications/running-apps/#using-configuration-files","title":"Using Configuration Files","text":"<pre><code>import yaml\n\n# Load config from file\nwith open('app_config.yaml', 'r') as f:\n    config = yaml.safe_load(f)\n\n# Use it\nresults = app.analyze(model_path, data_path, config)\n</code></pre>"},{"location":"user-guide/applications/running-apps/#dynamic-configuration","title":"Dynamic Configuration","text":"<pre><code>\"\"\"\nGenerate configs for different scenarios\n\"\"\"\n\ndef create_seasonal_configs(base_config, year=2024):\n    \"\"\"Create configs for seasonal analysis.\"\"\"\n\n    seasons = {\n        'winter': ('01-01', '03-31'),\n        'spring': ('04-01', '06-30'),\n        'summer': ('07-01', '09-30'),\n        'fall': ('10-01', '12-31')\n    }\n\n    configs = {}\n    for season, (start, end) in seasons.items():\n        config = base_config.copy()\n        config['time_range']['start_time'] = f\"{year}-{start} 00:00:00\"\n        config['time_range']['end_time'] = f\"{year}-{end} 23:59:59\"\n        config['output']['output_dir'] = f\"./results/{season}_{year}\"\n        configs[season] = config\n\n    return configs\n\n# Use it\nbase = apps.get_default_config(\"secondary_loop_temp_diff\")\nseasonal_configs = create_seasonal_configs(base, 2024)\n\nfor season, config in seasonal_configs.items():\n    results = app.analyze(model_path, data_path, config)\n    print(f\"{season}: {results['summary']['mean_temp_diff']:.2f}\u00b0C\")\n</code></pre>"},{"location":"user-guide/applications/running-apps/#results-management","title":"Results Management","text":""},{"location":"user-guide/applications/running-apps/#saving-results","title":"Saving Results","text":"<pre><code>\"\"\"\nSave and organize results\n\"\"\"\nimport json\nfrom datetime import datetime\n\ndef save_analysis_results(results, building_id, app_name, output_dir):\n    \"\"\"Save results with metadata.\"\"\"\n\n    from pathlib import Path\n    import pandas as pd\n\n    output_path = Path(output_dir)\n    output_path.mkdir(parents=True, exist_ok=True)\n\n    # Save summary as JSON\n    summary_file = output_path / f\"{building_id}_{app_name}_summary.json\"\n    summary_data = {\n        'building_id': building_id,\n        'app_name': app_name,\n        'analysis_date': datetime.now().isoformat(),\n        'summary': results['summary']\n    }\n    with open(summary_file, 'w') as f:\n        json.dump(summary_data, f, indent=2)\n\n    # Save detailed data as CSV\n    if 'data' in results:\n        data_file = output_path / f\"{building_id}_{app_name}_data.csv\"\n        df = pd.DataFrame(results['data'])\n        df.to_csv(data_file, index=False)\n\n    print(f\"Saved results to: {output_dir}\")\n\n# Use it\nresults = app.analyze(model_path, data_path, config)\nsave_analysis_results(results, \"105\", \"secondary_loop_temp_diff\", \"./results\")\n</code></pre>"},{"location":"user-guide/applications/running-apps/#aggregating-results","title":"Aggregating Results","text":"<pre><code>\"\"\"\nAggregate results from multiple buildings\n\"\"\"\nimport pandas as pd\n\ndef aggregate_building_results(results_dir):\n    \"\"\"Aggregate results from multiple analyses.\"\"\"\n\n    from pathlib import Path\n    import json\n\n    summary_files = Path(results_dir).rglob(\"*_summary.json\")\n\n    all_results = []\n    for file in summary_files:\n        with open(file, 'r') as f:\n            data = json.load(f)\n            all_results.append({\n                'building_id': data['building_id'],\n                'app': data['app_name'],\n                **data['summary']\n            })\n\n    # Create DataFrame\n    df = pd.DataFrame(all_results)\n\n    # Calculate statistics\n    print(\"Aggregated Results:\")\n    print(f\"  Total buildings: {len(df)}\")\n    print(f\"  Average temp diff: {df['mean_temp_diff'].mean():.2f}\u00b0C\")\n    print(f\"  Min temp diff: {df['mean_temp_diff'].min():.2f}\u00b0C\")\n    print(f\"  Max temp diff: {df['mean_temp_diff'].max():.2f}\u00b0C\")\n\n    # Save aggregate\n    df.to_csv(Path(results_dir) / \"aggregate_results.csv\", index=False)\n\n    return df\n\n# Use it\naggregate_df = aggregate_building_results(\"./results\")\n</code></pre>"},{"location":"user-guide/applications/running-apps/#error-handling","title":"Error Handling","text":""},{"location":"user-guide/applications/running-apps/#robust-execution","title":"Robust Execution","text":"<pre><code>\"\"\"\nProduction-ready application runner\n\"\"\"\nimport logging\nfrom pathlib import Path\n\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\ndef safe_run_app(model_path, data_path, app_name, config):\n    \"\"\"Run app with comprehensive error handling.\"\"\"\n\n    from hhw_brick import apps\n\n    try:\n        # Load app\n        app = apps.load_app(app_name)\n        logger.info(f\"Loaded app: {app_name}\")\n\n    except ImportError as e:\n        logger.error(f\"App not found: {app_name}\")\n        return None\n\n    try:\n        # Qualify\n        qualified, details = app.qualify(model_path)\n\n        if not qualified:\n            logger.warning(f\"Building not qualified for {app_name}\")\n            return None\n\n        logger.info(f\"Building qualified\")\n\n    except FileNotFoundError:\n        logger.error(f\"Model file not found: {model_path}\")\n        return None\n    except Exception as e:\n        logger.error(f\"Qualification failed: {e}\")\n        return None\n\n    try:\n        # Analyze\n        results = app.analyze(model_path, data_path, config)\n        logger.info(f\"Analysis complete\")\n        return results\n\n    except FileNotFoundError:\n        logger.error(f\"Data file not found: {data_path}\")\n        return None\n    except KeyError as e:\n        logger.error(f\"Missing data column: {e}\")\n        return None\n    except Exception as e:\n        logger.error(f\"Analysis failed: {e}\", exc_info=True)\n        return None\n\n# Use it\nresults = safe_run_app(\n    \"building_105.ttl\",\n    \"105_data.csv\",\n    \"secondary_loop_temp_diff\",\n    config\n)\n\nif results:\n    print(\"\u2713 Analysis successful\")\nelse:\n    print(\"\u2717 Analysis failed - check logs\")\n</code></pre>"},{"location":"user-guide/applications/running-apps/#best-practices","title":"Best Practices","text":""},{"location":"user-guide/applications/running-apps/#1-validate-before-analyzing","title":"1. Validate Before Analyzing","text":"<pre><code># Good \u2713\nvalidator = BrickModelValidator(use_local_brick=True)\nif validator.validate_ontology(model_path)['valid']:\n    results = app.analyze(model_path, data_path, config)\n\n# Bad \u2717\nresults = app.analyze(model_path, data_path, config)  # Might fail\n</code></pre>"},{"location":"user-guide/applications/running-apps/#2-check-data-quality","title":"2. Check Data Quality","text":"<pre><code># Good \u2713\ndf = pd.read_csv(data_path)\nif len(df) &lt; 100:\n    print(\"Warning: Limited data points\")\nif df.isnull().any().any():\n    print(\"Warning: Missing values detected\")\n\n# Then analyze\nresults = app.analyze(model_path, data_path, config)\n</code></pre>"},{"location":"user-guide/applications/running-apps/#3-use-configuration-files","title":"3. Use Configuration Files","text":"<pre><code># Good \u2713 - Reproducible\nconfig = yaml.safe_load(open('config.yaml'))\nresults = app.analyze(model_path, data_path, config)\n\n# Save config with results\nwith open('results/config_used.yaml', 'w') as f:\n    yaml.dump(config, f)\n</code></pre>"},{"location":"user-guide/applications/running-apps/#4-handle-failures-gracefully","title":"4. Handle Failures Gracefully","text":"<pre><code># Good \u2713\nfor building in buildings:\n    try:\n        results = app.analyze(building.model, building.data, config)\n        save_results(results)\n    except Exception as e:\n        logger.error(f\"Failed: {building.id} - {e}\")\n        continue  # Continue with next building\n</code></pre>"},{"location":"user-guide/applications/running-apps/#next-steps","title":"Next Steps","text":"<ul> <li>Developer Guide - Create your own applications</li> <li>Examples - More code samples</li> <li>API Reference - Complete API docs</li> </ul> <p>Applications documentation complete! \ud83c\udf89</p> <p>Ready to analyze your building data! Start with Apps Manager or Secondary Loop.</p>"},{"location":"user-guide/applications/secondary-loop/","title":"Secondary Loop Temperature Difference","text":"<p>Analyze temperature difference between supply and return water in secondary hot water loops.</p>"},{"location":"user-guide/applications/secondary-loop/#overview","title":"Overview","text":"<p>The Secondary Loop Temperature Difference application analyzes the temperature differential in building secondary loops. This helps:</p> <ul> <li>Monitor performance - Track loop efficiency</li> <li>Identify issues - Detect circulation problems</li> <li>Optimize operation - Understand load patterns</li> <li>Save energy - Find opportunities for improvement</li> </ul>"},{"location":"user-guide/applications/secondary-loop/#what-it-does","title":"What It Does","text":""},{"location":"user-guide/applications/secondary-loop/#analysis","title":"Analysis","text":"<pre><code>graph LR\n    SS[Secondary&lt;br/&gt;Supply Temp] --&gt;|Subtract| TD[Temperature&lt;br/&gt;Difference]\n    SR[Secondary&lt;br/&gt;Return Temp] --&gt;|Subtract| TD\n    TD --&gt; A[Analysis]\n    A --&gt; M[Metrics]\n    A --&gt; P[Plots]\n    A --&gt; R[Reports]\n\n    style SS fill:#ff9800\n    style SR fill:#2196f3\n    style TD fill:#4caf50</code></pre> <p>Calculates: - Temperature difference: Supply - Return - Statistical metrics: Mean, max, min, std dev - Time-series analysis: Trends over time - Visualizations: Plots and charts</p>"},{"location":"user-guide/applications/secondary-loop/#required-sensors","title":"Required Sensors","text":"<p>The building must have both sensors on the same secondary loop:</p> Sensor Type Brick Class Purpose Supply Temperature <code>Supply_Water_Temperature_Sensor</code> or<code>Leaving_Hot_Water_Temperature_Sensor</code> or<code>Hot_Water_Supply_Temperature_Sensor</code> Measures temperature leaving loop Return Temperature <code>Return_Water_Temperature_Sensor</code> or<code>Entering_Hot_Water_Temperature_Sensor</code> or<code>Hot_Water_Return_Temperature_Sensor</code> Measures temperature returning to loop <p>Secondary Loop Only</p> <p>This app specifically looks for sensors on secondary loops (not primary loops). It identifies secondary loops by checking if the equipment URI contains \"secondary\".</p>"},{"location":"user-guide/applications/secondary-loop/#quick-start","title":"Quick Start","text":""},{"location":"user-guide/applications/secondary-loop/#basic-usage","title":"Basic Usage","text":"<pre><code>from hhw_brick import apps\n\n# Load app\napp = apps.load_app(\"secondary_loop_temp_diff\")\n\n# Qualify building\nqualified, details = app.qualify(\"building_105.ttl\")\n\nif qualified:\n    # Get config\n    config = apps.get_default_config(\"secondary_loop_temp_diff\")\n\n    # Run analysis\n    results = app.analyze(\n        brick_model_path=\"building_105.ttl\",\n        timeseries_data_path=\"building_105_data.csv\",\n        config=config\n    )\n\n    # View results\n    print(f\"Mean Temp Diff: {results['summary']['mean_temp_diff']:.2f}\u00b0C\")\n    print(f\"Max Temp Diff: {results['summary']['max_temp_diff']:.2f}\u00b0C\")\n</code></pre>"},{"location":"user-guide/applications/secondary-loop/#qualification","title":"Qualification","text":""},{"location":"user-guide/applications/secondary-loop/#qualify","title":"qualify()","text":"<p>Check if building has required sensors.</p> <p>Signature: <pre><code>def qualify(brick_model_path: str) -&gt; Tuple[bool, Dict]\n</code></pre></p> <p>Returns: <pre><code>(True, {\n    'loop': 'https://hhws.example.org#Secondary_Loop',\n    'supply': 'https://hhws.example.org#Secondary_Supply_Temp',\n    'return': 'https://hhws.example.org#Secondary_Return_Temp'\n})\n</code></pre></p> <p>Example: <pre><code>qualified, details = app.qualify(\"building_105.ttl\")\n\nif qualified:\n    print(\"\u2713 Building qualified\")\n    print(f\"  Loop: {details['loop'].split('#')[-1]}\")\n    print(f\"  Supply: {details['supply'].split('#')[-1]}\")\n    print(f\"  Return: {details['return'].split('#')[-1]}\")\nelse:\n    print(\"\u2717 Building not qualified\")\n    print(\"  Missing secondary loop sensors\")\n</code></pre></p>"},{"location":"user-guide/applications/secondary-loop/#what-gets-checked","title":"What Gets Checked","text":"<p>The qualification process:</p> <ol> <li>Loads Brick model - Parses TTL file</li> <li>Finds secondary loops - Looks for <code>Hot_Water_Loop</code> entities with \"secondary\" in URI</li> <li>Searches for sensors - Finds supply and return temperature sensors</li> <li>Validates pairing - Ensures both sensors are on the same loop</li> </ol> <p>SPARQL Query Used: <pre><code>SELECT ?equipment ?supply ?return WHERE {\n    # Find secondary hot water loops\n    ?equipment rdf:type/rdfs:subClassOf* brick:Hot_Water_Loop .\n    FILTER(CONTAINS(LCASE(STR(?equipment)), \"secondary\"))\n\n    # Find supply temperature sensor\n    ?supply rdf:type/rdfs:subClassOf* ?supply_type .\n    VALUES ?supply_type {\n        brick:Supply_Water_Temperature_Sensor\n        brick:Leaving_Hot_Water_Temperature_Sensor\n        brick:Hot_Water_Supply_Temperature_Sensor\n    }\n\n    # Find return temperature sensor\n    ?return rdf:type/rdfs:subClassOf* ?return_type .\n    VALUES ?return_type {\n        brick:Return_Water_Temperature_Sensor\n        brick:Entering_Hot_Water_Temperature_Sensor\n        brick:Hot_Water_Return_Temperature_Sensor\n    }\n\n    # Both must be associated with the loop\n    {\n        ?equipment brick:hasPart ?supply .\n        ?equipment brick:hasPart ?return .\n    } UNION {\n        ?supply brick:isPointOf ?equipment .\n        ?return brick:isPointOf ?equipment .\n    }\n}\n</code></pre></p>"},{"location":"user-guide/applications/secondary-loop/#analysis_1","title":"Analysis","text":""},{"location":"user-guide/applications/secondary-loop/#analyze","title":"analyze()","text":"<p>Run temperature difference analysis.</p> <p>Signature: <pre><code>def analyze(\n    brick_model_path: str,\n    timeseries_data_path: str,\n    config: Dict\n) -&gt; Dict\n</code></pre></p> <p>Parameters: - <code>brick_model_path</code> (str): Path to Brick model TTL file - <code>timeseries_data_path</code> (str): Path to CSV data file - <code>config</code> (dict): Configuration dictionary</p> <p>Returns: <pre><code>{\n    'summary': {\n        'mean_temp_diff': 5.2,\n        'max_temp_diff': 12.1,\n        'min_temp_diff': 0.3,\n        'std_temp_diff': 2.1,\n        'data_points': 8760\n    },\n    'outputs': [\n        'results/temp_diff_plot.png',\n        'results/statistics.csv',\n        'results/hourly_data.csv'\n    ],\n    'data': {\n        'timestamps': [...],\n        'temp_diff': [...],\n        'supply_temp': [...],\n        'return_temp': [...]\n    }\n}\n</code></pre></p>"},{"location":"user-guide/applications/secondary-loop/#analysis-workflow","title":"Analysis Workflow","text":"<pre><code>graph TD\n    A[Load Brick Model] --&gt; B[Qualify Sensors]\n    B --&gt; C[Load Timeseries Data]\n    C --&gt; D[Map Sensors to Columns]\n    D --&gt; E[Calculate Temp Diff]\n    E --&gt; F[Compute Statistics]\n    F --&gt; G[Generate Plots]\n    G --&gt; H[Save Results]\n\n    style A fill:#e1f5ff\n    style E fill:#fff9c4\n    style H fill:#c8e6c9</code></pre> <p>Steps:</p> <ol> <li>QUALIFY - Check for required sensors</li> <li>FETCH - Load timeseries data</li> <li>MAP - Match sensors to data columns</li> <li>CALCULATE - Compute temperature difference</li> <li>ANALYZE - Calculate statistics</li> <li>VISUALIZE - Generate plots</li> <li>OUTPUT - Save results</li> </ol>"},{"location":"user-guide/applications/secondary-loop/#configuration","title":"Configuration","text":""},{"location":"user-guide/applications/secondary-loop/#default-configuration","title":"Default Configuration","text":"<pre><code>analysis:\n  threshold_min_delta: 0.5    # Minimum expected temp diff (\u00b0C)\n  threshold_max_delta: 10.0   # Maximum expected temp diff (\u00b0C)\n\noutput:\n  save_results: true\n  output_dir: ./results\n  export_format: csv\n  generate_plots: true\n  plot_format: png\n\ntime_range:\n  start_time: null  # Optional: \"2024-01-01 00:00:00\"\n  end_time: null    # Optional: \"2024-12-31 23:59:59\"\n</code></pre>"},{"location":"user-guide/applications/secondary-loop/#configuration-options","title":"Configuration Options","text":"Parameter Type Default Description <code>analysis.threshold_min_delta</code> float 0.5 Minimum expected temperature difference (\u00b0C) <code>analysis.threshold_max_delta</code> float 10.0 Maximum expected temperature difference (\u00b0C) <code>output.save_results</code> bool true Save analysis results to files <code>output.output_dir</code> str \"./results\" Directory for output files <code>output.export_format</code> str \"csv\" Format for data export (csv, excel) <code>output.generate_plots</code> bool true Generate visualization plots <code>output.plot_format</code> str \"png\" Plot image format (png, pdf, svg) <code>time_range.start_time</code> str null Start time for analysis (ISO format) <code>time_range.end_time</code> str null End time for analysis (ISO format)"},{"location":"user-guide/applications/secondary-loop/#custom-configuration","title":"Custom Configuration","text":"<pre><code>import yaml\n\n# Load default\nconfig = apps.get_default_config(\"secondary_loop_temp_diff\")\n\n# Customize\nconfig['analysis']['threshold_min_delta'] = 1.0\nconfig['analysis']['threshold_max_delta'] = 15.0\nconfig['output']['output_dir'] = './custom_results'\nconfig['output']['generate_plots'] = True\nconfig['time_range']['start_time'] = \"2024-01-01 00:00:00\"\nconfig['time_range']['end_time'] = \"2024-03-31 23:59:59\"\n\n# Save\nwith open('custom_config.yaml', 'w') as f:\n    yaml.dump(config, f)\n\n# Use it\nresults = app.analyze(model_path, data_path, config)\n</code></pre>"},{"location":"user-guide/applications/secondary-loop/#data-format","title":"Data Format","text":""},{"location":"user-guide/applications/secondary-loop/#timeseries-data-csv","title":"Timeseries Data CSV","text":"<p>Expected format:</p> <pre><code>datetime,secondary_supply_temp,secondary_return_temp\n2024-01-01 00:00:00,70.5,65.3\n2024-01-01 01:00:00,71.2,66.1\n2024-01-01 02:00:00,69.8,64.7\n...\n</code></pre> <p>Requirements: - datetime column - Timestamp for each row - Temperature columns - Sensor data (column names will be matched to Brick model) - Numeric values - Temperature in \u00b0C or \u00b0F - Regular intervals - Hourly, 15-min, etc. (any interval works)</p>"},{"location":"user-guide/applications/secondary-loop/#column-mapping","title":"Column Mapping","text":"<p>The app automatically maps Brick sensors to CSV columns:</p> <pre><code># Brick model has:\n# :Secondary_Supply_Temp a brick:Supply_Water_Temperature_Sensor\n\n# CSV column might be:\n# \"secondary_supply_temp\" or \"sup_temp_sec\" or \"sec_loop_supply\"\n\n# App automatically finds the match!\n</code></pre>"},{"location":"user-guide/applications/secondary-loop/#results","title":"Results","text":""},{"location":"user-guide/applications/secondary-loop/#summary-metrics","title":"Summary Metrics","text":"<pre><code>results['summary'] = {\n    'mean_temp_diff': 5.2,      # Average temperature difference\n    'max_temp_diff': 12.1,      # Maximum observed\n    'min_temp_diff': 0.3,       # Minimum observed\n    'std_temp_diff': 2.1,       # Standard deviation\n    'data_points': 8760,        # Number of data points analyzed\n    'start_time': '2024-01-01', # Analysis period start\n    'end_time': '2024-12-31'    # Analysis period end\n}\n</code></pre>"},{"location":"user-guide/applications/secondary-loop/#generated-files","title":"Generated Files","text":"<p>Typical outputs (when <code>save_results=true</code>):</p> <pre><code>results/\n\u251c\u2500\u2500 temp_diff_plot.png          # Time-series plot\n\u251c\u2500\u2500 statistics.csv              # Statistical summary\n\u251c\u2500\u2500 hourly_data.csv            # Detailed hourly results\n\u2514\u2500\u2500 distribution_plot.png       # Temperature difference distribution\n</code></pre>"},{"location":"user-guide/applications/secondary-loop/#visualizations","title":"Visualizations","text":"<p>Time-Series Plot: Shows temperature difference over time with supply and return temperatures.</p> <p>Distribution Plot: Histogram of temperature differences showing frequency distribution.</p>"},{"location":"user-guide/applications/secondary-loop/#examples","title":"Examples","text":""},{"location":"user-guide/applications/secondary-loop/#basic-analysis","title":"Basic Analysis","text":"<pre><code>from hhw_brick import apps\n\napp = apps.load_app(\"secondary_loop_temp_diff\")\n\n# Qualify\nqualified, details = app.qualify(\"building_105.ttl\")\n\nif qualified:\n    # Run with defaults\n    config = apps.get_default_config(\"secondary_loop_temp_diff\")\n    results = app.analyze(\n        \"building_105.ttl\",\n        \"building_105_data.csv\",\n        config\n    )\n\n    # Print summary\n    print(\"Analysis Summary:\")\n    for key, value in results['summary'].items():\n        print(f\"  {key}: {value}\")\n</code></pre>"},{"location":"user-guide/applications/secondary-loop/#time-range-analysis","title":"Time-Range Analysis","text":"<pre><code># Analyze specific time period\nconfig = apps.get_default_config(\"secondary_loop_temp_diff\")\nconfig['time_range']['start_time'] = \"2024-06-01 00:00:00\"\nconfig['time_range']['end_time'] = \"2024-08-31 23:59:59\"\n\nresults = app.analyze(model_path, data_path, config)\nprint(f\"Summer average temp diff: {results['summary']['mean_temp_diff']:.2f}\u00b0C\")\n</code></pre>"},{"location":"user-guide/applications/secondary-loop/#custom-output-directory","title":"Custom Output Directory","text":"<pre><code># Save to specific directory\nconfig = apps.get_default_config(\"secondary_loop_temp_diff\")\nconfig['output']['output_dir'] = f\"./results/building_105\"\nconfig['output']['generate_plots'] = True\n\nresults = app.analyze(model_path, data_path, config)\n\nprint(\"Generated files:\")\nfor file_path in results['outputs']:\n    print(f\"  - {file_path}\")\n</code></pre>"},{"location":"user-guide/applications/secondary-loop/#batch-analysis","title":"Batch Analysis","text":"<pre><code>\"\"\"\nRun secondary loop analysis on multiple buildings\n\"\"\"\nfrom pathlib import Path\nfrom hhw_brick import apps\n\napp = apps.load_app(\"secondary_loop_temp_diff\")\nconfig = apps.get_default_config(\"secondary_loop_temp_diff\")\n\nmodel_dir = Path(\"brick_models\")\ndata_dir = Path(\"timeseries_data\")\n\nfor model_file in model_dir.glob(\"*.ttl\"):\n    building_id = model_file.stem.split('_')[1]\n\n    # Qualify\n    qualified, details = app.qualify(str(model_file))\n\n    if not qualified:\n        continue\n\n    # Find data file\n    data_file = data_dir / f\"{building_id}_data.csv\"\n\n    if not data_file.exists():\n        continue\n\n    # Run analysis\n    try:\n        config['output']['output_dir'] = f\"./results/building_{building_id}\"\n        results = app.analyze(str(model_file), str(data_file), config)\n\n        print(f\"Building {building_id}:\")\n        print(f\"  Mean temp diff: {results['summary']['mean_temp_diff']:.2f}\u00b0C\")\n    except Exception as e:\n        print(f\"Building {building_id}: Failed - {e}\")\n</code></pre>"},{"location":"user-guide/applications/secondary-loop/#troubleshooting","title":"Troubleshooting","text":""},{"location":"user-guide/applications/secondary-loop/#issue-building-not-qualified","title":"Issue: Building not qualified","text":"<p>Check: 1. Building has secondary loop (URI contains \"secondary\") 2. Loop has both supply and return temperature sensors 3. Sensors use recognized Brick classes</p> <pre><code># Debug\nfrom rdflib import Graph\n\ng = Graph()\ng.parse(\"building_105.ttl\", format=\"turtle\")\n\n# Check for secondary loops\nquery = \"\"\"\nSELECT ?loop WHERE {\n    ?loop a/rdfs:subClassOf* brick:Hot_Water_Loop .\n    FILTER(CONTAINS(LCASE(STR(?loop)), \"secondary\"))\n}\n\"\"\"\n\nfor row in g.query(query):\n    print(f\"Found loop: {row.loop}\")\n</code></pre>"},{"location":"user-guide/applications/secondary-loop/#issue-column-mapping-failed","title":"Issue: Column mapping failed","text":"<p>Solution: Check CSV column names match sensors:</p> <pre><code>import pandas as pd\n\ndf = pd.read_csv(\"building_105_data.csv\")\nprint(\"Available columns:\")\nprint(df.columns.tolist())\n</code></pre>"},{"location":"user-guide/applications/secondary-loop/#issue-no-data-in-time-range","title":"Issue: No data in time range","text":"<p>Check: Time range configuration:</p> <pre><code>config['time_range']['start_time'] = \"2024-01-01 00:00:00\"\nconfig['time_range']['end_time'] = \"2024-12-31 23:59:59\"\n</code></pre>"},{"location":"user-guide/applications/secondary-loop/#best-practices","title":"Best Practices","text":""},{"location":"user-guide/applications/secondary-loop/#1-always-qualify-first","title":"1. Always Qualify First","text":"<pre><code># Good \u2713\nqualified, details = app.qualify(model_path)\nif qualified:\n    results = app.analyze(model_path, data_path, config)\n</code></pre>"},{"location":"user-guide/applications/secondary-loop/#2-check-data-quality","title":"2. Check Data Quality","text":"<pre><code># Verify data before analysis\ndf = pd.read_csv(data_path)\nprint(f\"Data points: {len(df)}\")\nprint(f\"Date range: {df['datetime'].min()} to {df['datetime'].max()}\")\n</code></pre>"},{"location":"user-guide/applications/secondary-loop/#3-save-configuration","title":"3. Save Configuration","text":"<pre><code># Save config for reproducibility\nwith open('analysis_config.yaml', 'w') as f:\n    yaml.dump(config, f)\n</code></pre>"},{"location":"user-guide/applications/secondary-loop/#next-steps","title":"Next Steps","text":"<ul> <li>Primary Loop App - Analyze primary loop temperature difference</li> <li>Running Apps Guide - Complete application workflow</li> <li>Examples - More code samples</li> </ul> <p>Continue to: Primary Loop Temperature Difference \u2192</p>"},{"location":"user-guide/conversion/","title":"CSV to Brick Conversion","text":"<p>Complete guide to converting heating hot water system data from CSV format to Brick ontology models.</p>"},{"location":"user-guide/conversion/#overview","title":"Overview","text":"<p>The conversion module transforms your building equipment data into standardized Brick ontology format. This enables:</p> <ul> <li>Interoperability - Use the same data with different tools</li> <li>Portability - Move analytics between buildings</li> <li>Standardization - Common vocabulary for all buildings</li> </ul>"},{"location":"user-guide/conversion/#conversion-process","title":"Conversion Process","text":"<pre><code>graph TD\n    A[CSV Files] --&gt;|Read| B[Parse Data]\n    B --&gt;|Identify| C[System Type]\n    C --&gt;|Map| D[Brick Classes]\n    D --&gt;|Create| E[Equipment Entities]\n    E --&gt;|Add| F[Points/Sensors]\n    F --&gt;|Link| G[Relationships]\n    G --&gt;|Generate| H[RDF Graph]\n    H --&gt;|Serialize| I[TTL File]\n\n    style A fill:#e1f5ff\n    style I fill:#c8e6c9</code></pre>"},{"location":"user-guide/conversion/#what-gets-converted","title":"What Gets Converted","text":"Source Destination Building metadata <code>rec:Building</code> entity System type Equipment classes (Boiler, HX, etc.) Sensor availability Point entities and <code>hasPoint</code> relationships System topology <code>feeds</code> relationships between equipment"},{"location":"user-guide/conversion/#conversion-methods","title":"Conversion Methods","text":""},{"location":"user-guide/conversion/#1-single-building-conversion","title":"1. Single Building Conversion","text":"<p>Convert one building at a time with full control:</p> <pre><code>from hhw_brick import CSVToBrickConverter\n\nconverter = CSVToBrickConverter()\nresult = converter.convert_to_brick(\n    metadata_csv=\"metadata.csv\",\n    vars_csv=\"vars_available_by_building.csv\",\n    building_tag=\"105\",\n    output_path=\"building_105.ttl\"\n)\n</code></pre> <p>Best for: - Testing and development - Single building focus - Custom output paths</p> <p>Learn more \u2192</p>"},{"location":"user-guide/conversion/#2-batch-conversion","title":"2. Batch Conversion","text":"<p>Convert multiple buildings at once:</p> <pre><code>from hhw_brick import BatchConverter\n\nbatch = BatchConverter()\nresults = batch.convert_all_buildings(\n    metadata_csv=\"metadata.csv\",\n    vars_csv=\"vars_available_by_building.csv\",\n    output_dir=\"brick_models/\",\n    show_progress=True\n)\n</code></pre> <p>Best for: - Portfolio-wide conversion - Production workflows - Large datasets</p> <p>Learn more \u2192</p>"},{"location":"user-guide/conversion/#3-system-type-filtering","title":"3. System Type Filtering","text":"<p>Convert only specific system types:</p> <pre><code># Convert only condensing systems\nresult = converter.convert_to_brick(\n    metadata_csv=\"metadata.csv\",\n    vars_csv=\"vars_available_by_building.csv\",\n    system_type=\"Condensing\",\n    output_path=\"condensing_systems.ttl\"\n)\n</code></pre> <p>Learn more \u2192</p>"},{"location":"user-guide/conversion/#module-components","title":"Module Components","text":""},{"location":"user-guide/conversion/#csvtobrickconverter","title":"CSVToBrickConverter","text":"<p>Main conversion class for single buildings.</p> <p>Key Methods:</p> <pre><code>converter = CSVToBrickConverter()\n\n# Primary conversion method\nresult = converter.convert_to_brick(\n    metadata_csv: str,\n    vars_csv: str,\n    system_type: Optional[str] = None,\n    building_tag: Optional[str] = None,\n    sensor_mapping: Optional[str] = None,\n    output_path: str = \"output.ttl\"\n) -&gt; Graph\n</code></pre> <p>Parameters: - <code>metadata_csv</code> - Building information file - <code>vars_csv</code> - Sensor availability file - <code>system_type</code> - Filter by system (optional) - <code>building_tag</code> - Specific building ID (optional) - <code>sensor_mapping</code> - Custom mapping file (optional) - <code>output_path</code> - Where to save the model</p> <p>Returns: RDFLib Graph object</p> <p>API Reference \u2192</p>"},{"location":"user-guide/conversion/#batchconverter","title":"BatchConverter","text":"<p>Batch processing for multiple buildings.</p> <p>Key Methods:</p> <pre><code>batch = BatchConverter()\n\n# Convert all buildings\nresults = batch.convert_all_buildings(\n    metadata_csv: str,\n    vars_csv: str,\n    output_dir: str,\n    system_type: Optional[str] = None,\n    building_tags: Optional[List[str]] = None,\n    show_progress: bool = True\n) -&gt; Dict[str, Any]\n</code></pre> <p>Returns: Statistics dictionary with: - <code>total</code> - Total buildings processed - <code>successful</code> - Successfully converted - <code>failed</code> - Failed conversions - <code>by_system</code> - Breakdown by system type - <code>total_triples</code> - Total RDF statements created</p> <p>API Reference \u2192</p>"},{"location":"user-guide/conversion/#common-workflows","title":"Common Workflows","text":""},{"location":"user-guide/conversion/#workflow-1-single-building-development","title":"Workflow 1: Single Building Development","text":"<pre><code>\"\"\"\nDevelopment workflow for a single building\n\"\"\"\nfrom hhw_brick import CSVToBrickConverter, BrickModelValidator\n\n# Convert\nconverter = CSVToBrickConverter()\nmodel = converter.convert_to_brick(\n    metadata_csv=\"metadata.csv\",\n    vars_csv=\"vars.csv\",\n    building_tag=\"105\",\n    output_path=\"building_105.ttl\"\n)\n\nprint(f\"Created {len(model)} triples\")\n\n# Validate\nvalidator = BrickModelValidator()\nis_valid, report = validator.validate_model(\"building_105.ttl\")\n\nif is_valid:\n    print(\"\u2713 Model is valid\")\nelse:\n    print(\"\u26a0 Warnings:\", report)\n</code></pre>"},{"location":"user-guide/conversion/#workflow-2-batch-production","title":"Workflow 2: Batch Production","text":"<pre><code>\"\"\"\nProduction workflow for multiple buildings\n\"\"\"\nfrom hhw_brick import BatchConverter\nfrom pathlib import Path\n\n# Set up output directory\noutput_dir = Path(\"brick_models\")\noutput_dir.mkdir(exist_ok=True)\n\n# Batch convert\nbatch = BatchConverter()\nresults = batch.convert_all_buildings(\n    metadata_csv=\"metadata.csv\",\n    vars_csv=\"vars.csv\",\n    output_dir=str(output_dir),\n    show_progress=True\n)\n\n# Report results\nprint(f\"\\nConversion Summary:\")\nprint(f\"  Total: {results['total']}\")\nprint(f\"  Successful: {results['successful']}\")\nprint(f\"  Failed: {results['failed']}\")\nprint(f\"  Total RDF triples: {results['total_triples']:,}\")\n\n# Breakdown by system\nprint(f\"\\nBy System Type:\")\nfor system, count in results['by_system'].items():\n    print(f\"  {system}: {count}\")\n</code></pre>"},{"location":"user-guide/conversion/#workflow-3-filtered-conversion","title":"Workflow 3: Filtered Conversion","text":"<pre><code>\"\"\"\nConvert only specific buildings or system types\n\"\"\"\n\n# Option 1: Specific buildings\ntarget_buildings = [\"105\", \"106\", \"107\"]\nbatch = BatchConverter()\nresults = batch.convert_all_buildings(\n    metadata_csv=\"metadata.csv\",\n    vars_csv=\"vars.csv\",\n    output_dir=\"selected_buildings/\",\n    building_tags=target_buildings\n)\n\n# Option 2: Specific system type\nresults = batch.convert_all_buildings(\n    metadata_csv=\"metadata.csv\",\n    vars_csv=\"vars.csv\",\n    output_dir=\"condensing_only/\",\n    system_type=\"Condensing\"\n)\n</code></pre>"},{"location":"user-guide/conversion/#output-files","title":"Output Files","text":""},{"location":"user-guide/conversion/#file-naming-convention","title":"File Naming Convention","text":"<p>Single building: <pre><code>building_{tag}_{system}_{variant}.ttl\n</code></pre></p> <p>Example: <code>building_105_non-condensing_h.ttl</code></p> <p>Batch conversion: <pre><code>building_{tag}_{system_abbrev}_{variant}.ttl\n</code></pre></p> <p>All files go to the specified <code>output_dir</code>.</p>"},{"location":"user-guide/conversion/#file-contents","title":"File Contents","text":"<p>Each TTL file contains:</p> <pre><code># Ontology declaration\n@prefix brick: &lt;https://brickschema.org/schema/Brick#&gt; .\n@prefix hhws: &lt;https://hhws.example.org#&gt; .\n@prefix rec: &lt;https://w3id.org/rec#&gt; .\n\n&lt;ontology_uri&gt; a owl:Ontology ;\n    owl:imports &lt;https://brickschema.org/schema/1.3/Brick&gt; .\n\n# Building entity\n:Building_105 a rec:Building ;\n    brick:hasLocation :Building_105_location .\n\n# Equipment entities\n:Boiler_Primary a brick:Boiler ;\n    brick:feeds :Heat_Exchanger .\n\n# Points/sensors\n:HW_Supply_Temp a brick:Hot_Water_Supply_Temperature_Sensor .\n\n# Relationships\n:Boiler_Primary brick:hasPoint :HW_Supply_Temp .\n</code></pre>"},{"location":"user-guide/conversion/#advanced-features","title":"Advanced Features","text":""},{"location":"user-guide/conversion/#custom-sensor-mapping","title":"Custom Sensor Mapping","text":"<p>Provide your own sensor mapping:</p> <pre><code>result = converter.convert_to_brick(\n    metadata_csv=\"metadata.csv\",\n    vars_csv=\"vars.csv\",\n    sensor_mapping=\"my_custom_mapping.yaml\",\n    output_path=\"output.ttl\"\n)\n</code></pre> <p>Learn more \u2192</p>"},{"location":"user-guide/conversion/#accessing-warnings","title":"Accessing Warnings","text":"<p>Check conversion warnings:</p> <pre><code>converter = CSVToBrickConverter()\nresult = converter.convert_to_brick(...)\n\n# Check for warnings\nif converter.validation_warnings:\n    print(\"Conversion warnings:\")\n    for warning in converter.validation_warnings:\n        print(f\"  - {warning}\")\n</code></pre>"},{"location":"user-guide/conversion/#working-with-graph-objects","title":"Working with Graph Objects","text":"<p>Use the returned Graph object directly:</p> <pre><code># Get the graph without saving\nresult_graph = converter.convert_to_brick(\n    metadata_csv=\"metadata.csv\",\n    vars_csv=\"vars.csv\",\n    building_tag=\"105\",\n    output_path=\"temp.ttl\"\n)\n\n# Query it\nquery = \"\"\"\nSELECT ?equip WHERE {\n    ?equip a brick:Boiler .\n}\n\"\"\"\n\nfor row in result_graph.query(query):\n    print(f\"Found boiler: {row.equip}\")\n\n# Serialize in different formats\nresult_graph.serialize(\"output.xml\", format=\"xml\")\nresult_graph.serialize(\"output.json\", format=\"json-ld\")\n</code></pre>"},{"location":"user-guide/conversion/#performance-considerations","title":"Performance Considerations","text":""},{"location":"user-guide/conversion/#large-datasets","title":"Large Datasets","text":"<p>For hundreds of buildings:</p> <pre><code># Use batch converter with progress bar\nbatch = BatchConverter()\nresults = batch.convert_all_buildings(\n    metadata_csv=\"large_dataset.csv\",\n    vars_csv=\"large_vars.csv\",\n    output_dir=\"models/\",\n    show_progress=True  # Shows progress bar\n)\n</code></pre>"},{"location":"user-guide/conversion/#memory-usage","title":"Memory Usage","text":"<p>Each building's graph is created and cleared independently, so memory usage stays constant regardless of dataset size.</p>"},{"location":"user-guide/conversion/#error-handling","title":"Error Handling","text":""},{"location":"user-guide/conversion/#common-errors","title":"Common Errors","text":"<p>FileNotFoundError: <pre><code>try:\n    result = converter.convert_to_brick(\n        metadata_csv=\"missing.csv\",\n        vars_csv=\"vars.csv\"\n    )\nexcept FileNotFoundError as e:\n    print(f\"File not found: {e}\")\n</code></pre></p> <p>ValueError (no data): <pre><code>try:\n    result = converter.convert_to_brick(\n        metadata_csv=\"metadata.csv\",\n        vars_csv=\"vars.csv\",\n        building_tag=\"999\"  # Doesn't exist\n    )\nexcept ValueError as e:\n    print(f\"No data for building: {e}\")\n</code></pre></p>"},{"location":"user-guide/conversion/#robust-conversion-script","title":"Robust Conversion Script","text":"<pre><code>\"\"\"\nProduction conversion script with error handling\n\"\"\"\nfrom hhw_brick import BatchConverter\nimport logging\n\n# Set up logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(levelname)s - %(message)s'\n)\n\ndef convert_with_error_handling():\n    batch = BatchConverter()\n\n    try:\n        results = batch.convert_all_buildings(\n            metadata_csv=\"metadata.csv\",\n            vars_csv=\"vars.csv\",\n            output_dir=\"brick_models/\",\n            show_progress=True\n        )\n\n        # Log results\n        logging.info(f\"Converted {results['successful']} buildings\")\n\n        if results['failed'] &gt; 0:\n            logging.warning(f\"Failed: {results['failed']}\")\n            for building in results.get('failed_buildings', []):\n                logging.error(f\"  - Building {building}\")\n\n        return results\n\n    except FileNotFoundError as e:\n        logging.error(f\"Input file not found: {e}\")\n        return None\n    except Exception as e:\n        logging.error(f\"Unexpected error: {e}\")\n        return None\n\nif __name__ == \"__main__\":\n    convert_with_error_handling()\n</code></pre>"},{"location":"user-guide/conversion/#next-steps","title":"Next Steps","text":""},{"location":"user-guide/conversion/#deep-dive-into-conversion","title":"Deep Dive into Conversion","text":"<ul> <li>Single Building - Detailed single building guide</li> <li>Batch Conversion - Multi-building workflows</li> <li>System Types - Understanding HVAC systems</li> <li>Sensor Mapping - Customize sensor mapping</li> </ul>"},{"location":"user-guide/conversion/#related-topics","title":"Related Topics","text":"<ul> <li>Validation - Validate converted models</li> <li>Examples - Working code samples</li> <li>API Reference - Complete API docs</li> </ul> <p>Continue to: Single Building Conversion \u2192</p>"},{"location":"user-guide/conversion/batch-conversion/","title":"Batch Conversion","text":"<p>Efficiently convert multiple buildings from CSV to Brick format in a single operation.</p>"},{"location":"user-guide/conversion/batch-conversion/#overview","title":"Overview","text":"<p>Batch conversion is designed for processing multiple buildings at once. It's ideal for:</p> <ul> <li>Portfolio-wide conversion - Convert all buildings in a dataset</li> <li>Production workflows - Automated, repeatable processes  </li> <li>Large-scale operations - Hundreds of buildings</li> <li>Progress tracking - Visual progress bars</li> </ul>"},{"location":"user-guide/conversion/batch-conversion/#basic-usage","title":"Basic Usage","text":""},{"location":"user-guide/conversion/batch-conversion/#minimal-example","title":"Minimal Example","text":"<p>Convert all buildings in your CSV files:</p> <pre><code>from hhw_brick import BatchConverter\n\nbatch = BatchConverter()\nresults = batch.convert_all_buildings(\n    metadata_csv=\"metadata.csv\",\n    vars_csv=\"vars_available_by_building.csv\",\n    output_dir=\"brick_models/\"\n)\n\nprint(f\"Converted {results['successful']} buildings\")\nprint(f\"Failed: {results['failed']}\")\n</code></pre> <p>Output: <pre><code>Converted 150 buildings\nFailed: 0\n</code></pre></p>"},{"location":"user-guide/conversion/batch-conversion/#with-progress-bar","title":"With Progress Bar","text":"<p>Show progress during conversion:</p> <pre><code>batch = BatchConverter()\nresults = batch.convert_all_buildings(\n    metadata_csv=\"metadata.csv\",\n    vars_csv=\"vars_available_by_building.csv\",\n    output_dir=\"brick_models/\",\n    show_progress=True  # Enable progress bar\n)\n</code></pre> <p>Output: <pre><code>Converting buildings: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 150/150 [01:23&lt;00:00,  1.80it/s]\n</code></pre></p>"},{"location":"user-guide/conversion/batch-conversion/#parameters","title":"Parameters","text":""},{"location":"user-guide/conversion/batch-conversion/#required-parameters","title":"Required Parameters","text":""},{"location":"user-guide/conversion/batch-conversion/#metadata_csv","title":"metadata_csv","text":"<p>Path to building metadata file:</p> <pre><code>metadata_csv=\"path/to/metadata.csv\"\n</code></pre>"},{"location":"user-guide/conversion/batch-conversion/#vars_csv","title":"vars_csv","text":"<p>Path to sensor availability file:</p> <pre><code>vars_csv=\"path/to/vars_available_by_building.csv\"\n</code></pre>"},{"location":"user-guide/conversion/batch-conversion/#output_dir","title":"output_dir","text":"<p>Directory where TTL files will be saved:</p> <pre><code>output_dir=\"brick_models/\"\n</code></pre> <p>The directory will be created if it doesn't exist.</p>"},{"location":"user-guide/conversion/batch-conversion/#optional-parameters","title":"Optional Parameters","text":""},{"location":"user-guide/conversion/batch-conversion/#system_type","title":"system_type","text":"<p>Filter by HVAC system type:</p> <pre><code>system_type=\"Condensing\"  # Only condensing systems\n</code></pre> <ul> <li>Type: String</li> <li>Default: <code>None</code> (convert all systems)</li> <li>Options: <code>\"Boiler\"</code>, <code>\"Non-condensing\"</code>, <code>\"Condensing\"</code>, <code>\"District HW\"</code>, <code>\"District Steam\"</code></li> </ul> <p>Example: <pre><code># Convert only district hot water systems\nresults = batch.convert_all_buildings(\n    metadata_csv=\"metadata.csv\",\n    vars_csv=\"vars.csv\",\n    output_dir=\"district_hw_models/\",\n    system_type=\"District HW\"\n)\n</code></pre></p>"},{"location":"user-guide/conversion/batch-conversion/#building_tags","title":"building_tags","text":"<p>List of specific buildings to convert:</p> <pre><code>building_tags=[\"105\", \"106\", \"107\"]\n</code></pre> <ul> <li>Type: List of strings</li> <li>Default: <code>None</code> (convert all buildings)</li> </ul> <p>Example: <pre><code># Convert only selected buildings\ntarget_buildings = [\"105\", \"106\", \"107\", \"108\", \"109\"]\n\nresults = batch.convert_all_buildings(\n    metadata_csv=\"metadata.csv\",\n    vars_csv=\"vars.csv\",\n    output_dir=\"selected_buildings/\",\n    building_tags=target_buildings\n)\n</code></pre></p>"},{"location":"user-guide/conversion/batch-conversion/#show_progress","title":"show_progress","text":"<p>Show progress bar during conversion:</p> <pre><code>show_progress=True  # Default: True\n</code></pre> <ul> <li>Type: Boolean</li> <li>Default: <code>True</code></li> <li>Uses <code>tqdm</code> for progress visualization</li> </ul>"},{"location":"user-guide/conversion/batch-conversion/#return-value","title":"Return Value","text":"<p>The <code>convert_all_buildings()</code> method returns a dictionary with statistics:</p> <pre><code>results = batch.convert_all_buildings(...)\n\n# Results structure\n{\n    'total': 150,              # Total buildings processed\n    'successful': 148,         # Successfully converted\n    'failed': 2,               # Failed conversions\n    'by_system': {             # Breakdown by system type\n        'Condensing': 85,\n        'Non-condensing': 45,\n        'District HW': 18\n    },\n    'total_triples': 156789,   # Total RDF statements created\n    'failed_buildings': [      # List of failed building IDs\n        '127', '304'\n    ],\n    'successful_files': [      # List of created files\n        'brick_models/building_105_non-condensing_h.ttl',\n        'brick_models/building_106_condensing_n.ttl',\n        # ...\n    ]\n}\n</code></pre>"},{"location":"user-guide/conversion/batch-conversion/#processing-results","title":"Processing Results","text":"<pre><code>results = batch.convert_all_buildings(...)\n\nprint(\"Conversion Summary:\")\nprint(f\"  Total: {results['total']}\")\nprint(f\"  Successful: {results['successful']}\")\nprint(f\"  Failed: {results['failed']}\")\nprint(f\"  Success Rate: {results['successful']/results['total']*100:.1f}%\")\n\nprint(\"\\nBy System Type:\")\nfor system, count in results['by_system'].items():\n    print(f\"  {system}: {count}\")\n\nif results['failed'] &gt; 0:\n    print(\"\\nFailed Buildings:\")\n    for building_id in results['failed_buildings']:\n        print(f\"  - Building {building_id}\")\n</code></pre>"},{"location":"user-guide/conversion/batch-conversion/#output-files","title":"Output Files","text":""},{"location":"user-guide/conversion/batch-conversion/#file-naming","title":"File Naming","text":"<p>Files are automatically named using the pattern:</p> <pre><code>building_{tag}_{system_abbreviation}_{variant}.ttl\n</code></pre> <p>Examples: - <code>building_105_non-condensing_h.ttl</code> - <code>building_106_condensing_n.ttl</code> - <code>building_107_district_hw_aa.ttl</code></p>"},{"location":"user-guide/conversion/batch-conversion/#output-directory-structure","title":"Output Directory Structure","text":"<pre><code>brick_models/\n\u251c\u2500\u2500 building_105_non-condensing_h.ttl\n\u251c\u2500\u2500 building_106_condensing_n.ttl\n\u251c\u2500\u2500 building_107_condensing_an.ttl\n\u251c\u2500\u2500 building_108_district_hw_aa.ttl\n\u2514\u2500\u2500 ...\n</code></pre>"},{"location":"user-guide/conversion/batch-conversion/#common-workflows","title":"Common Workflows","text":""},{"location":"user-guide/conversion/batch-conversion/#workflow-1-convert-all-buildings","title":"Workflow 1: Convert All Buildings","text":"<pre><code>\"\"\"\nSimple batch conversion of all buildings\n\"\"\"\nfrom hhw_brick import BatchConverter\nfrom pathlib import Path\n\n# Create output directory\noutput_dir = Path(\"brick_models\")\noutput_dir.mkdir(exist_ok=True)\n\n# Convert\nbatch = BatchConverter()\nresults = batch.convert_all_buildings(\n    metadata_csv=\"metadata.csv\",\n    vars_csv=\"vars_available_by_building.csv\",\n    output_dir=str(output_dir),\n    show_progress=True\n)\n\n# Report\nprint(f\"\\n{'='*60}\")\nprint(\"Conversion Complete!\")\nprint(f\"{'='*60}\")\nprint(f\"Total Buildings: {results['total']}\")\nprint(f\"Successful: {results['successful']}\")\nprint(f\"Failed: {results['failed']}\")\nprint(f\"Total RDF Triples: {results['total_triples']:,}\")\n\nif results['failed'] &gt; 0:\n    print(f\"\\n\u26a0 Failed buildings: {results['failed_buildings']}\")\n</code></pre>"},{"location":"user-guide/conversion/batch-conversion/#workflow-2-filter-by-system-type","title":"Workflow 2: Filter by System Type","text":"<pre><code>\"\"\"\nConvert buildings of specific system types\n\"\"\"\nfrom hhw_brick import BatchConverter\n\n# Convert condensing systems only\nbatch = BatchConverter()\ncondensing_results = batch.convert_all_buildings(\n    metadata_csv=\"metadata.csv\",\n    vars_csv=\"vars.csv\",\n    output_dir=\"condensing_systems/\",\n    system_type=\"Condensing\",\n    show_progress=True\n)\n\nprint(f\"Converted {condensing_results['successful']} condensing systems\")\n\n# Convert district systems separately\ndistrict_results = batch.convert_all_buildings(\n    metadata_csv=\"metadata.csv\",\n    vars_csv=\"vars.csv\",\n    output_dir=\"district_systems/\",\n    system_type=\"District HW\",\n    show_progress=True\n)\n\nprint(f\"Converted {district_results['successful']} district systems\")\n</code></pre>"},{"location":"user-guide/conversion/batch-conversion/#workflow-3-convert-by-organization","title":"Workflow 3: Convert by Organization","text":"<pre><code>\"\"\"\nBatch convert buildings grouped by organization\n\"\"\"\nimport pandas as pd\nfrom hhw_brick import BatchConverter\n\n# Load metadata\nmetadata = pd.read_csv(\"metadata.csv\")\n\n# Get unique organizations\norganizations = metadata['org'].unique()\n\nbatch = BatchConverter()\n\nfor org in organizations:\n    print(f\"\\nConverting buildings for: {org}\")\n\n    # Get building IDs for this org\n    org_buildings = metadata[metadata['org'] == org]['tag'].astype(str).tolist()\n\n    # Create org-specific output directory\n    output_dir = f\"brick_models/{org.replace(' ', '_')}\"\n\n    # Convert\n    results = batch.convert_all_buildings(\n        metadata_csv=\"metadata.csv\",\n        vars_csv=\"vars.csv\",\n        output_dir=output_dir,\n        building_tags=org_buildings,\n        show_progress=True\n    )\n\n    print(f\"  Converted: {results['successful']}/{results['total']}\")\n</code></pre>"},{"location":"user-guide/conversion/batch-conversion/#workflow-4-production-with-logging","title":"Workflow 4: Production with Logging","text":"<pre><code>\"\"\"\nProduction batch conversion with comprehensive logging\n\"\"\"\nfrom hhw_brick import BatchConverter\nimport logging\nfrom datetime import datetime\nfrom pathlib import Path\n\n# Set up logging\nlog_file = f\"conversion_{datetime.now().strftime('%Y%m%d_%H%M%S')}.log\"\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(levelname)s - %(message)s',\n    handlers=[\n        logging.FileHandler(log_file),\n        logging.StreamHandler()\n    ]\n)\n\ndef production_conversion():\n    \"\"\"Production batch conversion with error handling.\"\"\"\n\n    logging.info(\"Starting batch conversion\")\n\n    # Set up paths\n    output_dir = Path(\"brick_models_production\")\n    output_dir.mkdir(exist_ok=True)\n\n    try:\n        # Convert\n        batch = BatchConverter()\n        results = batch.convert_all_buildings(\n            metadata_csv=\"metadata.csv\",\n            vars_csv=\"vars.csv\",\n            output_dir=str(output_dir),\n            show_progress=True\n        )\n\n        # Log results\n        logging.info(f\"Conversion complete: {results['successful']}/{results['total']}\")\n        logging.info(f\"Total triples created: {results['total_triples']:,}\")\n\n        # Log by system type\n        logging.info(\"Breakdown by system:\")\n        for system, count in results['by_system'].items():\n            logging.info(f\"  {system}: {count}\")\n\n        # Log failures\n        if results['failed'] &gt; 0:\n            logging.warning(f\"{results['failed']} buildings failed:\")\n            for building_id in results['failed_buildings']:\n                logging.warning(f\"  - Building {building_id}\")\n\n        # Save results summary\n        summary_file = output_dir / \"conversion_summary.txt\"\n        with open(summary_file, 'w') as f:\n            f.write(f\"Conversion Date: {datetime.now()}\\n\")\n            f.write(f\"Total: {results['total']}\\n\")\n            f.write(f\"Successful: {results['successful']}\\n\")\n            f.write(f\"Failed: {results['failed']}\\n\")\n            f.write(f\"Total Triples: {results['total_triples']:,}\\n\")\n\n        logging.info(f\"Summary saved to {summary_file}\")\n        return results\n\n    except FileNotFoundError as e:\n        logging.error(f\"Input file not found: {e}\")\n        return None\n    except Exception as e:\n        logging.error(f\"Conversion failed: {e}\", exc_info=True)\n        return None\n\nif __name__ == \"__main__\":\n    results = production_conversion()\n</code></pre>"},{"location":"user-guide/conversion/batch-conversion/#advanced-usage","title":"Advanced Usage","text":""},{"location":"user-guide/conversion/batch-conversion/#parallel-processing-custom-implementation","title":"Parallel Processing (Custom Implementation)","text":"<p>For very large datasets, you can implement parallel processing:</p> <pre><code>\"\"\"\nCustom parallel batch conversion\n\"\"\"\nfrom hhw_brick import CSVToBrickConverter\nimport pandas as pd\nfrom multiprocessing import Pool\nfrom pathlib import Path\n\ndef convert_single_building(args):\n    \"\"\"Convert a single building (for use with multiprocessing).\"\"\"\n    building_tag, metadata_csv, vars_csv, output_dir = args\n\n    try:\n        converter = CSVToBrickConverter()\n        result = converter.convert_to_brick(\n            metadata_csv=metadata_csv,\n            vars_csv=vars_csv,\n            building_tag=building_tag,\n            output_path=f\"{output_dir}/building_{building_tag}.ttl\"\n        )\n        return building_tag, 'success', len(result)\n    except Exception as e:\n        return building_tag, 'failed', str(e)\n\ndef parallel_batch_conversion(metadata_csv, vars_csv, output_dir, num_workers=4):\n    \"\"\"Batch convert using multiple processes.\"\"\"\n\n    # Get building IDs\n    metadata = pd.read_csv(metadata_csv)\n    building_ids = metadata['tag'].astype(str).tolist()\n\n    # Create output directory\n    Path(output_dir).mkdir(exist_ok=True)\n\n    # Prepare arguments\n    args = [\n        (bid, metadata_csv, vars_csv, output_dir)\n        for bid in building_ids\n    ]\n\n    # Process in parallel\n    with Pool(num_workers) as pool:\n        results = pool.map(convert_single_building, args)\n\n    # Summarize\n    successful = sum(1 for _, status, _ in results if status == 'success')\n    failed = sum(1 for _, status, _ in results if status == 'failed')\n\n    print(f\"Parallel conversion complete:\")\n    print(f\"  Workers: {num_workers}\")\n    print(f\"  Successful: {successful}\")\n    print(f\"  Failed: {failed}\")\n\n    return results\n\n# Use it\nresults = parallel_batch_conversion(\n    \"metadata.csv\",\n    \"vars.csv\",\n    \"brick_models/\",\n    num_workers=8\n)\n</code></pre>"},{"location":"user-guide/conversion/batch-conversion/#incremental-conversion","title":"Incremental Conversion","text":"<p>Convert only new buildings:</p> <pre><code>\"\"\"\nIncremental conversion - skip already converted buildings\n\"\"\"\nfrom hhw_brick import BatchConverter\nimport pandas as pd\nfrom pathlib import Path\n\ndef incremental_conversion(metadata_csv, vars_csv, output_dir):\n    \"\"\"Convert only buildings not already in output directory.\"\"\"\n\n    # Get all buildings\n    metadata = pd.read_csv(metadata_csv)\n    all_buildings = set(metadata['tag'].astype(str))\n\n    # Get already converted buildings\n    output_path = Path(output_dir)\n    if output_path.exists():\n        existing_files = list(output_path.glob(\"building_*.ttl\"))\n        converted = set()\n        for file in existing_files:\n            # Extract building ID from filename\n            parts = file.stem.split('_')\n            if len(parts) &gt; 1:\n                converted.add(parts[1])  # building_105_... -&gt; 105\n    else:\n        converted = set()\n        output_path.mkdir(exist_ok=True)\n\n    # Find new buildings\n    new_buildings = all_buildings - converted\n\n    print(f\"Total buildings: {len(all_buildings)}\")\n    print(f\"Already converted: {len(converted)}\")\n    print(f\"New buildings: {len(new_buildings)}\")\n\n    if not new_buildings:\n        print(\"No new buildings to convert\")\n        return\n\n    # Convert new buildings\n    batch = BatchConverter()\n    results = batch.convert_all_buildings(\n        metadata_csv=metadata_csv,\n        vars_csv=vars_csv,\n        output_dir=output_dir,\n        building_tags=list(new_buildings),\n        show_progress=True\n    )\n\n    print(f\"\\nConverted {results['successful']} new buildings\")\n    return results\n\n# Use it\nresults = incremental_conversion(\n    \"metadata.csv\",\n    \"vars.csv\",\n    \"brick_models/\"\n)\n</code></pre>"},{"location":"user-guide/conversion/batch-conversion/#performance","title":"Performance","text":""},{"location":"user-guide/conversion/batch-conversion/#benchmarks","title":"Benchmarks","text":"<p>Typical performance on a standard laptop:</p> Buildings Time Rate 10 ~6 seconds 1.7 builds/sec 50 ~28 seconds 1.8 builds/sec 100 ~55 seconds 1.8 builds/sec 500 ~4.5 minutes 1.9 builds/sec"},{"location":"user-guide/conversion/batch-conversion/#optimization-tips","title":"Optimization Tips","text":"<ol> <li>Use SSD storage - Faster file I/O</li> <li>Disable progress bar for scripts - Slight speedup</li> <li>Consider parallel processing - For very large datasets (&gt;1000 buildings)</li> <li>Close other applications - More memory available</li> </ol>"},{"location":"user-guide/conversion/batch-conversion/#troubleshooting","title":"Troubleshooting","text":""},{"location":"user-guide/conversion/batch-conversion/#issue-no-such-file-or-directory","title":"Issue: \"No such file or directory\"","text":"<p>Cause: Output directory path is invalid</p> <p>Solution: <pre><code>from pathlib import Path\n\n# Create directory first\noutput_dir = Path(\"brick_models\")\noutput_dir.mkdir(parents=True, exist_ok=True)\n\n# Then convert\nresults = batch.convert_all_buildings(\n    metadata_csv=\"metadata.csv\",\n    vars_csv=\"vars.csv\",\n    output_dir=str(output_dir)\n)\n</code></pre></p>"},{"location":"user-guide/conversion/batch-conversion/#issue-some-buildings-failed","title":"Issue: Some buildings failed","text":"<p>Cause: Data issues in specific buildings</p> <p>Solution: <pre><code>results = batch.convert_all_buildings(...)\n\nif results['failed'] &gt; 0:\n    print(f\"Failed buildings: {results['failed_buildings']}\")\n\n    # Try converting failed buildings individually for debugging\n    from hhw_brick import CSVToBrickConverter\n    converter = CSVToBrickConverter()\n\n    for building_id in results['failed_buildings']:\n        try:\n            converter.convert_to_brick(\n                metadata_csv=\"metadata.csv\",\n                vars_csv=\"vars.csv\",\n                building_tag=building_id,\n                output_path=f\"debug_building_{building_id}.ttl\"\n            )\n        except Exception as e:\n            print(f\"Building {building_id} error: {e}\")\n</code></pre></p>"},{"location":"user-guide/conversion/batch-conversion/#issue-progress-bar-not-showing","title":"Issue: Progress bar not showing","text":"<p>Cause: <code>tqdm</code> not installed</p> <p>Solution: <pre><code>pip install tqdm\n</code></pre></p> <p>Or disable progress bar: <pre><code>results = batch.convert_all_buildings(\n    ...,\n    show_progress=False\n)\n</code></pre></p>"},{"location":"user-guide/conversion/batch-conversion/#best-practices","title":"Best Practices","text":""},{"location":"user-guide/conversion/batch-conversion/#1-test-first","title":"1. Test First","text":"<p>Test on a small subset before full conversion:</p> <pre><code># Test with 10 buildings\ntest_buildings = [\"105\", \"106\", \"107\", \"108\", \"109\"]\n\nresults = batch.convert_all_buildings(\n    metadata_csv=\"metadata.csv\",\n    vars_csv=\"vars.csv\",\n    output_dir=\"test_output/\",\n    building_tags=test_buildings\n)\n\n# If successful, run full conversion\nif results['failed'] == 0:\n    results = batch.convert_all_buildings(\n        metadata_csv=\"metadata.csv\",\n        vars_csv=\"vars.csv\",\n        output_dir=\"production_output/\"\n    )\n</code></pre>"},{"location":"user-guide/conversion/batch-conversion/#2-separate-by-system-type","title":"2. Separate by System Type","text":"<p>Organize outputs by system type:</p> <pre><code>system_types = [\"Condensing\", \"Non-condensing\", \"District HW\"]\n\nfor system in system_types:\n    results = batch.convert_all_buildings(\n        metadata_csv=\"metadata.csv\",\n        vars_csv=\"vars.csv\",\n        output_dir=f\"brick_models/{system.lower().replace(' ', '_')}/\",\n        system_type=system\n    )\n</code></pre>"},{"location":"user-guide/conversion/batch-conversion/#3-keep-conversion-logs","title":"3. Keep Conversion Logs","text":"<p>Save detailed logs for auditing:</p> <pre><code>import json\nfrom datetime import datetime\n\nresults = batch.convert_all_buildings(...)\n\n# Save results\nlog_data = {\n    'timestamp': datetime.now().isoformat(),\n    'results': results,\n    'metadata_file': 'metadata.csv',\n    'vars_file': 'vars.csv'\n}\n\nwith open('conversion_log.json', 'w') as f:\n    json.dump(log_data, f, indent=2)\n</code></pre>"},{"location":"user-guide/conversion/batch-conversion/#next-steps","title":"Next Steps","text":"<ul> <li>System Types - Learn about different HVAC systems</li> <li>Sensor Mapping - Customize sensor mappings</li> <li>Validation - Validate converted models</li> <li>Examples - More code examples</li> </ul> <p>Continue to: System Types \u2192</p>"},{"location":"user-guide/conversion/sensor-mapping/","title":"Sensor Mapping","text":"<p>Customize how CSV sensor columns map to Brick ontology classes.</p>"},{"location":"user-guide/conversion/sensor-mapping/#overview","title":"Overview","text":"<p>The sensor mapping file (<code>sensor_to_brick_mapping.yaml</code>) defines how CSV column names translate to Brick point classes. This allows you to:</p> <ul> <li>Customize mappings for your specific data</li> <li>Add new sensor types not in the default mapping</li> <li>Modify Brick classes for existing sensors</li> <li>Document sensor meanings with descriptions</li> </ul>"},{"location":"user-guide/conversion/sensor-mapping/#default-mapping-file","title":"Default Mapping File","text":"<p>The package includes a default mapping at: <pre><code>hhw_brick/conversion/sensor_to_brick_mapping.yaml\n</code></pre></p> <p>This is used automatically unless you provide a custom file.</p>"},{"location":"user-guide/conversion/sensor-mapping/#mapping-file-format","title":"Mapping File Format","text":""},{"location":"user-guide/conversion/sensor-mapping/#yaml-structure","title":"YAML Structure","text":"<p>Each sensor mapping has four fields:</p> <pre><code>sensor_name:\n  brick_class: \"brick:ClassName\"\n  description: \"Human-readable description\"\n  unit: \"UNIT_TYPE\"\n  equipment: \"equipment_type\"\n</code></pre>"},{"location":"user-guide/conversion/sensor-mapping/#example-entry","title":"Example Entry","text":"<pre><code>hw_supply_temp:\n  brick_class: \"brick:Hot_Water_Supply_Temperature_Sensor\"\n  description: \"Hot water supply temperature\"\n  unit: \"DEG_C\"\n  equipment: \"primary_loop\"\n</code></pre>"},{"location":"user-guide/conversion/sensor-mapping/#fields-explained","title":"Fields Explained","text":"Field Required Description Example <code>brick_class</code> Yes Full Brick class name <code>brick:Hot_Water_Supply_Temperature_Sensor</code> <code>description</code> Yes Sensor description <code>\"Primary loop supply temperature\"</code> <code>unit</code> No Unit of measurement <code>DEG_C</code>, <code>L_PER_MIN</code>, <code>KW</code> <code>equipment</code> No Associated equipment <code>boiler</code>, <code>heat_exchanger</code>, <code>pump</code>"},{"location":"user-guide/conversion/sensor-mapping/#default-mappings","title":"Default Mappings","text":""},{"location":"user-guide/conversion/sensor-mapping/#temperature-sensors","title":"Temperature Sensors","text":"<pre><code># Primary Loop\nhw_supply_temp:\n  brick_class: \"brick:Hot_Water_Supply_Temperature_Sensor\"\n  description: \"Primary hot water supply temperature\"\n  unit: \"DEG_C\"\n  equipment: \"primary_loop\"\n\nhw_return_temp:\n  brick_class: \"brick:Hot_Water_Return_Temperature_Sensor\"\n  description: \"Primary hot water return temperature\"\n  unit: \"DEG_C\"\n  equipment: \"primary_loop\"\n\n# Secondary Loop\nsecondary_supply_temp:\n  brick_class: \"brick:Hot_Water_Supply_Temperature_Sensor\"\n  description: \"Secondary loop supply temperature\"\n  unit: \"DEG_C\"\n  equipment: \"secondary_loop\"\n\nsecondary_return_temp:\n  brick_class: \"brick:Hot_Water_Return_Temperature_Sensor\"\n  description: \"Secondary loop return temperature\"\n  unit: \"DEG_C\"\n  equipment: \"secondary_loop\"\n\n# Outdoor\noutdoor_temp:\n  brick_class: \"brick:Outside_Air_Temperature_Sensor\"\n  description: \"Outdoor air temperature\"\n  unit: \"DEG_C\"\n  equipment: \"building\"\n</code></pre>"},{"location":"user-guide/conversion/sensor-mapping/#flow-sensors","title":"Flow Sensors","text":"<pre><code>hw_flow:\n  brick_class: \"brick:Water_Flow_Sensor\"\n  description: \"Primary hot water flow rate\"\n  unit: \"L_PER_MIN\"\n  equipment: \"primary_loop\"\n\nsecondary_flow:\n  brick_class: \"brick:Water_Flow_Sensor\"\n  description: \"Secondary loop flow rate\"\n  unit: \"L_PER_MIN\"\n  equipment: \"secondary_loop\"\n</code></pre>"},{"location":"user-guide/conversion/sensor-mapping/#numbered-sensors-boilers","title":"Numbered Sensors (Boilers)","text":"<pre><code>sup1:\n  brick_class: \"brick:Leaving_Hot_Water_Temperature_Sensor\"\n  description: \"Supply water temperature leaving boiler 1\"\n  unit: \"DEG_C\"\n  equipment: \"boiler\"\n\nret1:\n  brick_class: \"brick:Entering_Hot_Water_Temperature_Sensor\"\n  description: \"Return water temperature entering boiler 1\"\n  unit: \"DEG_C\"\n  equipment: \"boiler\"\n\nfire1:\n  brick_class: \"brick:Firing_Rate_Sensor\"\n  description: \"Boiler 1 firing rate\"\n  unit: \"PERCENT\"\n  equipment: \"boiler\"\n</code></pre>"},{"location":"user-guide/conversion/sensor-mapping/#pump-sensors","title":"Pump Sensors","text":"<pre><code>pmp1_pwr:\n  brick_class: \"brick:Power_Sensor\"\n  description: \"Pump 1 power consumption\"\n  unit: \"KW\"\n  equipment: \"pump\"\n\npmp1_spd:\n  brick_class: \"brick:Speed_Sensor\"\n  description: \"Pump 1 speed\"\n  unit: \"PERCENT\"\n  equipment: \"pump\"\n\npmp1_vfd:\n  brick_class: \"brick:VFD_Enable_Command\"\n  description: \"Pump 1 VFD enable status\"\n  unit: \"BINARY\"\n  equipment: \"pump\"\n</code></pre>"},{"location":"user-guide/conversion/sensor-mapping/#valves","title":"Valves","text":"<pre><code>hw_valve:\n  brick_class: \"brick:Heating_Valve\"\n  description: \"Hot water control valve position\"\n  unit: \"PERCENT\"\n  equipment: \"valve\"\n</code></pre>"},{"location":"user-guide/conversion/sensor-mapping/#creating-custom-mappings","title":"Creating Custom Mappings","text":""},{"location":"user-guide/conversion/sensor-mapping/#step-1-copy-default-file","title":"Step 1: Copy Default File","text":"<p>Start with the default as a template:</p> <pre><code>cp hhw_brick/conversion/sensor_to_brick_mapping.yaml custom_mapping.yaml\n</code></pre>"},{"location":"user-guide/conversion/sensor-mapping/#step-2-edit-mappings","title":"Step 2: Edit Mappings","text":"<p>Open <code>custom_mapping.yaml</code> and modify:</p> <pre><code># Add your custom sensors\nchilled_water_supply:\n  brick_class: \"brick:Chilled_Water_Supply_Temperature_Sensor\"\n  description: \"Chilled water supply temperature\"\n  unit: \"DEG_C\"\n  equipment: \"chiller\"\n\nchilled_water_return:\n  brick_class: \"brick:Chilled_Water_Return_Temperature_Sensor\"\n  description: \"Chilled water return temperature\"\n  unit: \"DEG_C\"\n  equipment: \"chiller\"\n\n# Modify existing mappings\noutdoor_temp:\n  brick_class: \"brick:Outside_Air_Temperature_Sensor\"\n  description: \"Custom outdoor sensor at roof level\"  # Changed\n  unit: \"DEG_F\"  # Changed to Fahrenheit\n  equipment: \"building\"\n</code></pre>"},{"location":"user-guide/conversion/sensor-mapping/#step-3-use-custom-mapping","title":"Step 3: Use Custom Mapping","text":"<pre><code>from hhw_brick import CSVToBrickConverter\n\nconverter = CSVToBrickConverter()\nresult = converter.convert_to_brick(\n    metadata_csv=\"metadata.csv\",\n    vars_csv=\"vars.csv\",\n    sensor_mapping=\"custom_mapping.yaml\",  # Your custom file\n    output_path=\"output.ttl\"\n)\n</code></pre>"},{"location":"user-guide/conversion/sensor-mapping/#common-customizations","title":"Common Customizations","text":""},{"location":"user-guide/conversion/sensor-mapping/#add-building-specific-sensors","title":"Add Building-Specific Sensors","text":"<p>Your building has unique sensors:</p> <pre><code># custom_mapping.yaml\n\n# Add solar collector sensors\nsolar_panel_temp:\n  brick_class: \"brick:Solar_Panel_Temperature_Sensor\"\n  description: \"Solar thermal panel temperature\"\n  unit: \"DEG_C\"\n  equipment: \"solar_collector\"\n\nsolar_flow:\n  brick_class: \"brick:Water_Flow_Sensor\"\n  description: \"Solar collector flow rate\"\n  unit: \"L_PER_MIN\"\n  equipment: \"solar_collector\"\n\n# Add thermal storage sensors\nstorage_tank_top:\n  brick_class: \"brick:Temperature_Sensor\"\n  description: \"Thermal storage tank top temperature\"\n  unit: \"DEG_C\"\n  equipment: \"thermal_storage\"\n\nstorage_tank_bottom:\n  brick_class: \"brick:Temperature_Sensor\"\n  description: \"Thermal storage tank bottom temperature\"\n  unit: \"DEG_C\"\n  equipment: \"thermal_storage\"\n</code></pre>"},{"location":"user-guide/conversion/sensor-mapping/#change-units","title":"Change Units","text":"<p>Convert between measurement systems:</p> <pre><code># Use Fahrenheit instead of Celsius\nhw_supply_temp:\n  brick_class: \"brick:Hot_Water_Supply_Temperature_Sensor\"\n  description: \"Hot water supply temperature\"\n  unit: \"DEG_F\"  # Changed from DEG_C\n  equipment: \"primary_loop\"\n\n# Use gallons per minute instead of liters\nhw_flow:\n  brick_class: \"brick:Water_Flow_Sensor\"\n  description: \"Primary hot water flow rate\"\n  unit: \"GAL_PER_MIN\"  # Changed from L_PER_MIN\n  equipment: \"primary_loop\"\n</code></pre>"},{"location":"user-guide/conversion/sensor-mapping/#use-more-specific-classes","title":"Use More Specific Classes","text":"<p>Brick has many specialized classes:</p> <pre><code># Instead of generic Temperature_Sensor\n# Use specific class:\nsupply_temp:\n  brick_class: \"brick:Leaving_Hot_Water_Temperature_Sensor\"  # Specific\n  # vs brick:Temperature_Sensor (generic)\n  description: \"Hot water leaving temperature\"\n  unit: \"DEG_C\"\n  equipment: \"boiler\"\n\n# Instead of generic Sensor\n# Use specific measurement type:\nenergy_meter:\n  brick_class: \"brick:Thermal_Energy_Sensor\"  # Specific\n  # vs brick:Sensor (generic)\n  description: \"Thermal energy meter\"\n  unit: \"KWH\"\n  equipment: \"primary_loop\"\n</code></pre>"},{"location":"user-guide/conversion/sensor-mapping/#brick-class-reference","title":"Brick Class Reference","text":""},{"location":"user-guide/conversion/sensor-mapping/#common-brick-classes","title":"Common Brick Classes","text":""},{"location":"user-guide/conversion/sensor-mapping/#temperature","title":"Temperature","text":"<ul> <li><code>brick:Temperature_Sensor</code> - Generic</li> <li><code>brick:Hot_Water_Supply_Temperature_Sensor</code> - HW supply</li> <li><code>brick:Hot_Water_Return_Temperature_Sensor</code> - HW return</li> <li><code>brick:Leaving_Hot_Water_Temperature_Sensor</code> - Equipment leaving</li> <li><code>brick:Entering_Hot_Water_Temperature_Sensor</code> - Equipment entering</li> <li><code>brick:Outside_Air_Temperature_Sensor</code> - Outdoor</li> <li><code>brick:Chilled_Water_Supply_Temperature_Sensor</code> - CHW supply</li> <li><code>brick:Chilled_Water_Return_Temperature_Sensor</code> - CHW return</li> </ul>"},{"location":"user-guide/conversion/sensor-mapping/#flow","title":"Flow","text":"<ul> <li><code>brick:Water_Flow_Sensor</code> - Water flow rate</li> <li><code>brick:Air_Flow_Sensor</code> - Air flow rate</li> <li><code>brick:Steam_Flow_Sensor</code> - Steam flow</li> </ul>"},{"location":"user-guide/conversion/sensor-mapping/#pressure","title":"Pressure","text":"<ul> <li><code>brick:Water_Pressure_Sensor</code> - Water pressure</li> <li><code>brick:Steam_Pressure_Sensor</code> - Steam pressure</li> <li><code>brick:Differential_Pressure_Sensor</code> - Pressure difference</li> </ul>"},{"location":"user-guide/conversion/sensor-mapping/#powerenergy","title":"Power/Energy","text":"<ul> <li><code>brick:Power_Sensor</code> - Electrical power</li> <li><code>brick:Energy_Sensor</code> - Energy consumption</li> <li><code>brick:Thermal_Power_Sensor</code> - Thermal power</li> <li><code>brick:Thermal_Energy_Sensor</code> - Thermal energy</li> </ul>"},{"location":"user-guide/conversion/sensor-mapping/#control","title":"Control","text":"<ul> <li><code>brick:Valve_Command</code> - Valve position</li> <li><code>brick:Heating_Valve</code> - Heating valve</li> <li><code>brick:VFD_Enable_Command</code> - VFD status</li> <li><code>brick:Speed_Setpoint</code> - Speed setpoint</li> </ul>"},{"location":"user-guide/conversion/sensor-mapping/#status","title":"Status","text":"<ul> <li><code>brick:Run_Status</code> - Equipment running</li> <li><code>brick:Enable_Status</code> - Equipment enabled</li> <li><code>brick:Alarm_Status</code> - Alarm condition</li> </ul>"},{"location":"user-guide/conversion/sensor-mapping/#finding-brick-classes","title":"Finding Brick Classes","text":"<p>Browse online: Brick Schema Explorer</p> <p>Search in Python: <pre><code>from brickschema import Graph\n\ng = Graph(load_brick=True)\n\n# Find all sensor types\nquery = \"\"\"\nPREFIX brick: &lt;https://brickschema.org/schema/Brick#&gt;\nSELECT ?sensor WHERE {\n    ?sensor rdfs:subClassOf* brick:Sensor .\n}\n\"\"\"\n\nfor row in g.query(query):\n    print(row.sensor)\n</code></pre></p>"},{"location":"user-guide/conversion/sensor-mapping/#validation","title":"Validation","text":""},{"location":"user-guide/conversion/sensor-mapping/#check-your-mapping","title":"Check Your Mapping","text":"<p>Validate mapping file structure:</p> <pre><code>import yaml\n\n# Load mapping\nwith open('custom_mapping.yaml', 'r') as f:\n    mapping = yaml.safe_load(f)\n\n# Check required fields\nfor sensor, config in mapping.items():\n    if 'brick_class' not in config:\n        print(f\"\u274c {sensor}: missing brick_class\")\n    if 'description' not in config:\n        print(f\"\u26a0\ufe0f  {sensor}: missing description (optional)\")\n\n    # Check brick_class format\n    if not config['brick_class'].startswith('brick:'):\n        print(f\"\u26a0\ufe0f  {sensor}: brick_class should start with 'brick:'\")\n</code></pre>"},{"location":"user-guide/conversion/sensor-mapping/#test-custom-mapping","title":"Test Custom Mapping","text":"<p>Test with a small dataset:</p> <pre><code>from hhw_brick import CSVToBrickConverter\n\nconverter = CSVToBrickConverter()\n\ntry:\n    result = converter.convert_to_brick(\n        metadata_csv=\"test_metadata.csv\",\n        vars_csv=\"test_vars.csv\",\n        building_tag=\"105\",\n        sensor_mapping=\"custom_mapping.yaml\",\n        output_path=\"test_output.ttl\"\n    )\n    print(f\"\u2713 Custom mapping works! Created {len(result)} triples\")\nexcept Exception as e:\n    print(f\"\u274c Error with custom mapping: {e}\")\n</code></pre>"},{"location":"user-guide/conversion/sensor-mapping/#complete-custom-mapping-example","title":"Complete Custom Mapping Example","text":""},{"location":"user-guide/conversion/sensor-mapping/#building-with-geothermal-system","title":"Building with Geothermal System","text":"<pre><code># geothermal_mapping.yaml\n\n# Geothermal loop sensors\ngeo_source_supply:\n  brick_class: \"brick:Leaving_Water_Temperature_Sensor\"\n  description: \"Geothermal source loop supply temperature\"\n  unit: \"DEG_C\"\n  equipment: \"geothermal_loop\"\n\ngeo_source_return:\n  brick_class: \"brick:Entering_Water_Temperature_Sensor\"\n  description: \"Geothermal source loop return temperature\"\n  unit: \"DEG_C\"\n  equipment: \"geothermal_loop\"\n\ngeo_flow:\n  brick_class: \"brick:Water_Flow_Sensor\"\n  description: \"Geothermal loop flow rate\"\n  unit: \"L_PER_MIN\"\n  equipment: \"geothermal_loop\"\n\n# Heat pump sensors\nhp_leaving_temp:\n  brick_class: \"brick:Leaving_Hot_Water_Temperature_Sensor\"\n  description: \"Heat pump leaving water temperature\"\n  unit: \"DEG_C\"\n  equipment: \"heat_pump\"\n\nhp_entering_temp:\n  brick_class: \"brick:Entering_Hot_Water_Temperature_Sensor\"\n  description: \"Heat pump entering water temperature\"\n  unit: \"DEG_C\"\n  equipment: \"heat_pump\"\n\nhp_power:\n  brick_class: \"brick:Power_Sensor\"\n  description: \"Heat pump electrical power\"\n  unit: \"KW\"\n  equipment: \"heat_pump\"\n\nhp_cop:\n  brick_class: \"brick:Sensor\"\n  description: \"Heat pump coefficient of performance\"\n  unit: \"DIMENSIONLESS\"\n  equipment: \"heat_pump\"\n\n# Building loop (same as standard)\nhw_supply_temp:\n  brick_class: \"brick:Hot_Water_Supply_Temperature_Sensor\"\n  description: \"Building hot water supply\"\n  unit: \"DEG_C\"\n  equipment: \"building_loop\"\n\nhw_return_temp:\n  brick_class: \"brick:Hot_Water_Return_Temperature_Sensor\"\n  description: \"Building hot water return\"\n  unit: \"DEG_C\"\n  equipment: \"building_loop\"\n</code></pre>"},{"location":"user-guide/conversion/sensor-mapping/#usage","title":"Usage","text":"<pre><code>from hhw_brick import CSVToBrickConverter\n\nconverter = CSVToBrickConverter()\nresult = converter.convert_to_brick(\n    metadata_csv=\"geothermal_buildings.csv\",\n    vars_csv=\"geothermal_sensors.csv\",\n    building_tag=\"205\",\n    sensor_mapping=\"geothermal_mapping.yaml\",\n    output_path=\"geothermal_building_205.ttl\"\n)\n</code></pre>"},{"location":"user-guide/conversion/sensor-mapping/#troubleshooting","title":"Troubleshooting","text":""},{"location":"user-guide/conversion/sensor-mapping/#issue-unknown-sensor-type","title":"Issue: \"Unknown sensor type\"","text":"<p>Cause: Sensor in CSV not in mapping file</p> <p>Solution: Add it to your custom mapping: <pre><code>new_sensor:\n  brick_class: \"brick:Sensor\"\n  description: \"New sensor type\"\n  unit: \"UNIT\"\n  equipment: \"equipment_type\"\n</code></pre></p>"},{"location":"user-guide/conversion/sensor-mapping/#issue-invalid-brick-class","title":"Issue: \"Invalid Brick class\"","text":"<p>Cause: Brick class doesn't exist</p> <p>Solution: Check class name at Brick Explorer</p> <pre><code># Wrong:\ntemp_sensor:\n  brick_class: \"brick:TemperatureSensor\"  # No such class\n\n# Right:\ntemp_sensor:\n  brick_class: \"brick:Temperature_Sensor\"  # Underscores\n</code></pre>"},{"location":"user-guide/conversion/sensor-mapping/#issue-mapping-not-being-used","title":"Issue: Mapping not being used","text":"<p>Cause: File path incorrect</p> <p>Solution: <pre><code>import os\n\n# Check file exists\nmapping_file = \"custom_mapping.yaml\"\nif not os.path.exists(mapping_file):\n    print(f\"\u274c File not found: {mapping_file}\")\nelse:\n    print(f\"\u2713 File exists: {os.path.abspath(mapping_file)}\")\n\n# Use absolute path\nresult = converter.convert_to_brick(\n    metadata_csv=\"metadata.csv\",\n    vars_csv=\"vars.csv\",\n    sensor_mapping=os.path.abspath(\"custom_mapping.yaml\"),\n    output_path=\"output.ttl\"\n)\n</code></pre></p>"},{"location":"user-guide/conversion/sensor-mapping/#best-practices","title":"Best Practices","text":""},{"location":"user-guide/conversion/sensor-mapping/#1-start-with-default","title":"1. Start with Default","text":"<p>Don't create from scratch: <pre><code># Copy default as starting point\ncp hhw_brick/conversion/sensor_to_brick_mapping.yaml my_mapping.yaml\n\n# Edit only what you need to change\n</code></pre></p>"},{"location":"user-guide/conversion/sensor-mapping/#2-use-specific-classes","title":"2. Use Specific Classes","text":"<p>Prefer specific Brick classes over generic: <pre><code># \u2713 Good - Specific\nsupply_temp:\n  brick_class: \"brick:Leaving_Hot_Water_Temperature_Sensor\"\n\n# \u2717 Avoid - Too generic\nsupply_temp:\n  brick_class: \"brick:Sensor\"\n</code></pre></p>"},{"location":"user-guide/conversion/sensor-mapping/#3-document-well","title":"3. Document Well","text":"<p>Write clear descriptions: <pre><code># \u2713 Good - Clear description\npmp1_vfd:\n  brick_class: \"brick:VFD_Enable_Command\"\n  description: \"Primary pump 1 variable frequency drive enable status\"\n  unit: \"BINARY\"\n  equipment: \"pump\"\n\n# \u2717 Avoid - Vague\npmp1_vfd:\n  brick_class: \"brick:VFD_Enable_Command\"\n  description: \"VFD\"  # Too brief\n  unit: \"BINARY\"\n  equipment: \"pump\"\n</code></pre></p>"},{"location":"user-guide/conversion/sensor-mapping/#4-version-control","title":"4. Version Control","text":"<p>Keep mapping files in version control: <pre><code>git add custom_mapping.yaml\ngit commit -m \"Add geothermal sensor mappings\"\n</code></pre></p>"},{"location":"user-guide/conversion/sensor-mapping/#5-test-thoroughly","title":"5. Test Thoroughly","text":"<p>Test with sample data before production use.</p>"},{"location":"user-guide/conversion/sensor-mapping/#next-steps","title":"Next Steps","text":"<ul> <li>Validation - Validate converted models</li> <li>Applications - Run analytics</li> <li>Examples - More examples</li> </ul> <p>Conversion documentation complete! \ud83c\udf89</p> <p>Continue to Validation Guide \u2192</p>"},{"location":"user-guide/conversion/single-building/","title":"Single Building Conversion","text":"<p>Detailed guide to converting individual buildings from CSV to Brick format.</p>"},{"location":"user-guide/conversion/single-building/#overview","title":"Overview","text":"<p>Single building conversion gives you precise control over the conversion process. It's ideal for:</p> <ul> <li>Development and testing - Work with one building at a time</li> <li>Custom workflows - Integrate into your own scripts</li> <li>Detailed inspection - Examine the output carefully</li> <li>Targeted conversion - Convert specific buildings</li> </ul>"},{"location":"user-guide/conversion/single-building/#basic-usage","title":"Basic Usage","text":""},{"location":"user-guide/conversion/single-building/#minimal-example","title":"Minimal Example","text":"<p>The simplest possible conversion:</p> <pre><code>from hhw_brick import CSVToBrickConverter\n\nconverter = CSVToBrickConverter()\nresult = converter.convert_to_brick(\n    metadata_csv=\"metadata.csv\",\n    vars_csv=\"vars_available_by_building.csv\",\n    building_tag=\"105\",\n    output_path=\"building_105.ttl\"\n)\n\nprint(f\"\u2713 Created {len(result)} RDF triples\")\n</code></pre> <p>This will: 1. Read building #105 from the CSV files 2. Auto-detect the system type 3. Create appropriate Brick entities 4. Save to <code>building_105.ttl</code></p>"},{"location":"user-guide/conversion/single-building/#complete-example","title":"Complete Example","text":"<p>With all parameters:</p> <pre><code>from hhw_brick import CSVToBrickConverter\n\nconverter = CSVToBrickConverter()\n\nresult = converter.convert_to_brick(\n    metadata_csv=\"metadata.csv\",\n    vars_csv=\"vars_available_by_building.csv\",\n    building_tag=\"105\",\n    system_type=\"Non-condensing\",  # Optional: specify type\n    sensor_mapping=\"custom_mapping.yaml\",  # Optional: custom mapping\n    output_path=\"output/building_105_non-condensing.ttl\"\n)\n\n# Check for warnings\nif converter.validation_warnings:\n    print(\"Warnings during conversion:\")\n    for warning in converter.validation_warnings:\n        print(f\"  \u26a0 {warning}\")\n\nprint(f\"\u2713 Conversion complete: {len(result)} triples\")\n</code></pre>"},{"location":"user-guide/conversion/single-building/#parameters-explained","title":"Parameters Explained","text":""},{"location":"user-guide/conversion/single-building/#required-parameters","title":"Required Parameters","text":""},{"location":"user-guide/conversion/single-building/#metadata_csv","title":"metadata_csv","text":"<p>Path to the building metadata file.</p> <pre><code>metadata_csv=\"path/to/metadata.csv\"\n</code></pre> <p>Format: <pre><code>tag,system,org\n105,Non-condensing,Organization A\n106,Condensing,Organization B\n</code></pre></p>"},{"location":"user-guide/conversion/single-building/#vars_csv","title":"vars_csv","text":"<p>Path to the sensor availability file.</p> <pre><code>vars_csv=\"path/to/vars_available_by_building.csv\"\n</code></pre> <p>Format: <pre><code>tag,hw_supply_temp,hw_return_temp,hw_flow\n105,1,1,1\n106,1,1,0\n</code></pre></p>"},{"location":"user-guide/conversion/single-building/#optional-parameters","title":"Optional Parameters","text":""},{"location":"user-guide/conversion/single-building/#building_tag","title":"building_tag","text":"<p>Specific building ID to convert.</p> <pre><code>building_tag=\"105\"  # Convert only building 105\n</code></pre> <ul> <li>Type: String or Integer</li> <li>Default: <code>None</code> (converts all matching buildings)</li> <li>When to use: Convert a single specific building</li> </ul> <p>Example: <pre><code># Convert building 105 only\nresult = converter.convert_to_brick(\n    metadata_csv=\"metadata.csv\",\n    vars_csv=\"vars.csv\",\n    building_tag=\"105\",  # Specific building\n    output_path=\"building_105.ttl\"\n)\n</code></pre></p>"},{"location":"user-guide/conversion/single-building/#system_type","title":"system_type","text":"<p>Filter by HVAC system type.</p> <pre><code>system_type=\"Condensing\"  # Only condensing systems\n</code></pre> <ul> <li>Type: String</li> <li>Default: <code>None</code> (auto-detect from metadata)</li> <li>Options: <code>\"Boiler\"</code>, <code>\"Non-condensing\"</code>, <code>\"Condensing\"</code>, <code>\"District HW\"</code>, <code>\"District Steam\"</code></li> <li>Case insensitive</li> </ul> <p>When to use: - Converting multiple buildings of the same type - Filtering a large dataset - Validation (ensure building matches expected type)</p> <p>Example: <pre><code># Convert all condensing systems\nresult = converter.convert_to_brick(\n    metadata_csv=\"metadata.csv\",\n    vars_csv=\"vars.csv\",\n    system_type=\"Condensing\",\n    output_path=\"all_condensing.ttl\"\n)\n</code></pre></p>"},{"location":"user-guide/conversion/single-building/#sensor_mapping","title":"sensor_mapping","text":"<p>Custom sensor mapping file.</p> <pre><code>sensor_mapping=\"my_custom_mapping.yaml\"\n</code></pre> <ul> <li>Type: String (file path)</li> <li>Default: Uses built-in mapping</li> <li>Format: YAML file</li> </ul> <p>See Sensor Mapping for details.</p>"},{"location":"user-guide/conversion/single-building/#output_path","title":"output_path","text":"<p>Where to save the generated Brick model.</p> <pre><code>output_path=\"output/building_105.ttl\"\n</code></pre> <ul> <li>Type: String (file path)</li> <li>Default: <code>\"output.ttl\"</code></li> <li>Format: Creates TTL (Turtle) format file</li> </ul>"},{"location":"user-guide/conversion/single-building/#return-value","title":"Return Value","text":"<p>The <code>convert_to_brick()</code> method returns an RDFLib Graph object.</p> <pre><code>result = converter.convert_to_brick(...)\n\n# Result is an rdflib.Graph\nprint(type(result))  # &lt;class 'rdflib.graph.Graph'&gt;\nprint(len(result))   # Number of RDF triples\n\n# Query the graph\nfor s, p, o in result:\n    print(f\"{s} {p} {o}\")\n</code></pre>"},{"location":"user-guide/conversion/single-building/#working-with-the-graph","title":"Working with the Graph","text":"<pre><code>from rdflib import Namespace\n\nresult = converter.convert_to_brick(\n    metadata_csv=\"metadata.csv\",\n    vars_csv=\"vars.csv\",\n    building_tag=\"105\",\n    output_path=\"building_105.ttl\"\n)\n\n# Define namespaces\nBRICK = Namespace(\"https://brickschema.org/schema/Brick#\")\n\n# Query for equipment\nquery = \"\"\"\nPREFIX brick: &lt;https://brickschema.org/schema/Brick#&gt;\n\nSELECT ?equip ?type WHERE {\n    ?equip a ?type .\n    FILTER(STRSTARTS(STR(?type), STR(brick:)))\n}\n\"\"\"\n\nprint(\"Equipment in model:\")\nfor row in result.query(query):\n    equip_name = str(row.equip).split('#')[-1]\n    type_name = str(row.type).split('#')[-1]\n    print(f\"  - {equip_name}: {type_name}\")\n\n# Serialize in different formats\nresult.serialize(\"output.xml\", format=\"xml\")\nresult.serialize(\"output.json\", format=\"json-ld\")\nresult.serialize(\"output.nt\", format=\"nt\")  # N-Triples\n</code></pre>"},{"location":"user-guide/conversion/single-building/#step-by-step-workflow","title":"Step-by-Step Workflow","text":""},{"location":"user-guide/conversion/single-building/#step-1-prepare-data","title":"Step 1: Prepare Data","text":"<p>Ensure your CSV files are ready:</p> <pre><code>import pandas as pd\n\n# Check metadata\nmetadata = pd.read_csv(\"metadata.csv\")\nprint(\"Buildings in metadata:\")\nprint(metadata[['tag', 'system', 'org']])\n\n# Check vars\nvars_df = pd.read_csv(\"vars_available_by_building.csv\")\nprint(\"\\nSensors available:\")\nprint(vars_df.head())\n</code></pre>"},{"location":"user-guide/conversion/single-building/#step-2-initialize-converter","title":"Step 2: Initialize Converter","text":"<pre><code>from hhw_brick import CSVToBrickConverter\n\nconverter = CSVToBrickConverter()\n</code></pre> <p>The converter initializes with: - Default namespaces (Brick, REC, etc.) - Empty RDF graph - Built-in sensor mapping</p>"},{"location":"user-guide/conversion/single-building/#step-3-convert","title":"Step 3: Convert","text":"<pre><code>result = converter.convert_to_brick(\n    metadata_csv=\"metadata.csv\",\n    vars_csv=\"vars_available_by_building.csv\",\n    building_tag=\"105\",\n    output_path=\"building_105.ttl\"\n)\n</code></pre> <p>During conversion: 1. \u2713 Reads CSV files 2. \u2713 Finds building #105 3. \u2713 Identifies system type 4. \u2713 Creates building entity 5. \u2713 Creates equipment entities 6. \u2713 Creates sensor/point entities 7. \u2713 Adds relationships 8. \u2713 Writes to file</p>"},{"location":"user-guide/conversion/single-building/#step-4-validate-output","title":"Step 4: Validate Output","text":"<pre><code>from hhw_brick import BrickModelValidator\n\nvalidator = BrickModelValidator()\nis_valid, report = validator.validate_model(\"building_105.ttl\")\n\nif is_valid:\n    print(\"\u2713 Model is valid!\")\nelse:\n    print(\"Validation report:\")\n    print(report)\n</code></pre>"},{"location":"user-guide/conversion/single-building/#step-5-inspect-results","title":"Step 5: Inspect Results","text":"<pre><code>from rdflib import Graph\n\n# Load the model\ng = Graph()\ng.parse(\"building_105.ttl\", format=\"turtle\")\n\n# Count entities\nprint(f\"Total triples: {len(g)}\")\n\n# List all equipment\nquery = \"\"\"\nPREFIX brick: &lt;https://brickschema.org/schema/Brick#&gt;\n\nSELECT DISTINCT ?type WHERE {\n    ?equip a ?type .\n    FILTER(STRSTARTS(STR(?type), STR(brick:)))\n}\n\"\"\"\n\nprint(\"\\nEquipment types:\")\nfor row in g.query(query):\n    print(f\"  - {str(row.type).split('#')[-1]}\")\n</code></pre>"},{"location":"user-guide/conversion/single-building/#common-patterns","title":"Common Patterns","text":""},{"location":"user-guide/conversion/single-building/#pattern-1-convert-multiple-buildings-sequentially","title":"Pattern 1: Convert Multiple Buildings Sequentially","text":"<pre><code>\"\"\"\nConvert multiple specific buildings one by one\n\"\"\"\nfrom hhw_brick import CSVToBrickConverter\n\nconverter = CSVToBrickConverter()\nbuilding_ids = [\"105\", \"106\", \"107\", \"108\"]\n\nfor building_id in building_ids:\n    print(f\"Converting building {building_id}...\")\n\n    try:\n        result = converter.convert_to_brick(\n            metadata_csv=\"metadata.csv\",\n            vars_csv=\"vars.csv\",\n            building_tag=building_id,\n            output_path=f\"output/building_{building_id}.ttl\"\n        )\n\n        print(f\"  \u2713 Success: {len(result)} triples\")\n\n    except Exception as e:\n        print(f\"  \u2717 Failed: {e}\")\n\n    # Clear graph for next building\n    converter.graph = converter.graph.__class__()\n</code></pre>"},{"location":"user-guide/conversion/single-building/#pattern-2-conditional-conversion","title":"Pattern 2: Conditional Conversion","text":"<pre><code>\"\"\"\nConvert only if building meets criteria\n\"\"\"\nimport pandas as pd\nfrom hhw_brick import CSVToBrickConverter\n\nmetadata = pd.read_csv(\"metadata.csv\")\nconverter = CSVToBrickConverter()\n\nfor _, building in metadata.iterrows():\n    building_id = str(int(building['tag']))\n    system = building['system']\n\n    # Only convert condensing systems\n    if 'condensing' in system.lower():\n        print(f\"Converting {building_id} ({system})...\")\n\n        result = converter.convert_to_brick(\n            metadata_csv=\"metadata.csv\",\n            vars_csv=\"vars.csv\",\n            building_tag=building_id,\n            output_path=f\"condensing/building_{building_id}.ttl\"\n        )\n\n        print(f\"  \u2713 {len(result)} triples\")\n</code></pre>"},{"location":"user-guide/conversion/single-building/#pattern-3-conversion-with-validation","title":"Pattern 3: Conversion with Validation","text":"<pre><code>\"\"\"\nConvert and validate in one workflow\n\"\"\"\nfrom hhw_brick import CSVToBrickConverter, BrickModelValidator\n\ndef convert_and_validate(building_id):\n    \"\"\"Convert a building and validate the result.\"\"\"\n\n    # Convert\n    converter = CSVToBrickConverter()\n    output_file = f\"building_{building_id}.ttl\"\n\n    result = converter.convert_to_brick(\n        metadata_csv=\"metadata.csv\",\n        vars_csv=\"vars.csv\",\n        building_tag=building_id,\n        output_path=output_file\n    )\n\n    print(f\"Converted: {len(result)} triples\")\n\n    # Validate\n    validator = BrickModelValidator()\n    is_valid, report = validator.validate_model(output_file)\n\n    if is_valid:\n        print(\"\u2713 Validation passed\")\n        return True, output_file\n    else:\n        print(\"\u26a0 Validation warnings:\")\n        for warning in report.get('warnings', []):\n            print(f\"  - {warning}\")\n        return False, output_file\n\n# Use it\nsuccess, file = convert_and_validate(\"105\")\n</code></pre>"},{"location":"user-guide/conversion/single-building/#advanced-usage","title":"Advanced Usage","text":""},{"location":"user-guide/conversion/single-building/#custom-output-processing","title":"Custom Output Processing","text":"<pre><code>\"\"\"\nProcess the graph before saving\n\"\"\"\nfrom hhw_brick import CSVToBrickConverter\nfrom rdflib import Namespace, Literal\n\nconverter = CSVToBrickConverter()\nresult = converter.convert_to_brick(\n    metadata_csv=\"metadata.csv\",\n    vars_csv=\"vars.csv\",\n    building_tag=\"105\",\n    output_path=\"temp.ttl\"\n)\n\n# Add custom metadata\nHHWS = Namespace(\"https://hhws.example.org#\")\nbuilding_uri = HHWS.Building_105\n\nresult.add((\n    building_uri,\n    HHWS.conversionDate,\n    Literal(\"2025-10-30\")\n))\n\nresult.add((\n    building_uri,\n    HHWS.conversionTool,\n    Literal(\"HHW Brick Application v0.2.0\")\n))\n\n# Save with custom metadata\nresult.serialize(\"building_105_annotated.ttl\", format=\"turtle\")\n</code></pre>"},{"location":"user-guide/conversion/single-building/#merging-multiple-buildings","title":"Merging Multiple Buildings","text":"<pre><code>\"\"\"\nCombine multiple buildings into one graph\n\"\"\"\nfrom hhw_brick import CSVToBrickConverter\nfrom rdflib import Graph\n\nconverter = CSVToBrickConverter()\ncombined = Graph()\n\n# Bind namespaces\nfor prefix, namespace in converter.graph.namespace_manager.namespaces():\n    combined.bind(prefix, namespace)\n\n# Convert and merge multiple buildings\nfor building_id in [\"105\", \"106\", \"107\"]:\n    result = converter.convert_to_brick(\n        metadata_csv=\"metadata.csv\",\n        vars_csv=\"vars.csv\",\n        building_tag=building_id,\n        output_path=f\"temp_{building_id}.ttl\"\n    )\n\n    # Add to combined graph\n    combined += result\n\n    print(f\"Added building {building_id}: {len(result)} triples\")\n\n# Save combined graph\ncombined.serialize(\"campus_model.ttl\", format=\"turtle\")\nprint(f\"\\nCombined model: {len(combined)} total triples\")\n</code></pre>"},{"location":"user-guide/conversion/single-building/#troubleshooting","title":"Troubleshooting","text":""},{"location":"user-guide/conversion/single-building/#issue-no-data-found-for-building-tag","title":"Issue: \"No data found for building tag\"","text":"<p>Cause: Building ID doesn't exist in CSV files</p> <p>Solution: <pre><code>import pandas as pd\n\n# Check which buildings exist\nmetadata = pd.read_csv(\"metadata.csv\")\nprint(\"Available building IDs:\")\nprint(metadata['tag'].tolist())\n\n# Then use a valid ID\nresult = converter.convert_to_brick(\n    metadata_csv=\"metadata.csv\",\n    vars_csv=\"vars.csv\",\n    building_tag=\"105\",  # Must be in the list above\n    output_path=\"output.ttl\"\n)\n</code></pre></p>"},{"location":"user-guide/conversion/single-building/#issue-conversion-warnings","title":"Issue: Conversion warnings","text":"<p>Cause: Some data issues (usually minor)</p> <p>Solution: <pre><code>converter = CSVToBrickConverter()\nresult = converter.convert_to_brick(...)\n\n# Check warnings\nif converter.validation_warnings:\n    print(\"Conversion completed with warnings:\")\n    for w in converter.validation_warnings:\n        print(f\"  {w}\")\n    print(\"\\nThese are usually safe to ignore.\")\n</code></pre></p>"},{"location":"user-guide/conversion/single-building/#issue-empty-output-file","title":"Issue: Empty output file","text":"<p>Cause: No matching data or wrong filters</p> <p>Solution: <pre><code># Don't use system_type filter unless needed\nresult = converter.convert_to_brick(\n    metadata_csv=\"metadata.csv\",\n    vars_csv=\"vars.csv\",\n    building_tag=\"105\",\n    # system_type=\"Condensing\",  # Remove this if not needed\n    output_path=\"output.ttl\"\n)\n</code></pre></p>"},{"location":"user-guide/conversion/single-building/#performance-tips","title":"Performance Tips","text":""},{"location":"user-guide/conversion/single-building/#memory-management","title":"Memory Management","text":"<p>Clear the graph between conversions:</p> <pre><code>converter = CSVToBrickConverter()\n\nfor building_id in range(105, 200):\n    result = converter.convert_to_brick(...)\n\n    # Clear for next iteration\n    converter.graph = converter.graph.__class__()\n</code></pre>"},{"location":"user-guide/conversion/single-building/#batch-vs-sequential","title":"Batch vs Sequential","text":"<p>For many buildings, use BatchConverter instead:</p> <pre><code># Instead of this:\nfor building_id in all_buildings:\n    converter.convert_to_brick(building_tag=building_id, ...)\n\n# Use this:\nfrom hhw_brick import BatchConverter\nbatch = BatchConverter()\nbatch.convert_all_buildings(...)\n</code></pre> <p>See Batch Conversion for details.</p>"},{"location":"user-guide/conversion/single-building/#next-steps","title":"Next Steps","text":"<ul> <li>Batch Conversion - Convert multiple buildings efficiently</li> <li>System Types - Understand different HVAC systems</li> <li>Sensor Mapping - Customize sensor mappings</li> <li>Examples - More code examples</li> </ul> <p>Continue to: Batch Conversion \u2192</p>"},{"location":"user-guide/conversion/system-types/","title":"System Types","text":"<p>Understanding the different HVAC system types supported by HHW Brick Application.</p>"},{"location":"user-guide/conversion/system-types/#overview","title":"Overview","text":"<p>HHW Brick Application supports five main system types for heating hot water systems. Each system type has different equipment configurations and Brick class mappings.</p>"},{"location":"user-guide/conversion/system-types/#supported-system-types","title":"Supported System Types","text":"System Type Description Common Use Equipment Created Boiler Generic boiler system Legacy/generic buildings Boiler, pumps Non-condensing Non-condensing boiler with heat exchanger Older buildings Boiler, HX, primary/secondary loops Condensing High-efficiency condensing boiler Modern buildings Condensing boiler, HX, loops District HW District hot water connection Campus settings District connection, HX, building loop District Steam District steam connection Dense urban areas Steam connection, HX, building loop"},{"location":"user-guide/conversion/system-types/#system-type-details","title":"System Type Details","text":""},{"location":"user-guide/conversion/system-types/#1-boiler-systems","title":"1. Boiler Systems","text":"<p>Generic boiler system without specific efficiency classification.</p>"},{"location":"user-guide/conversion/system-types/#equipment-hierarchy","title":"Equipment Hierarchy","text":"<pre><code>graph TD\n    B[Boiler] --&gt;|has point| SP[Supply Temp]\n    B --&gt;|has point| RP[Return Temp]\n    B --&gt;|has point| F[Flow]\n    B --&gt;|feeds| P[Pump]\n\n    style B fill:#ff9800\n    style P fill:#2196f3</code></pre>"},{"location":"user-guide/conversion/system-types/#created-equipment","title":"Created Equipment","text":"<ul> <li>Boiler (<code>brick:Boiler</code>)</li> <li>Supply temperature sensor</li> <li>Return temperature sensor</li> <li> <p>Flow sensor (if available)</p> </li> <li> <p>Pumps (<code>brick:Water_Pump</code>)</p> </li> <li>Primary pumps</li> <li>Variable frequency drives (if available)</li> </ul>"},{"location":"user-guide/conversion/system-types/#csv-example","title":"CSV Example","text":"<pre><code># metadata.csv\ntag,system,org\n105,Boiler,Organization A\n\n# vars_available_by_building.csv\ntag,hw_supply_temp,hw_return_temp,hw_flow\n105,1,1,1\n</code></pre>"},{"location":"user-guide/conversion/system-types/#2-non-condensing-systems","title":"2. Non-condensing Systems","text":"<p>Non-condensing boiler with heat exchanger separating primary and secondary loops.</p>"},{"location":"user-guide/conversion/system-types/#equipment-hierarchy_1","title":"Equipment Hierarchy","text":"<pre><code>graph LR\n    B[Boiler&lt;br/&gt;Primary] --&gt;|feeds| HX[Heat&lt;br/&gt;Exchanger]\n    HX --&gt;|feeds| SL[Secondary&lt;br/&gt;Loop]\n    B --&gt;|has| PP[Primary&lt;br/&gt;Pump]\n    SL --&gt;|has| SP[Secondary&lt;br/&gt;Pump]\n\n    style B fill:#ff9800\n    style HX fill:#2196f3\n    style SL fill:#4caf50</code></pre>"},{"location":"user-guide/conversion/system-types/#created-equipment_1","title":"Created Equipment","text":"<p>Primary Side: - Boiler (<code>brick:Boiler</code>)   - HW supply temperature   - HW return temperature   - Flow rate   - Firing rate (if available)</p> <ul> <li>Primary Pumps (<code>brick:Water_Pump</code>)</li> <li>Pump power</li> <li>Pump speed</li> <li>VFD status</li> </ul> <p>Heat Transfer: - Heat Exchanger (<code>brick:Heat_Exchanger</code>)   - Primary/secondary interface</p> <p>Secondary Side: - Secondary Loop Equipment   - Supply/return temperatures   - Flow rate   - Pumps with VFDs</p>"},{"location":"user-guide/conversion/system-types/#csv-example_1","title":"CSV Example","text":"<pre><code># metadata.csv\ntag,system,org,b_number\n105,Non-condensing,Org A,2\n\n# vars_available_by_building.csv\ntag,hw_supply_temp,hw_return_temp,hw_flow,secondary_supply_temp,secondary_return_temp,secondary_flow,sup1,ret1,sup2,ret2\n105,1,1,1,1,1,1,1,1,1,1\n</code></pre>"},{"location":"user-guide/conversion/system-types/#multiple-boilers","title":"Multiple Boilers","text":"<p>The system can model multiple boilers:</p> <pre><code># Building with 3 boilers\n# metadata.csv: b_number=3\n# Creates: Boiler_Primary_1, Boiler_Primary_2, Boiler_Primary_3\n</code></pre>"},{"location":"user-guide/conversion/system-types/#3-condensing-systems","title":"3. Condensing Systems","text":"<p>High-efficiency condensing boiler systems with same topology as non-condensing.</p>"},{"location":"user-guide/conversion/system-types/#key-differences","title":"Key Differences","text":"Feature Non-condensing Condensing Boiler Type <code>brick:Boiler</code> <code>brick:Condensing_Boiler</code> Efficiency ~80-85% ~90-98% Exhaust Temp High (&gt;140\u00b0C) Low (&lt;60\u00b0C) Return Temp &gt;60\u00b0C Can be &lt;60\u00b0C"},{"location":"user-guide/conversion/system-types/#equipment-hierarchy_2","title":"Equipment Hierarchy","text":"<p>Same as non-condensing, but uses <code>brick:Condensing_Boiler</code> class.</p>"},{"location":"user-guide/conversion/system-types/#csv-example_2","title":"CSV Example","text":"<pre><code># metadata.csv\ntag,system,org\n106,Condensing,Org A\n\n# vars_available_by_building.csv (same format as non-condensing)\ntag,hw_supply_temp,hw_return_temp,hw_flow\n106,1,1,1\n</code></pre>"},{"location":"user-guide/conversion/system-types/#4-district-hot-water-district-hw","title":"4. District Hot Water (District HW)","text":"<p>Building connected to a campus-wide hot water distribution system.</p>"},{"location":"user-guide/conversion/system-types/#equipment-hierarchy_3","title":"Equipment Hierarchy","text":"<pre><code>graph LR\n    DS[District&lt;br/&gt;Supply] --&gt;|feeds| HX[Heat&lt;br/&gt;Exchanger]\n    HX --&gt;|feeds| BL[Building&lt;br/&gt;Loop]\n    DS --&gt;|has| DM[District&lt;br/&gt;Meter]\n    BL --&gt;|has| BP[Building&lt;br/&gt;Pump]\n\n    style DS fill:#9c27b0\n    style HX fill:#2196f3\n    style BL fill:#4caf50</code></pre>"},{"location":"user-guide/conversion/system-types/#created-equipment_2","title":"Created Equipment","text":"<p>District Side: - District Connection (<code>brick:District_Hot_Water_System</code>)   - Supply temperature   - Return temperature   - Flow meter   - Energy meter</p> <p>Building Side: - Heat Exchanger (<code>brick:Heat_Exchanger</code>) - Building Loop   - Secondary supply/return temperatures   - Building circulation pumps   - Control valves</p>"},{"location":"user-guide/conversion/system-types/#csv-example_3","title":"CSV Example","text":"<pre><code># metadata.csv\ntag,system,org\n108,District HW,Org B\n\n# vars_available_by_building.csv\ntag,hw_supply_temp,hw_return_temp,hw_flow,secondary_supply_temp,secondary_return_temp\n108,1,1,1,1,1\n</code></pre>"},{"location":"user-guide/conversion/system-types/#no-boilers","title":"No Boilers","text":"<p>District systems do not create boiler entities, even if boiler-related data exists:</p> <pre><code># If b_number &gt; 0 in District HW system:\n# \u26a0 Warning logged: \"District system but found boiler data\"\n# \u2713 No boilers created (correct behavior)\n</code></pre>"},{"location":"user-guide/conversion/system-types/#5-district-steam","title":"5. District Steam","text":"<p>Building connected to campus steam distribution.</p>"},{"location":"user-guide/conversion/system-types/#equipment-hierarchy_4","title":"Equipment Hierarchy","text":"<pre><code>graph LR\n    DST[District&lt;br/&gt;Steam] --&gt;|feeds| SC[Steam&lt;br/&gt;Condenser/HX]\n    SC --&gt;|feeds| BL[Building&lt;br/&gt;HW Loop]\n    SC --&gt;|returns| CR[Condensate&lt;br/&gt;Return]\n\n    style DST fill:#9c27b0\n    style SC fill:#ff5722\n    style BL fill:#4caf50</code></pre>"},{"location":"user-guide/conversion/system-types/#created-equipment_3","title":"Created Equipment","text":"<p>Steam Side: - District Steam Connection (<code>brick:District_Steam_System</code>)   - Steam pressure   - Steam temperature   - Condensate return temperature</p> <p>Conversion: - Steam-to-Water Heat Exchanger   - Steam condensing   - Hot water generation</p> <p>Building Side: - Hot Water Loop   - Supply/return temperatures   - Pumps and controls</p>"},{"location":"user-guide/conversion/system-types/#csv-example_4","title":"CSV Example","text":"<pre><code># metadata.csv\ntag,system,org\n109,District Steam,Org B\n\n# vars_available_by_building.csv\ntag,steam_pressure,condensate_temp,hw_supply_temp,hw_return_temp\n109,1,1,1,1\n</code></pre>"},{"location":"user-guide/conversion/system-types/#system-type-selection","title":"System Type Selection","text":""},{"location":"user-guide/conversion/system-types/#auto-detection","title":"Auto-Detection","text":"<p>If you don't specify <code>system_type</code>, it's auto-detected from metadata:</p> <pre><code>converter = CSVToBrickConverter()\nresult = converter.convert_to_brick(\n    metadata_csv=\"metadata.csv\",\n    vars_csv=\"vars.csv\",\n    building_tag=\"105\"\n    # system_type not specified - auto-detected\n)\n</code></pre>"},{"location":"user-guide/conversion/system-types/#manual-specification","title":"Manual Specification","text":"<p>You can override the metadata:</p> <pre><code>result = converter.convert_to_brick(\n    metadata_csv=\"metadata.csv\",\n    vars_csv=\"vars.csv\",\n    building_tag=\"105\",\n    system_type=\"Condensing\"  # Force this type\n)\n</code></pre>"},{"location":"user-guide/conversion/system-types/#filtering","title":"Filtering","text":"<p>Convert only specific system types:</p> <pre><code># Convert only condensing systems\nresult = converter.convert_to_brick(\n    metadata_csv=\"metadata.csv\",\n    vars_csv=\"vars.csv\",\n    system_type=\"Condensing\"  # Filter\n)\n</code></pre>"},{"location":"user-guide/conversion/system-types/#equipment-numbering","title":"Equipment Numbering","text":""},{"location":"user-guide/conversion/system-types/#boiler-numbering","title":"Boiler Numbering","text":"<p>Boilers are numbered based on <code>b_number</code> in metadata and sensor patterns:</p> <pre><code># metadata.csv: b_number=3\n# Creates:\n#   Boiler_Primary_1\n#   Boiler_Primary_2\n#   Boiler_Primary_3\n</code></pre>"},{"location":"user-guide/conversion/system-types/#sensor-based-detection","title":"Sensor-Based Detection","text":"<p>If <code>b_number</code> is missing, the converter infers from sensors:</p> <pre><code># vars_available_by_building.csv\ntag,sup1,ret1,fire1,sup2,ret2,fire2,sup3,ret3,fire3\n105,1,1,1,1,1,1,1,1,1\n# Detects 3 boilers from sup1-3, ret1-3, fire1-3\n</code></pre>"},{"location":"user-guide/conversion/system-types/#pump-numbering","title":"Pump Numbering","text":"<p>Similar logic for pumps:</p> <pre><code># vars_available_by_building.csv\ntag,pmp1_pwr,pmp1_spd,pmp2_pwr,pmp2_spd\n105,1,1,1,1\n# Detects 2 pumps\n</code></pre>"},{"location":"user-guide/conversion/system-types/#point-mappings-by-system","title":"Point Mappings by System","text":""},{"location":"user-guide/conversion/system-types/#common-points-all-systems","title":"Common Points (All Systems)","text":"CSV Column Brick Class <code>hw_supply_temp</code> <code>Hot_Water_Supply_Temperature_Sensor</code> <code>hw_return_temp</code> <code>Hot_Water_Return_Temperature_Sensor</code> <code>hw_flow</code> <code>Water_Flow_Sensor</code> <code>outdoor_temp</code> <code>Outside_Air_Temperature_Sensor</code>"},{"location":"user-guide/conversion/system-types/#boiler-specific-points","title":"Boiler-Specific Points","text":"CSV Column Brick Class Systems <code>fire1</code>, <code>fire2</code>, ... <code>Firing_Rate_Sensor</code> Boiler, Non-condensing, Condensing <code>sup1</code>, <code>sup2</code>, ... <code>Hot_Water_Supply_Temperature_Sensor</code> Boiler, Non-condensing, Condensing <code>ret1</code>, <code>ret2</code>, ... <code>Hot_Water_Return_Temperature_Sensor</code> Boiler, Non-condensing, Condensing"},{"location":"user-guide/conversion/system-types/#secondary-loop-points","title":"Secondary Loop Points","text":"CSV Column Brick Class Systems <code>secondary_supply_temp</code> <code>Hot_Water_Supply_Temperature_Sensor</code> Non-condensing, Condensing, District <code>secondary_return_temp</code> <code>Hot_Water_Return_Temperature_Sensor</code> Non-condensing, Condensing, District <code>secondary_flow</code> <code>Water_Flow_Sensor</code> Non-condensing, Condensing, District"},{"location":"user-guide/conversion/system-types/#district-specific-points","title":"District-Specific Points","text":"CSV Column Brick Class Systems <code>steam_pressure</code> <code>Steam_Pressure_Sensor</code> District Steam <code>condensate_temp</code> <code>Condensate_Temperature_Sensor</code> District Steam"},{"location":"user-guide/conversion/system-types/#validation-and-warnings","title":"Validation and Warnings","text":""},{"location":"user-guide/conversion/system-types/#system-type-mismatch","title":"System Type Mismatch","text":"<pre><code># Building marked as \"District HW\" but has boiler data\n# \u26a0 Warning: \"District system but found boiler data\"\n# \u2713 Boilers not created (correct)\n</code></pre>"},{"location":"user-guide/conversion/system-types/#missing-equipment-count","title":"Missing Equipment Count","text":"<pre><code># Boiler system but b_number=0\n# \u26a0 Warning: \"Boiler system but b_number=0\"\n# \u2713 Falls back to sensor detection\n</code></pre>"},{"location":"user-guide/conversion/system-types/#inconsistent-data","title":"Inconsistent Data","text":"<pre><code># b_number=2 but sensors show 3 boilers\n# \u26a0 Warning: \"b_number=2 but sensors show 3, using max\"\n# \u2713 Creates 3 boilers\n</code></pre>"},{"location":"user-guide/conversion/system-types/#choosing-the-right-system-type","title":"Choosing the Right System Type","text":""},{"location":"user-guide/conversion/system-types/#when-to-use-each-type","title":"When to Use Each Type","text":"<p>Boiler: - Generic/legacy systems - Simple heating setups - When specific efficiency unknown</p> <p>Non-condensing: - Older buildings (pre-2000) - Systems with return temp &gt;60\u00b0C - Standard efficiency boilers</p> <p>Condensing: - Modern buildings (post-2000) - High-efficiency systems - Return temp can be &lt;60\u00b0C</p> <p>District HW: - Campus settings - Centralized hot water - No on-site boilers</p> <p>District Steam: - Dense urban areas - Legacy campus systems - Steam-to-hot-water conversion</p>"},{"location":"user-guide/conversion/system-types/#examples-by-system-type","title":"Examples by System Type","text":""},{"location":"user-guide/conversion/system-types/#convert-all-non-condensing","title":"Convert All Non-condensing","text":"<pre><code>from hhw_brick import BatchConverter\n\nbatch = BatchConverter()\nresults = batch.convert_all_buildings(\n    metadata_csv=\"metadata.csv\",\n    vars_csv=\"vars.csv\",\n    output_dir=\"non_condensing_models/\",\n    system_type=\"Non-condensing\"\n)\n</code></pre>"},{"location":"user-guide/conversion/system-types/#convert-district-systems","title":"Convert District Systems","text":"<pre><code># District HW\nresults_hw = batch.convert_all_buildings(\n    metadata_csv=\"metadata.csv\",\n    vars_csv=\"vars.csv\",\n    output_dir=\"district_hw/\",\n    system_type=\"District HW\"\n)\n\n# District Steam\nresults_steam = batch.convert_all_buildings(\n    metadata_csv=\"metadata.csv\",\n    vars_csv=\"vars.csv\",\n    output_dir=\"district_steam/\",\n    system_type=\"District Steam\"\n)\n</code></pre>"},{"location":"user-guide/conversion/system-types/#separate-by-type","title":"Separate by Type","text":"<pre><code>system_types = [\n    \"Non-condensing\",\n    \"Condensing\",\n    \"District HW\"\n]\n\nfor system in system_types:\n    results = batch.convert_all_buildings(\n        metadata_csv=\"metadata.csv\",\n        vars_csv=\"vars.csv\",\n        output_dir=f\"models/{system.lower().replace(' ', '_')}/\",\n        system_type=system,\n        show_progress=True\n    )\n\n    print(f\"{system}: {results['successful']} buildings\")\n</code></pre>"},{"location":"user-guide/conversion/system-types/#next-steps","title":"Next Steps","text":"<ul> <li>Sensor Mapping - Customize sensor mappings</li> <li>Validation - Validate system models</li> <li>Examples - Working examples</li> </ul> <p>Continue to: Sensor Mapping \u2192</p>"},{"location":"user-guide/validation/","title":"Model Validation","text":"<p>Ensure your Brick models are correct, complete, and follow schema rules.</p>"},{"location":"user-guide/validation/#overview","title":"Overview","text":"<p>After converting CSV data to Brick models, validation ensures:</p> <ul> <li>Ontology correctness - Models follow Brick schema rules</li> <li>Data completeness - All expected points and equipment exist</li> <li>Count accuracy - Point and equipment counts match expectations</li> </ul>"},{"location":"user-guide/validation/#why-validate","title":"Why Validate?","text":""},{"location":"user-guide/validation/#quality-assurance","title":"Quality Assurance","text":"<p>Catch errors early: <pre><code># Convert\nconverter.convert_to_brick(...)\n\n# Validate immediately\nvalidator = BrickModelValidator()\nis_valid, report = validator.validate_model(\"building_105.ttl\")\n\nif not is_valid:\n    print(\"Fix these issues:\", report)\n</code></pre></p>"},{"location":"user-guide/validation/#production-readiness","title":"Production Readiness","text":"<p>Ensure models are ready for analytics: <pre><code># Only use validated models\nif is_valid:\n    app = apps.load_app(\"secondary_loop_temp_diff\")\n    results = app.analyze(model, data, config)\n</code></pre></p>"},{"location":"user-guide/validation/#validation-types","title":"Validation Types","text":"<p>HHW Brick Application provides three types of validation:</p>"},{"location":"user-guide/validation/#1-ontology-validation","title":"1. Ontology Validation","text":"<p>Check if model follows Brick schema rules.</p> <pre><code>from hhw_brick import BrickModelValidator\n\nvalidator = BrickModelValidator(use_local_brick=True)\nresult = validator.validate_ontology(\"building_105.ttl\")\n\nif result['valid']:\n    print(\"\u2713 Model follows Brick schema\")\nelse:\n    print(f\"\u2717 Found {len(result['violations'])} violations\")\n</code></pre> <p>Checks: - \u2713 Valid Brick classes used - \u2713 Correct relationship types - \u2713 Proper namespaces - \u2713 RDF/OWL syntax</p> <p>Learn more \u2192</p>"},{"location":"user-guide/validation/#2-ground-truth-validation","title":"2. Ground Truth Validation","text":"<p>Compare model against expected values.</p> <pre><code>from hhw_brick import GroundTruthCalculator, BrickModelValidator\n\n# Generate ground truth from CSV\ncalculator = GroundTruthCalculator()\ncalculator.calculate(\n    metadata_csv=\"metadata.csv\",\n    vars_csv=\"vars.csv\",\n    output_csv=\"ground_truth.csv\"\n)\n\n# Validate against ground truth\nvalidator = BrickModelValidator(\n    ground_truth_csv_path=\"ground_truth.csv\"\n)\n\nresult = validator.validate_point_count(\"building_105.ttl\")\nprint(f\"Point accuracy: {result['accuracy_percentage']:.1f}%\")\n</code></pre> <p>Checks: - \u2713 Point count matches - \u2713 Boiler count correct - \u2713 Pump count correct - \u2713 Weather station present</p> <p>Learn more \u2192</p>"},{"location":"user-guide/validation/#3-subgraph-pattern-validation","title":"3. Subgraph Pattern Validation","text":"<p>Verify system topology patterns.</p> <pre><code>from hhw_brick.validation import SubgraphPatternValidator\n\nvalidator = SubgraphPatternValidator()\nresult = validator.validate(\"building_105.ttl\")\n\nif result['all_patterns_found']:\n    print(\"\u2713 All expected patterns found\")\nelse:\n    print(f\"\u2717 Missing: {result['missing_patterns']}\")\n</code></pre> <p>Checks: - \u2713 Boiler \u2192 Heat Exchanger connection - \u2713 Equipment \u2192 Points relationships - \u2713 Primary \u2192 Secondary loop flow</p> <p>Learn more \u2192</p>"},{"location":"user-guide/validation/#quick-start","title":"Quick Start","text":""},{"location":"user-guide/validation/#validate-a-single-model","title":"Validate a Single Model","text":"<p>Complete validation workflow:</p> <pre><code>from hhw_brick import BrickModelValidator, GroundTruthCalculator\n\n# Step 1: Generate ground truth\ncalculator = GroundTruthCalculator()\ncalculator.calculate(\n    metadata_csv=\"metadata.csv\",\n    vars_csv=\"vars.csv\",\n    output_csv=\"ground_truth.csv\"\n)\n\n# Step 2: Create validator\nvalidator = BrickModelValidator(\n    ground_truth_csv_path=\"ground_truth.csv\",\n    use_local_brick=True\n)\n\n# Step 3: Validate ontology\nontology_result = validator.validate_ontology(\"building_105.ttl\")\nprint(f\"Ontology valid: {ontology_result['valid']}\")\n\n# Step 4: Validate point counts\npoint_result = validator.validate_point_count(\"building_105.ttl\")\nprint(f\"Point accuracy: {point_result['accuracy_percentage']:.1f}%\")\n\n# Step 5: Validate equipment counts\nequipment_result = validator.validate_equipment_count(\"building_105.ttl\")\nprint(f\"Equipment match: {equipment_result['overall_success']}\")\n</code></pre>"},{"location":"user-guide/validation/#batch-validate-multiple-models","title":"Batch Validate Multiple Models","text":"<p>Validate all models in a directory:</p> <pre><code>from hhw_brick import BrickModelValidator\n\nvalidator = BrickModelValidator(\n    ground_truth_csv_path=\"ground_truth.csv\",\n    use_local_brick=True\n)\n\n# Batch ontology validation (parallel processing)\nresults = validator.batch_validate_ontology(\n    test_data_dir=\"brick_models/\",\n    max_workers=8  # Parallel workers\n)\n\nprint(f\"Validated {results['total_files']} models\")\nprint(f\"Valid: {results['passed_files']}\")\nprint(f\"Invalid: {results['failed_files']}\")\nprint(f\"Accuracy: {results['overall_accuracy']:.1f}%\")\n\n# Batch point count validation\npoint_results = validator.batch_validate_point_count(\n    test_data_dir=\"brick_models/\"\n)\n\nprint(f\"Point count accuracy: {point_results['overall_accuracy']:.1f}%\")\n</code></pre>"},{"location":"user-guide/validation/#validation-workflow","title":"Validation Workflow","text":""},{"location":"user-guide/validation/#complete-production-workflow","title":"Complete Production Workflow","text":"<pre><code>graph TD\n    A[CSV Files] --&gt;|Convert| B[Brick Models]\n    A --&gt;|Calculate| C[Ground Truth]\n    B --&gt;|Validate Ontology| D{Valid?}\n    D --&gt;|No| E[Fix Conversion]\n    E --&gt; A\n    D --&gt;|Yes| F[Validate Counts]\n    C --&gt;|Compare| F\n    F --&gt;|Check| G{Match?}\n    G --&gt;|No| H[Review Data]\n    H --&gt; A\n    G --&gt;|Yes| I[\u2713 Validated Models]\n    I --&gt;|Use in| J[Analytics Apps]\n\n    style A fill:#e1f5ff\n    style I fill:#c8e6c9\n    style E fill:#ffcdd2\n    style H fill:#ffcdd2</code></pre>"},{"location":"user-guide/validation/#step-by-step-example","title":"Step-by-Step Example","text":"<p>Based on <code>examples/02_ontology_validation.py</code> and <code>examples/03_point_count_validation.py</code>:</p> <pre><code>\"\"\"\nComplete validation workflow\nBased on HHW Brick Application examples\n\"\"\"\n\nfrom pathlib import Path\nfrom hhw_brick import (\n    CSVToBrickConverter,\n    BatchConverter,\n    BrickModelValidator,\n    GroundTruthCalculator\n)\n\ndef complete_workflow():\n    # Paths\n    metadata_csv = \"metadata.csv\"\n    vars_csv = \"vars_available_by_building.csv\"\n    output_dir = Path(\"brick_models\")\n    ground_truth_csv = \"ground_truth.csv\"\n\n    # ===== Step 1: Convert CSV to Brick =====\n    print(\"Step 1: Converting CSV to Brick...\")\n    batch = BatchConverter()\n    conversion_results = batch.convert_all_buildings(\n        metadata_csv=metadata_csv,\n        vars_csv=vars_csv,\n        output_dir=str(output_dir),\n        show_progress=True\n    )\n    print(f\"\u2713 Converted {conversion_results['successful']} buildings\")\n\n    # ===== Step 2: Generate Ground Truth =====\n    print(\"\\nStep 2: Generating ground truth...\")\n    calculator = GroundTruthCalculator()\n    ground_truth_df = calculator.calculate(\n        metadata_csv=metadata_csv,\n        vars_csv=vars_csv,\n        output_csv=ground_truth_csv\n    )\n    print(f\"\u2713 Ground truth generated for {len(ground_truth_df)} buildings\")\n\n    # ===== Step 3: Validate Ontology (Batch) =====\n    print(\"\\nStep 3: Validating ontology...\")\n    validator = BrickModelValidator(\n        ground_truth_csv_path=ground_truth_csv,\n        use_local_brick=True\n    )\n\n    ontology_results = validator.batch_validate_ontology(\n        test_data_dir=str(output_dir),\n        max_workers=8\n    )\n\n    print(f\"\u2713 Ontology validation:\")\n    print(f\"  - Valid: {ontology_results['passed_files']}/{ontology_results['total_files']}\")\n    print(f\"  - Accuracy: {ontology_results['overall_accuracy']:.1f}%\")\n\n    # ===== Step 4: Validate Point Counts (Batch) =====\n    print(\"\\nStep 4: Validating point counts...\")\n    point_results = validator.batch_validate_point_count(\n        test_data_dir=str(output_dir)\n    )\n\n    print(f\"\u2713 Point count validation:\")\n    print(f\"  - Matched: {point_results['passed_files']}/{point_results['total_files']}\")\n    print(f\"  - Accuracy: {point_results['overall_accuracy']:.1f}%\")\n\n    # ===== Step 5: Validate Equipment Counts (Batch) =====\n    print(\"\\nStep 5: Validating equipment counts...\")\n    equipment_results = validator.batch_validate_equipment_count(\n        test_data_dir=str(output_dir)\n    )\n\n    print(f\"\u2713 Equipment count validation:\")\n    print(f\"  - Matched: {equipment_results['passed_files']}/{equipment_results['total_files']}\")\n    print(f\"  - Accuracy: {equipment_results['overall_accuracy']:.1f}%\")\n\n    # ===== Summary =====\n    print(\"\\n\" + \"=\"*60)\n    print(\"Validation Summary\")\n    print(\"=\"*60)\n    print(f\"Total models: {conversion_results['successful']}\")\n    print(f\"Ontology valid: {ontology_results['passed_files']}\")\n    print(f\"Point counts match: {point_results['passed_files']}\")\n    print(f\"Equipment counts match: {equipment_results['passed_files']}\")\n\n    # Overall success\n    all_valid = (\n        ontology_results['passed_files'] == conversion_results['successful'] and\n        point_results['passed_files'] == conversion_results['successful'] and\n        equipment_results['passed_files'] == conversion_results['successful']\n    )\n\n    if all_valid:\n        print(\"\\n\u2713 All models validated successfully!\")\n        print(\"  Models are ready for analytics applications.\")\n    else:\n        print(\"\\n\u26a0 Some models have validation issues\")\n        print(\"  Review failed models before using in production.\")\n\n    return {\n        'conversion': conversion_results,\n        'ontology': ontology_results,\n        'points': point_results,\n        'equipment': equipment_results\n    }\n\nif __name__ == \"__main__\":\n    results = complete_workflow()\n</code></pre>"},{"location":"user-guide/validation/#common-validation-patterns","title":"Common Validation Patterns","text":""},{"location":"user-guide/validation/#pattern-1-validate-after-conversion","title":"Pattern 1: Validate After Conversion","text":"<p>Always validate after converting:</p> <pre><code># Convert\nresult = converter.convert_to_brick(\n    metadata_csv=\"metadata.csv\",\n    vars_csv=\"vars.csv\",\n    building_tag=\"105\",\n    output_path=\"building_105.ttl\"\n)\n\n# Validate immediately\nvalidator = BrickModelValidator(use_local_brick=True)\nvalidation = validator.validate_ontology(\"building_105.ttl\")\n\nif validation['valid']:\n    print(\"\u2713 Conversion successful and valid\")\nelse:\n    print(\"\u2717 Model has errors - review conversion\")\n</code></pre>"},{"location":"user-guide/validation/#pattern-2-pre-production-check","title":"Pattern 2: Pre-Production Check","text":"<p>Before deploying to analytics:</p> <pre><code>def is_model_ready(model_path, ground_truth_path):\n    \"\"\"Check if model is ready for production use.\"\"\"\n\n    validator = BrickModelValidator(\n        ground_truth_csv_path=ground_truth_path,\n        use_local_brick=True\n    )\n\n    # Check ontology\n    ont_result = validator.validate_ontology(model_path)\n    if not ont_result['valid']:\n        return False, \"Ontology validation failed\"\n\n    # Check point counts\n    point_result = validator.validate_point_count(model_path)\n    if not point_result['success']:\n        return False, \"Point count mismatch\"\n\n    # Check equipment counts\n    equip_result = validator.validate_equipment_count(model_path)\n    if not equip_result['overall_success']:\n        return False, \"Equipment count mismatch\"\n\n    return True, \"Model ready\"\n\n# Use it\nready, message = is_model_ready(\"building_105.ttl\", \"ground_truth.csv\")\nif ready:\n    # Run analytics\n    app.analyze(model, data, config)\n</code></pre>"},{"location":"user-guide/validation/#pattern-3-continuous-validation","title":"Pattern 3: Continuous Validation","text":"<p>Validate on data updates:</p> <pre><code>import os\nfrom datetime import datetime\n\ndef validate_if_changed(model_path, ground_truth_path, cache_file=\".validation_cache\"):\n    \"\"\"Only validate if model changed since last check.\"\"\"\n\n    # Get model modification time\n    mod_time = os.path.getmtime(model_path)\n\n    # Check cache\n    if os.path.exists(cache_file):\n        with open(cache_file, 'r') as f:\n            last_validated = float(f.read().strip())\n\n        if mod_time &lt;= last_validated:\n            print(\"Model unchanged, using cached validation result\")\n            return True\n\n    # Validate\n    validator = BrickModelValidator(\n        ground_truth_csv_path=ground_truth_path\n    )\n\n    result = validator.validate_ontology(model_path)\n\n    # Update cache\n    if result['valid']:\n        with open(cache_file, 'w') as f:\n            f.write(str(datetime.now().timestamp()))\n\n    return result['valid']\n</code></pre>"},{"location":"user-guide/validation/#validation-results","title":"Validation Results","text":""},{"location":"user-guide/validation/#understanding-results","title":"Understanding Results","text":"<p>All validation methods return dictionaries with results:</p> <pre><code># Ontology validation\n{\n    'valid': True,\n    'violations': [],\n    'ttl_file_path': 'building_105.ttl'\n}\n\n# Point count validation\n{\n    'success': True,\n    'match': True,\n    'expected_point_count': 23,\n    'actual_point_count': 23,\n    'accuracy_percentage': 100.0\n}\n\n# Equipment count validation\n{\n    'overall_success': True,\n    'boiler': {'expected': 2, 'actual': 2, 'match': True},\n    'pump': {'expected': 3, 'actual': 3, 'match': True},\n    'weather_station': {'expected': 1, 'actual': 1, 'match': True}\n}\n</code></pre>"},{"location":"user-guide/validation/#troubleshooting","title":"Troubleshooting","text":""},{"location":"user-guide/validation/#issue-brickschema-not-available","title":"Issue: \"brickschema not available\"","text":"<p>Solution: <pre><code>pip install brickschema\n</code></pre></p>"},{"location":"user-guide/validation/#issue-ground-truth-file-not-found","title":"Issue: \"Ground truth file not found\"","text":"<p>Solution: Generate it first: <pre><code>calculator = GroundTruthCalculator()\ncalculator.calculate(\n    metadata_csv=\"metadata.csv\",\n    vars_csv=\"vars.csv\",\n    output_csv=\"ground_truth.csv\"\n)\n</code></pre></p>"},{"location":"user-guide/validation/#issue-point-count-mismatch","title":"Issue: Point count mismatch","text":"<p>Possible causes: 1. Sensor mapping incorrect 2. Missing sensors in vars.csv 3. Conversion issues</p> <p>Solution: Review conversion warnings: <pre><code>converter = CSVToBrickConverter()\nresult = converter.convert_to_brick(...)\n\nif converter.validation_warnings:\n    for warning in converter.validation_warnings:\n        print(warning)\n</code></pre></p>"},{"location":"user-guide/validation/#performance","title":"Performance","text":""},{"location":"user-guide/validation/#batch-validation-speed","title":"Batch Validation Speed","text":"<p>Parallel processing significantly improves performance:</p> <pre><code># Serial (slow for many files)\nfor file in ttl_files:\n    validator.validate_ontology(file)\n\n# Parallel (much faster)\nresults = validator.batch_validate_ontology(\n    test_data_dir=\"brick_models/\",\n    max_workers=8  # Use 8 parallel workers\n)\n</code></pre> <p>Typical performance: - 10 models: ~5 seconds (parallel) vs ~30 seconds (serial) - 100 models: ~45 seconds (parallel) vs ~5 minutes (serial)</p>"},{"location":"user-guide/validation/#next-steps","title":"Next Steps","text":"<p>Learn about each validation type in detail:</p> <ul> <li>Ontology Validation - Check Brick schema compliance</li> <li>Ground Truth Validation - Verify counts and completeness</li> <li>Subgraph Patterns - Validate system topology</li> </ul> <p>Or explore related topics:</p> <ul> <li>Conversion Guide - How to generate models</li> <li>Applications Guide - Use validated models</li> <li>Examples - Working code samples</li> </ul> <p>Continue to: Ontology Validation \u2192</p>"},{"location":"user-guide/validation/ground-truth/","title":"Ground Truth Validation","text":"<p>Validate Brick models against expected counts calculated from source CSV data.</p>"},{"location":"user-guide/validation/ground-truth/#overview","title":"Overview","text":"<p>Ground truth validation compares your Brick model against expected values derived from the original CSV data:</p> <ul> <li>Point counts - Number of sensors/points</li> <li>Boiler counts - Number of boilers</li> <li>Pump counts - Number of pumps  </li> <li>Weather stations - Presence of weather data</li> </ul> <p>This ensures your conversion was complete and accurate.</p>"},{"location":"user-guide/validation/ground-truth/#why-ground-truth-validation","title":"Why Ground Truth Validation?","text":""},{"location":"user-guide/validation/ground-truth/#verify-completeness","title":"Verify Completeness","text":"<p>Ensure no data was lost during conversion:</p> <pre><code># Expected: 23 points (from CSV)\n# Actual: 18 points (in Brick model)\n# \u2717 5 points missing - conversion issue!\n</code></pre>"},{"location":"user-guide/validation/ground-truth/#catch-conversion-errors","title":"Catch Conversion Errors","text":"<p>Find problems early:</p> <pre><code># Expected: 2 boilers\n# Actual: 1 boiler\n# \u2717 Check b_number or sensor detection logic\n</code></pre>"},{"location":"user-guide/validation/ground-truth/#production-quality","title":"Production Quality","text":"<p>Only use complete models:</p> <pre><code>if point_validation['match']:\n    # Model is complete, safe to use\n    app.analyze(model, data, config)\n</code></pre>"},{"location":"user-guide/validation/ground-truth/#ground-truth-calculator","title":"Ground Truth Calculator","text":""},{"location":"user-guide/validation/ground-truth/#generate-ground-truth","title":"Generate Ground Truth","text":"<p>From <code>examples/03_point_count_validation.py</code>:</p> <pre><code>from hhw_brick.validation import GroundTruthCalculator\n\n# Create calculator\ncalculator = GroundTruthCalculator()\n\n# Calculate expected counts from CSV\nground_truth_df = calculator.calculate(\n    metadata_csv=\"metadata.csv\",\n    vars_csv=\"vars_available_by_building.csv\",\n    output_csv=\"ground_truth.csv\"\n)\n\nprint(f\"Generated ground truth for {len(ground_truth_df)} buildings\")\n</code></pre>"},{"location":"user-guide/validation/ground-truth/#ground-truth-format","title":"Ground Truth Format","text":"<p>The generated <code>ground_truth.csv</code> contains:</p> <pre><code>tag,system,point_count,boiler_count,pump_count,weather_station_count\n105,Non-condensing,23,2,3,1\n106,Condensing,18,1,2,0\n107,District HW,15,0,2,1\n</code></pre> <p>Columns: - <code>tag</code> - Building ID - <code>system</code> - System type - <code>point_count</code> - Expected total points - <code>boiler_count</code> - Expected boilers - <code>pump_count</code> - Expected pumps - <code>weather_station_count</code> - Expected weather stations (0 or 1)</p>"},{"location":"user-guide/validation/ground-truth/#how-counts-are-calculated","title":"How Counts Are Calculated","text":""},{"location":"user-guide/validation/ground-truth/#point-count","title":"Point Count","text":"<p>Counts all sensors marked as available (value=1) in <code>vars_available_by_building.csv</code>:</p> <pre><code># vars.csv\ntag,hw_supply_temp,hw_return_temp,hw_flow,outdoor_temp\n105,1,1,1,1  # 4 sensors available\n\n# ground_truth.csv\ntag,point_count\n105,4  # Calculated from available sensors\n</code></pre>"},{"location":"user-guide/validation/ground-truth/#boiler-count","title":"Boiler Count","text":"<p>From <code>b_number</code> in metadata.csv or inferred from sensor patterns:</p> <pre><code># metadata.csv\ntag,b_number\n105,2  # Explicitly set\n\n# OR inferred from sensors\n# vars.csv: sup1, ret1, fire1, sup2, ret2, fire2\n# Infers: 2 boilers\n\n# ground_truth.csv\ntag,boiler_count\n105,2\n</code></pre>"},{"location":"user-guide/validation/ground-truth/#pump-count","title":"Pump Count","text":"<p>Inferred from pump sensor patterns (<code>pmp1_*</code>, <code>pmp2_*</code>, etc.):</p> <pre><code># vars.csv\ntag,pmp1_pwr,pmp1_spd,pmp2_pwr,pmp2_spd,pmp3_pwr\n105,1,1,1,1,1  # Pump 1, 2, 3 detected\n\n# ground_truth.csv\ntag,pump_count\n105,3\n</code></pre>"},{"location":"user-guide/validation/ground-truth/#weather-station","title":"Weather Station","text":"<p>From <code>oper</code> column or outdoor sensors:</p> <pre><code># Has outdoor_temp sensor or oper != 0\n# weather_station_count = 1\n</code></pre>"},{"location":"user-guide/validation/ground-truth/#point-count-validation","title":"Point Count Validation","text":""},{"location":"user-guide/validation/ground-truth/#validate-single-building","title":"Validate Single Building","text":"<p>From <code>examples/03_point_count_validation.py</code>:</p> <pre><code>from hhw_brick import BrickModelValidator\n\n# Create validator with ground truth\nvalidator = BrickModelValidator(\n    ground_truth_csv_path=\"ground_truth.csv\"\n)\n\n# Validate point count\nresult = validator.validate_point_count(\"building_105.ttl\")\n\n# Check result\nif result['success'] and result['match']:\n    print(\"\u2713 Point count matches!\")\nelse:\n    print(f\"\u2717 Point count mismatch\")\n    print(f\"  Expected: {result['expected_point_count']}\")\n    print(f\"  Actual: {result['actual_point_count']}\")\n    print(f\"  Accuracy: {result['accuracy_percentage']:.1f}%\")\n</code></pre>"},{"location":"user-guide/validation/ground-truth/#validate_point_count","title":"validate_point_count()","text":"<p>Signature: <pre><code>def validate_point_count(ttl_file_path: str) -&gt; Dict\n</code></pre></p> <p>Returns: <pre><code>{\n    'success': bool,                # Overall success\n    'match': bool,                  # Counts match exactly\n    'expected_point_count': int,    # From ground truth\n    'actual_point_count': int,      # From Brick model\n    'accuracy_percentage': float,   # Match percentage\n    'ttl_file_path': str,          # Model file path\n    'building_tag': str             # Extracted building ID\n}\n</code></pre></p> <p>Example: <pre><code>result = validator.validate_point_count(\"building_105.ttl\")\n\nprint(f\"Expected: {result['expected_point_count']}\")\nprint(f\"Actual: {result['actual_point_count']}\")\nprint(f\"Match: {result['match']}\")\nprint(f\"Accuracy: {result['accuracy_percentage']:.1f}%\")\n</code></pre></p>"},{"location":"user-guide/validation/ground-truth/#equipment-count-validation","title":"Equipment Count Validation","text":""},{"location":"user-guide/validation/ground-truth/#validate-equipment-counts","title":"Validate Equipment Counts","text":"<p>From <code>examples/04_equipment_count_validation.py</code>:</p> <pre><code>from hhw_brick import BrickModelValidator\n\nvalidator = BrickModelValidator(\n    ground_truth_csv_path=\"ground_truth.csv\",\n    use_local_brick=True\n)\n\n# Validate equipment counts\nresult = validator.validate_equipment_count(\"building_105.ttl\")\n\n# Check overall result\nif result['overall_success']:\n    print(\"\u2713 All equipment counts match!\")\nelse:\n    print(\"\u2717 Equipment count mismatch detected\")\n\n# Check individual equipment\nprint(f\"Boilers: {result['boiler']['actual']}/{result['boiler']['expected']}\")\nprint(f\"Pumps: {result['pump']['actual']}/{result['pump']['expected']}\")\nprint(f\"Weather: {result['weather_station']['actual']}/{result['weather_station']['expected']}\")\n</code></pre>"},{"location":"user-guide/validation/ground-truth/#validate_equipment_count","title":"validate_equipment_count()","text":"<p>Signature: <pre><code>def validate_equipment_count(ttl_file_path: str) -&gt; Dict\n</code></pre></p> <p>Returns: <pre><code>{\n    'overall_success': bool,        # All equipment matches\n    'boiler': {\n        'expected': int,\n        'actual': int,\n        'match': bool\n    },\n    'pump': {\n        'expected': int,\n        'actual': int,\n        'match': bool\n    },\n    'weather_station': {\n        'expected': int,\n        'actual': int,\n        'match': bool\n    },\n    'ttl_file_path': str,\n    'building_tag': str\n}\n</code></pre></p> <p>Example: <pre><code>result = validator.validate_equipment_count(\"building_105.ttl\")\n\nfor equip_type in ['boiler', 'pump', 'weather_station']:\n    equip = result[equip_type]\n    status = \"\u2713\" if equip['match'] else \"\u2717\"\n    print(f\"{status} {equip_type}: {equip['actual']}/{equip['expected']}\")\n</code></pre></p>"},{"location":"user-guide/validation/ground-truth/#batch-validation","title":"Batch Validation","text":""},{"location":"user-guide/validation/ground-truth/#batch-point-count-validation","title":"Batch Point Count Validation","text":"<p>Validate multiple models:</p> <pre><code>from hhw_brick import BrickModelValidator\n\nvalidator = BrickModelValidator(\n    ground_truth_csv_path=\"ground_truth.csv\"\n)\n\n# Batch validate point counts\nresults = validator.batch_validate_point_count(\n    test_data_dir=\"brick_models/\"\n)\n\nprint(f\"Total files: {results['total_files']}\")\nprint(f\"Matched: {results['passed_files']}\")\nprint(f\"Mismatched: {results['failed_files']}\")\nprint(f\"Accuracy: {results['overall_accuracy']:.1f}%\")\n</code></pre>"},{"location":"user-guide/validation/ground-truth/#batch-equipment-count-validation","title":"Batch Equipment Count Validation","text":"<pre><code># Batch validate equipment counts\nresults = validator.batch_validate_equipment_count(\n    test_data_dir=\"brick_models/\"\n)\n\nprint(f\"Total files: {results['total_files']}\")\nprint(f\"All matched: {results['passed_files']}\")\nprint(f\"Accuracy: {results['overall_accuracy']:.1f}%\")\n</code></pre>"},{"location":"user-guide/validation/ground-truth/#batch_validate_point_count","title":"batch_validate_point_count()","text":"<p>Signature: <pre><code>def batch_validate_point_count(test_data_dir: str) -&gt; Dict\n</code></pre></p> <p>Returns: <pre><code>{\n    'total_files': int,\n    'passed_files': int,            # Exact matches\n    'failed_files': int,            # Mismatches\n    'overall_accuracy': float,      # Average accuracy %\n    'individual_results': [...]     # List of individual results\n}\n</code></pre></p>"},{"location":"user-guide/validation/ground-truth/#complete-validation-workflow","title":"Complete Validation Workflow","text":"<p>From examples:</p> <pre><code>\"\"\"\nComplete ground truth validation workflow\nBased on examples/03 and 04\n\"\"\"\n\nfrom pathlib import Path\nfrom hhw_brick import BatchConverter, BrickModelValidator\nfrom hhw_brick.validation import GroundTruthCalculator\n\ndef complete_ground_truth_workflow():\n    # Paths\n    metadata_csv = \"metadata.csv\"\n    vars_csv = \"vars_available_by_building.csv\"\n    output_dir = Path(\"brick_models\")\n    ground_truth_csv = \"ground_truth.csv\"\n\n    # ===== Step 1: Convert CSV to Brick =====\n    print(\"Step 1: Converting CSV to Brick...\")\n    batch = BatchConverter()\n    conversion_results = batch.convert_all_buildings(\n        metadata_csv=metadata_csv,\n        vars_csv=vars_csv,\n        output_dir=str(output_dir),\n        show_progress=True\n    )\n    print(f\"\u2713 Converted {conversion_results['successful']} buildings\")\n\n    # ===== Step 2: Generate Ground Truth =====\n    print(\"\\nStep 2: Generating ground truth...\")\n    calculator = GroundTruthCalculator()\n    ground_truth_df = calculator.calculate(\n        metadata_csv=metadata_csv,\n        vars_csv=vars_csv,\n        output_csv=ground_truth_csv\n    )\n    print(f\"\u2713 Ground truth for {len(ground_truth_df)} buildings\")\n\n    # Show sample\n    print(\"\\n  Sample (first 3 buildings):\")\n    for _, row in ground_truth_df.head(3).iterrows():\n        print(f\"    Building {row['tag']}: \"\n              f\"{int(row['point_count'])} points, \"\n              f\"{int(row['boiler_count'])} boilers, \"\n              f\"{int(row['pump_count'])} pumps\")\n\n    # ===== Step 3: Create Validator =====\n    validator = BrickModelValidator(\n        ground_truth_csv_path=ground_truth_csv,\n        use_local_brick=True\n    )\n\n    # ===== Step 4: Validate Point Counts =====\n    print(\"\\nStep 3: Validating point counts...\")\n    point_results = validator.batch_validate_point_count(\n        test_data_dir=str(output_dir)\n    )\n\n    print(f\"\u2713 Point count validation:\")\n    print(f\"  - Matched: {point_results['passed_files']}/{point_results['total_files']}\")\n    print(f\"  - Accuracy: {point_results['overall_accuracy']:.1f}%\")\n\n    # ===== Step 5: Validate Equipment Counts =====\n    print(\"\\nStep 4: Validating equipment counts...\")\n    equipment_results = validator.batch_validate_equipment_count(\n        test_data_dir=str(output_dir)\n    )\n\n    print(f\"\u2713 Equipment count validation:\")\n    print(f\"  - Matched: {equipment_results['passed_files']}/{equipment_results['total_files']}\")\n    print(f\"  - Accuracy: {equipment_results['overall_accuracy']:.1f}%\")\n\n    # ===== Step 6: Detailed Report for Failures =====\n    if point_results['failed_files'] &gt; 0:\n        print(\"\\nPoint count mismatches:\")\n        for result in point_results['individual_results']:\n            if not result['match']:\n                file_name = Path(result['ttl_file_path']).name\n                print(f\"  \u2717 {file_name}\")\n                print(f\"      Expected: {result['expected_point_count']}\")\n                print(f\"      Actual: {result['actual_point_count']}\")\n                print(f\"      Accuracy: {result['accuracy_percentage']:.1f}%\")\n\n    # ===== Summary =====\n    print(\"\\n\" + \"=\"*60)\n    print(\"Ground Truth Validation Summary\")\n    print(\"=\"*60)\n    print(f\"Total buildings: {conversion_results['successful']}\")\n    print(f\"Point counts matched: {point_results['passed_files']}\")\n    print(f\"Equipment counts matched: {equipment_results['passed_files']}\")\n\n    all_valid = (\n        point_results['passed_files'] == conversion_results['successful'] and\n        equipment_results['passed_files'] == conversion_results['successful']\n    )\n\n    if all_valid:\n        print(\"\\n\u2713 All models complete and accurate!\")\n        print(\"  Ready for production use.\")\n    else:\n        print(\"\\n\u26a0 Some models have count mismatches\")\n        print(\"  Review conversion or source data.\")\n\n    return {\n        'conversion': conversion_results,\n        'ground_truth': ground_truth_df,\n        'points': point_results,\n        'equipment': equipment_results\n    }\n\nif __name__ == \"__main__\":\n    results = complete_ground_truth_workflow()\n</code></pre>"},{"location":"user-guide/validation/ground-truth/#understanding-results","title":"Understanding Results","text":""},{"location":"user-guide/validation/ground-truth/#point-count-match","title":"Point Count Match","text":"<pre><code># Perfect match\n{\n    'success': True,\n    'match': True,\n    'expected_point_count': 23,\n    'actual_point_count': 23,\n    'accuracy_percentage': 100.0\n}\n\n# Partial match\n{\n    'success': True,\n    'match': False,\n    'expected_point_count': 23,\n    'actual_point_count': 20,\n    'accuracy_percentage': 86.96  # 20/23 * 100\n}\n</code></pre>"},{"location":"user-guide/validation/ground-truth/#equipment-count-results","title":"Equipment Count Results","text":"<pre><code># All match\n{\n    'overall_success': True,\n    'boiler': {'expected': 2, 'actual': 2, 'match': True},\n    'pump': {'expected': 3, 'actual': 3, 'match': True},\n    'weather_station': {'expected': 1, 'actual': 1, 'match': True}\n}\n\n# Mismatch detected\n{\n    'overall_success': False,\n    'boiler': {'expected': 2, 'actual': 1, 'match': False},  # Missing 1\n    'pump': {'expected': 3, 'actual': 3, 'match': True},\n    'weather_station': {'expected': 1, 'actual': 1, 'match': True}\n}\n</code></pre>"},{"location":"user-guide/validation/ground-truth/#common-patterns","title":"Common Patterns","text":""},{"location":"user-guide/validation/ground-truth/#pattern-1-validate-during-conversion","title":"Pattern 1: Validate During Conversion","text":"<pre><code>from hhw_brick import CSVToBrickConverter, BrickModelValidator\nfrom hhw_brick.validation import GroundTruthCalculator\n\n# Generate ground truth once\ncalculator = GroundTruthCalculator()\ncalculator.calculate(\"metadata.csv\", \"vars.csv\", \"ground_truth.csv\")\n\n# Create validator\nvalidator = BrickModelValidator(ground_truth_csv_path=\"ground_truth.csv\")\n\n# Convert and validate each building\nconverter = CSVToBrickConverter()\nfor building_id in [\"105\", \"106\", \"107\"]:\n    # Convert\n    converter.convert_to_brick(\n        metadata_csv=\"metadata.csv\",\n        vars_csv=\"vars.csv\",\n        building_tag=building_id,\n        output_path=f\"building_{building_id}.ttl\"\n    )\n\n    # Validate immediately\n    result = validator.validate_point_count(f\"building_{building_id}.ttl\")\n\n    if result['match']:\n        print(f\"\u2713 Building {building_id}: Complete\")\n    else:\n        print(f\"\u2717 Building {building_id}: {result['accuracy_percentage']:.1f}% complete\")\n</code></pre>"},{"location":"user-guide/validation/ground-truth/#pattern-2-only-use-complete-models","title":"Pattern 2: Only Use Complete Models","text":"<pre><code>def get_complete_models(model_dir, ground_truth_path):\n    \"\"\"Return list of models with 100% point count match.\"\"\"\n\n    validator = BrickModelValidator(\n        ground_truth_csv_path=ground_truth_path\n    )\n\n    results = validator.batch_validate_point_count(test_data_dir=model_dir)\n\n    complete_models = []\n    for result in results['individual_results']:\n        if result['match']:  # 100% match\n            complete_models.append(result['ttl_file_path'])\n\n    return complete_models\n\n# Use only complete models\ncomplete = get_complete_models(\"brick_models/\", \"ground_truth.csv\")\nprint(f\"Found {len(complete)} complete models\")\n\nfor model_path in complete:\n    # Safe to use in analytics\n    app.analyze(model_path, data, config)\n</code></pre>"},{"location":"user-guide/validation/ground-truth/#pattern-3-threshold-based-acceptance","title":"Pattern 3: Threshold-Based Acceptance","text":"<p>Accept models above a certain accuracy threshold:</p> <pre><code>def get_acceptable_models(model_dir, ground_truth_path, threshold=95.0):\n    \"\"\"Return models with accuracy &gt;= threshold.\"\"\"\n\n    validator = BrickModelValidator(\n        ground_truth_csv_path=ground_truth_path\n    )\n\n    results = validator.batch_validate_point_count(test_data_dir=model_dir)\n\n    acceptable = []\n    for result in results['individual_results']:\n        if result['accuracy_percentage'] &gt;= threshold:\n            acceptable.append({\n                'path': result['ttl_file_path'],\n                'accuracy': result['accuracy_percentage']\n            })\n\n    return acceptable\n\n# Use models with 95%+ accuracy\nacceptable = get_acceptable_models(\"brick_models/\", \"ground_truth.csv\", 95.0)\nprint(f\"Found {len(acceptable)} acceptable models (\u226595% accurate)\")\n</code></pre>"},{"location":"user-guide/validation/ground-truth/#troubleshooting","title":"Troubleshooting","text":""},{"location":"user-guide/validation/ground-truth/#issue-ground-truth-file-not-found","title":"Issue: \"Ground truth file not found\"","text":"<p>Solution: Generate it first: <pre><code>calculator = GroundTruthCalculator()\ncalculator.calculate(\n    metadata_csv=\"metadata.csv\",\n    vars_csv=\"vars.csv\",\n    output_csv=\"ground_truth.csv\"\n)\n</code></pre></p>"},{"location":"user-guide/validation/ground-truth/#issue-point-count-always-0","title":"Issue: Point count always 0","text":"<p>Cause: Building tag not found in ground truth</p> <p>Solution: Check building ID format: <pre><code>import pandas as pd\n\n# Check ground truth\ngt = pd.read_csv(\"ground_truth.csv\")\nprint(\"Buildings in ground truth:\")\nprint(gt['tag'].tolist())\n\n# Ensure building ID matches\n# File: building_105.ttl -&gt; tag should be \"105\" in ground_truth.csv\n</code></pre></p>"},{"location":"user-guide/validation/ground-truth/#issue-all-equipment-counts-mismatch","title":"Issue: All equipment counts mismatch","text":"<p>Cause: Ground truth calculation issue</p> <p>Solution: Regenerate ground truth: <pre><code># Delete old file\nimport os\nif os.exists(\"ground_truth.csv\"):\n    os.remove(\"ground_truth.csv\")\n\n# Regenerate\ncalculator = GroundTruthCalculator()\ncalculator.calculate(\n    metadata_csv=\"metadata.csv\",\n    vars_csv=\"vars.csv\",\n    output_csv=\"ground_truth.csv\"\n)\n</code></pre></p>"},{"location":"user-guide/validation/ground-truth/#issue-point-count-slightly-off","title":"Issue: Point count slightly off","text":"<p>Possible causes: 1. Sensor mapping differences 2. Optional sensors not counted 3. Generated points (e.g., virtual points)</p> <p>Investigation: <pre><code># Check what's in the model\nfrom rdflib import Graph\n\ng = Graph()\ng.parse(\"building_105.ttl\", format=\"turtle\")\n\n# Count points manually\nquery = \"\"\"\nPREFIX brick: &lt;https://brickschema.org/schema/Brick#&gt;\nSELECT (COUNT(?point) as ?count) WHERE {\n    ?point a ?type .\n    ?type rdfs:subClassOf* brick:Point .\n}\n\"\"\"\n\nfor row in g.query(query):\n    print(f\"Actual points in model: {row.count}\")\n</code></pre></p>"},{"location":"user-guide/validation/ground-truth/#best-practices","title":"Best Practices","text":""},{"location":"user-guide/validation/ground-truth/#1-generate-ground-truth-first","title":"1. Generate Ground Truth First","text":"<pre><code># Good \u2713\ncalculator.calculate(\"metadata.csv\", \"vars.csv\", \"ground_truth.csv\")\nvalidator = BrickModelValidator(ground_truth_csv_path=\"ground_truth.csv\")\n\n# Bad \u2717\n# Try to validate without ground truth\n</code></pre>"},{"location":"user-guide/validation/ground-truth/#2-regenerate-after-data-changes","title":"2. Regenerate After Data Changes","text":"<pre><code># If CSV data changes, regenerate ground truth\ncalculator.calculate(\"updated_metadata.csv\", \"updated_vars.csv\", \"ground_truth.csv\")\n</code></pre>"},{"location":"user-guide/validation/ground-truth/#3-check-both-points-and-equipment","title":"3. Check Both Points and Equipment","text":"<pre><code># Good \u2713\npoint_result = validator.validate_point_count(model)\nequip_result = validator.validate_equipment_count(model)\n\n# Bad \u2717\n# Only check one type\n</code></pre>"},{"location":"user-guide/validation/ground-truth/#4-handle-partial-matches","title":"4. Handle Partial Matches","text":"<pre><code># Good \u2713\nif result['accuracy_percentage'] &gt;= 95.0:\n    # Use model with warning\n    logging.warning(f\"Model {model} is {result['accuracy_percentage']:.1f}% complete\")\n    use_model(model)\n\n# Bad \u2717\nif result['match']:  # Only accept 100% matches\n    use_model(model)\n# Might reject many usable models\n</code></pre>"},{"location":"user-guide/validation/ground-truth/#next-steps","title":"Next Steps","text":"<ul> <li>Subgraph Patterns - Validate system topology</li> <li>Applications - Use validated models</li> <li>Examples - Working code</li> </ul> <p>Continue to: Subgraph Patterns \u2192</p>"},{"location":"user-guide/validation/ontology/","title":"Ontology Validation","text":"<p>Verify that Brick models follow the Brick schema rules and RDF/OWL standards.</p>"},{"location":"user-guide/validation/ontology/#overview","title":"Overview","text":"<p>Ontology validation checks if your Brick model:</p> <ul> <li>Uses valid Brick classes (e.g., <code>brick:Boiler</code>, <code>brick:Temperature_Sensor</code>)</li> <li>Has correct relationships (e.g., <code>brick:hasPoint</code>, <code>brick:feeds</code>)</li> <li>Follows RDF/OWL syntax rules</li> <li>Uses proper namespaces</li> </ul>"},{"location":"user-guide/validation/ontology/#why-ontology-validation","title":"Why Ontology Validation?","text":""},{"location":"user-guide/validation/ontology/#ensure-interoperability","title":"Ensure Interoperability","text":"<p>Valid models work with all Brick-compatible tools:</p> <pre><code># If model is valid, it works with:\n# - Other Brick applications\n# - SPARQL queries\n# - Visualization tools\n# - Analytics frameworks\n</code></pre>"},{"location":"user-guide/validation/ontology/#catch-errors-early","title":"Catch Errors Early","text":"<p>Find issues before using models in production:</p> <pre><code># Invalid model might cause:\n# - Analytics failures\n# - Query errors\n# - Integration problems\n\n# Validate first:\nif validator.validate_ontology(model)['valid']:\n    # Safe to use\n    app.analyze(model, data, config)\n</code></pre>"},{"location":"user-guide/validation/ontology/#basic-usage","title":"Basic Usage","text":""},{"location":"user-guide/validation/ontology/#validate-single-model","title":"Validate Single Model","text":"<p>Based on <code>examples/02_ontology_validation.py</code>:</p> <pre><code>from hhw_brick import BrickModelValidator\n\n# Create validator with local Brick schema\nvalidator = BrickModelValidator(use_local_brick=True)\n\n# Validate a model\nresult = validator.validate_ontology(\"building_105.ttl\")\n\n# Check result\nif result['valid']:\n    print(\"\u2713 Model is valid!\")\nelse:\n    print(f\"\u2717 Model has {len(result['violations'])} violations\")\n    for violation in result['violations']:\n        print(f\"  - {violation}\")\n</code></pre>"},{"location":"user-guide/validation/ontology/#expected-output","title":"Expected Output","text":"<p>Valid model: <pre><code>\u2713 Model is valid!\n</code></pre></p> <p>Invalid model: <pre><code>\u2717 Model has 3 violations\n  - Invalid class: brick:InvalidBoiler\n  - Missing required property: brick:hasPoint\n  - Invalid namespace: http://wrong.namespace.org#\n</code></pre></p>"},{"location":"user-guide/validation/ontology/#validation-methods","title":"Validation Methods","text":""},{"location":"user-guide/validation/ontology/#validate_ontology","title":"validate_ontology()","text":"<p>Main ontology validation method.</p> <p>Signature: <pre><code>def validate_ontology(ttl_file_path: str) -&gt; Dict\n</code></pre></p> <p>Parameters: - <code>ttl_file_path</code> (str): Path to TTL file to validate</p> <p>Returns: <pre><code>{\n    'valid': bool,              # True if valid\n    'violations': list,         # List of violation messages\n    'ttl_file_path': str,       # Path to validated file\n    'success': bool,            # Same as 'valid'\n    'is_valid': bool,           # Same as 'valid'\n    'validation_report': str    # Text report\n}\n</code></pre></p> <p>Example: <pre><code>result = validator.validate_ontology(\"building_105.ttl\")\n\nprint(f\"Valid: {result['valid']}\")\nprint(f\"File: {result['ttl_file_path']}\")\n\nif not result['valid']:\n    print(\"Violations:\")\n    for v in result['violations']:\n        print(f\"  - {v}\")\n</code></pre></p>"},{"location":"user-guide/validation/ontology/#batch-validation","title":"Batch Validation","text":""},{"location":"user-guide/validation/ontology/#validate-multiple-models-parallel","title":"Validate Multiple Models (Parallel)","text":"<p>From <code>examples/02_ontology_validation.py</code>:</p> <pre><code>from hhw_brick import BrickModelValidator\n\nvalidator = BrickModelValidator(use_local_brick=True)\n\n# Batch validate with parallel processing\nresults = validator.batch_validate_ontology(\n    test_data_dir=\"brick_models/\",\n    max_workers=8  # Number of parallel workers\n)\n\n# Results\nprint(f\"Total files: {results['total_files']}\")\nprint(f\"Valid: {results['passed_files']}\")\nprint(f\"Invalid: {results['failed_files']}\")\nprint(f\"Accuracy: {results['overall_accuracy']:.1f}%\")\n</code></pre>"},{"location":"user-guide/validation/ontology/#batch_validate_ontology","title":"batch_validate_ontology()","text":"<p>Signature: <pre><code>def batch_validate_ontology(\n    test_data_dir: str,\n    max_workers: int = None\n) -&gt; Dict\n</code></pre></p> <p>Parameters: - <code>test_data_dir</code> (str): Directory containing TTL files - <code>max_workers</code> (int, optional): Number of parallel workers (default: CPU count - 1)</p> <p>Returns: <pre><code>{\n    'total_files': int,           # Total TTL files found\n    'passed_files': int,          # Valid models\n    'failed_files': int,          # Invalid models\n    'overall_accuracy': float,    # Percentage valid\n    'individual_results': [...]   # List of individual results\n}\n</code></pre></p> <p>Example: <pre><code># Auto-detect worker count\nresults = validator.batch_validate_ontology(\n    test_data_dir=\"brick_models/\"\n)\n\n# Custom worker count for better performance\nresults = validator.batch_validate_ontology(\n    test_data_dir=\"brick_models/\",\n    max_workers=16  # Use 16 workers\n)\n\n# Show detailed results\nfor result in results['individual_results']:\n    file_name = result['ttl_file_path'].split('/')[-1]\n    status = \"\u2713\" if result['valid'] else \"\u2717\"\n    print(f\"{status} {file_name}\")\n</code></pre></p>"},{"location":"user-guide/validation/ontology/#local-vs-remote-brick-schema","title":"Local vs Remote Brick Schema","text":""},{"location":"user-guide/validation/ontology/#using-local-brick-schema-recommended","title":"Using Local Brick Schema (Recommended)","text":"<p>Faster and works offline:</p> <pre><code>validator = BrickModelValidator(use_local_brick=True)\nresult = validator.validate_ontology(\"building_105.ttl\")\n</code></pre> <p>Advantages: - \u2713 Faster validation - \u2713 Works offline - \u2713 Consistent results - \u2713 No network dependency</p> <p>Uses: <code>hhw_brick/validation/Brick_Self.ttl</code></p>"},{"location":"user-guide/validation/ontology/#using-remote-brick-schema","title":"Using Remote Brick Schema","text":"<p>Latest Brick schema from GitHub:</p> <pre><code>validator = BrickModelValidator(use_local_brick=False)\nresult = validator.validate_ontology(\"building_105.ttl\")\n</code></pre> <p>Advantages: - \u2713 Always latest Brick version - \u2713 Latest class definitions</p> <p>Disadvantages: - \u2717 Requires internet - \u2717 Slower validation - \u2717 May change over time</p>"},{"location":"user-guide/validation/ontology/#common-validation-patterns","title":"Common Validation Patterns","text":""},{"location":"user-guide/validation/ontology/#pattern-1-validate-after-conversion","title":"Pattern 1: Validate After Conversion","text":"<pre><code>from hhw_brick import CSVToBrickConverter, BrickModelValidator\n\n# Convert\nconverter = CSVToBrickConverter()\nresult = converter.convert_to_brick(\n    metadata_csv=\"metadata.csv\",\n    vars_csv=\"vars.csv\",\n    building_tag=\"105\",\n    output_path=\"building_105.ttl\"\n)\n\n# Validate immediately\nvalidator = BrickModelValidator(use_local_brick=True)\nvalidation = validator.validate_ontology(\"building_105.ttl\")\n\nif validation['valid']:\n    print(\"\u2713 Conversion successful and valid\")\nelse:\n    print(\"\u2717 Conversion produced invalid model\")\n    print(\"Review these issues:\")\n    for v in validation['violations']:\n        print(f\"  - {v}\")\n</code></pre>"},{"location":"user-guide/validation/ontology/#pattern-2-production-batch-validation","title":"Pattern 2: Production Batch Validation","text":"<pre><code>\"\"\"\nProduction validation workflow\n\"\"\"\nfrom pathlib import Path\nfrom hhw_brick import BatchConverter, BrickModelValidator\n\ndef production_validation():\n    \"\"\"Convert and validate all buildings.\"\"\"\n\n    # Step 1: Batch convert\n    print(\"Converting buildings...\")\n    batch = BatchConverter()\n    conversion_results = batch.convert_all_buildings(\n        metadata_csv=\"metadata.csv\",\n        vars_csv=\"vars.csv\",\n        output_dir=\"brick_models/\",\n        show_progress=True\n    )\n\n    print(f\"Converted {conversion_results['successful']} buildings\")\n\n    # Step 2: Batch validate\n    print(\"\\nValidating models...\")\n    validator = BrickModelValidator(use_local_brick=True)\n    validation_results = validator.batch_validate_ontology(\n        test_data_dir=\"brick_models/\",\n        max_workers=8\n    )\n\n    # Step 3: Report\n    print(f\"\\nValidation Results:\")\n    print(f\"  Total: {validation_results['total_files']}\")\n    print(f\"  Valid: {validation_results['passed_files']}\")\n    print(f\"  Invalid: {validation_results['failed_files']}\")\n    print(f\"  Accuracy: {validation_results['overall_accuracy']:.1f}%\")\n\n    # Step 4: Handle failures\n    if validation_results['failed_files'] &gt; 0:\n        print(\"\\nFailed models:\")\n        for result in validation_results['individual_results']:\n            if not result['valid']:\n                print(f\"  \u2717 {Path(result['ttl_file_path']).name}\")\n                for v in result.get('violations', [])[:3]:  # First 3\n                    print(f\"      - {v}\")\n\n    return validation_results\n\nif __name__ == \"__main__\":\n    results = production_validation()\n</code></pre>"},{"location":"user-guide/validation/ontology/#pattern-3-selective-validation","title":"Pattern 3: Selective Validation","text":"<p>Only validate new or changed models:</p> <pre><code>import os\nfrom pathlib import Path\n\ndef validate_new_models(model_dir, cache_file=\".validation_cache\"):\n    \"\"\"Validate only new/changed models.\"\"\"\n\n    # Load validation cache\n    validated = set()\n    if os.path.exists(cache_file):\n        with open(cache_file, 'r') as f:\n            validated = set(line.strip() for line in f)\n\n    # Find new models\n    all_models = set(str(p) for p in Path(model_dir).glob(\"*.ttl\"))\n    new_models = all_models - validated\n\n    if not new_models:\n        print(\"No new models to validate\")\n        return\n\n    print(f\"Validating {len(new_models)} new models...\")\n\n    validator = BrickModelValidator(use_local_brick=True)\n\n    # Validate new models\n    newly_validated = []\n    for model_path in new_models:\n        result = validator.validate_ontology(model_path)\n\n        if result['valid']:\n            newly_validated.append(model_path)\n            print(f\"\u2713 {Path(model_path).name}\")\n        else:\n            print(f\"\u2717 {Path(model_path).name}\")\n\n    # Update cache\n    with open(cache_file, 'a') as f:\n        for model in newly_validated:\n            f.write(f\"{model}\\n\")\n\n    print(f\"\\nValidated {len(newly_validated)}/{len(new_models)} new models\")\n\n# Use it\nvalidate_new_models(\"brick_models/\")\n</code></pre>"},{"location":"user-guide/validation/ontology/#what-gets-validated","title":"What Gets Validated","text":""},{"location":"user-guide/validation/ontology/#brick-class-names","title":"Brick Class Names","text":"<p>Checks if classes exist in Brick schema:</p> <pre><code># Valid \u2713\nbrick:Boiler\nbrick:Hot_Water_Supply_Temperature_Sensor\nbrick:Heat_Exchanger\n\n# Invalid \u2717\nbrick:InvalidBoiler  # No such class\nbrick:TemperatureSensor  # Wrong name (should be Temperature_Sensor)\nmyprefix:CustomClass  # Not in Brick namespace\n</code></pre>"},{"location":"user-guide/validation/ontology/#relationship-types","title":"Relationship Types","text":"<p>Checks if relationships are valid:</p> <pre><code># Valid \u2713\nbrick:hasPoint\nbrick:feeds\nbrick:isPartOf\n\n# Invalid \u2717\nbrick:hasInvalidRelation  # No such relation\ncustom:feeds  # Wrong namespace\n</code></pre>"},{"location":"user-guide/validation/ontology/#rdf-syntax","title":"RDF Syntax","text":"<p>Checks RDF/Turtle syntax:</p> <pre><code># Valid \u2713\n:Boiler_01 a brick:Boiler .\n:Boiler_01 brick:hasPoint :Temp_Sensor .\n\n# Invalid \u2717\n:Boiler_01 a brick:Boiler  # Missing period\n:Boiler_01 brick:hasPoint  # Incomplete triple\n</code></pre>"},{"location":"user-guide/validation/ontology/#namespace-declarations","title":"Namespace Declarations","text":"<p>Checks proper namespace usage:</p> <pre><code># Valid \u2713\n@prefix brick: &lt;https://brickschema.org/schema/Brick#&gt; .\n@prefix hhws: &lt;https://hhws.example.org#&gt; .\n\n# Invalid \u2717\n@prefix brick: &lt;http://wrong.url.org#&gt; .  # Wrong URL\n# Missing namespace declarations\n</code></pre>"},{"location":"user-guide/validation/ontology/#understanding-validation-results","title":"Understanding Validation Results","text":""},{"location":"user-guide/validation/ontology/#valid-result","title":"Valid Result","text":"<pre><code>{\n    'valid': True,\n    'violations': [],\n    'ttl_file_path': 'building_105.ttl',\n    'success': True,\n    'is_valid': True,\n    'validation_report': 'Model is valid'\n}\n</code></pre>"},{"location":"user-guide/validation/ontology/#invalid-result","title":"Invalid Result","text":"<pre><code>{\n    'valid': False,\n    'violations': [\n        'sh:Violation on brick:hasPoint',\n        'Invalid class: brick:WrongClass',\n        'Missing required property'\n    ],\n    'ttl_file_path': 'building_105.ttl',\n    'success': False,\n    'is_valid': False,\n    'validation_report': 'Model has 3 violations'\n}\n</code></pre>"},{"location":"user-guide/validation/ontology/#performance","title":"Performance","text":""},{"location":"user-guide/validation/ontology/#single-model","title":"Single Model","text":"<p>Typical validation time: - Local Brick: 0.5-2 seconds per model - Remote Brick: 3-5 seconds per model (first time)</p>"},{"location":"user-guide/validation/ontology/#batch-validation_1","title":"Batch Validation","text":"<p>Parallel processing dramatically improves speed:</p> <pre><code># Serial (slow)\nfor file in ttl_files:\n    validator.validate_ontology(file)  # ~2 sec each\n# 100 files = ~200 seconds\n\n# Parallel (fast)\nresults = validator.batch_validate_ontology(\n    test_data_dir=\"models/\",\n    max_workers=8\n)\n# 100 files = ~30 seconds (8x speedup)\n</code></pre> <p>Performance table:</p> Models Serial Parallel (8 workers) Speedup 10 ~20s ~5s 4x 50 ~100s ~15s 6.7x 100 ~200s ~30s 6.7x 500 ~1000s ~150s 6.7x"},{"location":"user-guide/validation/ontology/#optimization-tips","title":"Optimization Tips","text":"<ol> <li>Use local Brick for faster validation</li> <li>Increase workers for more parallelism (up to CPU count)</li> <li>Validate in batches rather than one-by-one</li> <li>Cache results for unchanged models</li> </ol>"},{"location":"user-guide/validation/ontology/#troubleshooting","title":"Troubleshooting","text":""},{"location":"user-guide/validation/ontology/#issue-brickschema-not-available","title":"Issue: \"brickschema not available\"","text":"<p>Cause: Missing dependency</p> <p>Solution: <pre><code>pip install brickschema\n</code></pre></p>"},{"location":"user-guide/validation/ontology/#issue-local-brick-file-not-found","title":"Issue: \"Local Brick file not found\"","text":"<p>Cause: Package not properly installed</p> <p>Solution: <pre><code># Reinstall package\npip install --force-reinstall hhw-brick\n</code></pre></p> <p>Or use remote Brick: <pre><code>validator = BrickModelValidator(use_local_brick=False)\n</code></pre></p>"},{"location":"user-guide/validation/ontology/#issue-all-models-failing-validation","title":"Issue: All models failing validation","text":"<p>Possible causes: 1. Conversion issues 2. Wrong Brick version 3. Corrupted TTL files</p> <p>Solution: <pre><code># Check single model manually\nfrom rdflib import Graph\n\ng = Graph()\ntry:\n    g.parse(\"building_105.ttl\", format=\"turtle\")\n    print(f\"\u2713 File parses correctly: {len(g)} triples\")\nexcept Exception as e:\n    print(f\"\u2717 Parse error: {e}\")\n</code></pre></p>"},{"location":"user-guide/validation/ontology/#issue-validation-too-slow","title":"Issue: Validation too slow","text":"<p>Solution 1: Use local Brick <pre><code>validator = BrickModelValidator(use_local_brick=True)\n</code></pre></p> <p>Solution 2: Increase workers <pre><code>results = validator.batch_validate_ontology(\n    test_data_dir=\"models/\",\n    max_workers=16  # More workers\n)\n</code></pre></p> <p>Solution 3: Validate only changed files <pre><code># See \"Pattern 3: Selective Validation\" above\n</code></pre></p>"},{"location":"user-guide/validation/ontology/#best-practices","title":"Best Practices","text":""},{"location":"user-guide/validation/ontology/#1-always-validate-after-conversion","title":"1. Always Validate After Conversion","text":"<pre><code># Good \u2713\nresult = converter.convert_to_brick(...)\nvalidation = validator.validate_ontology(output_file)\n\n# Bad \u2717\nresult = converter.convert_to_brick(...)\n# Skip validation - might have invalid models\n</code></pre>"},{"location":"user-guide/validation/ontology/#2-use-local-brick-for-production","title":"2. Use Local Brick for Production","text":"<pre><code># Production \u2713\nvalidator = BrickModelValidator(use_local_brick=True)\n\n# Development (occasional use)\nvalidator = BrickModelValidator(use_local_brick=False)\n</code></pre>"},{"location":"user-guide/validation/ontology/#3-handle-validation-failures","title":"3. Handle Validation Failures","text":"<pre><code># Good \u2713\nresult = validator.validate_ontology(\"model.ttl\")\nif not result['valid']:\n    log_error(result['violations'])\n    notify_admin()\n    skip_model()\n\n# Bad \u2717\nresult = validator.validate_ontology(\"model.ttl\")\n# Ignore failures - use invalid model anyway\n</code></pre>"},{"location":"user-guide/validation/ontology/#4-log-validation-results","title":"4. Log Validation Results","text":"<pre><code>import logging\n\nlogging.basicConfig(level=logging.INFO)\n\nresult = validator.validate_ontology(\"model.ttl\")\nif result['valid']:\n    logging.info(f\"\u2713 Valid: {result['ttl_file_path']}\")\nelse:\n    logging.error(f\"\u2717 Invalid: {result['ttl_file_path']}\")\n    for v in result['violations']:\n        logging.error(f\"  - {v}\")\n</code></pre>"},{"location":"user-guide/validation/ontology/#next-steps","title":"Next Steps","text":"<ul> <li>Ground Truth Validation - Validate counts and completeness</li> <li>Subgraph Patterns - Validate system topology</li> <li>Examples - Working code samples</li> </ul> <p>Continue to: Ground Truth Validation \u2192</p>"},{"location":"user-guide/validation/subgraph-patterns/","title":"Subgraph Pattern Validation","text":"<p>Validate system topology and architectural patterns in Brick models.</p>"},{"location":"user-guide/validation/subgraph-patterns/#overview","title":"Overview","text":"<p>Subgraph pattern validation checks if your Brick model follows expected system architecture patterns:</p> <ul> <li>Pattern 1 (Boiler System): Has boilers, primary loop, heat exchanger, secondary loop</li> <li>Pattern 2 (District System): Has district connection, secondary loop, no boilers</li> </ul> <p>This ensures system topology is correct.</p>"},{"location":"user-guide/validation/subgraph-patterns/#why-validate-patterns","title":"Why Validate Patterns?","text":""},{"location":"user-guide/validation/subgraph-patterns/#verify-system-architecture","title":"Verify System Architecture","text":"<p>Ensure model represents the actual system:</p> <pre><code># Pattern 2: District System\n# Expected: District connection \u2192 HX \u2192 Secondary loop\n# Should NOT have: Boilers, primary loop\n\nresult = validator.check_pattern_2_district_system(\"building_108.ttl\")\nif result['matched']:\n    print(\"\u2713 District system architecture correct\")\n</code></pre>"},{"location":"user-guide/validation/subgraph-patterns/#catch-modeling-errors","title":"Catch Modeling Errors","text":"<p>Find structural issues:</p> <pre><code># District system but has boilers? Error!\nif result['has_boiler']:\n    print(\"\u2717 District system should not have boilers\")\n</code></pre>"},{"location":"user-guide/validation/subgraph-patterns/#prepare-for-analytics","title":"Prepare for Analytics","text":"<p>Some analytics require specific patterns:</p> <pre><code># This app requires boiler system (Pattern 1)\nif not has_boilers(model):\n    print(\"Skip: Model doesn't match required pattern\")\n</code></pre>"},{"location":"user-guide/validation/subgraph-patterns/#subgraphpatternvalidator","title":"SubgraphPatternValidator","text":""},{"location":"user-guide/validation/subgraph-patterns/#basic-usage","title":"Basic Usage","text":"<p>From <code>examples/05_subgraph_pattern_matching.py</code>:</p> <pre><code>from hhw_brick.validation import SubgraphPatternValidator\n\n# Create validator\nvalidator = SubgraphPatternValidator()\n\n# Check if model matches Pattern 2 (District System)\nresult = validator.check_pattern_2_district_system(\"building_108.ttl\")\n\nif result['matched']:\n    print(\"\u2713 This is a District System\")\n    print(f\"  - Has building: {result['details']['has_building']}\")\n    print(f\"  - Has HW system: {result['details']['has_hot_water_system']}\")\n    print(f\"  - Has secondary loop: {result['details']['has_secondary_loop']}\")\n    print(f\"  - No boilers: {not result['details']['has_boiler']}\")\nelse:\n    print(\"\u2717 Not a District System\")\n</code></pre>"},{"location":"user-guide/validation/subgraph-patterns/#pattern-definitions","title":"Pattern Definitions","text":""},{"location":"user-guide/validation/subgraph-patterns/#pattern-1-boiler-system","title":"Pattern 1: Boiler System","text":"<p>Architecture: <pre><code>graph LR\n    B[Boiler] --&gt;|feeds| HX[Heat Exchanger]\n    HX --&gt;|feeds| SL[Secondary Loop]\n    B --&gt;|has| PP[Primary Pump]\n    SL --&gt;|has| SP[Secondary Pump]\n\n    style B fill:#ff9800\n    style HX fill:#2196f3\n    style SL fill:#4caf50</code></pre></p> <p>Components: - \u2713 One or more boilers - \u2713 Primary loop - \u2713 Heat exchanger - \u2713 Secondary loop - \u2713 Primary and secondary pumps</p> <p>System Types: Non-condensing, Condensing, Boiler</p>"},{"location":"user-guide/validation/subgraph-patterns/#pattern-2-district-system","title":"Pattern 2: District System","text":"<p>Architecture: <pre><code>graph LR\n    DS[District&lt;br/&gt;Supply] --&gt;|feeds| HX[Heat&lt;br/&gt;Exchanger]\n    HX --&gt;|feeds| BL[Building&lt;br/&gt;Loop]\n    DS --&gt;|has| DM[District&lt;br/&gt;Meter]\n    BL --&gt;|has| BP[Building&lt;br/&gt;Pump]\n\n    style DS fill:#9c27b0\n    style HX fill:#2196f3\n    style BL fill:#4caf50</code></pre></p> <p>Components: - \u2713 District hot water/steam connection - \u2713 Heat exchanger - \u2713 Secondary loop (building side) - \u2713 Building pumps - \u2717 NO boilers - \u2717 NO primary loop</p> <p>System Types: District HW, District Steam</p>"},{"location":"user-guide/validation/subgraph-patterns/#validation-methods","title":"Validation Methods","text":""},{"location":"user-guide/validation/subgraph-patterns/#check_pattern_2_district_system","title":"check_pattern_2_district_system()","text":"<p>Check if model matches District System pattern.</p> <p>Signature: <pre><code>def check_pattern_2_district_system(ttl_file_path: str) -&gt; Dict\n</code></pre></p> <p>Returns: <pre><code>{\n    'matched': bool,                    # True if matches Pattern 2\n    'details': {\n        'has_building': bool,           # Building entity exists\n        'has_hot_water_system': bool,   # HW system exists\n        'has_secondary_loop': bool,     # Secondary loop exists\n        'has_pump': bool,               # Pumps exist\n        'has_weather_station': bool,    # Weather station exists\n        'has_boiler': bool,             # Should be False for Pattern 2\n        'has_primary_loop': bool,       # Should be False for Pattern 2\n        'pump_count': int               # Number of pumps\n    },\n    'ttl_file_path': str,\n    'error': str or None                # Error message if failed\n}\n</code></pre></p> <p>Example: <pre><code>result = validator.check_pattern_2_district_system(\"building_108.ttl\")\n\nprint(f\"Matched Pattern 2: {result['matched']}\")\n\ndetails = result['details']\nprint(f\"\\nComponents:\")\nprint(f\"  Building: {details['has_building']}\")\nprint(f\"  HW System: {details['has_hot_water_system']}\")\nprint(f\"  Secondary Loop: {details['has_secondary_loop']}\")\nprint(f\"  Pump Count: {details['pump_count']}\")\n\n# Verify no boiler components\nprint(f\"\\nNo Boiler Components (should be False):\")\nprint(f\"  Has Boiler: {details['has_boiler']}\")\nprint(f\"  Has Primary Loop: {details['has_primary_loop']}\")\n</code></pre></p>"},{"location":"user-guide/validation/subgraph-patterns/#batch-pattern-validation","title":"Batch Pattern Validation","text":"<p>From <code>examples/05_subgraph_pattern_matching.py</code>:</p> <pre><code>from hhw_brick.validation import SubgraphPatternValidator\n\nvalidator = SubgraphPatternValidator()\n\n# Batch validate all buildings\nbatch_results = validator.batch_validate_all_buildings(\n    ttl_directory=\"brick_models/\",\n    max_workers=4  # Parallel workers\n)\n\n# Summary\ntotal = len(batch_results)\npattern_2 = sum(1 for r in batch_results if r.get('matched'))\npattern_1 = total - pattern_2\n\nprint(f\"Total buildings: {total}\")\nprint(f\"Pattern 1 (Boiler Systems): {pattern_1}\")\nprint(f\"Pattern 2 (District Systems): {pattern_2}\")\n</code></pre>"},{"location":"user-guide/validation/subgraph-patterns/#batch_validate_all_buildings","title":"batch_validate_all_buildings()","text":"<p>Signature: <pre><code>def batch_validate_all_buildings(\n    ttl_directory: str,\n    max_workers: int = None\n) -&gt; List[Dict]\n</code></pre></p> <p>Parameters: - <code>ttl_directory</code> (str): Directory containing TTL files - <code>max_workers</code> (int, optional): Number of parallel workers</p> <p>Returns: <pre><code>[\n    {\n        'matched': bool,\n        'details': {...},\n        'ttl_file_path': str,\n        'error': str or None\n    },\n    # ... one dict per file\n]\n</code></pre></p> <p>Example: <pre><code>results = validator.batch_validate_all_buildings(\n    ttl_directory=\"brick_models/\",\n    max_workers=8\n)\n\n# Group by pattern\npattern_1_models = []\npattern_2_models = []\n\nfor result in results:\n    file_name = Path(result['ttl_file_path']).name\n\n    if result['matched']:\n        pattern_2_models.append(file_name)\n    else:\n        pattern_1_models.append(file_name)\n\nprint(f\"Pattern 1 (Boiler): {len(pattern_1_models)} models\")\nprint(f\"Pattern 2 (District): {len(pattern_2_models)} models\")\n</code></pre></p>"},{"location":"user-guide/validation/subgraph-patterns/#complete-validation-example","title":"Complete Validation Example","text":"<p>Based on <code>examples/05_subgraph_pattern_matching.py</code>:</p> <pre><code>\"\"\"\nComplete subgraph pattern validation\n\"\"\"\n\nfrom pathlib import Path\nfrom hhw_brick.validation import SubgraphPatternValidator\n\ndef validate_system_patterns():\n    # Create validator\n    validator = SubgraphPatternValidator()\n\n    # ===== Single Building Validation =====\n    print(\"Single Building Pattern Validation\")\n    print(\"=\"*60)\n\n    building_file = \"building_108_district_hw_aa.ttl\"\n\n    # Check Pattern 2\n    result = validator.check_pattern_2_district_system(building_file)\n\n    if result['matched']:\n        print(f\"\u2713 {building_file} matches Pattern 2 (District System)\")\n\n        details = result['details']\n        print(\"\\nSystem Components:\")\n        print(f\"  \u2713 Building: {details['has_building']}\")\n        print(f\"  \u2713 HW System: {details['has_hot_water_system']}\")\n        print(f\"  \u2713 Secondary Loop: {details['has_secondary_loop']}\")\n        print(f\"  \u2713 Pumps: {details['pump_count']}\")\n        print(f\"  \u2713 Weather Station: {details['has_weather_station']}\")\n\n        print(\"\\nNo Boiler Components (correct for District):\")\n        print(f\"  \u2713 No Boiler: {not details['has_boiler']}\")\n        print(f\"  \u2713 No Primary Loop: {not details['has_primary_loop']}\")\n    else:\n        print(f\"\u2717 {building_file} does NOT match Pattern 2\")\n        print(f\"  This is likely a Pattern 1 (Boiler System)\")\n\n    # ===== Batch Validation =====\n    print(\"\\n\" + \"=\"*60)\n    print(\"Batch Pattern Validation\")\n    print(\"=\"*60)\n\n    batch_results = validator.batch_validate_all_buildings(\n        ttl_directory=\"brick_models/\",\n        max_workers=8\n    )\n\n    # Analyze results\n    total = len(batch_results)\n    pattern_2_count = 0\n    pattern_1_count = 0\n    errors = 0\n\n    pattern_2_files = []\n    pattern_1_files = []\n\n    for result in batch_results:\n        file_name = Path(result['ttl_file_path']).name\n\n        if result.get('error'):\n            errors += 1\n        elif result['matched']:\n            pattern_2_count += 1\n            pattern_2_files.append(file_name)\n        else:\n            pattern_1_count += 1\n            pattern_1_files.append(file_name)\n\n    # Summary\n    print(f\"\\nPattern Validation Summary:\")\n    print(f\"  Total files: {total}\")\n    print(f\"  Pattern 1 (Boiler Systems): {pattern_1_count}\")\n    print(f\"  Pattern 2 (District Systems): {pattern_2_count}\")\n    print(f\"  Errors: {errors}\")\n\n    # Show samples\n    if pattern_1_files:\n        print(f\"\\nPattern 1 (Boiler) sample:\")\n        for file in pattern_1_files[:3]:\n            print(f\"  - {file}\")\n\n    if pattern_2_files:\n        print(f\"\\nPattern 2 (District) sample:\")\n        for file in pattern_2_files[:3]:\n            print(f\"  - {file}\")\n\n    return batch_results\n\nif __name__ == \"__main__\":\n    results = validate_system_patterns()\n</code></pre>"},{"location":"user-guide/validation/subgraph-patterns/#common-use-cases","title":"Common Use Cases","text":""},{"location":"user-guide/validation/subgraph-patterns/#use-case-1-separate-by-pattern","title":"Use Case 1: Separate by Pattern","text":"<p>Group models by their pattern:</p> <pre><code>def separate_by_pattern(model_dir):\n    \"\"\"Separate models into Pattern 1 and Pattern 2 directories.\"\"\"\n\n    from pathlib import Path\n    import shutil\n\n    validator = SubgraphPatternValidator()\n\n    # Create output directories\n    pattern_1_dir = Path(\"pattern_1_boiler\")\n    pattern_2_dir = Path(\"pattern_2_district\")\n    pattern_1_dir.mkdir(exist_ok=True)\n    pattern_2_dir.mkdir(exist_ok=True)\n\n    # Validate all\n    results = validator.batch_validate_all_buildings(\n        ttl_directory=model_dir,\n        max_workers=8\n    )\n\n    # Copy to appropriate directories\n    for result in results:\n        src = Path(result['ttl_file_path'])\n\n        if result['matched']:\n            dst = pattern_2_dir / src.name\n        else:\n            dst = pattern_1_dir / src.name\n\n        shutil.copy(src, dst)\n\n    print(f\"Pattern 1 (Boiler): {len(list(pattern_1_dir.glob('*.ttl')))} files\")\n    print(f\"Pattern 2 (District): {len(list(pattern_2_dir.glob('*.ttl')))} files\")\n\n# Use it\nseparate_by_pattern(\"brick_models/\")\n</code></pre>"},{"location":"user-guide/validation/subgraph-patterns/#use-case-2-validate-before-analytics","title":"Use Case 2: Validate Before Analytics","text":"<p>Only run certain analytics on matching patterns:</p> <pre><code>def run_pattern_specific_analytics(model_path, data, config):\n    \"\"\"Run analytics based on system pattern.\"\"\"\n\n    validator = SubgraphPatternValidator()\n    result = validator.check_pattern_2_district_system(model_path)\n\n    if result['matched']:\n        # Pattern 2: District System\n        print(\"Running district system analytics...\")\n        app = apps.load_app(\"district_efficiency\")\n    else:\n        # Pattern 1: Boiler System\n        print(\"Running boiler system analytics...\")\n        app = apps.load_app(\"boiler_efficiency\")\n\n    # Run appropriate analytics\n    qualified, details = app.qualify(model_path)\n    if qualified:\n        results = app.analyze(model_path, data, config)\n        return results\n    else:\n        print(\"Building doesn't qualify for this analysis\")\n        return None\n</code></pre>"},{"location":"user-guide/validation/subgraph-patterns/#use-case-3-validation-report","title":"Use Case 3: Validation Report","text":"<p>Generate detailed pattern validation report:</p> <pre><code>def generate_pattern_report(model_dir, output_file=\"pattern_report.csv\"):\n    \"\"\"Generate CSV report of pattern validation.\"\"\"\n\n    import pandas as pd\n\n    validator = SubgraphPatternValidator()\n    results = validator.batch_validate_all_buildings(\n        ttl_directory=model_dir,\n        max_workers=8\n    )\n\n    # Create report data\n    report_data = []\n    for result in results:\n        file_name = Path(result['ttl_file_path']).name\n        building_id = file_name.split('_')[1]  # Extract from filename\n\n        details = result.get('details', {})\n\n        report_data.append({\n            'building_id': building_id,\n            'file_name': file_name,\n            'pattern': 'Pattern 2 (District)' if result['matched'] else 'Pattern 1 (Boiler)',\n            'has_building': details.get('has_building', False),\n            'has_hw_system': details.get('has_hot_water_system', False),\n            'has_secondary_loop': details.get('has_secondary_loop', False),\n            'has_boiler': details.get('has_boiler', False),\n            'pump_count': details.get('pump_count', 0),\n            'has_weather_station': details.get('has_weather_station', False)\n        })\n\n    # Create DataFrame and save\n    df = pd.DataFrame(report_data)\n    df.to_csv(output_file, index=False)\n\n    print(f\"Pattern report saved to: {output_file}\")\n    print(f\"Total buildings: {len(df)}\")\n    print(df['pattern'].value_counts())\n\n    return df\n\n# Use it\nreport = generate_pattern_report(\"brick_models/\")\n</code></pre>"},{"location":"user-guide/validation/subgraph-patterns/#understanding-results","title":"Understanding Results","text":""},{"location":"user-guide/validation/subgraph-patterns/#pattern-2-match-district-system","title":"Pattern 2 Match (District System)","text":"<pre><code>{\n    'matched': True,\n    'details': {\n        'has_building': True,\n        'has_hot_water_system': True,\n        'has_secondary_loop': True,\n        'has_pump': True,\n        'has_weather_station': True,\n        'has_boiler': False,          # Correct: No boiler\n        'has_primary_loop': False,    # Correct: No primary loop\n        'pump_count': 2\n    },\n    'ttl_file_path': 'building_108.ttl',\n    'error': None\n}\n</code></pre>"},{"location":"user-guide/validation/subgraph-patterns/#pattern-1-not-pattern-2","title":"Pattern 1 (Not Pattern 2)","text":"<pre><code>{\n    'matched': False,  # Not Pattern 2\n    'details': {\n        'has_building': True,\n        'has_hot_water_system': True,\n        'has_secondary_loop': True,\n        'has_pump': True,\n        'has_weather_station': True,\n        'has_boiler': True,           # Has boiler -&gt; Pattern 1\n        'has_primary_loop': True,     # Has primary loop -&gt; Pattern 1\n        'pump_count': 4\n    },\n    'ttl_file_path': 'building_105.ttl',\n    'error': None\n}\n</code></pre>"},{"location":"user-guide/validation/subgraph-patterns/#troubleshooting","title":"Troubleshooting","text":""},{"location":"user-guide/validation/subgraph-patterns/#issue-all-models-show-matchedfalse","title":"Issue: All models show matched=False","text":"<p>Cause: Models are Pattern 1 (Boiler systems)</p> <p>Solution: This is correct if you have boiler systems. Pattern 2 is specifically for district systems.</p>"},{"location":"user-guide/validation/subgraph-patterns/#issue-pattern-validation-fails","title":"Issue: Pattern validation fails","text":"<p>Cause: Model parsing error</p> <p>Solution: <pre><code>result = validator.check_pattern_2_district_system(\"model.ttl\")\n\nif result.get('error'):\n    print(f\"Validation error: {result['error']}\")\n    # Check if file is valid\n    from rdflib import Graph\n    g = Graph()\n    g.parse(\"model.ttl\", format=\"turtle\")\n</code></pre></p>"},{"location":"user-guide/validation/subgraph-patterns/#issue-district-system-not-matching-pattern-2","title":"Issue: District system not matching Pattern 2","text":"<p>Possible causes: 1. Model has boiler entities (shouldn't) 2. Missing secondary loop components 3. Conversion issue</p> <p>Investigation: <pre><code>result = validator.check_pattern_2_district_system(\"district_model.ttl\")\n\ndetails = result['details']\nprint(f\"Has boiler (should be False): {details['has_boiler']}\")\nprint(f\"Has primary loop (should be False): {details['has_primary_loop']}\")\nprint(f\"Has secondary loop (should be True): {details['has_secondary_loop']}\")\n</code></pre></p>"},{"location":"user-guide/validation/subgraph-patterns/#best-practices","title":"Best Practices","text":""},{"location":"user-guide/validation/subgraph-patterns/#1-use-pattern-validation-for-filtering","title":"1. Use Pattern Validation for Filtering","text":"<pre><code># Separate district systems for specific analytics\nvalidator = SubgraphPatternValidator()\nresults = validator.batch_validate_all_buildings(\"brick_models/\")\n\ndistrict_models = [\n    r['ttl_file_path'] for r in results if r['matched']\n]\n\nfor model in district_models:\n    # Run district-specific analytics\n    run_district_analysis(model)\n</code></pre>"},{"location":"user-guide/validation/subgraph-patterns/#2-combine-with-other-validation","title":"2. Combine with Other Validation","text":"<pre><code># Complete validation pipeline\nontology_valid = validator.validate_ontology(model)['valid']\npattern_matched = pattern_validator.check_pattern_2_district_system(model)['matched']\ncounts_match = validator.validate_point_count(model)['match']\n\nif ontology_valid and counts_match:\n    # Model is valid, check pattern for analytics selection\n    if pattern_matched:\n        run_district_analytics(model)\n    else:\n        run_boiler_analytics(model)\n</code></pre>"},{"location":"user-guide/validation/subgraph-patterns/#3-document-pattern-in-metadata","title":"3. Document Pattern in Metadata","text":"<pre><code># Add pattern info to model metadata\nresults = validator.batch_validate_all_buildings(\"brick_models/\")\n\nfor result in results:\n    pattern = \"District\" if result['matched'] else \"Boiler\"\n    file_path = result['ttl_file_path']\n\n    # Store in database or metadata file\n    save_metadata(file_path, pattern=pattern)\n</code></pre>"},{"location":"user-guide/validation/subgraph-patterns/#next-steps","title":"Next Steps","text":"<ul> <li>Applications - Use validated models in analytics</li> <li>Examples - More pattern examples</li> <li>API Reference - Complete API</li> </ul> <p>Validation documentation complete! \ud83c\udf89</p> <p>Continue to Applications Guide \u2192</p>"}]}